
AVRASM ver. 2.1.30  avr/src/ff-atmega.asm Sat Jul 02 16:57:13 2016

avr/src/ff-atmega.asm(34): Including file 'avr/src/config.inc'
avr/src/config.inc(5): Including file 'avrasm2/inc\m2560def.inc'
avr/src/ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
avr/src/ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
avr/src/ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
avr/src/ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
avr/src/ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
avr/src/ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
avr/src/ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          02.07.2016                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2016  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 .include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega2560.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m2560def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega2560
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega2560
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M2560DEF_INC_
                 #define _M2560DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega2560
                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x98
                 .equ	SIGNATURE_002	= 0x01
                 
                 #pragma AVRPART CORE CORE_VERSION V3
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                 .equ	PINL	= 0x109	; MEMORY MAPPED
                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                 .equ	PINK	= 0x106	; MEMORY MAPPED
                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                 .equ	PINH	= 0x100	; MEMORY MAPPED
                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	EIND	= 0x3c
                 .equ	RAMPZ	= 0x3b
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	OCDR	= 0x31
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR5	= 0x1a
                 .equ	TIFR4	= 0x19
                 .equ	TIFR3	= 0x18
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTG	= 0x14
                 .equ	DDRG	= 0x13
                 .equ	PING	= 0x12
                 .equ	PORTF	= 0x11
                 .equ	DDRF	= 0x10
                 .equ	PINF	= 0x0f
                 .equ	PORTE	= 0x0e
                 .equ	DDRE	= 0x0d
                 .equ	PINE	= 0x0c
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 .equ	PORTA	= 0x02
                 .equ	DDRA	= 0x01
                 .equ	PINA	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** PORTE ************************
                 ; PORTE - Data Register, Port E
                 .equ	PORTE0	= 0	; 
                 .equ	PE0	= 0	; For compatibility
                 .equ	PORTE1	= 1	; 
                 .equ	PE1	= 1	; For compatibility
                 .equ	PORTE2	= 2	; 
                 .equ	PE2	= 2	; For compatibility
                 .equ	PORTE3	= 3	; 
                 .equ	PE3	= 3	; For compatibility
                 .equ	PORTE4	= 4	; 
                 .equ	PE4	= 4	; For compatibility
                 .equ	PORTE5	= 5	; 
                 .equ	PE5	= 5	; For compatibility
                 .equ	PORTE6	= 6	; 
                 .equ	PE6	= 6	; For compatibility
                 .equ	PORTE7	= 7	; 
                 .equ	PE7	= 7	; For compatibility
                 
                 ; DDRE - Data Direction Register, Port E
                 .equ	DDE0	= 0	; 
                 .equ	DDE1	= 1	; 
                 .equ	DDE2	= 2	; 
                 .equ	DDE3	= 3	; 
                 .equ	DDE4	= 4	; 
                 .equ	DDE5	= 5	; 
                 .equ	DDE6	= 6	; 
                 .equ	DDE7	= 7	; 
                 
                 ; PINE - Input Pins, Port E
                 .equ	PINE0	= 0	; 
                 .equ	PINE1	= 1	; 
                 .equ	PINE2	= 2	; 
                 .equ	PINE3	= 3	; 
                 .equ	PINE4	= 4	; 
                 .equ	PINE5	= 5	; 
                 .equ	PINE6	= 6	; 
                 .equ	PINE7	= 7	; 
                 
                 
                 ; ***** PORTF ************************
                 ; PORTF - Data Register, Port F
                 .equ	PORTF0	= 0	; 
                 .equ	PF0	= 0	; For compatibility
                 .equ	PORTF1	= 1	; 
                 .equ	PF1	= 1	; For compatibility
                 .equ	PORTF2	= 2	; 
                 .equ	PF2	= 2	; For compatibility
                 .equ	PORTF3	= 3	; 
                 .equ	PF3	= 3	; For compatibility
                 .equ	PORTF4	= 4	; 
                 .equ	PF4	= 4	; For compatibility
                 .equ	PORTF5	= 5	; 
                 .equ	PF5	= 5	; For compatibility
                 .equ	PORTF6	= 6	; 
                 .equ	PF6	= 6	; For compatibility
                 .equ	PORTF7	= 7	; 
                 .equ	PF7	= 7	; For compatibility
                 
                 ; DDRF - Data Direction Register, Port F
                 .equ	DDF0	= 0	; 
                 .equ	DDF1	= 1	; 
                 .equ	DDF2	= 2	; 
                 .equ	DDF3	= 3	; 
                 .equ	DDF4	= 4	; 
                 .equ	DDF5	= 5	; 
                 .equ	DDF6	= 6	; 
                 .equ	DDF7	= 7	; 
                 
                 ; PINF - Input Pins, Port F
                 .equ	PINF0	= 0	; 
                 .equ	PINF1	= 1	; 
                 .equ	PINF2	= 2	; 
                 .equ	PINF3	= 3	; 
                 .equ	PINF4	= 4	; 
                 .equ	PINF5	= 5	; 
                 .equ	PINF6	= 6	; 
                 .equ	PINF7	= 7	; 
                 
                 
                 ; ***** PORTG ************************
                 ; PORTG - Data Register, Port G
                 .equ	PORTG0	= 0	; 
                 .equ	PG0	= 0	; For compatibility
                 .equ	PORTG1	= 1	; 
                 .equ	PG1	= 1	; For compatibility
                 .equ	PORTG2	= 2	; 
                 .equ	PG2	= 2	; For compatibility
                 .equ	PORTG3	= 3	; 
                 .equ	PG3	= 3	; For compatibility
                 .equ	PORTG4	= 4	; 
                 .equ	PG4	= 4	; For compatibility
                 .equ	PORTG5	= 5	; 
                 .equ	PG5	= 5	; For compatibility
                 
                 ; DDRG - Data Direction Register, Port G
                 .equ	DDG0	= 0	; 
                 .equ	DDG1	= 1	; 
                 .equ	DDG2	= 2	; 
                 .equ	DDG3	= 3	; 
                 .equ	DDG4	= 4	; 
                 .equ	DDG5	= 5	; 
                 
                 ; PING - Input Pins, Port G
                 .equ	PING0	= 0	; 
                 .equ	PING1	= 1	; 
                 .equ	PING2	= 2	; 
                 .equ	PING3	= 3	; 
                 .equ	PING4	= 4	; 
                 .equ	PING5	= 5	; 
                 
                 
                 ; ***** PORTH ************************
                 ; PORTH - PORT H Data Register
                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                 .equ	PH0	= 0	; For compatibility
                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                 .equ	PH1	= 1	; For compatibility
                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                 .equ	PH2	= 2	; For compatibility
                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                 .equ	PH3	= 3	; For compatibility
                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                 .equ	PH4	= 4	; For compatibility
                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                 .equ	PH5	= 5	; For compatibility
                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                 .equ	PH6	= 6	; For compatibility
                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                 .equ	PH7	= 7	; For compatibility
                 
                 ; DDRH - PORT H Data Direction Register
                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                 
                 ; PINH - PORT H Input Pins
                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                 
                 
                 ; ***** PORTJ ************************
                 ; PORTJ - PORT J Data Register
                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                 .equ	PJ0	= 0	; For compatibility
                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                 .equ	PJ1	= 1	; For compatibility
                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                 .equ	PJ2	= 2	; For compatibility
                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                 .equ	PJ3	= 3	; For compatibility
                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                 .equ	PJ4	= 4	; For compatibility
                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                 .equ	PJ5	= 5	; For compatibility
                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                 .equ	PJ6	= 6	; For compatibility
                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                 .equ	PJ7	= 7	; For compatibility
                 
                 ; DDRJ - PORT J Data Direction Register
                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                 
                 ; PINJ - PORT J Input Pins
                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                 
                 
                 ; ***** PORTK ************************
                 ; PORTK - PORT K Data Register
                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                 .equ	PK0	= 0	; For compatibility
                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                 .equ	PK1	= 1	; For compatibility
                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                 .equ	PK2	= 2	; For compatibility
                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                 .equ	PK3	= 3	; For compatibility
                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                 .equ	PK4	= 4	; For compatibility
                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                 .equ	PK5	= 5	; For compatibility
                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                 .equ	PK6	= 6	; For compatibility
                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                 .equ	PK7	= 7	; For compatibility
                 
                 ; DDRK - PORT K Data Direction Register
                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                 
                 ; PINK - PORT K Input Pins
                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                 
                 
                 ; ***** PORTL ************************
                 ; PORTL - PORT L Data Register
                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                 .equ	PL0	= 0	; For compatibility
                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                 .equ	PL1	= 1	; For compatibility
                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                 .equ	PL2	= 2	; For compatibility
                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                 .equ	PL3	= 3	; For compatibility
                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                 .equ	PL4	= 4	; For compatibility
                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                 .equ	PL5	= 5	; For compatibility
                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                 .equ	PL6	= 6	; For compatibility
                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                 .equ	PL7	= 7	; For compatibility
                 
                 ; DDRL - PORT L Data Direction Register
                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                 
                 ; PINL - PORT L Input Pins
                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** USART1 ***********************
                 ; UDR1 - USART I/O Data Register
                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR1A - USART Control and Status Register A
                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                 .equ	U2X1	= 1	; Double the USART transmission speed
                 .equ	UPE1	= 2	; Parity Error
                 .equ	DOR1	= 3	; Data overRun
                 .equ	FE1	= 4	; Framing Error
                 .equ	UDRE1	= 5	; USART Data Register Empty
                 .equ	TXC1	= 6	; USART Transmitt Complete
                 .equ	RXC1	= 7	; USART Receive Complete
                 
                 ; UCSR1B - USART Control and Status Register B
                 .equ	TXB81	= 0	; Transmit Data Bit 8
                 .equ	RXB81	= 1	; Receive Data Bit 8
                 .equ	UCSZ12	= 2	; Character Size
                 .equ	TXEN1	= 3	; Transmitter Enable
                 .equ	RXEN1	= 4	; Receiver Enable
                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR1C - USART Control and Status Register C
                 .equ	UCPOL1	= 0	; Clock Polarity
                 .equ	UCSZ10	= 1	; Character Size
                 .equ	UCPHA1	= UCSZ10	; For compatibility
                 .equ	UCSZ11	= 2	; Character Size
                 .equ	UDORD1	= UCSZ11	; For compatibility
                 .equ	USBS1	= 3	; Stop Bit Select
                 .equ	UPM10	= 4	; Parity Mode Bit 0
                 .equ	UPM11	= 5	; Parity Mode Bit 1
                 .equ	UMSEL10	= 6	; USART Mode Select
                 .equ	UMSEL11	= 7	; USART Mode Select
                 
                 ; UBRR1H - USART Baud Rate Register High Byte
                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR1L - USART Baud Rate Register Low Byte
                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARH - EEPROM Address Register Low Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                 
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_5 **************
                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                 
                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                 .equ	ICF5	= 5	; Input Capture Flag 5
                 
                 ; TCCR5A - Timer/Counter5 Control Register A
                 .equ	WGM50	= 0	; Waveform Generation Mode
                 .equ	WGM51	= 1	; Waveform Generation Mode
                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR5B - Timer/Counter5 Control Register B
                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                 .equ	WGM52	= 3	; Waveform Generation Mode
                 .equ	WGM53	= 4	; Waveform Generation Mode
                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                 
                 ; TCCR5C - Timer/Counter 5 Control Register C
                 .equ	FOC5C	= 5	; Force Output Compare 5C
                 .equ	FOC5B	= 6	; Force Output Compare 5B
                 .equ	FOC5A	= 7	; Force Output Compare 5A
                 
                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                 
                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                 
                 
                 ; ***** TIMER_COUNTER_4 **************
                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                 
                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                 .equ	ICF4	= 5	; Input Capture Flag 4
                 
                 ; TCCR4A - Timer/Counter4 Control Register A
                 .equ	WGM40	= 0	; Waveform Generation Mode
                 .equ	WGM41	= 1	; Waveform Generation Mode
                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR4B - Timer/Counter4 Control Register B
                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                 .equ	WGM42	= 3	; Waveform Generation Mode
                 .equ	WGM43	= 4	; Waveform Generation Mode
                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                 
                 ; TCCR4C - Timer/Counter 4 Control Register C
                 .equ	FOC4C	= 5	; Force Output Compare 4C
                 .equ	FOC4B	= 6	; Force Output Compare 4B
                 .equ	FOC4A	= 7	; Force Output Compare 4A
                 
                 
                 ; ***** TIMER_COUNTER_3 **************
                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                 
                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                 .equ	ICF3	= 5	; Input Capture Flag 3
                 
                 ; TCCR3A - Timer/Counter3 Control Register A
                 .equ	WGM30	= 0	; Waveform Generation Mode
                 .equ	WGM31	= 1	; Waveform Generation Mode
                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR3B - Timer/Counter3 Control Register B
                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                 .equ	WGM32	= 3	; Waveform Generation Mode
                 .equ	WGM33	= 4	; Waveform Generation Mode
                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                 
                 ; TCCR3C - Timer/Counter 3 Control Register C
                 .equ	FOC3C	= 5	; Force Output Compare 3C
                 .equ	FOC3B	= 6	; Force Output Compare 3B
                 .equ	FOC3A	= 7	; Force Output Compare 3A
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter 1 Control Register C
                 .equ	FOC1C	= 5	; Force Output Compare 1C
                 .equ	FOC1B	= 6	; Force Output Compare 1B
                 .equ	FOC1A	= 7	; Force Output Compare 1A
                 
                 
                 ; ***** JTAG *************************
                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                 .equ	IDRD	= OCDR7	; For compatibility
                 
                 ; MCUCR - MCU Control Register
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                 
                 ; EICRB - External Interrupt Control Register B
                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 .equ	INTF2	= 2	; External Interrupt Flag 2
                 .equ	INTF3	= 3	; External Interrupt Flag 3
                 .equ	INTF4	= 4	; External Interrupt Flag 4
                 .equ	INTF5	= 5	; External Interrupt Flag 5
                 .equ	INTF6	= 6	; External Interrupt Flag 6
                 .equ	INTF7	= 7	; External Interrupt Flag 7
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	PUD	= 4	; Pull-up disable
                 ;.equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                 
                 ; XMCRA - External Memory Control Register A
                 .equ	SRW00	= 0	; Wait state select bit lower page
                 .equ	SRW01	= 1	; Wait state select bit lower page
                 .equ	SRW10	= 2	; Wait state select bit upper page
                 .equ	SRW11	= 3	; Wait state select bit upper page
                 .equ	SRL0	= 4	; Wait state page limit
                 .equ	SRL1	= 5	; Wait state page limit
                 .equ	SRL2	= 6	; Wait state page limit
                 .equ	SRE	= 7	; External SRAM Enable
                 
                 ; XMCRB - External Memory Control Register B
                 .equ	XMM0	= 0	; External Memory High Mask
                 .equ	XMM1	= 1	; External Memory High Mask
                 .equ	XMM2	= 2	; External Memory High Mask
                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - 
                 .equ	CLKPS0	= 0	; 
                 .equ	CLKPS1	= 1	; 
                 .equ	CLKPS2	= 2	; 
                 .equ	CLKPS3	= 3	; 
                 .equ	CLKPCE	= 7	; 
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                 
                 ; RAMPZ - RAM Page Z Select Register
                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                 
                 ; EIND - Extended Indirect Register
                 .equ	EIND0	= 0	; Bit 0
                 
                 ; GPIOR2 - General Purpose IO Register 2
                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                 
                 ; GPIOR1 - General Purpose IO Register 1
                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                 
                 ; GPIOR0 - General Purpose IO Register 0
                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                 
                 ; PRR1 - Power Reduction Register1
                 .equ	PRUSART1	= 0	; Power Reduction USART1
                 .equ	PRUSART2	= 1	; Power Reduction USART2
                 .equ	PRUSART3	= 2	; Power Reduction USART3
                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                 
                 ; PRR0 - Power Reduction Register0
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                 ;.equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 .equ	ADC6D	= 6	; 
                 .equ	ADC7D	= 7	; 
                 
                 ; DIDR2 - Digital Input Disable Register
                 .equ	ADC8D	= 0	; 
                 .equ	ADC9D	= 1	; 
                 .equ	ADC10D	= 2	; 
                 .equ	ADC11D	= 3	; 
                 .equ	ADC12D	= 4	; 
                 .equ	ADC13D	= 5	; 
                 .equ	ADC14D	= 6	; 
                 .equ	ADC15D	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write section read enable
                 .equ	SIGRD	= 5	; Signature Row Read
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** USART2 ***********************
                 ; UDR2 - USART I/O Data Register
                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR2A - USART Control and Status Register A
                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                 .equ	U2X2	= 1	; Double the USART transmission speed
                 .equ	UPE2	= 2	; Parity Error
                 .equ	DOR2	= 3	; Data overRun
                 .equ	FE2	= 4	; Framing Error
                 .equ	UDRE2	= 5	; USART Data Register Empty
                 .equ	TXC2	= 6	; USART Transmitt Complete
                 .equ	RXC2	= 7	; USART Receive Complete
                 
                 ; UCSR2B - USART Control and Status Register B
                 .equ	TXB82	= 0	; Transmit Data Bit 8
                 .equ	RXB82	= 1	; Receive Data Bit 8
                 .equ	UCSZ22	= 2	; Character Size
                 .equ	TXEN2	= 3	; Transmitter Enable
                 .equ	RXEN2	= 4	; Receiver Enable
                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR2C - USART Control and Status Register C
                 .equ	UCPOL2	= 0	; Clock Polarity
                 .equ	UCSZ20	= 1	; Character Size
                 .equ	UCSZ21	= 2	; Character Size
                 .equ	USBS2	= 3	; Stop Bit Select
                 .equ	UPM20	= 4	; Parity Mode Bit 0
                 .equ	UPM21	= 5	; Parity Mode Bit 1
                 .equ	UMSEL20	= 6	; USART Mode Select
                 .equ	UMSEL21	= 7	; USART Mode Select
                 
                 ; UBRR2H - USART Baud Rate Register High Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR2L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** USART3 ***********************
                 ; UDR3 - USART I/O Data Register
                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR3A - USART Control and Status Register A
                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                 .equ	U2X3	= 1	; Double the USART transmission speed
                 .equ	UPE3	= 2	; Parity Error
                 .equ	DOR3	= 3	; Data overRun
                 .equ	FE3	= 4	; Framing Error
                 .equ	UDRE3	= 5	; USART Data Register Empty
                 .equ	TXC3	= 6	; USART Transmitt Complete
                 .equ	RXC3	= 7	; USART Receive Complete
                 
                 ; UCSR3B - USART Control and Status Register B
                 .equ	TXB83	= 0	; Transmit Data Bit 8
                 .equ	RXB83	= 1	; Receive Data Bit 8
                 .equ	UCSZ32	= 2	; Character Size
                 .equ	TXEN3	= 3	; Transmitter Enable
                 .equ	RXEN3	= 4	; Receiver Enable
                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR3C - USART Control and Status Register C
                 .equ	UCPOL3	= 0	; Clock Polarity
                 .equ	UCSZ30	= 1	; Character Size
                 .equ	UCSZ31	= 2	; Character Size
                 .equ	USBS3	= 3	; Stop Bit Select
                 .equ	UPM30	= 4	; Parity Mode Bit 0
                 .equ	UPM31	= 5	; Parity Mode Bit 1
                 .equ	UMSEL30	= 6	; USART Mode Select
                 .equ	UMSEL31	= 7	; USART Mode Select
                 
                 ; UBRR3H - USART Baud Rate Register High Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR3L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog timer always on
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                 .equ	IOEND	= 0x01ff
                 .equ	SRAM_START	= 0x0200
                 .equ	SRAM_SIZE	= 8192
                 .equ	RAMEND	= 0x21ff
                 .equ	XRAMEND	= 0xffff
                 .equ	E2END	= 0x0fff
                 .equ	EEPROMEND	= 0x0fff
                 .equ	EEADRBITS	= 12
                 #pragma AVRPART MEMORY PROG_FLASH 262144
                 #pragma AVRPART MEMORY EEPROM 4096
                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x1f000
                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x1efff
                 .equ	PAGESIZE	= 128
                 .equ	FIRSTBOOTSTART	= 0x1fe00
                 .equ	SECONDBOOTSTART	= 0x1fc00
                 .equ	THIRDBOOTSTART	= 0x1f800
                 .equ	FOURTHBOOTSTART	= 0x1f000
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                 
                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                 
                 #endif  /* _M2560DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 ;.include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program. Or use the ff-shell.py which adds CR LF flow control.
                 .equ BAUDRATE0 = 9600               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 1
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 7            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 96                   ; 86 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 #if defined(__ATmega2560__)
                 #define partstring "ATmega2560"
                 #elif defined(__ATmega328P__)
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "02.07.2016"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def il = r18         ; FOR..LOOP INDEX variable
                   .def ih = r19
                   .def pl = r20         ; P Register
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*255/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fIDLE=     6   ; 0 = busy, 1 = idle
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords flash
                 .equ OFLASH  = PEEPROM+EEPROMEND+1    ; 52 Kbytes available for FlashForth(atm2560)
                 .equ PFLASH  = 0
                 .equ RAMPZV  = 3
                 .equ KERNEL_SIZE=0x0d00
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 ;.equ uaddsize=     0          ; No additional user variables 
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000200           ibuf:         .byte PAGESIZEB
000300           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
000372           rbuf0_wr:    .byte 1
000373           rbuf0_rd:    .byte 1
000374           rbuf0_lv:    .byte 1
000375           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 rxqueue1:
000395           rbuf1_wr:    .byte 1
000396           rbuf1_rd:    .byte 1
000397           rbuf1_lv:    .byte 1
000398           rbuf1:       .byte RX1_BUF_SIZE
                 .endif
                 
0003b8           dpSTART:    .byte 2
0003ba           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0003bc           dpEEPROM:   .byte 2
0003be           dpRAM:      .byte 2
0003c0           dpLATEST:   .byte 2
                 
0003c2           areg:       .byte 2 ; A register data
0003c4           iaddrl:     .byte 1
0003c5           iaddrh:     .byte 1
                 .ifdef RAMPZ
0003c6           iaddru:	    .byte 1
0003c7           ibaseu:	    .byte 1
                 .endif
                 
0003c8           load_acc:   .byte 3 ; Load measurement accumulator
0003cb           load_res:   .byte 3 ; Load result
                 
0003ce           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0003cf           state:      .byte 1 ; Compilation state
0003d0           uvars:      .byte   (-us0)
0003ec           up0:        .byte   2
0003ee           urbuf:      .byte   ursize
00044e           usbuf:      .byte   ussize
00048e           utibbuf:    .byte   utibsize
0004ee           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
01ef00 2081              .db     NFA|1," "
                 MEMQ:
01ef01 940f f0d0         call    CSE_
01ef03 940f f745         call    DOLIT
01ef05 ffb8              fdw     MEMQADDR_N
01ef06 940f f26c         call    PLUS
01ef08 940f f685         call    FETCH_A
01ef0a 940f f4eb         call    CFETCHPP
01ef0c 940f f745         call    DOLIT
01ef0e 000f              .dw     NFAmask
01ef0f 940d f282         jmp     AND_
                 
                 
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
01ef11 94e8              clt
01ef12 2388              tst  tosl
01ef13 f429              brne umslashmodstart
01ef14 2399              tst  tosh
01ef15 f419              brne umslashmodstart
01ef16 9468              set  ; Set T flag
01ef17 940d fdad         jmp  WARM_
                 umslashmodstart:
01ef19 920f              push t2
01ef1a 921f              push t3
01ef1b 01dc              movw t4, tosl
                 
01ef1c 9019              ld t3, Y+
01ef1d 91e9              ld t6, Y+
                   
01ef1e 9189              ld tosl, Y+
01ef1f 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
01ef20 e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
01ef21 27ff              clr t7
01ef22 0f88              lsl tosl
01ef23 1f99              rol tosh
01ef24 1c11              rol t3
01ef25 1fee              rol t6
01ef26 1fff              rol t7
                 
                         ; try subtracting divisor
01ef27 161a              cp  t3, t4
01ef28 07eb              cpc t6, t5
01ef29 05f5              cpc t7,zero
                 
01ef2a f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
01ef2b 9583              inc tosl
01ef2c 1a1a              sub t3, t4
01ef2d 0beb              sbc t6, t5
                 
                 umslashmod2:
01ef2e 950a              dec  t0
01ef2f f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
01ef30 93ea              st -Y,t6
01ef31 921a              st -Y,t3
01ef32 901f              pop t3
01ef33 900f              pop t2
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
01ef34 9508              ret
                 ;*********************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
01ef35 0000              .dw     0
                 EXIT_L:
01ef36 6584
01ef37 6978
01ef38 0074              .db     NFA|4,"exit",0
                 EXIT:
01ef39 910f              m_pop_t0
01ef3a 910f              pop     t0
01ef3b 910f              pop     t0
01ef3c 9508              ret
                 
01ef3d fb28              fdw     IFLUSH_L
                 OPERATOR_L:
01ef3e 6f88
01ef3f 6570
01ef40 6172
01ef41 6f74
01ef42 0072              .db     NFA|8,"operator",0
                 OPERATOR:
01ef43 940f f063         call    DOCREATE
01ef45 de8c              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
01ef46 03ec              .dw     up0
01ef47 0000
01ef48 0060              .dw     0, ursize
01ef49 0040
01ef4a 0060              .dw     ussize, utibsize
                 
                 ; idle
01ef4b de6c              fdw(EXIT_L)
                 IDLE_L:
01ef4c 6984
01ef4d 6c64
01ef4e 0065              .db     NFA|4,"idle",0
                 IDLE:
01ef4f 6470              sbr     FLAGS2, (1<<fIDLE)
01ef50 9508              ret
                         
                 ; busy
01ef51 de98              fdw(IDLE_L)
                 BUSY_L:
01ef52 6284
01ef53 7375
01ef54 0079              .db     NFA|4,"busy",0
                 BUSY:
01ef55 7b7f              cbr     FLAGS2, (1<<fIDLE)
01ef56 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
01ef57 ff82              fdw     ICCOMMA_L
                 MSET_L:
01ef58 6d84
01ef59 6573
01ef5a 0074              .db     NFA|4,"mset",0
                 MSET:
01ef5b 01fc              movw    zl, tosl
01ef5c 9189
01ef5d 9199              poptos
01ef5e 8100              ld      t0, z
01ef5f 2b08              or      t0, tosl
01ef60 8300              st      z, t0
01ef61 9189
01ef62 9199              poptos
01ef63 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
01ef64 deb0              fdw     MSET_L
                 MCLR_L:
01ef65 6d84
01ef66 6c63
01ef67 0072              .db     NFA|4,"mclr",0
                 MCLR_:
01ef68 01fc              movw    zl, tosl
01ef69 9189
01ef6a 9199              poptos
01ef6b 8100              ld      t0, z
01ef6c 9580              com     tosl
01ef6d 2308              and     t0, tosl
01ef6e 8300              st      z, t0
01ef6f 9189
01ef70 9199              poptos
01ef71 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
01ef72 deca              fdw     MCLR_L
                 LSHIFT_L:
01ef73 6c86
01ef74 6873
01ef75 6669
01ef76 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
01ef77 01fc              movw    zl, tosl
01ef78 9189
01ef79 9199              poptos
                 LSHIFT1:
01ef7a 9731              sbiw    zl, 1
01ef7b f01a              brmi    LSHIFT2
01ef7c 0f88              lsl     tosl
01ef7d 1f99              rol     tosh
01ef7e cffb              rjmp    LSHIFT1
                 LSHIFT2:
01ef7f 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
01ef80 dee6              fdw     LSHIFT_L
                 RSHIFT_L:
01ef81 7286
01ef82 6873
01ef83 6669
01ef84 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
01ef85 01fc              movw    zl, tosl
01ef86 9189
01ef87 9199              poptos
                 RSHIFT1:
01ef88 9731              sbiw    zl, 1
01ef89 f01a              brmi    RSHIFT2
01ef8a 9596              lsr     tosh
01ef8b 9587              ror     tosl
01ef8c cffb              rjmp    RSHIFT1
                 RSHIFT2:
01ef8d 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
01ef8e d55c              rcall   CFETCHPP
01ef8f d2ac              rcall   ROT
01ef90 d55a              rcall   CFETCHPP
01ef91 940d f23c         jmp     ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
01ef93 df02              fdw     RSHIFT_L
                 NEQUAL_L:
01ef94 6e82
01ef95 003d              .db     NFA|2,"n=",0
                 NEQUAL:
01ef96 dff7              rcall   NEQUALSFETCH
01ef97 708f              andi    tosl, 0xf
01ef98 d350              rcall   EQUAL
01ef99 d3c0              rcall   ZEROSENSE
01ef9a f0b1              breq    NEQUAL5
01ef9b d313              rcall   ONEMINUS
01ef9c d54e              rcall   CFETCHPP
01ef9d d2a6              rcall   TOR
01ef9e c00c              rjmp    NEQUAL4
                 NEQUAL2:
01ef9f dfee              rcall   NEQUALSFETCH
01efa0 d340              rcall   NOTEQUAL
01efa1 d3b8              rcall   ZEROSENSE
01efa2 f021              breq    NEQUAL3
01efa3 d74c              rcall   TRUE_
01efa4 940f fa03         call    LEAVE
01efa6 c004              rjmp    NEQUAL4
                 NEQUAL3:
01efa7 d2b2              rcall   RFETCH
01efa8 d3b1              rcall   ZEROSENSE
01efa9 f409              brne    NEQUAL4
01efaa d73c              rcall   FALSE_
                 NEQUAL4:
01efab 940f f9f2         call    XNEXT
01efad f788              brcc    NEQUAL2
01efae 911f              pop     t1
01efaf 910f              pop     t0
01efb0 c001              rjmp    NEQUAL6
                 NEQUAL5:
01efb1 d73e              rcall   TRUE_
                 NEQUAL6:
01efb2 d3e8              rcall   NIP
01efb3 940d f39b         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
01efb5 df28              fdw     NEQUAL_L
                 SKIP_L:
01efb6 7384
01efb7 696b
01efb8 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
01efb9 d28a              rcall   TOR
                 SKIP0:
01efba d3a5              rcall   DUPZEROSENSE
01efbb f089              breq    SKIP2
                 
01efbc d277              rcall   OVER
01efbd d3ff              rcall   CFETCH_A
                 
01efbe d790              rcall   DUP
01efbf d785              rcall   DOLIT
01efc0 0009              .dw     TAB_
01efc1 d327              rcall   EQUAL
01efc2 d397              rcall   ZEROSENSE
01efc3 f429              brne    SKIP05    
01efc4 d295              rcall   RFETCH
01efc5 d323              rcall   EQUAL
01efc6 d393              rcall   ZEROSENSE
01efc7 f029              breq    SKIP2
01efc8 c001                      rjmp    SKIP1
                 SKIP05:
01efc9 d259              rcall   DROP
                 SKIP1:
01efca d1cc              rcall   ONE
01efcb d4ca              rcall   SLASHSTRING
01efcc cfed              rjmp    SKIP0
                 SKIP2:
01efcd 910f              pop     t0
01efce 910f              pop     t0
01efcf 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
01efd0 df6c              fdw     SKIP_L
                 SCAN_L:
01efd1 7384
01efd2 6163
01efd3 006e              .db     NFA|4,"scan",0
                 SCAN:
01efd4 d339              rcall   STORE_P_TO_R
01efd5 d26e              rcall   TOR
01efd6 c010              rjmp    SCAN3
                 SCAN1:
01efd7 d513              rcall   CFETCHPP
01efd8 d776              rcall   DUP
01efd9 d76b              rcall   DOLIT
01efda 0009              .dw     TAB_
01efdb d30d              rcall   EQUAL
01efdc d37d              rcall   ZEROSENSE
01efdd f011              breq    SCAN2
01efde d244              rcall   DROP
01efdf c005              rjmp    SCAN25
                 SCAN2:
01efe0 940f fadf         call    FETCH_P
01efe2 d306              rcall   EQUAL
01efe3 d376              rcall   ZEROSENSE
01efe4 f011              breq    SCAN3
                 SCAN25:
01efe5 d2c9              rcall   ONEMINUS
01efe6 c003              rjmp    SCAN4
                 SCAN3:
01efe7 940f f9f2         call    XNEXT
01efe9 f768              brcc    SCAN1
                 SCAN4:
01efea d264              rcall   RFROM
01efeb d2be              rcall   ONEPLUS
01efec d32d              rcall   R_TO_P
01efed 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
01efee dfa2              fdw     SCAN_L
                 MTST_L:
01efef 6d84
01eff0 7374
01eff1 0074              .db     NFA|4,"mtst",0
                 MTST:
01eff2 940f ff12         call    CFETCH
01eff4 940d f282         jmp     AND_
                 
01eff6 dfde              fdw     MTST_L
                 FCY_L:
01eff7 4683
01eff8 7963              .db     NFA|3,"Fcy"
01eff9 d069              rcall   DOCREATE
01effa 3e80              .dw     FREQ_OSC / 1000
                 
                 ;*******************************************************
                 ; Assembler
                 ;*******************************************************
                 ; FIXME
                 ;*******************************************************
                         
                 
                 ;;; Check parameter stack pointer
01effb 7383
01effc 3f70              .db     NFA|3,"sp?"
                 check_sp:
01effd d08e              rcall   SPFETCH
01effe 940f f87d         call    R0_
01f000 d684              rcall   FETCH_A
01f001 940f f878         call    S0
01f003 d681              rcall   FETCH_A
01f004 d2a5              rcall   ONEPLUS
01f005 d2d1              rcall   WITHIN
01f006 d1e4              rcall   XSQUOTE
01f007 5303
01f008 3f50              .db     3,"SP?"
01f009 d728              rcall   QABORT
01f00a 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
01f00b dfee              fdw     FCY_L
                 EMIT_L:
01f00c 6584
01f00d 696d
01f00e 0074              .db     NFA|4,"emit",0
                 EMIT:
01f00f d33a              rcall   UEMIT_
01f010 940d f02e         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
01f012 e018              fdw     EMIT_L
                 KEY_L:
01f013 6b83
01f014 7965              .db     NFA|3,"key"
                 KEY:
01f015 d33a              rcall   UKEY_
01f016 940d f02e         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
01f018 e026              fdw     KEY_L
                 KEYQ_L:
01f019 6b84
01f01a 7965
01f01b 003f              .db     NFA|4,"key?",0
                 KEYQ:
01f01c d339              rcall   UKEYQ_
01f01d 940d f02e         jmp     FEXECUTE
                 
01f01f e032              fdw     KEYQ_L
                 EXECUTE_L:
01f020 6587
01f021 6578
01f022 7563
01f023 6574              .db     NFA|7,"execute"
                 EXECUTE:
01f024 01fc              movw    zl, tosl
                         sub_pflash_z
01f025 9189
01f026 9199              poptos
01f027 9408              rampv_to_c
01f028 95f7              ror     zh
01f029 95e7              ror     zl
01f02a 9419              mijmp
                 
01f02b e040              fdw     EXECUTE_L
                 FEXECUTE_L:
01f02c 4083
01f02d 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
01f02e d656              rcall   FETCH_A
01f02f 940d f024         jmp     EXECUTE
                 
01f031 e058              fdw     FEXECUTE_L
                 VARIABLE_L:
01f032 7688
01f033 7261
01f034 6169
01f035 6c62
01f036 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
01f037 d0a2              rcall   HERE
01f038 d0b7              rcall   CELL
01f039 d1e2              rcall   ALLOT
01f03a 940d f04e         jmp     CONSTANT_
                 
01f03c e064              fdw     VARIABLE_L
                 TWOVARIABLE_L:
01f03d 3289
01f03e 6176
01f03f 6972
01f040 6261
01f041 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
01f042 d097              rcall   HERE
01f043 d701              rcall   DOLIT
01f044 0004              .dw     0x4
01f045 d1d6              rcall   ALLOT
01f046 940d f04e         jmp     CONSTANT_
                 
01f048 e07a              fdw     TWOVARIABLE_L
                 CONSTANT_L:
01f049 6388
01f04a 6e6f
01f04b 7473
01f04c 6e61
01f04d 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
01f04e d7c1              rcall   COLON
01f04f 940f fe6e         call    LITERAL
01f051 940d f81e         jmp     SEMICOLON
                 
01f053 e092              fdw     CONSTANT_L
                 TWOCONSTANT_L:
01f054 3289
01f055 6f63
01f056 736e
01f057 6174
01f058 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
01f059 d1d0              rcall   SWOP
01f05a d7b5              rcall   COLON
01f05b 940f fe6e         call    LITERAL
01f05d 940f fe6e         call    LITERAL
01f05f 940d f81e         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
01f061 2883
01f062 2963              .db     NFA|3, "(c)"
                 DOCREATE:
01f063 91ff              m_pop_zh
01f064 91ff              pop     zh
01f065 91ef              pop     zl
01f066 d00f              rcall   FETCHLIT
01f067 91ff              m_pop_zh
01f068 91ff              pop     zh
01f069 91ef              pop     zl
01f06a 9419              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
01f06b 2883
01f06c 2964              .db     NFA|3, "(d)"
                 DODOES:
01f06d 91bf              m_pop_xh
01f06e 91bf              pop     xh
01f06f 91af              pop     xl
01f070 91ff              m_pop_zh
01f071 91ff              pop     zh
01f072 91ef              pop     zl
01f073 d002              rcall   FETCHLIT
01f074 01fd              movw    z, x
01f075 9419              mijmp    ; (z)
                 FETCHLIT:
01f076 939a
01f077 938a              pushtos
01f078 0fee              lsl     zl
01f079 1fff              rol     zh
01f07a 9187              lpm_    tosl, z+
01f07b 9197              lpm_    tosh, z+
01f07c 9508              ret
                 
01f07d 2883
01f07e 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
01f07f 910f              m_pop_t0
01f080 91ff              pop     zh
01f081 91ef              pop     zl
01f082 dff3              rcall   FETCHLIT
01f083 95f7              ror     zh
01f084 95e7              ror     zl
01f085 93ef              push    zl
01f086 93ff              push    zh
01f087 930f              m_push_t0
01f088 c09a              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
01f089 e0a8              fdw     TWOCONSTANT_L
                 SPFETCH_L:
01f08a 7383
01f08b 4070              .db     NFA|3,"sp@"
                 SPFETCH:
01f08c 01fe              movw    z, y
01f08d 939a
01f08e 938a              pushtos
01f08f 01cf              movw    tosl, z
01f090 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
01f091 7383
01f092 2170              .db     NFA|3,"sp!"
                 SPSTORE:
01f093 01ec              movw    y, tosl
01f094 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
01f095 7283
01f096 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
01f097 91bf              m_pop_xh
01f098 91bf              pop     xh
01f099 91af              pop     xl
01f09a d7e2              rcall   R0_
01f09b d5e9              rcall   FETCH_A
01f09c bf8d              out     spl, tosl
01f09d bf9e              out     sph, tosh
01f09e 9189
01f09f 9199              poptos
01f0a0 01fd              movw    zl, xl
01f0a1 9419              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
01f0a2 e114              fdw     SPFETCH_L
                 RPFETCH_L:
01f0a3 72b3
01f0a4 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
01f0a5 939a
01f0a6 938a              pushtos
01f0a7 b78d              in      tosl, spl
01f0a8 b79e              in      tosh, sph
01f0a9 9508              ret
                 
                 ;   ><  Swap bytes        
01f0aa e146              fdw     RPFETCH_L
                 SWAPB_L:
01f0ab 3ea2
01f0ac 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
01f0ad 2f08              mov     t0, tosl
01f0ae 2f89              mov     tosl, tosh
01f0af 2f90              mov     tosh, t0
01f0b0 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
01f0b1 e156              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
01f0b2 6685
01f0b3 616c
01f0b4 6873              .db     NFA|5,"flash"
                 ROM_:
01f0b5 9250 03ce         sts     cse, zero
01f0b7 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
01f0b8 e164              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
01f0b9 6586
01f0ba 7065
01f0bb 6f72
01f0bc 006d              .db     NFA|6,"eeprom",0
                 EROM:
01f0bd 9270 03ce         sts     cse, r_two
01f0bf 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
01f0c0 e172              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
01f0c1 7283
01f0c2 6d61              .db     NFA|3,"ram"
                 FRAM:
01f0c3 e004              ldi     t0, 4
01f0c4 9300 03ce         sts     cse, t0
01f0c6 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
01f0c7 e182              fdw     RAM_L
                 DP_L:
01f0c8 6482
01f0c9 0070              .db     NFA|2,"dp",0
                 DP:
01f0ca d717              rcall   IDP
01f0cb d004              rcall   CSE_
01f0cc 940d f26c         jmp     PLUS
                 
                 
                 ;;; 
01f0ce 6383
01f0cf 6573              .db     NFA|3,"cse"
                 CSE_:
01f0d0 939a
01f0d1 938a              pushtos
01f0d2 9180 03ce         lds     tosl, cse
01f0d4 2799              clr     tosh
01f0d5 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
01f0d6 e190              fdw     DP_L
                 HERE_L:
01f0d7 6884
01f0d8 7265
01f0d9 0065              .db     NFA|4,"here",0
                 HERE:
01f0da dfef              rcall   DP
01f0db 940d fee5         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
01f0dd e1ae              fdw     HERE_L
                 COMMA_L:
01f0de 2c81              .db     NFA|1,","
                 COMMA:
01f0df dffa              rcall   HERE
01f0e0 d418              rcall   STORE_A
01f0e1 d00e              rcall   CELL
01f0e2 940d f21c         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
01f0e4 e1bc              fdw     COMMA_L 
                 CCOMMA_L:
01f0e5 6382
01f0e6 002c              .db     NFA|2,"c,",0
                 CCOMMA:
01f0e7 dff2              rcall   HERE
01f0e8 d2d8              rcall   CSTORE_A
01f0e9 d0ad              rcall   ONE
01f0ea 940d f21c         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
01f0ec e1ca              fdw     CCOMMA_L
                 CELL_L:
01f0ed 6384
01f0ee 6c65
01f0ef 006c              .db     NFA|4,"cell",0
                 CELL:
01f0f0 939a
01f0f1 938a              pushtos
01f0f2 e082              ldi     tosl, 2
01f0f3 e090              ldi     tosh, 0
01f0f4 9508              ret
                 
                 ; ALIGN    --                         align DP
01f0f5 e1da              fdw     CELL_L
                 ALIGN_L:
01f0f6 6185
01f0f7 696c
01f0f8 6e67              .db     NFA|5,"align"
                 ALIGN:
01f0f9 dfe0              rcall   HERE
01f0fa d008              rcall   ALIGNED
01f0fb dfce              rcall   DP
01f0fc 940d fe9a         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
01f0fe e1ec              fdw     ALIGN_L
                 ALIGNED_L:
01f0ff 6187
01f100 696c
01f101 6e67
01f102 6465              .db     NFA|7,"aligned"
                 ALIGNED:
01f103 9601              adiw    tosl, 1
01f104 d640              rcall   DOLIT
01f105 fffe              .dw     0xfffe
01f106 940d f282         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
01f108 e1fe              fdw     ALIGNED_L
                 CELLPLUS_L:
01f109 63a5
01f10a 6c65
01f10b 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
01f10c 9602              adiw    tosl, 2
01f10d 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
01f10e e212              fdw     CELLPLUS_L
                 CELLS_L:
01f10f 63a5
01f110 6c65
01f111 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
01f112 0f88              lsl     tosl
01f113 1f99              rol     tosh
01f114 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
01f115 e21e              fdw     CELLS_L
                 CHARPLUS_L:
01f116 63a5
01f117 6168
01f118 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
01f119 9601              adiw    tosl, 1
01f11a 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
01f11b e22c              fdw     CHARPLUS_L
                 CHARS_L:
01f11c 63a5
01f11d 6168
01f11e 7372              .db     NFA|INLINE|5,"chars"
01f11f 9508      CHARS:  ret
                 
01f120 e238              fdw     CHARS_L
                 COMMAXT_L:
01f121 6383
01f122 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
01f123 d62b              rcall   DUP
01f124 d656              rcall   IHERE
01f125 d153              rcall   MINUS
01f126 d140              rcall   ABS_ 
01f127 d61d              rcall   DOLIT
01f128 0ff0              .dw     0xff0
01f129 d1c9              rcall   GREATER
01f12a d22f              rcall   ZEROSENSE
01f12b f051              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
01f12c d618              rcall   DOLIT
                 .ifdef EIND
01f12d 940f              .dw     0x940F  ; On Atmega 2560 all code is on 128 - 256 Kword area.
                 .else
                 .endif
01f12e 940f ffb9         call    ICOMMA
                         sub_pflash_tos
01f130 9408              rampv_to_c
01f131 9597              ror     tosh
01f132 9587              ror     tosl
01f133 940f ffb9         call    ICOMMA
01f135 c008              rjmp    STORECF2
                 STORECF1:
01f136 d644              rcall   IHERE
01f137 d141              rcall   MINUS
01f138 d721              rcall   TWOMINUS
01f139 d18b              rcall   TWOSLASH
                         ;rcall   RCALL_
01f13a 709f              andi    tosh, 0x0f
01f13b 6d90              ori     tosh, 0xd0
01f13c 940f ffb9         call    ICOMMA
                 STORECF2:
01f13e 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
01f13f 2186
01f140 6f63
01f141 6f6c
01f142 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
01f143 d601              rcall   DOLIT
01f144 fffa              .dw     0xfffa         ;  -6
01f145 940d f922         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
01f147 e242              fdw     COMMAXT_L
                 TWOFETCH_L:
01f148 3282
01f149 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
01f14a d604              rcall   DUP
01f14b d539              rcall   FETCH_A
01f14c d0dd              rcall   SWOP
01f14d dfbe              rcall   CELLPLUS
01f14e 940d f685         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
01f150 e290              fdw     TWOFETCH_L
                 TWOSTORE_L:
01f151 3282
01f152 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
01f153 d0d6              rcall   SWOP
01f154 d0df              rcall   OVER
01f155 dfb6              rcall   CELLPLUS
01f156 d3a2              rcall   STORE_A
01f157 940d fe9a         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
01f159 e2a2              fdw     TWOSTORE_L
                 TWODROP_L:
01f15a 3285
01f15b 7264
01f15c 706f              .db     NFA|5,"2drop"
                 TWODROP:
01f15d d0c5              rcall   DROP
01f15e 940d f223         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
01f160 e2b4              fdw     TWODROP_L
                 TWODUP_L:
01f161 3284
01f162 7564
01f163 0070              .db     NFA|4,"2dup",0
                 TWODUP:
01f164 d0cf              rcall   OVER
01f165 940d f234         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
01f167 e2c2              fdw     TWODUP_L
                 TWOSWAP_L:
01f168 3285
01f169 7773
01f16a 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
01f16b d0d0              rcall   ROT
01f16c d0d7              rcall   TOR
01f16d d0ce              rcall   ROT
01f16e d0e0              rcall   RFROM
01f16f 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
01f170 e2d0              fdw     TWOSWAP_L
                 SPACE_L:
01f171 7385
01f172 6170
01f173 6563              .db     NFA|5,"space"
                 SPACE_:  
01f174 d6ea              rcall   BL
01f175 940d f00f         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
01f177 e2e2              fdw     SPACE_L
                 SPACES_L:
01f178 7386
01f179 6170
01f17a 6563
01f17b 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
01f17c d1e3              rcall   DUPZEROSENSE
01f17d f019              breq    SPCS2
01f17e dff5              rcall   SPACE_
01f17f d12f              rcall   ONEMINUS
01f180 cffb              rjmp    SPCS1
01f181 940d f223 SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
01f183 e2f0              fdw     SPACES_L
                 UMIN_L:
01f184 7584
01f185 696d
01f186 006e              .db     NFA|4,"umin",0
                 UMIN:
01f187 dfdc              rcall   TWODUP
01f188 d177              rcall   UGREATER
01f189 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
01f18a e308              fdw     UMIN_L
                 UMAX_L:
01f18b 7584
01f18c 616d
01f18d 0078              .db     NFA|4,"umax",0
                 UMAX:
01f18e dfd5              rcall   TWODUP
01f18f d169              rcall   ULESS
                 MINMAX:
01f190 d1c9              rcall   ZEROSENSE
01f191 f009              breq    UMAX1
01f192 d097              rcall   SWOP
01f193 940d f223 UMAX1:  jmp     DROP
                 
01f195 e316              fdw     UMAX_L
                 ONE_L:
01f196 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
01f197 939a
01f198 938a              pushtos
01f199 e081              ldi     tosl, 1
01f19a e090              ldi     tosh, 0
01f19b 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
01f19c e32c              fdw     ONE_L
                 ACCEPT_L:
01f19d 6186
01f19e 6363
01f19f 7065
01f1a0 0074              .db     NFA|6,"accept",0
                 ACCEPT:
01f1a1 d092              rcall   OVER
01f1a2 d0c9              rcall   PLUS
01f1a3 d090              rcall   OVER
                 ACC1:
01f1a4 de70              rcall   KEY
                 
01f1a5 308d              cpi     tosl, CR_
01f1a6 f429              brne    ACC_LF
                         
01f1a7 d548              rcall   TRUE_
01f1a8 d02f              rcall   FCR
01f1a9 d217              rcall   CSTORE_A
01f1aa d078              rcall   DROP
01f1ab c026              rjmp    ACC6
                 ACC_LF:
01f1ac 308a              cpi     tosl, LF_
01f1ad f449              brne    ACC2
01f1ae d074              rcall   DROP
                 
01f1af d028              rcall   FCR
01f1b0 d20c              rcall   CFETCH_A
01f1b1 d1a8              rcall   ZEROSENSE
01f1b2 f0f9              breq    ACC6
01f1b3 d533              rcall   FALSE_
01f1b4 d023              rcall   FCR
01f1b5 d20b              rcall   CSTORE_A
01f1b6 cfed              rjmp    ACC1
                 ACC2:
01f1b7 d52f              rcall   FALSE_
01f1b8 d01f              rcall   FCR
01f1b9 d207              rcall   CSTORE_A
01f1ba d594              rcall   DUP
01f1bb de53              rcall   EMIT
01f1bc d592              rcall   DUP
01f1bd d587              rcall   DOLIT
01f1be 0008              .dw     BS_
01f1bf d129              rcall   EQUAL
01f1c0 d199              rcall   ZEROSENSE
01f1c1 f039              breq    ACC3
01f1c2 d060              rcall   DROP
01f1c3 d0eb              rcall   ONEMINUS
01f1c4 d07f              rcall   TOR
01f1c5 d06e              rcall   OVER
01f1c6 d088              rcall   RFROM
01f1c7 dfc6              rcall   UMAX
01f1c8 cfdb              rjmp    ACC1
                 ACC3:
01f1c9 d06a              rcall   OVER
01f1ca d1f6              rcall   CSTORE_A
01f1cb d0de              rcall   ONEPLUS
01f1cc d067              rcall   OVER
01f1cd dfb9              rcall   UMIN
01f1ce df95              rcall   TWODUP
01f1cf d111              rcall   NOTEQUAL
01f1d0 d189              rcall   ZEROSENSE
01f1d1 f691              brne     ACC1
                 ACC6:
01f1d2 d1c8              rcall   NIP
01f1d3 d056              rcall   SWOP
01f1d4 940d f279         jmp     MINUS
                 
01f1d6 6683
01f1d7 7263              .db     NFA|3,"fcr"
                 FCR:
01f1d8 d2a9              rcall   DOUSER
01f1d9 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
01f1da e33a              fdw      ACCEPT_L
                 TYPE_L:
01f1db 7484
01f1dc 7079
01f1dd 0065              .db     NFA|4,"type",0
                 TYPE:
01f1de d065              rcall   TOR
01f1df c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
01f1e0 d30a              rcall   CFETCHPP
01f1e1 de2d              rcall   EMIT
                 TYPE2:
01f1e2 940f f9f2         call    XNEXT
01f1e4 f7d8              brcc    TYPE1
01f1e5 911f              pop     t1
01f1e6 910f              pop     t0
01f1e7 940d f223         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
01f1e9 2883
01f1ea 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
01f1eb 91ff              m_pop_zh
01f1ec d06d              rcall   RFETCH
01f1ed 0f88              lsl     tosl
01f1ee 1f99              rol     tosh
                         add_pflash_tos
01f1ef d2fb              rcall   CFETCHPP
01f1f0 d55e              rcall   DUP
01f1f1 d0b8              rcall   ONEPLUS
01f1f2 df10              rcall   ALIGNED
01f1f3 9596              lsr     tosh
01f1f4 9587              ror     tosl
01f1f5 d059              rcall   RFROM
01f1f6 d075              rcall   PLUS
01f1f7 01fc              movw    zl, tosl
01f1f8 9189
01f1f9 9199              poptos
01f1fa 9419              mijmp
                 
01f1fb e3b6              fdw     TYPE_L
                 SQUOTE_L:
01f1fc 73d2
01f1fd 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
01f1fe de80              rcall   DOCOMMAXT
01f1ff e3d6              fdw     XSQUOTE
01f200 deb4              rcall   ROM_
01f201 d005              rcall   CQUOTE
01f202 940d f0c3         jmp     FRAM
                 
01f204 e3f8              fdw     SQUOTE_L
                 CQUOTE_L:
01f205 2c82
01f206 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
01f207 d53d              rcall   DOLIT
01f208 0022              .dw     0x22
01f209 d29f              rcall   PARSE
01f20a decf              rcall   HERE
01f20b d028              rcall   OVER
01f20c d09d              rcall   ONEPLUS
01f20d def5              rcall   ALIGNED
01f20e d00d              rcall   ALLOT
01f20f 940d f4e2         jmp     PLACE
                 
                 
01f211 e40a              fdw     CQUOTE_L
                 DOTQUOTE_L:
01f212 2ed2
01f213 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
01f214 dfe9              rcall   SQUOTE
01f215 de69              rcall   DOCOMMAXT
01f216 e3bc              fdw     TYPE
01f217 9508              ret
                 
01f218 e424              fdw     DOTQUOTE_L
                 ALLOT_L:
01f219 6185
01f21a 6c6c
01f21b 746f              .db     NFA|5,"allot"
                 ALLOT:
01f21c dead              rcall   DP
01f21d 940d f2cb         jmp     PLUSSTORE
                 
01f21f e432              fdw     ALLOT_L
                 DROP_L:
01f220 64a4
01f221 6f72
01f222 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
01f223 9189
01f224 9199              poptos
01f225 9508              ret
                 
01f226 e440              fdw     DROP_L
                 SWOP_L:
01f227 7384
01f228 6177
01f229 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
01f22a 9109              ld      t0, y+
01f22b 9119              ld      t1, y+
01f22c 939a
01f22d 938a              pushtos
01f22e 01c8              movw    tosl, t0
01f22f 9508              ret
                 
01f230 e44e              fdw     SWOP_L
                 OVER_L:
01f231 6f84
01f232 6576
01f233 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
01f234 939a
01f235 938a              pushtos
01f236 818a              ldd     tosl, y+2
01f237 819b              ldd     tosh, y+3
01f238 9508              ret
                 
01f239 e462              fdw     OVER_L
                 ROT_L:
01f23a 7283
01f23b 746f              .db     NFA|3, "rot"
                 ROT:
01f23c d007              rcall   TOR
01f23d dfec              rcall   SWOP
01f23e d010              rcall   RFROM
01f23f 940d f22a         jmp     SWOP
                 
01f241 e474              fdw     ROT_L
                 TOR_L:
01f242 3e92
01f243 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
01f244 91ff              m_pop_zh
01f245 91ff              pop     zh
01f246 91ef              pop     zl
01f247 938f              push    tosl
01f248 939f              push    tosh
01f249 9189
01f24a 9199              poptos
01f24b 9419              mijmp
                 
01f24c e484              fdw     TOR_L
                 RFROM_L:
01f24d 7292
01f24e 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
01f24f 91ff              m_pop_zh
01f250 91ff              pop     zh
01f251 91ef              pop     zl
01f252 939a
01f253 938a              pushtos
01f254 919f              pop     tosh
01f255 918f              pop     tosl
01f256 9419              mijmp
                 
01f257 e49a              fdw     RFROM_L
                 RFETCH_L:
01f258 7292
01f259 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
01f25a 91ff              m_pop_zh
01f25b 91ff              pop     zh
01f25c 91ef              pop     zl
01f25d 939a
01f25e 938a              pushtos
01f25f 919f              pop     tosh
01f260 918f              pop     tosl
01f261 938f              push    tosl
01f262 939f              push    tosh
01f263 9419              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
01f264 ee9a              fdw     DUP_L
                 ABS_L:
01f265 6183
01f266 7362              .db     NFA|3,"abs"
                 ABS_:
01f267 d4e7              rcall   DUP
01f268 940d f3aa         jmp     QNEGATE
                 
01f26a e4ca              fdw     ABS_L
                 PLUS_L:
01f26b 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
01f26c 9109              ld      t0, Y+        
01f26d 9119              ld      t1, Y+
01f26e 0f80              add     tosl, t0
01f26f 1f91              adc     tosh, t1
01f270 9508              ret
                 
                 ; m+  ( d n -- d1 )
01f271 e4d6              fdw     PLUS_L
                 MPLUS_L:
01f272 6d82
01f273 002b              .db     NFA|2, "m+",0
                 MPLUS:
01f274 d7a3              rcall   STOD
01f275 940d fa3a         jmp     DPLUS
                 
01f277 e4e4              fdw     MPLUS_L
                 MINUS_L:
01f278 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
01f279 9109              ld      t0, Y+
01f27a 9119              ld      t1, Y+
01f27b 1b08              sub     t0, tosl
01f27c 0b19              sbc     t1, tosh
01f27d 01c8              movw    tosl, t0
01f27e 9508              ret
                 
01f27f e4f0              fdw     MINUS_L
                 AND_L:
01f280 6183
01f281 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
01f282 9109              ld      t0, Y+
01f283 9119              ld      t1, Y+
01f284 2380              and     tosl, t0
01f285 2391              and     tosh, t1
01f286 9508              ret
                 
01f287 e500              fdw     AND_L
                 OR_L:
01f288 6f82
01f289 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
01f28a 9109              ld      t0, Y+
01f28b 9119              ld      t1, Y+
01f28c 2b80              or      tosl, t0
01f28d 2b91              or      tosh, t1
01f28e 9508              ret
                 
01f28f e510              fdw     OR_L
                 XOR_L:
01f290 7883
01f291 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
01f292 9109              ld      t0, Y+
01f293 9119              ld      t1, Y+
01f294 2780              eor     tosl, t0
01f295 2791              eor     tosh, t1
01f296 9508              ret
                 
01f297 e520              fdw     XOR_L
                 INVERT_L:
01f298 69a6
01f299 766e
01f29a 7265
01f29b 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
01f29c 9580              com     tosl
01f29d 9590              com     tosh
01f29e 9508              ret
                 
01f29f e530              fdw     INVERT_L
                 NEGATE_L:
01f2a0 6e86
01f2a1 6765
01f2a2 7461
01f2a3 0065              .db     NFA|6, "negate",0
                 NEGATE:
01f2a4 dff7              rcall   INVERT
01f2a5 940d f2aa         jmp     ONEPLUS
                 
01f2a7 e540              fdw     NEGATE_L
                 ONEPLUS_L:
01f2a8 31a2
01f2a9 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
01f2aa 9601              adiw    tosl, 1
01f2ab 9508              ret
                 
01f2ac e550              fdw     ONEPLUS_L
                 ONEMINUS_L:
01f2ad 31a2
01f2ae 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
01f2af 9701              sbiw    tosl, 1
01f2b0 9508              ret
                 
01f2b1 e55a              fdw     ONEMINUS_L
                 TWOPLUS_L:
01f2b2 32a2
01f2b3 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
01f2b4 9602              adiw    tosl, 2
01f2b5 9508              ret
                 
01f2b6 e564              fdw     TWOPLUS_L
                 TOBODY_L:
01f2b7 3ea5
01f2b8 6f62
01f2b9 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
01f2ba 9604              adiw    tosl, 4
01f2bb 9508              ret
                 
01f2bc e56e              fdw     TOBODY_L
                 TWOSTAR_L:
01f2bd 32a2
01f2be 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
01f2bf 0f88              lsl     tosl
01f2c0 1f99              rol     tosh
01f2c1 9508              ret
                 
01f2c2 e57a              fdw     TWOSTAR_L
                 TWOSLASH_L:
01f2c3 32a2
01f2c4 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
01f2c5 9595              asr     tosh
01f2c6 9587              ror     tosl
01f2c7 9508              ret
                 
01f2c8 e586              fdw     TWOSLASH_L
                 PLUSSTORE_L:
01f2c9 2b82
01f2ca 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
01f2cb df5e              rcall   SWOP
01f2cc df67              rcall   OVER
01f2cd d3b7              rcall   FETCH_A
01f2ce df9d              rcall   PLUS
01f2cf df5a              rcall   SWOP
01f2d0 940d fe9a         jmp     STORE
                 
01f2d2 e592              fdw     PLUSSTORE_L
                 WITHIN_L:
01f2d3 7786
01f2d4 7469
01f2d5 6968
01f2d6 006e              .db     NFA|6,"within",0
                 WITHIN:
01f2d7 df5c              rcall   OVER
01f2d8 dfa0              rcall   MINUS
01f2d9 df6a              rcall   TOR
01f2da df9e              rcall   MINUS
01f2db df73              rcall   RFROM
01f2dc 940d f2f9         jmp     ULESS
                 
01f2de e5a6              fdw     WITHIN_L
                 NOTEQUAL_L:
01f2df 3c82
01f2e0 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
01f2e1 df97              rcall   MINUS           ; MINUS leaves a valid zero flag
01f2e2 ef9f              ser     tosh
01f2e3 ef8f              ser     tosl
01f2e4 f409              brne    NOTEQUAL1
01f2e5 9601              adiw    tosl,1
                 NOTEQUAL1:
01f2e6 9508              ret
                 
01f2e7 eeb4              fdw     ZEROLESS_L
                 EQUAL_L:
01f2e8 3d81              .db     NFA|1, "="
                 EQUAL:
01f2e9 df8f              rcall   MINUS
01f2ea 940d f755         jmp     ZEROEQUAL
                 
                 
01f2ec e5d0              fdw     EQUAL_L
                 LESS_L:
01f2ed 3c81              .db     NFA|1,"<"
                 LESS:
01f2ee df8a              rcall   MINUS
01f2ef 940d f75c         jmp     ZEROLESS
                 
01f2f1 e5da              fdw     LESS_L
                 GREATER_L:
01f2f2 3e81              .db     NFA|1,">"
                 GREATER:
01f2f3 df36              rcall   SWOP
01f2f4 940d f2ee         jmp     LESS
                 
01f2f6 e5e4              fdw     GREATER_L
                 ULESS_L:
01f2f7 7582
01f2f8 003c              .db     NFA|2,"u<",0
                 ULESS:
01f2f9 df7f              rcall   MINUS       ; Carry is valid after MINUS
01f2fa 0b88              sbc     tosl, tosl
01f2fb 0b99              sbc     tosh, tosh
01f2fc 9508              ret
                 
01f2fd e5ee              fdw     ULESS_L
                 UGREATER_L:
01f2fe 7582
01f2ff 003e              .db     NFA|2, "u>",0
                 UGREATER:
01f300 df29              rcall   SWOP
01f301 940d f2f9         jmp     ULESS
                 
01f303 e5fc              fdw     UGREATER_L
                 STORE_P_L:
01f304 2182
01f305 0070              .db     NFA|2,"!p",0
                 STORE_P:
01f306 01ac              movw    pl, tosl
01f307 9189
01f308 9199              poptos
01f309 9508              ret
                 
01f30a e608              fdw     STORE_P_L
                 STORE_P_TO_R_L:
01f30b 2194
01f30c 3e70
01f30d 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
01f30e 91ff              m_pop_zh
01f30f 91ff              pop     zh
01f310 91ef              pop     zl
01f311 934f              push    pl
01f312 935f              push    ph
01f313 01ac              movw    pl, tosl
01f314 9189
01f315 9199              poptos
01f316 9419              mijmp
                 
01f317 e616              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
01f318 7293
01f319 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
01f31a 91ff              m_pop_zh
01f31b 91ff              pop     zh
01f31c 91ef              pop     zl
01f31d 915f              pop     ph
01f31e 914f              pop     pl
01f31f 9419              mijmp
                 
01f320 e630              fdw     R_TO_P_L
                 PFETCH_L:
01f321 7082
01f322 0040              .db     NFA|2,"p@",0
                 PFETCH:
01f323 939a
01f324 938a              pushtos
01f325 01ca              movw    tosl, pl
01f326 940d fee5         jmp     FETCH
                 
01f328 e642              fdw     PFETCH_L
                 PSTORE_L:
01f329 7082
01f32a 0021              .db     NFA|2,"p!",0
                 PSTORE:
01f32b 939a
01f32c 938a              pushtos
01f32d 01ca              movw    tosl, pl
01f32e 940d fe9a         jmp     STORE
                 
01f330 e652              fdw     PSTORE_L
                 PCSTORE_L:
01f331 7083
01f332 2163              .db     NFA|3,"pc!"
                 PCSTORE:
01f333 939a
01f334 938a              pushtos
01f335 01ca              movw    tosl, pl
01f336 940d ff35         jmp     CSTORE
                 
01f338 e662              fdw     PCSTORE_L
                 PPLUS_L:
01f339 70a2
01f33a 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
01f33b 0d46              add     pl, r_one
01f33c 1d55              adc     ph, zero
01f33d 9508              ret   
                 
01f33e e672              fdw     PPLUS_L
                 PNPLUS_L:
01f33f 7083
01f340 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
01f341 0f48              add     pl, tosl
01f342 1f59              adc     ph, tosh
01f343 9189
01f344 9199              poptos
01f345 9508              ret
                 
01f346 e67e              fdw     PNPLUS_L
                 UEMIT_L:
01f347 2785
01f348 6d65
01f349 7469              .db     NFA|5,"'emit"
                 UEMIT_:
01f34a d137              rcall   DOUSER
01f34b ffe8              .dw     uemit
                         
01f34c e68e              fdw     UEMIT_L
                 UKEY_L:
01f34d 2784
01f34e 656b
01f34f 0079              .db     NFA|4,"'key",0
                 UKEY_:
01f350 d131              rcall   DOUSER
01f351 ffea              .dw     ukey
                 
01f352 e69a              fdw     UKEY_L
                 UKEYQ_L:
01f353 2785
01f354 656b
01f355 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
01f356 d12b              rcall   DOUSER
01f357 ffec              .dw     ukeyq
                 
01f358 3f83
01f359 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
01f35a 9700              sbiw    tosl, 0
01f35b 9189
01f35c 9199              poptos
01f35d 9508              ret
                 
01f35e 6483
01f35f 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
01f360 9700              sbiw    tosl, 0
01f361 9508              ret
                 
01f362 e6a6              fdw     UKEYQ_L
                 UMSTAR_L:
01f363 7583
01f364 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
01f365 940d ffdf         jmp     umstar0
                 
01f367 e6c6              fdw     UMSTAR_L
                 UMSLASHMOD_L:
01f368 7586
01f369 2f6d
01f36a 6f6d
01f36b 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
01f36c 940d ef11         jmp     umslashmod0
                 
                 
01f36e e6d0              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
01f36f 7585
01f370 6d2f
01f371 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
01f372 d374              rcall   FALSE_
01f373 deb6              rcall   SWOP
01f374 940d ef11         jmp     umslashmod0
                 
01f376 e6de              fdw     USLASHMOD_L
                 STAR_L:
01f377 2a81              .db     NFA|1,"*"
                 STAR: 
01f378 dfec              rcall   UMSTAR
01f379 940d f223         jmp     DROP
                 
01f37b e6ee              fdw     STAR_L
                 USLASH_L:
01f37c 7582
01f37d 002f              .db     NFA|2,"u/",0
                 USLASH:
01f37e dff3              rcall   USLASHMOD
01f37f 940d f39b         jmp     NIP
                 
01f381 e6f8              fdw     USLASH_L
                 USSMOD_L:
01f382 7586
01f383 2f2a
01f384 6f6d
01f385 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
01f386 debd              rcall   TOR
01f387 dfdd              rcall   UMSTAR
01f388 dec6              rcall   RFROM
01f389 940d f36c         jmp     UMSLASHMOD
                 
                 
01f38b e704              fdw     USSMOD_L
                 SLASH_L:
01f38c 2f81              .db     NFA|1,"/"
                 SLASH: 
01f38d ddd6              rcall   TWODUP
01f38e df03              rcall   XOR_
01f38f deb4              rcall   TOR
01f390 ded6              rcall   ABS_
01f391 de98              rcall   SWOP
01f392 ded4              rcall   ABS_
01f393 de96              rcall   SWOP
01f394 dfe9              rcall   USLASH
01f395 deb9              rcall   RFROM
01f396 940d f3aa         jmp     QNEGATE
                 
01f398 e718              fdw     SLASH_L
                 NIP_L:
01f399 6ea3
01f39a 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
01f39b 9109              ld      t0, y+
01f39c 9109              ld      t0, y+
01f39d 9508              ret
                     
01f39e e732              fdw     NIP_L
                 TUCK_L:
01f39f 7484
01f3a0 6375
01f3a1 006b              .db     NFA|4,"tuck",0
                 TUCK:
01f3a2 de87              rcall   SWOP
01f3a3 940d f234         jmp     OVER
                 
01f3a5 e73e              fdw     TUCK_L
                 QNEGATE_L:
01f3a6 3f87
01f3a7 656e
01f3a8 6167
01f3a9 6574              .db     NFA|7,"?negate"
                 QNEGATE:
01f3aa d3b1              rcall   ZEROLESS
01f3ab dfae              rcall   ZEROSENSE
01f3ac f009              breq    QNEGATE1
01f3ad def6              rcall   NEGATE
                 QNEGATE1:
01f3ae 9508              ret
                 
01f3af e74c              fdw     QNEGATE_L
                 MAX_L:
01f3b0 6d83
01f3b1 7861              .db     NFA|3,"max"
01f3b2 ddb1      MAX:    rcall   TWODUP
01f3b3 df3a              rcall   LESS
01f3b4 cddb              rjmp    MINMAX
                 
01f3b5 e760              fdw     MAX_L
                 MIN_L:
01f3b6 6d83
01f3b7 6e69              .db     NFA|3,"min"
01f3b8 ddab      MIN:    rcall   TWODUP
01f3b9 df39              rcall   GREATER
01f3ba cdd5              rjmp    MINMAX
                 
01f3bb 6382
01f3bc 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
01f3bd 940d ff12         jmp     CFETCH
                 
01f3bf 6382
01f3c0 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
01f3c1 940d ff35         jmp     CSTORE
                 
01f3c3 e76c              fdw     MIN_L
                 UPTR_L:
01f3c4 7582
01f3c5 0070              .db     NFA|2,"up",0
01f3c6 dc9c      UPTR:   rcall   DOCREATE
01f3c7 0002              .dw     2 ; upl
                 
01f3c8 e788              fdw     UPTR_L
                 HOLD_L:
01f3c9 6884
01f3ca 6c6f
01f3cb 0064              .db     NFA|4,"hold",0
01f3cc d323      HOLD:   rcall   TRUE_
01f3cd d09a              rcall   HP
01f3ce defc              rcall   PLUSSTORE
01f3cf d098              rcall   HP
01f3d0 d2b4              rcall   FETCH_A
01f3d1 940d ff35         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
01f3d3 e792              fdw     HOLD_L
                 LESSNUM_L:
01f3d4 3c82
01f3d5 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
01f3d6 d096              rcall   PAD
01f3d7 d090              rcall   HP
01f3d8 940d fe9a         jmp     STORE
                 
                 ; >digit   n -- c            convert to 0..9a..z
01f3da e7a8              fdw     LESSNUM_L
                 TODIGIT_L:
01f3db 3e86
01f3dc 6964
01f3dd 6967
01f3de 0074              .db     NFA|6,">digit",0
                 TODIGIT: 
01f3df d36f              rcall   DUP
01f3e0 d364              rcall   DOLIT
01f3e1 0009              .dw     9
01f3e2 df10              rcall   GREATER
01f3e3 d361              rcall   DOLIT
01f3e4 0027              .dw     0x27
01f3e5 de9c              rcall   AND_
01f3e6 de85              rcall   PLUS
01f3e7 d35d              rcall   DOLIT
01f3e8 0030              .dw     0x30
01f3e9 940d f26c         jmp     PLUS
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
01f3eb e7b6              fdw     TODIGIT_L
                 NUM_L:
01f3ec 2381              .db     NFA|1,"#"
                 NUM:
01f3ed d087              rcall   BASE
01f3ee d296              rcall   FETCH_A
01f3ef d194              rcall   UDSLASHMOD
01f3f0 de4b              rcall   ROT
01f3f1 dfed              rcall   TODIGIT
01f3f2 940d f3cc         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
01f3f4 e7d8              fdw     NUM_L
                 NUMS_L:
01f3f5 2382
01f3f6 0073              .db     NFA|2,"#s",0
                 NUMS:
01f3f7 dff5              rcall   NUM
01f3f8 dd6b              rcall   TWODUP
01f3f9 de90              rcall   OR_
01f3fa df5f              rcall   ZEROSENSE
01f3fb f7d9              brne    NUMS
01f3fc 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
01f3fd e7ea              fdw     NUMS_L
                 NUMGREATER_L:
01f3fe 2382
01f3ff 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
01f400 dd5c              rcall   TWODROP
01f401 d066              rcall   HP
01f402 d282              rcall   FETCH_A
01f403 d069              rcall   PAD
01f404 de2f              rcall   OVER
01f405 940d f279         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
01f407 e7fc              fdw     NUMGREATER_L
                 SIGN_L:
01f408 7384
01f409 6769
01f40a 006e              .db     NFA|4,"sign",0
                 SIGN:   
01f40b d350              rcall   ZEROLESS
01f40c df4d              rcall   ZEROSENSE
01f40d f019              breq    SIGN1
01f40e d336              rcall   DOLIT
01f40f 002d              .dw     0x2D
01f410 dfbb              rcall   HOLD
                 SIGN1:
01f411 9508              ret
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
01f412 e810              fdw     SIGN_L
                 UDOT_L:
01f413 7582
01f414 002e              .db     NFA|2,"u.",0
                 UDOT:
01f415 dfc0              rcall   LESSNUM
01f416 d2d0              rcall   FALSE_
01f417 dfdf              rcall   NUMS
01f418 dfe7              rcall   NUMGREATER
01f419 ddc4              rcall   TYPE
01f41a 940d f174         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
01f41c e826              fdw     UDOT_L
                 UDOTR_L:
01f41d 7583
01f41e 722e              .db     NFA|3,"u.r"
                 UDOTR:
01f41f dfb6              rcall   LESSNUM
01f420 de8e              rcall   ONEMINUS
01f421 de22              rcall   TOR
01f422 d2c4              rcall   FALSE_
01f423 c001              rjmp    UDOTR2
                 UDOTR1:
01f424 dfc8              rcall   NUM
                 UDOTR2: 
01f425 d5cc              rcall   XNEXT
01f426 f7e8              brcc    UDOTR1
01f427 911f              pop     t1
01f428 910f              pop     t0
01f429 dfcd              rcall   NUMS
01f42a dfd5              rcall   NUMGREATER
01f42b ddb2              rcall   TYPE
01f42c 940d f174         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
01f42e e83a              fdw     UDOTR_L
                 DOT_L:
01f42f 2e81              .db     NFA|1,"."
01f430 dfa5      DOT:    rcall   LESSNUM
01f431 d31d              rcall   DUP
01f432 de34              rcall   ABS_
01f433 d2b3              rcall   FALSE_
01f434 dfc2              rcall   NUMS
01f435 de06              rcall   ROT
01f436 dfd4              rcall   SIGN
01f437 dfc8              rcall   NUMGREATER
01f438 dda5              rcall   TYPE
01f439 940d f174         jmp     SPACE_
                 
01f43b e85e              FDW     DOT_L
                 DECIMAL_L:
01f43c 6487
01f43d 6365
01f43e 6d69
01f43f 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
01f440 d27e              rcall   TEN
01f441 d033              rcall   BASE
01f442 940d fe9a         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
01f444 e878              Fdw     DECIMAL_l
                 HEX_L:
01f445 6883
01f446 7865              .db     NFA|3,"hex"
                 HEX:
01f447 d2fd              rcall   DOLIT
01f448 0010              .dw     16
01f449 d02b              rcall   BASE
01f44a 940d fe9a         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
01f44c e88a              Fdw     HEX_L
                 BIN_L:
01f44d 6283
01f44e 6e69              .db     NFA|3,"bin"
01f44f dca0      BIN:    rcall   CELL
01f450 d024              rcall   BASE
01f451 940d fe9a         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
01f453 e89a              fdw     BIN_L
                 RSAVE_L:
01f454 7285
01f455 6173
01f456 6576              .db     NFA|5,"rsave"
01f457 d02a      RSAVE_: rcall   DOUSER
01f458 fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
01f459 e8a8              fdw     RSAVE_L
                 ULINK_L:
01f45a 7585
01f45b 696c
01f45c 6b6e              .db     NFA|5,"ulink"
01f45d d024      ULINK_: rcall   DOUSER
01f45e fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
01f45f e8b4              fdw     ULINK_L
                 TASK_L:
01f460 7484
01f461 7361
01f462 006b              .db     NFA|4,"task",0
01f463 d01e      TASK:   rcall   DOUSER
01f464 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
01f465 e8c0              fdw     TASK_L
                 HP_L:
01f466 6882
01f467 0070              .db     NFA|2,"hp",0
01f468 d019      HP:     rcall   DOUSER
01f469 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
01f46a e8cc              fdw     HP_L
                 PAD_L:
01f46b 7083
01f46c 6461              .db     NFA|3,"pad"
                 PAD:
01f46d d19b              rcall   TIB
01f46e d192              rcall   TIBSIZE
01f46f 940d f26c         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
01f471 e8d6              fdw     PAD_L
                 BASE_L:
01f472 6284
01f473 7361
01f474 0065              .db     NFA|4,"base",0
                 BASE:
01f475 d00c              rcall   DOUSER
01f476 ffee              .dw     ubase
                 
                 ; USER   n --
01f477 e8e4              fdw     BASE_L
                 USER_L:
01f478 7584
01f479 6573
01f47a 0072              .db     NFA|4,"user",0
                 USER:
01f47b d31c              rcall   CREATE
01f47c dc73              rcall   CELL
01f47d de26              rcall   NEGATE
01f47e d4a3              rcall   IALLOT
01f47f 940f ffb9         call    ICOMMA
01f481 d366              rcall   XDOES
                 DOUSER:
01f482 91ff              m_pop_zh
01f483 91ff              pop     zh
01f484 91ef              pop     zl
01f485 dbf0              rcall   FETCHLIT
01f486 0d82              add     tosl, upl
01f487 1d93              adc     tosh, uph
01f488 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
01f489 e8f0              fdw     USER_L
                 SOURCE_L:
01f48a 7386
01f48b 756f
01f48c 6372
01f48d 0065              .db     NFA|6,"source",0
                 SOURCE:
01f48e d18c              rcall   TICKSOURCE
01f48f 940d f14a         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
01f491 e914              fdw      SOURCE_L
                 SLASHSTRING_L:
01f492 2f87
01f493 7473
01f494 6972
01f495 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
01f496 dd93              rcall   SWOP
01f497 dd9c              rcall   OVER
01f498 dde0              rcall   MINUS
01f499 ddaa              rcall   TOR
01f49a ddd1              rcall   PLUS
01f49b ddb3              rcall   RFROM
01f49c 9508              ret
                 
                 ; \     Skip the rest of the line
01f49d e924              fdw     SLASHSTRING_L
                 BSLASH_L:
01f49e 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
01f49f dfee              rcall   SOURCE
01f4a0 d173              rcall   TOIN
01f4a1 d057              rcall   STORE_A
01f4a2 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
01f4a3 940d f223         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
01f4a5 e93c              fdw     BSLASH_L
                 PARSE_L:
01f4a6 7085
01f4a7 7261
01f4a8 6573              .db     NFA|5,"parse"
                 PARSE:
01f4a9 d2a5              rcall   DUP             ; c c
01f4aa dfe3              rcall   SOURCE          ; c c a u
01f4ab d168              rcall   TOIN            ; c c a u a
01f4ac d1d8              rcall   FETCH_A         ; c c a u n
01f4ad dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
01f4ae d2a0              rcall   DUP             ; c c a u u
01f4af dd94              rcall   TOR             ; c c a u                  R: u (new tib len
01f4b0 dd8b              rcall   ROT             ; c a u c
01f4b1 db07              rcall   SKIP            ; c a u        
01f4b2 dd81              rcall   OVER            ; c a u a
01f4b3 dd90              rcall   TOR             ; c a u                    R: u a (start of word
01f4b4 dd87              rcall   ROT             ; a u c
01f4b5 db1e              rcall   SCAN            ; a u      end of word, tib left       
01f4b6 dea9              rcall   DUPZEROSENSE
01f4b7 f009              breq    PARSE1
01f4b8 ddf6              rcall   ONEMINUS
01f4b9 dd95      PARSE1: rcall   RFROM           ; a u a
01f4ba dd94              rcall   RFROM           ; a u a u
01f4bb dd80              rcall   ROT             ; a a u u
01f4bc ddbc              rcall   MINUS           ; a a n  ( addition to toin
01f4bd d156              rcall   TOIN
01f4be de0c              rcall   PLUSSTORE       ; aend astart
01f4bf dee2              rcall   TUCK            ; astart aend astart
01f4c0 940d f279         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
01f4c2 e94c              fdw     PARSE_L
                 WORD_L:
01f4c3 7784
01f4c4 726f
01f4c5 0064              .db     NFA|4,"word",0
                 WORD:
01f4c6 dfe2              rcall   PARSE           ; c-addr wlen
01f4c7 dd62              rcall   SWOP
01f4c8 dde6              rcall   ONEMINUS
01f4c9 ded8              rcall   TUCK
01f4ca 940d ff35         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
01f4cc e986              fdw     WORD_L
                 CMOVE_L:
01f4cd 6385
01f4ce 6f6d
01f4cf 6576              .db     NFA|5,"cmove"
                 CMOVE:
01f4d0 dd59              rcall   SWOP
01f4d1 de3c              rcall   STORE_P_TO_R
01f4d2 dd71              rcall   TOR
01f4d3 c003              rjmp    CMOVE2
                 CMOVE1:
01f4d4 d016              rcall   CFETCHPP
01f4d5 de5d              rcall   PCSTORE
01f4d6 de64              rcall   PPLUS
                 CMOVE2:
01f4d7 d51a              rcall   XNEXT
01f4d8 f7d8              brcc    CMOVE1
01f4d9 911f              pop     t1
01f4da 910f              pop     t0
01f4db de3e              rcall   R_TO_P
01f4dc 940d f223         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
01f4de e99a              fdw     CMOVE_L
                 PLACE_L:
01f4df 7085
01f4e0 616c
01f4e1 6563              .db     NFA|5,"place"
                 PLACE: 
01f4e2 dc81              rcall   TWODUP
01f4e3 dedd              rcall   CSTORE_A
01f4e4 dc34              rcall   CHARPLUS
01f4e5 dd44              rcall   SWOP
01f4e6 940d f4d0         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
01f4e8 e9be              fdw     PLACE_L
                 CFETCHPP_L:
01f4e9 6383
01f4ea 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
01f4eb d263              rcall   DUP
01f4ec ddbd              rcall   ONEPLUS
01f4ed dd3c              rcall   SWOP
01f4ee 940d ff12         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
01f4f0 e9d2              fdw     CFETCHPP_L
                 FETCHPP_L:
01f4f1 4082
01f4f2 002b              .db     NFA|2,"@+",0
                 FETCHPP:
01f4f3 d25b              rcall   DUP
01f4f4 ddbf              rcall   TWOPLUS
01f4f5 dd34              rcall   SWOP
01f4f6 940d fee5         jmp     FETCH
                 
01f4f8 2181              .db     NFA|1,"!"
                 STORE_A:        
01f4f9 940d fe9a         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
01f4fb e9e2              fdw    FETCHPP_L
                 NTOC_L:
01f4fc 6e83
01f4fd 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
01f4fe dfec              rcall   CFETCHPP
01f4ff d245              rcall   DOLIT
01f500 000f              .dw     0x0f
01f501 dd80              rcall   AND_
01f502 dd69              rcall   PLUS
01f503 940d f103         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
01f505 e9f8              fdw    NTOC_L
                 CTON_L:
01f506 6383
01f507 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
01f508 d351              rcall   TWOMINUS
01f509 d245              rcall   DUP
01f50a deb2              rcall   CFETCH_A
01f50b d239              rcall   DOLIT
01f50c 007f              .dw     0x007F
01f50d dde5              rcall   GREATER
01f50e de4b              rcall   ZEROSENSE
01f50f f3c1              breq    CFATONFA
01f510 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
01f511 ea0c              fdw     CTON_L
                 BRACFIND_L:
01f512 2883
01f513 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
01f514 dc4f              rcall   TWODUP
                 ;        rcall   OVER
                 ;        rcall   CFETCH_A
01f515 da80              rcall   NEQUAL
01f516 de49              rcall   DUPZEROSENSE
01f517 f021              breq    findi2
01f518 dd0a              rcall   DROP
01f519 d340              rcall   TWOMINUS ;;;      NFATOLFA
01f51a d16a              rcall   FETCH_A
01f51b d233              rcall   DUP
                 findi2:
01f51c de3d              rcall   ZEROSENSE
01f51d f7b1              brne    findi1
01f51e de41              rcall   DUPZEROSENSE
01f51f f041              breq    findi3
01f520 de7a              rcall   NIP
01f521 d22d              rcall   DUP
01f522 dfdb              rcall   NFATOCFA
01f523 dd06              rcall   SWOP
01f524 d009              rcall   IMMEDQ
01f525 d22f              rcall   ZEROEQUAL
01f526 dc70              rcall   ONE
01f527 dd62              rcall   OR_
                 findi3: 
01f528 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
01f529 ea24              fdw     BRACFIND_L
                 IMMEDQ_L:
01f52a 6986
01f52b 6d6d
01f52c 6465
01f52d 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
01f52e de8e              rcall   CFETCH_A
01f52f 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
01f530 d214              rcall   DOLIT
01f531 0040              .dw     IMMED
01f532 940d f282         jmp     AND_
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
01f534 ea54              fdw     IMMEDQ_L
                 FIND_L:
01f535 6684
01f536 6e69
01f537 0064              .db     NFA|4,"find",0
                 FIND:   
01f538 d20c              rcall   DOLIT
01f539 f5d8              fdw     kernellink
01f53a dfd9              rcall   findi
01f53b de24              rcall   DUPZEROSENSE
01f53c f421              brne    FIND1
01f53d dce5              rcall   DROP
01f53e d333              rcall   LATEST_
01f53f d145              rcall   FETCH_A
01f540 dfd3              rcall   findi
                 FIND1:
01f541 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
01f542 ea6a              fdw     FIND_L
                 DIGITQ_L:
01f543 6486
01f544 6769
01f545 7469
01f546 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
01f547 d207              rcall   DUP             ; c c       c c
01f548 d1fc              rcall   DOLIT
01f549 0039              .dw     0x39            ; c c 39    c c 39
01f54a dda8              rcall   GREATER         ; c 0       c ffff
01f54b de0e              rcall   ZEROSENSE
01f54c f019              breq    DIGITQ1
01f54d d1f7              rcall   DOLIT
01f54e 0027              .dw     0x27
01f54f dd29              rcall   MINUS
                 DIGITQ1:        
01f550 d1f4              rcall   DOLIT
01f551 0030              .dw     0x30            ; c 30
01f552 dd26              rcall   MINUS           ; 1
01f553 d1fb              rcall   DUP             ; 1 1
01f554 df20              rcall   BASE            ; 1 1 base
01f555 d12f              rcall   FETCH_A         ; 1 1 10
01f556 dd97              rcall   LESS            ; 1 ffff
01f557 dcdc              rcall   OVER            ; 1 ffff 1
01f558 d203              rcall   ZEROLESS        ; 1 ffff 0
01f559 dd42              rcall   INVERT
01f55a 940d f282         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
01f55c ea86              fdw     DIGITQ_L
                 SIGNQ_L:
01f55d 7385
01f55e 6769
01f55f 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
01f560 dcd3              rcall   OVER
01f561 de5b              rcall   CFETCH_A
01f562 d1e2              rcall   DOLIT
01f563 002c              .dw     ','
01f564 dd14              rcall   MINUS
01f565 d1e9              rcall   DUP
01f566 dd00              rcall   ABS_
01f567 dc2f              rcall   ONE
01f568 dd80              rcall   EQUAL
01f569 dd18              rcall   AND_
01f56a ddf5              rcall   DUPZEROSENSE
01f56b f029              breq    QSIGN1
01f56c dd3d              rcall   ONEPLUS
01f56d dcd6              rcall   TOR
01f56e dc28              rcall   ONE
01f56f df26              rcall   SLASHSTRING
01f570 dcde              rcall   RFROM
01f571 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
01f572 eaba              fdw     SIGNQ_L
                 UDSTAR_L:
01f573 7583
01f574 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
01f575 d1d9              rcall   DUP
01f576 dccd              rcall   TOR
01f577 dded              rcall   UMSTAR
01f578 dcaa              rcall   DROP
01f579 dcb0              rcall   SWOP
01f57a dcd4              rcall   RFROM
01f57b dde9              rcall   UMSTAR
01f57c dcbf              rcall   ROT
01f57d 940d f26c         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
01f57f eae6              fdw     UDSTAR_L
                 UDSLASHMOD_L:
01f580 7586
01f581 2f64
01f582 6f6d
01f583 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
01f584 dcbf              rcall   TOR             ; ud.l ud.h 
01f585 d161              rcall   FALSE_          ; ud.l ud.h 0
01f586 dcd3              rcall   RFETCH          ; ud.l ud.h 0 u
01f587 dde4              rcall   UMSLASHMOD      ; ud.l r.h q.h
01f588 dcb3              rcall   ROT             ; r.h q.h ud.l
01f589 dcb2              rcall   ROT             ; q.h ud.l r.h
01f58a dcc4              rcall   RFROM           ; q.h ud.l r.h u
01f58b dde0              rcall   UMSLASHMOD      ; q.h r.l q.l
01f58c 940d f23c         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
01f58e eb00              fdw     UDSLASHMOD_L
                 TONUMBER_L:
01f58f 3e87
01f590 756e
01f591 626d
01f592 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
01f593 ddcc              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
01f594 f0b1              breq    TONUM3
01f595 dcae              rcall   TOR
01f596 d1b8              rcall   DUP
01f597 dcac              rcall   TOR             ; ud.l ud.h adr
01f598 de24              rcall   CFETCH_A
01f599 dfad              rcall   DIGITQ          ; ud.l ud.h digit flag
01f59a ddbf              rcall   ZEROSENSE
01f59b f421              brne    TONUM2
01f59c dc86              rcall   DROP
01f59d dcb1              rcall   RFROM
01f59e dcb0              rcall   RFROM
01f59f c00b              rjmp    TONUM3
                 TONUM2: 
01f5a0 dca3              rcall   TOR             ; ud.l ud.h digit
01f5a1 ded3              rcall   BASE
01f5a2 d0e2              rcall   FETCH_A
01f5a3 dfd1              rcall   UDSTAR
01f5a4 dcaa              rcall   RFROM
01f5a5 dcce              rcall   MPLUS
01f5a6 dca8              rcall   RFROM
01f5a7 dca7              rcall   RFROM
                         
01f5a8 dbee              rcall   ONE
01f5a9 deec              rcall   SLASHSTRING
01f5aa cfe8              rjmp    TONUM1
                 TONUM3: 
01f5ab 9508              ret
                 
                 BASEQV:   
01f5ac e880              fdw     DECIMAL
01f5ad e88e              fdw     HEX
01f5ae e89e              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
01f5af eb1e              fdw     TONUMBER_L
                 NUMBERQ_L:
01f5b0 6e87
01f5b1 6d75
01f5b2 6562
01f5b3 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
01f5b4 d19a              rcall   DUP             ; a a
01f5b5 d131              rcall   FALSE_          ; a a 0 0
01f5b6 d130              rcall   FALSE_          ; a a 0 0
01f5b7 dc84              rcall   ROT             ; a 0 0 a
01f5b8 df32              rcall   CFETCHPP        ; a 0 0 a' u
01f5b9 dfa6              rcall   SIGNQ           ; a 0 0 a' u f
01f5ba dc89              rcall   TOR             ; a 0 0 a' u
                 
01f5bb deb9              rcall   BASE
01f5bc d0c8              rcall   FETCH_A
01f5bd dc86              rcall   TOR             ; a 0 0 a' u
                         
01f5be dc75              rcall   OVER
01f5bf ddfd              rcall   CFETCH_A
                         
01f5c0 d184              rcall   DOLIT
01f5c1 0023              .dw     '#'
01f5c2 dcb6              rcall   MINUS
01f5c3 d18b              rcall   DUP
01f5c4 d180              rcall   DOLIT
01f5c5 0003              .dw     3
01f5c6 dd32              rcall   ULESS
01f5c7 dd92              rcall   ZEROSENSE
01f5c8 f041              breq    BASEQ1
01f5c9 db48              rcall   CELLS
                         
01f5ca d17a              rcall   DOLIT
01f5cb eb58              fdw     BASEQV
01f5cc dc9f              rcall   PLUS
01f5cd da60              rcall   FEXECUTE
                 
01f5ce dbc8              rcall   ONE
01f5cf dec6              rcall   SLASHSTRING
01f5d0 c001              rjmp    BASEQ2
                 BASEQ1:
01f5d1 dc51              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
01f5d2 dfc0              rcall   TONUMBER        ; a ud.l ud.h  a' u
01f5d3 dc7b              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
01f5d4 dea0              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
01f5d5 df23              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
01f5d6 d178              rcall   DUP
01f5d7 d282              rcall   TWOMINUS
01f5d8 d183              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
01f5d9 dd80              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
01f5da f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
01f5db dc73              rcall   RFROM           ; a ud.l ud.h a' u sign
01f5dc dc46              rcall   DROP
01f5dd db7f              rcall   TWODROP
                 QNUM_ERR1:      
01f5de db7e              rcall   TWODROP
01f5df d107              rcall   FALSE_          ; a 0           Not a number
01f5e0 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
01f5e1 db89              rcall   TWOSWAP         ; a a' u ud.l ud.h 
01f5e2 dc6c              rcall   RFROM           ; a a' u ud.l ud.d sign
01f5e3 dd76              rcall   ZEROSENSE
01f5e4 f009              breq    QNUMD1
01f5e5 d43a              rcall   DNEGATE
                 QNUMD1: 
01f5e6 db84              rcall   TWOSWAP         ; a d.l d.h a' u
01f5e7 dd72              rcall   ZEROSENSE       ; a d.l d.h a'
01f5e8 f061              breq    QNUM1
01f5e9 940f ff12         call    CFETCH
01f5eb d159              rcall   DOLIT
01f5ec 002e              .dw     '.'
01f5ed dc8b              rcall   MINUS
01f5ee dd6b              rcall   ZEROSENSE       ; a d.l d.h
01f5ef f771              brne    QNUM_ERR1
01f5f0 dc4b              rcall   ROT             ; d.l d.h a
01f5f1 dc31              rcall   DROP            ; d.l d.h
01f5f2 d152              rcall   DOLIT         ; 
01f5f3 0002              .dw     2               ; d.l ud.h 2    Double number
01f5f4 c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
01f5f5 db67              rcall   TWODROP         ; a n
01f5f6 dda4              rcall   NIP             ; n
01f5f7 db9f              rcall   ONE             ; n 1           Single number
                 QNUM3:  
01f5f8 9508              ret
                 
                 
01f5f9 7384
01f5fa 6177
01f5fb 0070              .db     NFA|4,"swap",0
                 SWOP_A:
01f5fc 940d f22a         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
01f5fe eb60              fdw     NUMBERQ_L
                 TIBSIZE_L:
01f5ff 7483
01f600 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
01f601 de61              rcall   TASK
01f602 d082              rcall   FETCH_A
01f603 9608              adiw    tosl, 8
01f604 940d fee5         jmp     FETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
01f606 ebfe              fdw     TIBSIZE_L
                 TIB_L:
01f607 7483
01f608 6269              .db     NFA|3,"tib"
                 TIB:
01f609 d005              rcall   TIU
01f60a 940d fee5         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
01f60c ec0e              fdw     TIB_L
                 TIU_L:
01f60d 7483
01f60e 7569              .db     NFA|3,"tiu"
                 TIU:
01f60f de72              rcall   DOUSER
01f610 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
01f611 ec1a              fdw     TIU_L
                 TOIN_L:
01f612 3e83
01f613 6e69              .db     NFA|3,">in"
                 TOIN:
01f614 de6d              rcall   DOUSER
01f615 fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
01f616 ec24              fdw     TOIN_L
                 TICKSOURCE_L:
01f617 2787
01f618 6f73
01f619 7275
01f61a 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
01f61b de66              rcall   DOUSER
01f61c fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
01f61d ec2e              fdw     TICKSOURCE_L
                 INTERPRET_L:
01f61e 6989
01f61f 746e
01f620 7265
01f621 7270
01f622 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
01f623 dff7              rcall   TICKSOURCE
01f624 db2e              rcall   TWOSTORE
01f625 d0c1              rcall   FALSE_
01f626 dfed              rcall   TOIN
01f627 ded1              rcall   STORE_A
                 IPARSEWORD:
01f628 d236              rcall   BL
01f629 de9c              rcall   WORD
                 
01f62a d124              rcall   DUP
01f62b dd91              rcall   CFETCH_A
01f62c dd2d              rcall   ZEROSENSE
01f62d f409              brne    IPARSEWORD1
01f62e c053              rjmp    INOWORD
                 IPARSEWORD1:
01f62f df08              rcall   FIND            ; sets also wflags
01f630 dd2f              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
01f631 f1a1              breq    INUMBER         ; NUMBER?
01f632 dc77              rcall   ONEPLUS         ; 0 = normal 2 = immediate
01f633 d232              rcall   STATE_
01f634 d120              rcall   ZEROEQUAL
01f635 dc54              rcall   OR_
01f636 dd23              rcall   ZEROSENSE
01f637 f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
01f638 fe94              sbrs    wflags, 4       ; Compile only check
01f639 c00a              rjmp    IEXECUTE        ; Not a compile only word
01f63a d22b              rcall   STATE_          ; Compile only word check
01f63b dbaf              rcall   XSQUOTE
01f63c 430c
01f63d 4d4f
01f63e 4950
01f63f 454c
01f640 4f20
01f641 4c4e
01f642 0059              .db     12,"COMPILE ONLY",0
01f643 d0ee              rcall   QABORT
                 IEXECUTE:
01f644 7b6f              cbr     FLAGS1, (1<<noclear)
01f645 d9de              rcall   EXECUTE
01f646 fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
01f647 cfe0              rjmp    IPARSEWORD
01f648 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f649 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f64a cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
01f64b 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f64c d102              rcall   DUP
01f64d d0f7              rcall   DOLIT
01f64e eeaa              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
01f64f dc99              rcall   EQUAL
01f650 dd09              rcall   ZEROSENSE
01f651 f011              breq    ICOMPILE_2
01f652 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
01f653 c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
01f654 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f655 d0f9              rcall   DUP
01f656 d0ee              rcall   DOLIT
01f657 ee9e              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
01f658 dc90              rcall   EQUAL
01f659 dd00              rcall   ZEROSENSE
01f65a f009              breq    ICOMPILE
01f65b 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
01f65c fe95              sbrs    wflags, 5       ; Inline check
01f65d c003              rjmp    ICOMMAXT
01f65e 940f f9c9         call    INLINE0
01f660 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
01f661 d125              rcall   COMMAXT_A
01f662 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
01f663 fc94              sbrc    wflags, 4            ; Compile only ?
01f664 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f665 cfc2              rjmp    IPARSEWORD
                 INUMBER: 
01f666 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f667 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f668 dbba              rcall   DROP
01f669 df4a              rcall   NUMBERQ
01f66a dcf5              rcall   DUPZEROSENSE
01f66b f081              breq    IUNKNOWN
01f66c d1f9              rcall   STATE_
01f66d dcec              rcall   ZEROSENSE
01f66e f059              breq    INUMBER1
01f66f 2f08              mov     t0, tosl
01f670 9189
01f671 9199              poptos
01f672 ff01              sbrs    t0, 1
01f673 c003              rjmp    ISINGLE
                 IDOUBLE:
01f674 df87              rcall   SWOP_A
01f675 940f fe6e         call    LITERAL
                 ISINGLE:        
01f677 940f fe6e         call    LITERAL
01f679 cfae              rjmp    IPARSEWORD
                 
                 INUMBER1:
01f67a dba8              rcall   DROP
01f67b cfac              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
01f67c dba6              rcall   DROP 
01f67d d045              rcall   DP_TO_RAM
01f67e de6c              rcall   CFETCHPP
01f67f db5e              rcall   TYPE
01f680 d066              rcall   FALSE_
01f681 d0a7              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
01f682 940d f223         jmp     DROP
                 
01f684 4081              .db     NFA|1,"@"
                 FETCH_A:        
01f685 940d fee5         jmp     FETCH
                 
                 ;;;    bitmask -- 
01f687 ec3c              fdw     INTERPRET_L
                 SHB_L:
01f688 7383
01f689 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
01f68a d1e7              rcall   LATEST_
01f68b dff9              rcall   FETCH_A
01f68c d0c2              rcall   DUP
01f68d dd2f              rcall   CFETCH_A
01f68e dbad              rcall   ROT
01f68f dbfa              rcall   OR_
01f690 df6b              rcall   SWOP_A
01f691 940d ff35         jmp     CSTORE
                         
01f693 ed10              fdw     SHB_L
                 IMMEDIATE_L:
01f694 6989
01f695 6d6d
01f696 6465
01f697 6169
01f698 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
01f699 d0ab              rcall   DOLIT
01f69a 0040              .dw     IMMED
01f69b 940d f68a         jmp     SHB
                 
                 ;***************************************************************
01f69d ed28              fdw     IMMEDIATE_L
                 INLINED_L:
01f69e 6987
01f69f 6c6e
01f6a0 6e69
01f6a1 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
01f6a2 d0a2              rcall   DOLIT
01f6a3 0020              .dw     INLINE
01f6a4 940d f68a         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
01f6a6 ed3c              fdw     INLINED_L
                 DOTSTATUS_L:
01f6a7 2e83
01f6a8 7473              .db     NFA|3,".st"
                 DOTSTATUS:
01f6a9 d09b              rcall   DOLIT
01f6aa 003c              .dw     '<'
01f6ab d963              rcall   EMIT
01f6ac 940f ffcb         call    DOTBASE
01f6ae d960              rcall   EMIT
01f6af d095              rcall   DOLIT
01f6b0 002c              .dw     ','
01f6b1 d95d              rcall   EMIT
01f6b2 940f ef01         call    MEMQ
01f6b4 db29              rcall   TYPE
01f6b5 d08f              rcall   DOLIT
01f6b6 003e              .dw     '>'
01f6b7 d957              rcall   EMIT
01f6b8 940d f8e1         jmp     DOTS
                 
01f6ba 3e82
01f6bb 0072              .db     NFA|2,">r",0
01f6bc 940d f244 TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
01f6be 6181              .db     NFA|1,"a"
                 TEN:
01f6bf d9a3              rcall   DOCREATE
01f6c0 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
01f6c1 6483
01f6c2 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
01f6c3 d081              rcall   DOLIT
01f6c4 2200              .dw     dp_start
01f6c5 d1bb              rcall   INI
01f6c6 dff8              rcall   TEN
01f6c7 940d f4d0         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
01f6c9 3e83
01f6ca 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
01f6cb d079              rcall   DOLIT
01f6cc 2200              .dw     dp_start
01f6cd dc40              rcall   STORE_P_TO_R
01f6ce d1b2              rcall   INI
01f6cf d075              rcall   DOLIT
01f6d0 0004              .dw     4
01f6d1 db72              rcall   TOR
                 DP_TO_EEPROM_0: 
01f6d2 de20              rcall   FETCHPP
01f6d3 d07b              rcall   DUP
01f6d4 dc4e              rcall   PFETCH
01f6d5 dc0b              rcall   NOTEQUAL
01f6d6 dc83              rcall   ZEROSENSE
01f6d7 f011              breq    DP_TO_EEPROM_1
01f6d8 dc52              rcall   PSTORE
01f6d9 c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
01f6da db48              rcall   DROP
                 DP_TO_EEPROM_2:
01f6db d412              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
01f6dc d315              rcall   XNEXT
01f6dd f7a0              brcc    DP_TO_EEPROM_0
01f6de 911f              pop     t1
01f6df 910f              pop     t0
01f6e0 dc39              rcall   R_TO_P
01f6e1 940d f223         jmp     DROP
                 
01f6e3 ed4e              fdw     DOTSTATUS_L
                 FALSE_L:
01f6e4 6685
01f6e5 6c61
01f6e6 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
01f6e7 939a
01f6e8 938a              pushtos
01f6e9 2788              clr     tosl
01f6ea 2799              clr     tosh
01f6eb 9508              ret
                 
01f6ec edc8              fdw     FALSE_L
                 TRUE_L:
01f6ed 7484
01f6ee 7572
01f6ef 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
01f6f0 939a
01f6f1 938a              pushtos
01f6f2 ef8f              ser     tosl
01f6f3 ef9f              ser     tosh
01f6f4 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
01f6f5 edda              fdw     TRUE_L
                 QUIT_L:
01f6f6 7184
01f6f7 6975
01f6f8 0074              .db     NFA|4,"quit",0
                 QUIT:
01f6f9 d99d              rcall   RPEMPTY
01f6fa d109              rcall   LEFTBRACKET
01f6fb d9c7              rcall   FRAM
                 QUIT0:  
01f6fc d69b              rcall   IFLUSH
                         ;; Copy INI and DP's from eeprom to ram
01f6fd dfc5              rcall   DP_TO_RAM
                 QUIT1: 
01f6fe d8fe              rcall   check_sp
01f6ff d08c              rcall   CR
01f700 df08              rcall   TIB
01f701 d04d              rcall   DUP
01f702 defe              rcall   TIBSIZE
01f703 dfbb              rcall   TEN                 ; Reserve 10 bytes for hold buffer
01f704 db74              rcall   MINUS
01f705 da9b              rcall   ACCEPT
01f706 da6d              rcall   SPACE_
01f707 df1b              rcall   INTERPRET
01f708 d15d              rcall   STATE_
01f709 dc50              rcall   ZEROSENSE
01f70a f799              brne    QUIT1
01f70b dfbf              rcall   DP_TO_EEPROM
                          
01f70c dade              rcall    XSQUOTE
01f70d 2003
01f70e 6b6f              .db     3," ok"
01f70f dace              rcall    TYPE
01f710 d007              rcall   PROMPT_
01f711 cfea              rjmp    QUIT0
01f712 9508              ret
                 
01f713 edec              fdw     QUIT_L
                 PROMPT_L:
01f714 7086
01f715 6f72
01f716 706d
01f717 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
01f718 940f ff6f         call    DEFER_DOES
01f71a 220a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
01f71b ee28              fdw     PROMPT_L
                 ABORT_L:
01f71c 6185
01f71d 6f62
01f71e 7472              .db     NFA|5,"abort"
                 ABORT:
01f71f d158              rcall   S0
01f720 df64              rcall   FETCH_A
01f721 d971              rcall   SPSTORE
01f722 940d f6f9         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
01f724 ee38              fdw     ABORT_L
                 QABORTQ_L:
01f725 3f87
01f726 6261
01f727 726f
01f728 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
01f729 dac1              rcall   XSQUOTE
01f72a 3f01              .db     1,"?"
01f72b 940d f732         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
01f72d ee4a              fdw     QABORTQ_L
                 QABORT_L:
01f72e 3f86
01f72f 6261
01f730 726f
01f731 0074              .db     NFA|6,"?abort",0
                 QABORT:
01f732 db09              rcall   ROT
01f733 dc26              rcall   ZEROSENSE
01f734 f419              brne    QABO1
                 QABORT1:        
01f735 da3e              rcall   SPACE_
01f736 daa7              rcall   TYPE
01f737 dfe7              rcall   ABORT  ; ABORT never returns
01f738 940d f15d QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
01f73a ee5c              fdw     QABORT_L
                 ABORTQUOTE_L:
01f73b 61d6
01f73c 6f62
01f73d 7472
01f73e 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
01f73f dabe              rcall   SQUOTE
01f740 d93e              rcall   DOCOMMAXT
01f741 ee64              fdw     QABORT
01f742 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
01f743 6c83
01f744 7469              .db     NFA|3, "lit"
                 DOLIT:
01f745 91ff              m_pop_zh
01f746 91ff              pop     zh
01f747 91ef              pop     zl
01f748 d92d              rcall   FETCHLIT
01f749 95f7              ror     zh
01f74a 95e7              ror     zl
01f74b 9419              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
01f74c e4b0              fdw     RFETCH_L
                 DUP_L:
01f74d 64a3
01f74e 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
01f74f 939a
01f750 938a              pushtos
01f751 9508              ret
                 
01f752 e5be              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
01f753 3082
01f754 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:
01f755 9701              sbiw    tosl, 1
01f756 0b88              sbc     tosl, tosl
01f757 0b99              sbc     tosh, tosh
01f758 9508              ret
                 
01f759 eea6              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
01f75a 3082
01f75b 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
01f75c 0f99              lsl     tosh
01f75d 0b88              sbc     tosl, tosl
01f75e 0b99              sbc     tosh, tosh
01f75f 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
01f760 ee76              fdw     ABORTQUOTE_L
                 TICK_L:
01f761 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
01f762 d0fc              rcall   BL
01f763 dd62              rcall   WORD
01f764 ddd3              rcall   FIND
01f765 940d f729         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
01f767 eec2              fdw     TICK_L
                 CHAR_L:
01f768 6384
01f769 6168
01f76a 0072              .db     NFA|4,"char",0
                 CHAR:
01f76b d0f3              rcall   BL
01f76c dd3c              rcall   PARSE
01f76d dab5              rcall   DROP
01f76e 940d ff12         jmp     CFETCH
                 
                 ; (    --                     skip input until )
01f770 eed0              fdw     CHAR_L
                 PAREN_L:
01f771 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
01f772 dfd2              rcall   DOLIT
01f773 0029              .dw     ')'
01f774 dd34              rcall   PARSE
01f775 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
01f776 940d f15d         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
01f778 6985
01f779 6568
01f77a 6572              .db     NFA|5,"ihere"
                 IHERE:
01f77b d066              rcall   IDP
01f77c cf08              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
01f77d eee2              fdw     PAREN_L
                 BRACCHAR_L:
01f77e 5bd6
01f77f 6863
01f780 7261
01f781 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
01f782 dfe8              rcall   CHAR
01f783 940d fe6e         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
01f785 6383
01f786 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
01f787 940d f123         jmp     COMMAXT
                 
                 ; CR      --                      output newline
01f789 eefc              fdw     BRACCHAR_L
                 CR_L:
01f78a 6382
01f78b 0072              .db     NFA|2,"cr",0
                 CR:
01f78c dfb8              rcall   DOLIT
01f78d 000d              .dw     0x0d       ; CR \r
01f78e d880              rcall   EMIT
01f78f dfb5              rcall   DOLIT
01f790 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
01f791 940d f00f         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
01f793 ef14              fdw     CR_L
                 CREATE_L:
01f794 6386
01f795 6572
01f796 7461
01f797 0065              .db     NFA|6,"create",0
                 CREATE:
01f798 d0c6              rcall   BL
01f799 dd2c              rcall   WORD            ; Parse a word
                 
01f79a dfb4              rcall   DUP             ; Remember parsed word at rhere
01f79b dd9c              rcall   FIND
01f79c dbfe              rcall   NIP
01f79d dfb7              rcall   ZEROEQUAL
01f79e da4c              rcall   XSQUOTE
01f79f 410f
01f7a0 524c
01f7a1 4145
01f7a2 5944
01f7a3 4420
01f7a4 4645
01f7a5 4e49
01f7a6 4445              .db     15,"ALREADY DEFINED"
01f7a7 df8a              rcall   QABORT         ; ABORT if word has already been defined
01f7a8 dfa6              rcall   DUP             ; Check the word length 
01f7a9 dc13              rcall   CFETCH_A
01f7aa d9ec              rcall   ONE
01f7ab df99              rcall   DOLIT
01f7ac 0010              .dw     16
01f7ad db29              rcall   WITHIN
01f7ae df7a              rcall   QABORTQ          ; Abort if there is no name for create
                 
01f7af d0c2              rcall   LATEST_
01f7b0 ded4              rcall   FETCH_A
01f7b1 940f ffb9         call    ICOMMA          ; Link field
01f7b3 dd37              rcall   CFETCHPP        ; str len
01f7b4 dfc6              rcall   IHERE
01f7b5 df99              rcall   DUP             
01f7b6 d0bb              rcall   LATEST_         ; new 'latest' link
01f7b7 dd41              rcall   STORE_A         ; str len ihere
01f7b8 dd29              rcall   PLACE           ; 
01f7b9 dfc1              rcall   IHERE           ; ihere
01f7ba dc02              rcall   CFETCH_A
01f7bb df89              rcall   DOLIT
01f7bc 0080              .dw     NFA
01f7bd decc              rcall   SHB
01f7be daeb              rcall   ONEPLUS
01f7bf d943              rcall   ALIGNED
01f7c0 d161              rcall   IALLOT          ; The header has now been created
01f7c1 df83              rcall   DOLIT             
01f7c2 e0c6              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
01f7c3 d968              rcall   STORECFF1       ; Append an exeution token, CALL !
01f7c4 d934              rcall   ALIGN
01f7c5 d914              rcall   HERE            ; compiles the current dataspace dp into the dictionary
01f7c6 d909              rcall   CSE_
01f7c7 db92              rcall   ZEROSENSE
01f7c8 f409              brne    CREATE2
01f7c9 daea              rcall   TWOPLUS
                 CREATE2:
01f7ca 940d ffb9         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
01f7cc ef28              fdw    CREATE_L
                 POSTPONE_L:
01f7cd 70d8
01f7ce 736f
01f7cf 7074
01f7d0 6e6f
01f7d1 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
01f7d2 d08c              rcall   BL
01f7d3 dcf2              rcall   WORD
01f7d4 dd63              rcall   FIND
01f7d5 df79              rcall   DUP
01f7d6 df52              rcall   QABORTQ
01f7d7 df84              rcall   ZEROLESS
01f7d8 db81              rcall   ZEROSENSE
01f7d9 f021              breq    POSTPONE1
01f7da d8a4              rcall   DOCOMMAXT
01f7db e0fe              fdw     DOCOMMAXT
01f7dc 940d ffb9         jmp     ICOMMA
                 POSTPONE1:
01f7de 940d f123         jmp     COMMAXT
                 
                 
                 IDP_L:
01f7e0 6983
01f7e1 7064              .db     NFA|3,"idp"
                 IDP:
01f7e2 d880              rcall   DOCREATE
01f7e3 03ba              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
01f7e4 2887
01f7e5 6f64
01f7e6 7365
01f7e7 293e              .db     NFA|7,"(does>)"
                 XDOES:
01f7e8 91ff              m_pop_zh
01f7e9 da65              rcall   RFROM
01f7ea d087              rcall   LATEST_
01f7eb de99              rcall   FETCH_A
01f7ec dd11              rcall   NFATOCFA
01f7ed dff4              rcall   IDP
01f7ee de96              rcall   FETCH_A
01f7ef decc              rcall   TOR_A
01f7f0 dff1              rcall   IDP
01f7f1 dd07              rcall   STORE_A
01f7f2 0f88              lsl     tosl
01f7f3 1f99              rol     tosh
01f7f4 d937              rcall   STORECFF1 ; Always stores a 4 byte call
01f7f5 da59              rcall   RFROM
01f7f6 dfeb              rcall   IDP
01f7f7 940d fe9a         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
01f7f9 ef9a              fdw     POSTPONE_L
                 DOES_L:
01f7fa 64d5
01f7fb 656f
01f7fc 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
01f7fd d881      DOES:   rcall   DOCOMMAXT
01f7fe efd0              fdw     XDOES
01f7ff d87f              rcall   DOCOMMAXT
01f800 e0da              fdw     DODOES
01f801 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
01f802 eff4              fdw     DOES_L
                 LEFTBRACKET_L:
01f803 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
01f804 7000              cbr     t0, 0xff
01f805 9300 03cf         sts     state, t0
01f807 9508              ret
                 
                 
                 ; ]        --      enter compiling state
01f808 f006              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
01f809 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
01f80a 6f0f              sbr     t0, 0xff
01f80b 9300 03cf         sts     state, t0
01f80d 9508              ret
                 
                 ; :        --           begin a colon definition
01f80e f012              fdw     RIGHTBRACKET_L
                 COLON_L:
01f80f 3a81              .db     NFA|1,":"
                 COLON:
01f810 df87              rcall   CREATE
01f811 dff8              rcall   RIGHTBRACKET
01f812 940d f143         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
01f814 f01e              fdw     COLON_L
                 NONAME_L:
01f815 3a87
01f816 6f6e
01f817 616e
01f818 656d              .db     NFA|7,":noname"
                 NONAME:
01f819 df61              rcall   IHERE
01f81a 940d f80a         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
01f81c f02a              fdw     NONAME_L
                 SEMICOLON_L:
01f81d 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
01f81e dfe5              rcall   LEFTBRACKET
01f81f fd61              sbrc    FLAGS1, fTAILC
01f820 c025              rjmp    ADD_RETURN_1
01f821 df59              rcall   IHERE
01f822 d02a              rcall   MINUS_FETCH
01f823 018c              movw    t0, tosl
01f824 7f10              andi    t1, 0xf0
01f825 5d10              subi    t1, 0xd0
01f826 f059              breq    RCALL_TO_JMP
01f827 9189
01f828 9199              poptos
01f829 d023              rcall   MINUS_FETCH
                 .ifdef EIND
01f82a 508f              subi    tosl, 0x0f
                 .else
                 .endif
01f82b 4994              sbci    tosh, 0x94
01f82c f4c1              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
01f82d e08d              ldi     tosl, 0x0d
                 .else
                 .endif
01f82e e994              ldi     tosh, 0x94
01f82f d9fa              rcall   SWOP
01f830 940d fe9a         jmp     STORE
                 RCALL_TO_JMP:
01f832 db68              rcall   NIP
01f833 709f              andi    tosh, 0x0f
01f834 fd93              sbrc    tosh, 3
01f835 6f90              ori     tosh, 0xf0
01f836 da88              rcall   TWOSTAR
01f837 df43              rcall   IHERE
01f838 da33              rcall   PLUS
01f839 df0b              rcall   DOLIT
01f83a fffe              .dw     -2
01f83b d0e6              rcall   IALLOT
01f83c df08              rcall   DOLIT
                 .ifdef EIND
01f83d 940d              .dw     0x940d
                 .else
                 .endif
01f83e 940f ffb9         call    ICOMMA
                         sub_pflash_tos
01f840 9408              rampv_to_c
01f841 9597              ror     tosh
01f842 9587              ror     tosl
01f843 940d ffb9         jmp     ICOMMA
                 ADD_RETURN:
01f845 d917              rcall   TWODROP
                 ADD_RETURN_1:
01f846 defe              rcall   DOLIT   ; Compile a ret
01f847 9508              .dw     0x9508
01f848 940d ffb9         jmp    ICOMMA
                 
                 
                 
01f84a f03a              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
01f84b 2d82
01f84c 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
01f84d d00c              rcall   TWOMINUS
01f84e df00              rcall   DUP
01f84f 940d fee5         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
01f851 f096              fdw     MINUS_FETCH_L
                 BRACTICK_L:
01f852 5bd3
01f853 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
01f854 df0d              rcall   TICK       ; get xt of 'xxx'
01f855 940d fe6e         jmp     LITERAL
                 
                 ; 2-    n -- n-2
01f857 f0a4              fdw     BRACTICK_L
                 TWOMINUS_L:
01f858 32a2
01f859 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
01f85a 9702              sbiw    tosl, 2
01f85b 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
01f85c f0b0              fdw     TWOMINUS_L
                 BL_l:
01f85d 6282
01f85e 006c              .db     NFA|2,"bl",0
                 BL:
01f85f 940f f063         call    DOCREATE
01f861 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
01f862 f0ba              fdw     BL_L
                 STATE_L:
01f863 7385
01f864 6174
01f865 6574              .db     NFA|5,"state"
                 STATE_:
01f866 939a
01f867 938a              pushtos
01f868 9180 03cf         lds     tosl, state
01f86a 9190 03cf         lds     tosh, state
01f86c 9508              ret
                 
                 ; LATEST    -- a-addr           
01f86d f0c6              fdw     STATE_L
                 LATEST_L:
01f86e 6c86
01f86f 7461
01f870 7365
01f871 0074              .db     NFA|6,"latest",0
                 LATEST_:
01f872 940f f063         call    DOCREATE
01f874 03c0              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
01f875 f0dc              fdw     LATEST_L
                 S0_L:
01f876 7382
01f877 0030              .db     NFA|2,"s0",0
                 S0:
01f878 dc09              rcall   DOUSER
01f879 ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
01f87a f0ec              fdw     S0_L
                 R0_L:
01f87b 7282
01f87c 0030              .db     NFA|2,"r0",0
                 R0_:
01f87d dc04              rcall   DOUSER
01f87e ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
01f87f 6983
01f880 696e              .db     NFA|3,"ini"
                 INI:
01f881 940f f063          call   DOCREATE
01f883 03b8              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
01f884 f0f6              fdw     R0_L
                 TICKS_L:
01f885 7485
01f886 6369
01f887 736b              .db     NFA|5,"ticks"
                 TICKS:
01f888 939a
01f889 938a              pushtos
01f88a b70f              in_     t0, SREG
01f88b 94f8              cli
01f88c 2d8e              mov     tosl, ms_count
01f88d 2d9f              mov     tosh, ms_count1
01f88e bf0f              out_    SREG, t0
01f88f 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
01f890 f10a              fdw     TICKS_L
                 MS_L:
01f891 6d82
01f892 0073              .db     NFA|2,"ms",0
                 MS:
01f893 dff4              rcall   TICKS
01f894 d9d7              rcall   PLUS
                 MS1:    
01f895 d703              rcall   PAUSE
01f896 deb8              rcall   DUP
01f897 dff0              rcall   TICKS
01f898 d9e0              rcall   MINUS
01f899 dec2              rcall   ZEROLESS
01f89a dabf              rcall   ZEROSENSE
01f89b f3c9              breq    MS1
01f89c 940d f223         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
01f89e f122              fdw     MS_L
                 DOTID_L:
01f89f 2e83
01f8a0 6469              .db     NFA|3,".id"
                 DOTID:
01f8a1 dc49              rcall   CFETCHPP
01f8a2 dea2              rcall   DOLIT
01f8a3 000f              .dw     0x0f
01f8a4 d9dd              rcall   AND_
01f8a5 d99e              rcall   TOR
01f8a6 c003              rjmp    DOTID3
                 DOTID1:
01f8a7 dc43              rcall   CFETCHPP
01f8a8 d00a              rcall   TO_PRINTABLE
01f8a9 dee7              rcall   EMIT_A
                 DOTID3:
01f8aa d147              rcall   XNEXT
01f8ab f7d8              brcc    DOTID1  
01f8ac 911f              pop     t1
01f8ad 910f              pop     t0
01f8ae 940d f223         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
01f8b0 f13e              fdw     DOTID_L
                 TO_PRINTABLE_L:
01f8b1 3e83
01f8b2 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:
01f8b3 2799              clr     tosh   
01f8b4 3080              cpi     tosl, 0
01f8b5 f012              brmi    TO_PRINTABLE1
01f8b6 3280              cpi     tosl, 0x20
01f8b7 f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
01f8b8 e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
01f8b9 9508              ret
                 
                  ; WORDS    --          list all words in dict.
01f8ba f162              fdw     TO_PRINTABLE_L
                 WORDS_L:
01f8bb 7785
01f8bc 726f
01f8bd 7364              .db     NFA|5,"words"
01f8be de28              rcall   FALSE_
01f8bf decc              rcall   CR
01f8c0 de84              rcall   DOLIT
01f8c1 f5d8              fdw     kernellink
01f8c2 d005              rcall   WDS1
01f8c3 de23              rcall   FALSE_
01f8c4 dec7              rcall   CR
01f8c5 dec6                      rcall   CR
01f8c6 dfab              rcall   LATEST_
01f8c7 ddbd              rcall   FETCH_A
01f8c8 de86      WDS1:   rcall   DUP
01f8c9 dfd7              rcall   DOTID
01f8ca dd31              rcall   SWOP_A
01f8cb d9de              rcall   ONEPLUS
01f8cc de82              rcall   DUP
01f8cd de77              rcall   DOLIT
01f8ce 0007              .dw     7
01f8cf d9b2              rcall   AND_
01f8d0 da89              rcall   ZEROSENSE
01f8d1 f021              breq    WDS2
01f8d2 de72              rcall   DOLIT
01f8d3 0009              .dw     9
01f8d4 debc              rcall   EMIT_A
01f8d5 c001              rjmp    WDS3
                 WDS2:   
01f8d6 deb5              rcall   CR
                 WDS3:
01f8d7 dd24              rcall   SWOP_A
                 
01f8d8 df81              rcall   TWOMINUS
01f8d9 ddab              rcall   FETCH_A
01f8da da85              rcall   DUPZEROSENSE
01f8db f761              brne    WDS1
01f8dc 940d f15d         jmp     TWODROP
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
01f8de f176              fdw     WORDS_L
                 DOTS_L:
01f8df 2e82
01f8e0 0073              .db     NFA|2,".s",0
                 DOTS:
01f8e1 d892              rcall   SPACE_
01f8e2 de6c              rcall   DUP          ; push tosl:tosh to memory
01f8e3 940f f08c         call    SPFETCH
01f8e5 df92              rcall   S0
01f8e6 dd9e              rcall   FETCH_A
01f8e7 df72              rcall   TWOMINUS
                 DOTS1:
01f8e8 d87b              rcall   TWODUP
01f8e9 da04              rcall   LESS
01f8ea da6f              rcall   ZEROSENSE
01f8eb f019              breq    DOTS2
01f8ec df60              rcall   MINUS_FETCH
01f8ed db27              rcall   UDOT
01f8ee cff9              rjmp    DOTS1
                 DOTS2:  
01f8ef d933              rcall   DROP
01f8f0 940d f15d         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
01f8f2 f1be              fdw     DOTS_L
                 DUMP_L:
01f8f3 6484
01f8f4 6d75
01f8f5 0070              .db     NFA|4,"dump",0
                 DUMP:
01f8f6 de4e              rcall   DOLIT
01f8f7 0010              .dw     16
01f8f8 da85              rcall   USLASH
01f8f9 d94a              rcall   TOR
01f8fa c020              rjmp    DUMP7
                 DUMP1:  
01f8fb de90              rcall   CR
01f8fc de52              rcall   DUP
01f8fd de47              rcall   DOLIT
01f8fe 0004              .dw     4
01f8ff db1f              rcall   UDOTR
01f900 de44              rcall   DOLIT
01f901 003a              .dw     ':'
01f902 de8e              rcall   EMIT_A
01f903 de41              rcall   DOLIT
01f904 000f              .dw     15
01f905 d93e              rcall   TOR
                 DUMP2:
01f906 dbe4              rcall   CFETCHPP
01f907 de3d              rcall   DOLIT
01f908 0002              .dw     2
01f909 db15              rcall   UDOTR
01f90a d0e7              rcall   XNEXT
01f90b f7d0              brcc    DUMP2
01f90c 911f              pop     t1
01f90d 910f              pop     t0
                 
01f90e de36              rcall   DOLIT
01f90f 0010              .dw     16
01f910 d968              rcall   MINUS
01f911 de33              rcall   DOLIT
01f912 000f              .dw     15
01f913 d930              rcall   TOR
                 DUMP4:  
01f914 dbd6              rcall   CFETCHPP
01f915 df9d              rcall   TO_PRINTABLE
01f916 de7a              rcall   EMIT_A
01f917 d0da              rcall   XNEXT
01f918 f7d8              brcc    DUMP4
01f919 911f              pop     t1
01f91a 910f              pop     t0
                 DUMP7:
01f91b d0d6              rcall   XNEXT
01f91c f6f0              brcc    DUMP1
01f91d 911f              pop     t1
01f91e 910f              pop     t0
01f91f 940d f223         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
01f921 2081              .db     NFA|1," "
                 IALLOT:
01f922 debf              rcall   IDP
01f923 940d f2cb         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
01f925 f1e6              fdw     DUMP_L
                 X_TO_R_L:
01f926 7883
01f927 723e              .db     NFA|3,"x>r"
                 X_TO_R:
01f928 01fc              movw    zl, tosl
01f929 9189
01f92a 9199              poptos
01f92b d00a              rcall   TO_XA
01f92c 9631              adiw    zl, 1
01f92d 9382              st      -z, tosl
01f92e 9392              st      -z, tosh
                 .ifdef EIND
01f92f 9262              st      -z, r_one
                 .endif
01f930 9252              st      -z, zero
01f931 01cf              movw    tosl, zl
01f932 9508              ret
                 ;***************************************************************
01f933 f24c              fdw     X_TO_R_L
                 TO_XA_L:
01f934 3e83
01f935 6178              .db NFA|3,">xa"
                 TO_XA:
                          sub_pflash_tos
01f936 9408               rampv_to_c
01f937 9597               ror tosh
01f938 9587               ror tosl
01f939 9508               ret
                 
01f93a f268               fdw     TO_XA_L
                 XA_FROM_L:
01f93b 7883
01f93c 3e61              .db NFA|3,"xa>"
                 XA_FROM:
01f93d 0f88               lsl     tosl
01f93e 1f99               rol     tosh
                          add_pflash_tos
01f93f 9508               ret
                 ;***************************************************************
01f940 f276               fdw    XA_FROM_L
                 PFL_L:
01f941 7083
01f942 6c66              .db     NFA|3,"pfl"
                 PFL:
01f943 940f f063          call   DOCREATE
01f945 3200              .dw     OFLASH
                 ;***************************************************************
01f946 f282              fdw    PFL_L
                 ZFL_L:
01f947 7a83
01f948 6c66              .db     NFA|3, "zfl"
                 ZFL:
01f949 940f f063          call   DOCREATE
01f94b 0003              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
01f94c 2c84
01f94d 303f
01f94e 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
01f94f fd65              sbrc    FLAGS1, idup
01f950 c003              rjmp    COMMAZEROSENSE1
01f951 ddf3              rcall   DOLIT
01f952 e6b4              fdw     ZEROSENSE
01f953 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
01f954 d004              rcall   IDPMINUS
01f955 ddef              rcall   DOLIT
01f956 e6c0              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
01f957 7d6f              cbr     FLAGS1, (1<<idup)
01f958 c070              rjmp    INLINE0
                 
                 IDPMINUS:
01f959 ddeb              rcall   DOLIT
01f95a fffc              .dw     -4
01f95b cfc6              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
01f95c d968              rcall   TWOSLASH
01f95d 709f              andi    tosh, 0x0f
01f95e 6c90              ori     tosh, 0xc0
01f95f 940d ffb9         jmp     ICOMMA
                 
                 
                 BRCCC:
01f961 dde3              rcall   DOLIT
01f962 f008              .dw     0xf008      ; brcc pc+2
01f963 940d ffb9         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
01f965 dddf              rcall   DOLIT
01f966 f409              .dw     0xf409      ; brne pc+2
01f967 fd64              sbrc    FLAGS1, izeroeq
01f968 7f9b              andi    tosh, ~4
01f969 940d ffb9         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
01f96b f28e              fdw     ZFL_L
                 IF_L:
01f96c 69d2
01f96d 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
01f96e fd64              sbrc    FLAGS1, izeroeq
01f96f dfe9              rcall   IDPMINUS
01f970 dfde              rcall   COMMAZEROSENSE
01f971 dff3              rcall   BRNEC
01f972 7e6f              cbr     FLAGS1, (1<<izeroeq)
01f973 de07              rcall   IHERE
01f974 dd72              rcall   FALSE_
01f975 940d f95c         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
01f977 f2d8              fdw     IF_L
                 ELSE_L:
01f978 65d4
01f979 736c
01f97a 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
01f97b ddff              rcall   IHERE
01f97c dd6a              rcall   FALSE_
01f97d dfde              rcall   RJMPC
01f97e dc7d              rcall   SWOP_A      ; else-addr  if-addr 
01f97f 940d f985         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
01f981 f2f0              fdw     ELSE_L
                 THEN_L:
01f982 74d4
01f983 6568
01f984 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
01f985 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f986 ddf4              rcall   IHERE
01f987 d8ac              rcall   OVER
01f988 d8f0              rcall   MINUS
01f989 ded0              rcall   TWOMINUS
01f98a d93a              rcall   TWOSLASH
01f98b ddb9              rcall   DOLIT
01f98c c000              .dw     0xc000      ;  back-addr mask 
01f98d d8fc              rcall   OR_
01f98e dc6d              rcall   SWOP_A
01f98f 940d fe9a         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
01f991 f304              fdw     THEN_L
                 BEGIN_L:
01f992 62d5
01f993 6765
01f994 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
01f995 940d f77b         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
01f997 f324              fdw     BEGIN_L
                 UNTIL_L:
01f998 75d5
01f999 746e
01f99a 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
01f99b 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f99c fd64              sbrc    FLAGS1, izeroeq
01f99d dfbb              rcall   IDPMINUS
01f99e dfb0              rcall   COMMAZEROSENSE
01f99f dfc5              rcall   BRNEC
01f9a0 7e6f              cbr     FLAGS1, (1<<izeroeq)
01f9a1 940d f9a7         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
01f9a3 f330              fdw     UNTIL_L
                 AGAIN_L:
01f9a4 61d5
01f9a5 6167
01f9a6 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
01f9a7 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f9a8 ddd2              rcall   IHERE
01f9a9 d8cf              rcall   MINUS
01f9aa deaf              rcall   TWOMINUS
01f9ab 940d f95c         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
01f9ad f348              fdw     AGAIN_L
                 WHILE_L:
01f9ae 77d5
01f9af 6968
01f9b0 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
01f9b1 dfbc              rcall   IF_
01f9b2 940d f22a         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
01f9b4 f35c              fdw     WHILE_L
                 REPEAT_L:
01f9b5 72d6
01f9b6 7065
01f9b7 6165
01f9b8 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
01f9b9 dfed              rcall   AGAIN_
01f9ba 940d f985         jmp     THEN_
                 
01f9bc f36a              fdw     REPEAT_L
                 INLINE_L:
01f9bd 69d6
01f9be 6c6e
01f9bf 6e69
01f9c0 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
01f9c1 7e6f              cbr      FLAGS1, (1<<izeroeq)
01f9c2 7d6f              cbr      FLAGS1, (1<<idup)
01f9c3 dd9e              rcall    TICK
01f9c4 940d f9c9         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
01f9c6 f37a              fdw      INLINE_L
                 INLINEC_L:
01f9c7 6983
01f9c8 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
01f9c9 db29              rcall   FETCHPP
01f9ca dd84              rcall   DUP
01f9cb dd79              rcall   DOLIT
01f9cc 9508              .dw     0x9508
01f9cd d913              rcall   NOTEQUAL
01f9ce d98b              rcall   ZEROSENSE
01f9cf f011              breq    INLINE1
01f9d0 d5e8              rcall   ICOMMA
01f9d1 cff7              rjmp    INLINE0
                 INLINE1:
01f9d2 940d f15d         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
01f9d4 f38e              fdw     INLINEC_L
                 FOR_L:
01f9d5 66d3
01f9d6 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
01f9d7 940f f07f         call    DOCOMMAXT
01f9d9 e488              fdw     TOR
01f9da dda0              rcall   IHERE
01f9db dd0b              rcall   FALSE_
01f9dc df7f              rcall   RJMPC
01f9dd dd9d              rcall   IHERE
01f9de 940d f22a         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
01f9e0 f3aa              fdw     FOR_L
                 NEXT_L:
01f9e1 6ed4
01f9e2 7865
01f9e3 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
01f9e4 dfa0              rcall   THEN_
01f9e5 940f f07f         call    DOCOMMAXT
01f9e7 f3e4              fdw     XNEXT
01f9e8 df78              rcall   BRCCC
                 
01f9e9 dfbd              rcall   AGAIN_
                 
01f9ea dd5a              rcall   DOLIT
01f9eb f3f8              fdw     XNEXT1
01f9ec 940d f9c9         jmp     INLINE0
                 ; (next) decrement top of return stack
01f9ee 2887
01f9ef 656e
01f9f0 7478
01f9f1 2029              .db     NFA|7,"(next) "
                 XNEXT:  
01f9f2 91ff              m_pop_zh
01f9f3 91ff              pop     zh
01f9f4 91ef              pop     zl
01f9f5 91bf              pop     xh
01f9f6 91af              pop     xl
01f9f7 9711              sbiw    xl, 1
01f9f8 93af              push    xl
01f9f9 93bf              push    xh
01f9fa 9419              mijmp
01f9fb 9508              ret
                 XNEXT1:
01f9fc 911f              pop     t1
01f9fd 910f              pop     t0
01f9fe 9508              ret
                 
                 ; leave clear top of return stack
01f9ff f3c2              fdw     NEXT_L
                 LEAVE_L:
01fa00 6595
01fa01 646e
01fa02 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
01fa03 91ff              m_pop_zh
01fa04 91ff              pop     zh
01fa05 91ef              pop     zl
01fa06 911f              pop     t1
01fa07 910f              pop     t0
01fa08 2700              clr     t0
01fa09 2711              clr     t1
01fa0a 930f              push    t0
01fa0b 931f              push    t1
01fa0c 9419              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
01fa0d f400              fdw      LEAVE_L
                 RDROP_L:
01fa0e 72d5
01fa0f 7264
01fa10 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
01fa11 dd33              rcall   DOLIT
01fa12 f3f8              fdw     XNEXT1
01fa13 940d f9c9         jmp     INLINE0
                 ;***************************************************
01fa15 f41c              fdw     RDROP_L
                 STOD_L:
01fa16 7383
01fa17 643e              .db     NFA|3,"s>d"
                 STOD:
01fa18 ff97              sbrs    tosh, 7
01fa19 cccd              rjmp    FALSE_
01fa1a ccd5              rjmp    TRUE_
                 ;***************************************************
01fa1b f42c              fdw     STOD_L
                 DNEGATE_L:
01fa1c 6487
01fa1d 656e
01fa1e 6167
01fa1f 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
01fa20 d049              rcall   DINVERT
01fa21 940f f197         call    ONE
01fa23 940d f274         jmp     MPLUS
                 ;***************************************************
01fa25 f438              fdw     DNEGATE_L
                 QDNEGATE_L:
01fa26 3f88
01fa27 6e64
01fa28 6765
01fa29 7461
01fa2a 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
01fa2b dd30              rcall   ZEROLESS
01fa2c d92d              rcall   ZEROSENSE
01fa2d f009              breq    QDNEGATE1
01fa2e dff1              rcall   DNEGATE
                 QDNEGATE1:
01fa2f 9508              ret
                 
                 ;***************************************************
01fa30 f44c              fdw     QDNEGATE_L
                 DABS_L:
01fa31 6484
01fa32 6261
01fa33 0073              .db     NFA|4,"dabs",0
                 DABS:
01fa34 dd1a              rcall   DUP
01fa35 940d fa2b         jmp     QDNEGATE
                 ;***************************************************
01fa37 f462              fdw     DABS_L
                 DPLUS_L:
01fa38 6482
01fa39 002b              .db     NFA|2,"d+",0
                 DPLUS:
01fa3a 91a9              ld      xl, Y+
01fa3b 91b9              ld      xh, Y+
01fa3c 91e9              ld      t6, Y+
01fa3d 91f9              ld      t7, Y+
01fa3e 9109              ld      t0, Y+
01fa3f 9119              ld      t1, Y+
01fa40 0fa0              add     xl, t0
01fa41 1fb1              adc     xh, t1
01fa42 1f8e              adc     tosl, t6
01fa43 1f9f              adc     tosh, t7
01fa44 93ba              st      -Y, xh
01fa45 93aa              st      -Y, xl
01fa46 9508              ret
                 
                 ;***************************************************
01fa47 f470              fdw     DPLUS_L
                 DMINUS_L:
01fa48 6482
01fa49 002d              .db     NFA|2,"d-",0
                 DMINUS:
01fa4a dfd5              rcall   DNEGATE
01fa4b 940d fa3a         jmp     DPLUS
                 ;***************************************************
01fa4d f490              fdw     DMINUS_L
                 DTWOSLASH_L:
01fa4e 6483
01fa4f 2f32              .db     NFA|3,"d2/"
01fa50 9109              ld      t0, y+
01fa51 9119              ld      t1, y+
01fa52 9595              asr     tosh
01fa53 9587              ror     tosl
01fa54 9517              ror     t1
01fa55 9507              ror     t0
01fa56 931a              st      -y, t1
01fa57 930a              st      -y, t0
01fa58 9508              ret
                 ;***************************************************
01fa59 f49c              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
01fa5a 6483
01fa5b 2a32              .db     NFA|3,"d2*"
01fa5c 9109              ld      t0, y+
01fa5d 9119              ld      t1, y+
01fa5e 0f00              lsl     t0
01fa5f 1f11              rol     t1
01fa60 1f88              rol     tosl
01fa61 1f99              rol     tosh
01fa62 931a              st      -y, t1
01fa63 930a              st      -y, t0
01fa64 9508              ret
                 ;***************************************************
01fa65 f4b4              fdw     DTWOSTAR_L
                 DINVERT_L:
01fa66 6487
01fa67 6e69
01fa68 6576
01fa69 7472              .db     NFA|7,"dinvert"
                 DINVERT:
01fa6a 91a9              ld      xl, y+
01fa6b 91b9              ld      xh, y+
01fa6c 95a0              com     xl
01fa6d 95b0              com     xh
01fa6e 9580              com     tosl
01fa6f 9590              com     tosh
01fa70 93ba              st      -y, xh
01fa71 93aa              st      -y, xl
01fa72 9508              ret
                 ;***************************************************
01fa73 f4cc              fdw     DINVERT_L
                 DZEROEQUAL_L:
01fa74 6483
01fa75 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
01fa76 91a9              ld      xl, y+
01fa77 91b9              ld      xh, y+
01fa78 2b89              or      tosl, tosh
01fa79 2b8a              or      tosl, xl
01fa7a 2b8b              or      tosl, xh
01fa7b f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
01fa7c ef8f              ser     tosl
01fa7d ef9f              ser     tosh
01fa7e 9508              ret
                 
                 ;***************************************************
01fa7f f4e8              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
01fa80 6483
01fa81 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
01fa82 91a9              ld      xl, y+
01fa83 91b9              ld      xh, y+
01fa84 3090              cpi     tosh, 0
01fa85 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
01fa86 2788              clr     tosl
01fa87 2799              clr     tosh
01fa88 9508              ret
                 ;***************************************************
01fa89 f500              fdw     DZEROLESS_L
                 DEQUAL_L:
01fa8a 6482
01fa8b 003d              .db     NFA|2,"d=",0
01fa8c dfbd              rcall   DMINUS
01fa8d 940d fa76         jmp     DZEROEQUAL
                 ;***************************************************
01fa8f f514              fdw     DEQUAL_L
                 DLESS_L:
01fa90 6482
01fa91 003c              .db     NFA|2,"d<",0
                 DLESS:
01fa92 dfb7              rcall   DMINUS
01fa93 940d fa82         jmp     DZEROLESS
                 ;***************************************************
01fa95 f520              fdw     DLESS_L
                 DGREATER_L:
01fa96 6482
01fa97 003e              .db     NFA|2,"d>",0
                 DGREATER:
01fa98 940f f16b         call    TWOSWAP
01fa9a 940d fa92         jmp     DLESS
                 ;***************************************************
01fa9c f52c              fdw     DGREATER_L
                 UDDOT_L:
01fa9d 7583
01fa9e 2e64              .db     NFA|3,"ud."
01fa9f d936              rcall   LESSNUM
01faa0 d956              rcall   NUMS
01faa1 d95e              rcall   NUMGREATER
01faa2 940f f1de         call    TYPE
01faa4 940d f174         jmp     SPACE_
                 ;***************************************************
01faa6 f53a              fdw     UDDOT_L
                 DDOT_L:
01faa7 6482
01faa8 002e              .db     NFA|2,"d.",0
01faa9 d92c              rcall   LESSNUM
01faaa 940f f74f         call    DUP
01faac 940f f244         call    TOR
01faae df85              rcall   DABS
01faaf d947              rcall   NUMS
01fab0 940f f24f         call    RFROM
01fab2 d958              rcall   SIGN
01fab3 d94c              rcall   NUMGREATER
01fab4 940f f1de         call    TYPE
01fab6 940d f174         jmp     SPACE_
                 ;****************************************************
01fab8 f54e              fdw      DDOT_L
                 MEMHI_L:
01fab9 6882
01faba 0069              .db     NFA|2,"hi",0
                 MEMHI:
01fabb dc89              rcall   DOLIT
01fabc f586              fdw     FLASHHI
01fabd 940f f0d0         call    CSE_
01fabf 940f f26c         call    PLUS
01fac1 940d fee5         jmp     FETCH
                 FLASHHI:
01fac3 ddff              .dw      FLASH_HI
01fac4 31ff              .dw      EEPROM_HI
01fac5 21ff              .dw      RAM_HI
                 
                 .if FLASHEND > 0x3fff
                 ;;; x@ ( addrl addru -- x )
01fac6 fdb8              fdw     A_FROM_L
                 XFETCH_L:
01fac7 7882
01fac8 0040              .db     NFA|2, "x@",0
                 .ifdef RAMPZ
01fac9 bf8b      	out_    RAMPZ, tosl
                 .endif
01faca 9189
01facb 9199      	poptos
01facc 01fc              movw    z, tosl
01facd 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01face 9197              lpm_    tosh, z+
                 .ifdef RAMPZ
01facf e003              ldi     t0, RAMPZV
01fad0 bf0b              out_    RAMPZ, t0
                 .endif
01fad1 9508      	ret
                 	
                 ;;; x! ( x addrl addru -- )
01fad2 f58e              fdw     XFETCH_L
                 XSTORE_L:
01fad3 7882
01fad4 0021              .db     NFA|2, "x!",0
01fad5 2f08      	mov     t0, tosl
01fad6 9189
01fad7 9199      	poptos
01fad8 940f fd21         call    XUPDATEBUF
01fada 940d fe84 	jmp     ISTORE1
                 .endif
                 
                 ;***************************************************
                 
01fadc f572              fdw      MEMHI_L
                 L_FETCH_P:
01fadd 40a2
01fade 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
01fadf 939a
01fae0 938a              pushtos
01fae1 01ca              movw    tosl, pl
01fae2 9508              ret
                 ;***************************************************
01fae3 f5ba              fdw     L_FETCH_P
                 L_PCFETCH:
01fae4 7083
01fae5 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
01fae6 939a
01fae7 938a              pushtos
01fae8 01ca              movw    tosl, pl
01fae9 940d ff12         jmp     CFETCH
                 ;***************************************************
01faeb f5c8              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
01faec 70a3
01faed 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
01faee 0d47              add     pl, r_two
01faef 1d55              adc     ph, zero
01faf0 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
01faf1 0000              .dw     0
                 L_MARKER:
                 lastword:
01faf2 6d86
01faf3 7261
01faf4 656b
01faf5 0072              .db     NFA|6,"marker",0
                 MARKER:
01faf6 940f f0b5         call    ROM_
01faf8 dc9f              rcall   CREATE
01faf9 dc4b              rcall   DOLIT
01fafa 2200              .dw     dp_start
01fafb 940f f0da         call    HERE
01fafd dbc1              rcall   TEN
01fafe d9d1              rcall   CMOVE
01faff dbbf              rcall   TEN
01fb00 940f f21c         call    ALLOT
01fb02 940f f0c3         call    FRAM
01fb04 dce3              rcall   XDOES
01fb05 940f f06d         call    DODOES
01fb07 dd79              rcall   INI
01fb08 dbb6              rcall   TEN
01fb09 940d f4d0         jmp     CMOVE
                 
                 
                 ;;; Enable load led
01fb0b dea4              fdw     BUSY_L
                 LOADON_L:
01fb0c 6c85
01fb0d 616f
01fb0e 2b64              .db     NFA|5,"load+"
01fb0f 6170              sbr     FLAGS2, (1<<fLOADled)
01fb10 9508              ret
                 
                 ;;; Disable load led
01fb11 f618              fdw     LOADON_L
                 LOADOFF_L:
01fb12 6c85
01fb13 616f
01fb14 2d64              .db     NFA|5,"load-"
01fb15 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
01fb16 9827              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
01fb17 982f              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
01fb18 9508              ret
                 ;;; Enable load led
01fb19 f624              fdw     LOADOFF_L
                 LOAD_L:
01fb1a 6c84
01fb1b 616f
01fb1c 0064              .db     NFA|4,"load",0
01fb1d 939a
01fb1e 938a              pushtos
01fb1f 9180 03cb         lds     tosl, load_res
01fb21 9190 03cc         lds     tosh, load_res+1
01fb23 939a
01fb24 938a              pushtos
01fb25 9180 03cd         lds     tosl, load_res+2
01fb27 2799              clr     tosh
01fb28 939a
01fb29 938a              pushtos
01fb2a e680              ldi     tosl, low(CPU_LOAD_VAL)
01fb2b e99f              ldi     tosh, high(CPU_LOAD_VAL)
01fb2c 940f f36c         call    UMSLASHMOD
01fb2e 940d f39b         jmp     NIP 
                 
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
01fb30 0200              .dw      0x0200                ; cse, state
01fb31 048a              .dw      utibbuf-4             ; S0
01fb32 044d              .dw      usbuf-1               ; R0
01fb33 f992              fdw      OP_TX_
01fb34 f9e0              fdw      OP_RX_
01fb35 fa20              fdw      OP_RXQ
01fb36 000a              .dw      BASE_DEFAULT          ; BASE
01fb37 048e              .dw      utibbuf               ; TIB
01fb38 de8c              fdw      OPERATOR_AREA         ; TASK
01fb39 0000              .dw      0                     ; ustatus & uflg
01fb3a 0000              .dw      0                     ; source
01fb3b 0000              .dw      0                     ; source
01fb3c 0000              .dw      0                     ; TOIN
01fb3d 03ec              .dw      up0                   ; Task link
                 
                 .ifdef UCSR1A
                 ;***************************************************
                 ; TX1   c --    output character to UART 1
01fb3e fa1a              fdw     RX0Q_L
                 TX1_L:
01fb3f 7483
01fb40 3178              .db     NFA|3,"tx1"
                 TX1_:
01fb41 3181              cpi     tosl, XON
01fb42 f061              breq    XXON_TX1_TOS
01fb43 3183              cpi     tosl, XOFF
01fb44 f091              breq    XXOFF_TX1_TOS
                 TX1_LOOP:
01fb45 d453              rcall   PAUSE
01fb46 9100 00c8         in_     t0, UCSR1A
01fb48 ff05              sbrs    t0, UDRE1
01fb49 cffb              rjmp    TX1_LOOP
01fb4a 9380 00ce         out_    UDR1, tosl
01fb4c 9189
01fb4d 9199              poptos
01fb4e 9508              ret
                 
                 XXON_TX1_TOS:
01fb4f 9189
01fb50 9199              poptos
01fb51 c002              rjmp    XXON_TX1_1
                 XXON_TX1:
01fb52 ff71              sbrs    FLAGS2, ixoff_tx1
01fb53 9508              ret
                 XXON_TX1_1:
01fb54 7f7d              cbr     FLAGS2, (1<<ixoff_tx1)
01fb55 e1f1              ldi     zh, XON
01fb56 c007              rjmp    TX1_SEND
                 
                 XXOFF_TX1_TOS:
01fb57 9189
01fb58 9199              poptos
01fb59 c002              rjmp    XXOFF_TX1_1
                 XXOFF_TX1:
01fb5a fd71              sbrc    FLAGS2, ixoff_tx1
01fb5b 9508              ret     
                 XXOFF_TX1_1:
01fb5c 6072              sbr     FLAGS2, (1<<ixoff_tx1)
01fb5d e1f3              ldi     zh, XOFF
                 TX1_SEND:
01fb5e 91e0 00c8         in_     zl, UCSR1A
01fb60 ffe5              sbrs    zl, UDRE1
01fb61 cffc              rjmp    TX1_SEND
01fb62 93f0 00ce         out_    UDR1, zh
01fb64 9508              ret
                 ;***************************************************
                 ; RX1    -- c    get character from the serial line
01fb65 f67e              fdw     TX1_L
                 RX1_L:
01fb66 7283
01fb67 3178              .db     NFA|3,"rx1"
                 RX1_:
01fb68 d430              rcall   PAUSE
01fb69 d01e              rcall   RX1Q
01fb6a 940f f35a         call    ZEROSENSE
01fb6c f3d9              breq    RX1_
01fb6d 939a
01fb6e 938a              pushtos
01fb6f e9e8              ldi     zl, low(rbuf1)
01fb70 e0f3              ldi     zh, high(rbuf1)
01fb71 91a0 0396         lds     xl, rbuf1_rd
01fb73 0fea              add     zl, xl
01fb74 1df5              adc     zh, zero
01fb75 8180              ld      tosl, z
01fb76 2799              clr     tosh
01fb77 b70f              in_     t0, SREG
01fb78 94f8              cli
01fb79 95a3              inc     xl
01fb7a 71af              andi    xl, (RX1_BUF_SIZE-1)
01fb7b 93a0 0396         sts     rbuf1_rd, xl
01fb7d 91a0 0397         lds     xl, rbuf1_lv
01fb7f 95aa              dec     xl
01fb80 93a0 0397         sts     rbuf1_lv, xl
01fb82 bf0f              out_    SREG, t0
01fb83 9508              ret
                 ;***************************************************
                 ; RX1?  -- n    return the number of characters in queue
01fb84 f6cc              fdw     RX1_L
                 RX1Q_L:
01fb85 7284
01fb86 3178
01fb87 003f              .db     NFA|4,"rx1?",0
                 RX1Q:
01fb88 91a0 0397         lds     xl, rbuf1_lv
01fb8a 11a5              cpse    xl, zero
01fb8b 940d f6f0         jmp     TRUE_
                 .if U1FC_TYPE == 1
01fb8d dfc4              rcall   XXON_TX1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
01fb8e 940d f6e7         jmp     FALSE_
                 
                 ;****************************************************
                 RX1_ISRR:
01fb90 e9e8              ldi     zl, low(rbuf1)
01fb91 e0f3              ldi     zh, high(rbuf1)
01fb92 91a0 0395         lds     xl, rbuf1_wr
01fb94 0fea              add     zl, xl
01fb95 1df5              adc     zh, zero
01fb96 91b0 00ce         in_     xh, UDR1
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
01fb98 83b0              st      z, xh
01fb99 95a3              inc     xl
01fb9a 71af              andi    xl, (RX1_BUF_SIZE-1)
01fb9b 93a0 0395         sts     rbuf1_wr, xl
01fb9d 91a0 0397         lds     xl, rbuf1_lv
01fb9f 95a3              inc     xl
01fba0 93a0 0397         sts     rbuf1_lv, xl
01fba2 31ae              cpi     xl, RX1_BUF_SIZE-2
01fba3 f409              brne    PC+2
01fba4 d004              rcall   RX1_OVF
01fba5 30a4              cpi     xl, RX0_OFF_FILL
01fba6 f00a              brmi    RX1_ISR_SKIP_XOFF
                 .if U1FC_TYPE == 1
01fba7 dfb4              rcall   XXOFF_TX1_1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 RX1_ISR_SKIP_XOFF:
01fba8 c0c8              rjmp    FF_ISR_EXIT
                 RX1_OVF:
01fba9 e7fc              ldi     zh, '|'
01fbaa cfb3              rjmp    TX1_SEND
                 TX1_ISR:
                 .endif
                 ;***************************************************
                 RQ_EMIT:
01fbab fe00              sbrs    t2, PORF
01fbac c003              rjmp    RQ_EXTR
01fbad db97              rcall   DOLIT
01fbae 0050              .dw     'P'
01fbaf dbe1              rcall   EMIT_A
                 RQ_EXTR:
01fbb0 fe01              sbrs    t2, EXTRF
01fbb1 c003              rjmp    RQ_BORF
01fbb2 db92              rcall   DOLIT
01fbb3 0045              .dw     'E'
01fbb4 dbdc              rcall   EMIT_A
                 RQ_BORF:
01fbb5 fe02              sbrs    t2, BORF
01fbb6 c003              rjmp    RQ_WDRF
01fbb7 db8d              rcall   DOLIT
01fbb8 0042              .dw     'B'
01fbb9 dbd7              rcall   EMIT_A
                 RQ_WDRF:
01fbba fe03              sbrs    t2, WDRF
01fbbb c003              rjmp    RQ_DIVZERO
01fbbc db88              rcall   DOLIT
01fbbd 0057              .dw     'W'
01fbbe dbd2              rcall   EMIT_A
                 RQ_DIVZERO:
01fbbf fe16              sbrs    t3, 6 ; T bit MATH error
01fbc0 c003              rjmp    RQ_END
01fbc1 db83              rcall   DOLIT
01fbc2 004d              .dw     'M'
01fbc3 dbcd              rcall   EMIT_A
                 RQ_END: 
01fbc4 940d f174         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
01fbc6 ff75              sbrs    FLAGS2, fLOAD
01fbc7 c00d              rjmp    CPU_LOAD_END
01fbc8 b70f              in_     t0, SREG
01fbc9 94f8              cli
01fbca 7d7f              cbr     FLAGS2, (1<<fLOAD)
01fbcb 9240 03cb         sts     load_res, loadreg0
01fbcd 92c0 03cc         sts     load_res+1,loadreg1
01fbcf 92d0 03cd         sts     load_res+2, loadreg2
01fbd1 2444              clr     loadreg0
01fbd2 24cc              clr     loadreg1
01fbd3 24dd              clr     loadreg2
01fbd4 bf0f              out_    SREG, t0
                 CPU_LOAD_END:
                 .endif
                 .if CPU_LOAD_LED == 1
01fbd5 ff74              sbrs    FLAGS2, fLOADled
01fbd6 c002              rjmp    LOAD_LED_END
01fbd7 9a27              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
01fbd8 982f              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
01fbd9 ff76              sbrs    FLAGS2, fIDLE
01fbda c009              rjmp    IDLE_LOAD1
01fbdb ee0c              ldi     t0, low(up0)
01fbdc 1620              cp      upl, t0
01fbdd f431              brne    IDLE_LOAD1
                 .ifdef SMCR
01fbde e001              ldi     t0, (1<<SE)
01fbdf bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
01fbe0 9250 0081         out_    TCCR1B, zero    ; Stop load counter
                 .endif
01fbe2 9588              sleep               ; IDLE mode
                 .ifdef SMCR
01fbe3 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
01fbe4 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
01fbe5 9a2f              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
01fbe6 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
01fc00 940d fdad RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
01fc02 d079                  rcall FF_ISR
                 .org BOOT_START + 0x04
01fc04 d077                  rcall FF_ISR
                 .org BOOT_START + 0x06
01fc06 d075                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
01fc08 d073                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
01fc0a d071                  rcall FF_ISR
                 .org BOOT_START + 0x0c
01fc0c d06f                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
01fc0e d06d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
01fc10 d06b                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
01fc12 d069                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
01fc14 d067                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
01fc16 d065                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
01fc18 d063                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
01fc1a d061                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
                 .else
01fc1c d05f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
01fc1e d05d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
01fc20 d05b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
01fc22 d059                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
01fc24 d057                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
01fc26 d055                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
01fc28 d053                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
01fc2a c065                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
01fc2c d04f                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
01fc2e d04d                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
01fc30 d04b                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
01fc32 d049                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x34
01fc34 d047                  rcall FF_ISR
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x36
01fc36 d045                  rcall FF_ISR
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x38
01fc38 d043                  rcall FF_ISR
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3a
01fc3a d041                  rcall FF_ISR
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3c
01fc3c d03f                  rcall FF_ISR
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3e
01fc3e d03d                  rcall FF_ISR
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x40
01fc40 d03b                  rcall FF_ISR
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x42
01fc42 d039                  rcall FF_ISR
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x44
01fc44 d037                  rcall FF_ISR
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x46
01fc46 d035                  rcall FF_ISR
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x48
01fc48 d033                  rcall FF_ISR
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4a
01fc4a d031                  rcall FF_ISR
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4c
01fc4c d02f                  rcall FF_ISR
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4e
01fc4e d02d                  rcall FF_ISR
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x50
01fc50 d02b                  rcall FF_ISR
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x52
01fc52 d029                  rcall FF_ISR
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x54
01fc54 d027                  rcall FF_ISR
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x56
01fc56 d025                  rcall FF_ISR
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x58
01fc58 d023                  rcall FF_ISR
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5a
01fc5a d021                  rcall FF_ISR
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5c
01fc5c d01f                  rcall FF_ISR
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5e
01fc5e d01d                  rcall FF_ISR
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x60
01fc60 d01b                  rcall FF_ISR
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x62
01fc62 d019                  rcall FF_ISR
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x64
01fc64 d017                  rcall FF_ISR
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x66
01fc66 d015                  rcall FF_ISR
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x68
01fc68 d013                  rcall FF_ISR
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6a
01fc6a d011                  rcall FF_ISR
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6c
01fc6c d00f                  rcall FF_ISR
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6e
01fc6e d00d                  rcall FF_ISR
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x70
01fc70 d00b                  rcall FF_ISR
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
01fc71 919f              pop     tosh
01fc72 918f              pop     tosl
01fc73 911f              pop     t1
01fc74 910f              pop     t0
01fc75 91ff              pop     zh
01fc76 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
01fc77 91a9              ld      xl, y+
01fc78 91b9              ld      xh, y+
01fc79 bfbf              out_    SREG, xh
01fc7a 91b9              ld      xh, y+
01fc7b 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
01fc7c 9260 0081         out_    TCCR1B, r_one   ; Start load counter
                 .endif
                 .endif
01fc7e 93ba              st      -y, xh
01fc7f b7bf              in_     xh, SREG
01fc80 93ba              st      -y, xh
01fc81 93aa              st      -y, xl
01fc82 91bf              m_pop_xh
01fc83 91bf              pop     xh
01fc84 91af              pop     xl
01fc85 93ef              push    zl
01fc86 93ff              push    zh
01fc87 930f              push    t0
01fc88 931f              push    t1
01fc89 938f              push    tosl
01fc8a 939f              push    tosh
                 .if low(ivec) == 0x80
                 .else
01fc8b 50a1              subi    xl, 1
                 .endif
01fc8c e0b3              ldi     xh, high(ivec)
01fc8d 91ed              ld      zl, x+
01fc8e 91fd              ld      zh, x+
01fc8f 9419              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
01fc90 9260 0081         out_    TCCR1B, r_one   ; Start load counter
                 .endif
                 .endif
01fc92 93ba              st      -y, xh
01fc93 b7bf              in_     xh, SREG
01fc94 93ba              st      -y, xh
01fc95 93aa              st      -y, xl
01fc96 0ce6              add     ms_count,  r_one
01fc97 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
                 LOAD_ADD:
01fc98 91a0 0084         in_     xl, TCNT1L
01fc9a 91b0 0085         in_     xh, TCNT1H
01fc9c 9250 0085         out_    TCNT1H, zero
01fc9e 9270 0084         out_    TCNT1L, r_two
                 
01fca0 0e4a              add     loadreg0, xl
01fca1 1ecb              adc     loadreg1, xh
01fca2 1cd5              adc     loadreg2, zero
                 
01fca3 20ee              tst     ms_count
01fca4 f409              brne    LOAD_ADD_END
01fca5 6270              sbr     FLAGS2, (1<<fLOAD)
                 LOAD_ADD_END:
                 .endif
01fca6 cfd0              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
01fca7 e7e5              ldi     zl, low(rbuf0)
01fca8 e0f3              ldi     zh, high(rbuf0)
01fca9 91a0 0372         lds     xl, rbuf0_wr
01fcab 0fea              add     zl, xl
01fcac 1df5              adc     zh, zero
01fcad 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
01fcaf 30bf              cpi     xh, 0xf
01fcb0 f409              brne    pc+2
01fcb1 cf4e              rjmp    RESET_
                 .endif
                 .endif
01fcb2 83b0              st      z, xh
01fcb3 95a3              inc     xl
01fcb4 71af              andi    xl, (RX0_BUF_SIZE-1)
01fcb5 93a0 0372         sts     rbuf0_wr, xl
01fcb7 91a0 0374         lds     xl, rbuf0_lv
01fcb9 95a3              inc     xl
01fcba 93a0 0374         sts     rbuf0_lv, xl
01fcbc 31ae              cpi     xl, RX0_BUF_SIZE-2
01fcbd f409              brne    PC+2
01fcbe d004              rcall   RX0_OVF
01fcbf 30a4              cpi     xl, RX0_OFF_FILL
01fcc0 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
01fcc1 d022              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
01fcc2 cfae              rjmp    FF_ISR_EXIT
                 RX0_OVF:
01fcc3 e7fc              ldi     zh, '|'
01fcc4 c021              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
01fcc5 ceca      RX1_ISR: rjmp   RX1_ISRR
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
01fcc6 f634              fdw(LOAD_L)
                 TX0_L:
01fcc7 7483
01fcc8 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
01fcc9 3181              cpi     tosl, XON
01fcca f061              breq    XXON_TX0_TOS
01fccb 3183              cpi     tosl, XOFF
01fccc f091              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
01fccd d2cb              rcall   PAUSE
01fcce 9100 00c0         in_     t0, UCSR0A
01fcd0 ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
01fcd1 cffb              rjmp    TX0_LOOP
01fcd2 9380 00c6         out_    UDR0_, tosl
01fcd4 9189
01fcd5 9199              poptos
01fcd6 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
01fcd7 9189
01fcd8 9199              poptos
01fcd9 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
01fcda ff70              sbrs    FLAGS2, ixoff_tx0
01fcdb 9508              ret
                 XXON_TX0_1:
01fcdc 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
01fcdd e1f1              ldi     zh, XON
01fcde c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
01fcdf 9189
01fce0 9199              poptos
01fce1 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
01fce2 fd70              sbrc    FLAGS2, ixoff_tx0
01fce3 9508              ret     
                 XXOFF_TX0_1:
01fce4 6071              sbr     FLAGS2, (1<<ixoff_tx0)
01fce5 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
01fce6 91e0 00c0         in_     zl, UCSR0A
01fce8 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
01fce9 cffc              rjmp    TX0_SEND
01fcea 93f0 00c6         out_    UDR0_, zh
01fcec 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
01fced f98e              fdw(TX0_L)
                 RX0_L:
01fcee 7283
01fcef 3078              .db     NFA|3,"rx0"
                 RX0_:
01fcf0 d2a8              rcall   PAUSE
01fcf1 d01e              rcall   RX0Q
01fcf2 940f f35a         call    ZEROSENSE
01fcf4 f3d9              breq    RX0_
01fcf5 939a
01fcf6 938a              pushtos
01fcf7 e7e5              ldi     zl, low(rbuf0)
01fcf8 e0f3              ldi     zh, high(rbuf0)
01fcf9 91a0 0373         lds     xl, rbuf0_rd
01fcfb 0fea              add     zl, xl
01fcfc 1df5              adc     zh, zero
01fcfd 8180              ld      tosl, z
01fcfe 2799              clr     tosh
01fcff b70f              in_     t0, SREG
01fd00 94f8              cli
01fd01 95a3              inc     xl
01fd02 71af              andi    xl, (RX0_BUF_SIZE-1)
01fd03 93a0 0373         sts     rbuf0_rd, xl
01fd05 91a0 0374         lds     xl, rbuf0_lv
01fd07 95aa              dec     xl
01fd08 93a0 0374         sts     rbuf0_lv, xl
01fd0a bf0f              out_    SREG, t0
01fd0b 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
01fd0c f9dc              fdw     RX0_L
                 RX0Q_L:
01fd0d 7284
01fd0e 3078
01fd0f 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
01fd10 91a0 0374         lds     xl, rbuf0_lv
01fd12 11a5              cpse    xl, zero
01fd13 940d f6f0         jmp     TRUE_
                 .if U0FC_TYPE == 1
01fd15 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
01fd16 940d f6e7         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
01fd18 dbc8              rcall   DOTS
01fd19 940f f1eb         call    XSQUOTE
01fd1b 4103
01fd1c 3f44              .db     3,"AD?"
01fd1d 940f f1de         call    TYPE
01fd1f c9ff              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
                 	sub_pflash_tos
                 .ifdef  RAMPZ
01fd20 e003      	ldi     t0, RAMPZV
                 .endif
                 XUPDATEBUF:
01fd21 9380 03c4         sts     iaddrl, tosl
01fd23 9390 03c5         sts     iaddrh, tosh
                 .ifdef RAMPZ
01fd25 9300 03c6         sts     iaddru, t0
01fd27 3003      	cpi     t0, RAMPZV
01fd28 f411      	brne    XUPDATEBUF2
                 .endif
01fd29 3d9e              cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
01fd2a f768              brcc    ISTORERR
                 XUPDATEBUF2:	
01fd2b 9100 03c4 	lds     t0, iaddrl
01fd2d 7000              andi    t0, ~(PAGESIZEB-1)
01fd2e 110a              cpse    t0, ibasel
01fd2f c00b              rjmp    IFILL_BUFFER
01fd30 9100 03c5         lds     t0, iaddrh
01fd32 110b              cpse    t0, ibaseh
01fd33 c007              rjmp    IFILL_BUFFER
                 .ifdef RAMPZ
01fd34 9100 03c6         lds     t0, iaddru
01fd36 9110 03c7 	lds     t1, ibaseu
01fd38 1301              cpse    t0, t1
01fd39 c001              rjmp    IFILL_BUFFER
                 .endif
01fd3a 9508              ret
                 
                 IFILL_BUFFER:
01fd3b d05c              rcall   IFLUSH
01fd3c 9100 03c4         lds     t0, iaddrl
01fd3e 7000              andi    t0, ~(PAGESIZEB-1)
01fd3f 2ea0              mov     ibasel, t0
01fd40 90b0 03c5         lds     ibaseh, iaddrh
                 .ifdef RAMPZ
01fd42 9100 03c6 	lds     t0, iaddru
01fd44 9300 03c7 	sts     ibaseu, t0
01fd46 bf0b      	out_    RAMPZ, t0
                 .endif
                 IFILL_BUFFER_1:
01fd47 e000              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
01fd48 01f5              movw    zl, ibasel
01fd49 e0a0              ldi     xl, low(ibuf)
01fd4a e0b2              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
01fd4b 9117              lpm_    t1, z+
01fd4c 931d              st      x+, t1
01fd4d 950a              dec     t0
01fd4e f7e1              brne    IFILL_BUFFER_2
                 .ifdef RAMPZ
01fd4f e003              ldi     t0, RAMPZV
01fd50 bf0b              out_    RAMPZ, t0
                 .endif
01fd51 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
01fd52 d9f2              rcall   DOLIT
01fd53 0013              .dw     XOFF
01fd54 940f f00f         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fd56 d9ee              rcall   DOLIT
01fd57 000a              .dw     10
01fd58 db3a              rcall   MS
                         ; Disable interrupts
01fd59 94f8              cli
01fd5a 01f5              movw    zl, ibasel
                 .ifdef RAMPZ
01fd5b 9100 03c7 	lds     t0, ibaseu
01fd5d bf0b      	out_    RAMPZ, t0
                 .endif
01fd5e e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
01fd5f d02d              rcall   DO_SPM
01fd60 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
01fd61 d02b              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
01fd62 e000              ldi     t0, low(PAGESIZEB);init loop variable
01fd63 e0a0              ldi     xl, low(ibuf)
01fd64 e0b2              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
01fd65 900d              ld      r0, x+
01fd66 901d              ld      r1, x+
01fd67 e011              ldi     t1, (1<<SPMEN)
01fd68 d024              rcall   DO_SPM
01fd69 9632              adiw    zl, 2
01fd6a 5002              subi    t0, 2
01fd6b f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
01fd6c 50e0              subi    zl, low(PAGESIZEB) ;restore pointer
01fd6d 40f1              sbci    zh, high(PAGESIZEB)
01fd6e e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
01fd6f d01d              rcall   DO_SPM
                         ; re-enable the RWW section
01fd70 d016              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
01fd71 e000              ldi     t0, low(PAGESIZEB);init loop variable
01fd72 50a0              subi    xl, low(PAGESIZEB) ;restore pointer
01fd73 40b1              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
01fd74 9007              lpm_    r0, z+
01fd75 901d              ld      r1, x+
01fd76 1001              cpse    r0, r1
01fd77 c035              rjmp    WARM_     ; reset
01fd78 5001              subi    t0, 1
01fd79 f7d1              brne    IWRITE_BUFFER2
01fd7a ef0f      	ser     t0
01fd7b 2eb0      	mov     ibaseh, t0
                 .ifdef RAMPZ
01fd7c 9300 03c7 	sts     ibaseu, t0
                 .endif
                 .ifdef RAMPZ
01fd7e e003              ldi     t0, RAMPZV
01fd7f bf0b              out_    RAMPZ, t0
                 .endif
01fd80 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
01fd81 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
01fd82 d9c2              rcall   DOLIT
01fd83 0011              .dw     XON
01fd84 940f f00f         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fd86 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
01fd87 b687              in_     t8, SPMCSR
01fd88 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
01fd89 9508              ret
                         ; re-enable the RWW section
01fd8a e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
01fd8b d001              rcall   DO_SPM
01fd8c cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
01fd8d b687              in_     t8, SPMCSR
01fd8e fc80              sbrc    t8, SPMEN
01fd8f cffd              rjmp    DO_SPM       ; Wait for previous write to complete
01fd90 bf17              out_    SPMCSR, t1
01fd91 95e8              spm
01fd92 9508              ret
                 
01fd93 ff2c              fdw     PAUSE_L
                 IFLUSH_L:
01fd94 6986
01fd95 6c66
01fd96 7375
01fd97 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
01fd98 fd60              sbrc    FLAGS1, idirty
01fd99 cfb8              rjmp    IWRITE_BUFFER
01fd9a 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
01fd9b f70a              fdw     RX1Q_L
                 .else
                 .endif
                 EMPTY_L:
01fd9c 6585
01fd9d 706d
01fd9e 7974              .db     NFA|5,"empty"
                 EMPTY:
01fd9f d9a5              rcall   DOLIT
01fda0 fff0              fdw     COLDLIT
01fda1 d9a3              rcall   DOLIT
01fda2 2200              .dw     dp_start
01fda3 d9a1              rcall   DOLIT
01fda4 000c              .dw     coldlitsize
01fda5 940f f4d0         call    CMOVE
01fda7 940d f6c3         jmp     DP_TO_RAM
                         
                 ;*******************************************************
01fda9 fb38              fdw     EMPTY_L
                 WARM_L:
01fdaa 7784
01fdab 7261
01fdac 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
01fdad 94f8              cli           ; Disable interrupts
01fdae 27aa              clr     xl
01fdaf 27bb              clr     xh
01fdb0 e1c9              ldi     yl, 25
01fdb1 e0d0              ldi     yh, 0
                 WARM_1:
01fdb2 93dd              st      x+, yh
01fdb3 50c1              subi    yl, 1
01fdb4 f7e9              brne    WARM_1
                 
01fdb5 b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
01fdb6 b604              in_     t2, MCUSR
01fdb7 9250 0034         sts     MCUSR, zero
                 .endif
01fdb9 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
01fdba 925d              st      x+, zero
01fdbb 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
01fdbc f7e9              brne    WARM_2
                 
                 ; Init empty flash buffer
01fdbd 94ba      	dec     ibaseh
                 .ifdef RAMPZ
01fdbe 92b0 03c7 	sts     ibaseu, ibaseh
                 .endif
                 
                 ; Init constant registers
01fdc0 e0c1              ldi     yl, 1
01fdc1 2e6c              mov     r_one, yl
01fdc2 e0c2              ldi     yl, 2
01fdc3 2e7c              mov     r_two, yl
                 ; Init Stack pointer
01fdc4 e8ca              ldi     yl, low(utibbuf-4)
01fdc5 e0d4              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
01fdc6 e40d              ldi     t0, low(usbuf-1)
01fdc7 e014              ldi     t1, high(usbuf-1)
01fdc8 bf0d              out     spl, t0
01fdc9 bf1e              out     sph, t1
                 ; Init user pointer
01fdca ee0c              ldi     t0, low(up0)
01fdcb e013              ldi     t1, high(up0)
01fdcc 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
01fdcd e003              ldi     t0, RAMPZV
01fdce bf0b              out_    RAMPZ, t0
                 .endif
                 .ifdef EIND
01fdcf be6c              out_    EIND, r_one
                 .endif
                 ; init warm literals
01fdd0 d974              rcall   DOLIT
01fdd1 f660              fdw     WARMLIT
01fdd2 d972              rcall   DOLIT
01fdd3 03ce              .dw     cse
01fdd4 d970              rcall   DOLIT
01fdd5 001c              .dw     warmlitsize
01fdd6 940f f4d0         call    CMOVE
                 ; init cold data to eeprom
01fdd8 d96c              rcall   DOLIT
01fdd9 2200              .dw     dp_start
01fdda d10a              rcall   FETCH
01fddb d914              rcall   TRUE_
01fddc 940f f2e9         call    EQUAL
01fdde 940f f35a         call    ZEROSENSE
01fde0 f009              breq    WARM_3  
01fde1 dfbd              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
01fde2 be65              out_    MCUCR, r_one   ; (1<<IVCE)
01fde3 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
01fde4 bc74              out_    TCCR0A, r_two  ; CTC
01fde5 e003              ldi     t0, ms_pre_tmr0
01fde6 bd05              out_    TCCR0B, t0
01fde7 ef09              ldi     t0, ms_value_tmr0
01fde8 bd07              out_    OCR0A, t0
01fde9 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
01fdeb d959              rcall   DOLIT
01fdec fca7              .dw     RX0_ISR
01fded d957              rcall   DOLIT
                 .ifdef URXC0addr
01fdee 0332              .dw     URXC0addr+ivec
                 .else
                 .endif
01fdef d0aa              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, zero
01fdf0 e607              ldi     t0, ubrr0val
01fdf1 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
01fdf3 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
01fdf4 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
01fdf6 e006              ldi     t0, (3<<UCSZ00)|URSEL_
01fdf7 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
01fdf9 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
01fdfa d94a              rcall   DOLIT
01fdfb fcc5              .dw     RX1_ISR
01fdfc d948              rcall   DOLIT
01fdfd 0348              .dw     URXC1addr+ivec
01fdfe d09b              rcall   STORE
                         ; Set baud rate
                 ;        out_    UBRR1H, zero
01fdff e109              ldi     t0, ubrr1val
01fe00 9300 00cc         out_    UBRR1L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
01fe02 e908              ldi     t0, (1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1)
01fe03 9300 00c9         out_    UCSR1B,t0
                         ; Set frame format: 8data, 1stop bit
01fe05 e006              ldi     t0, (3<<UCSZ10)
01fe06 9300 00ca         out_    UCSR1C,t0
                 .if U1FC_TYPE == 1
01fe08 6072              sbr     FLAGS2, (1<<ixoff_tx1)
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fe09 d8b9              rcall   DP_TO_RAM
01fe0a 9478              sei
                 
01fe0b dd9f              rcall   RQ_EMIT
01fe0c d023              rcall   VER
                 ; Turnkey ?
01fe0d d184              rcall   TURNKEY
01fe0e 940f f35a         call    ZEROSENSE
01fe10 f0d1              breq    STARTQ2
01fe11 940f f1eb         call    XSQUOTE
01fe13 4503
01fe14 4353              .db     3,"ESC"
01fe15 940f f1de         call    TYPE
01fe17 d92d              rcall   DOLIT
01fe18 07d0              .dw     TURNKEY_DELAY
01fe19 da79              rcall   MS
01fe1a 940f f01c         call    KEYQ
01fe1c 940f f35a         call    ZEROSENSE
01fe1e f049              breq    STARTQ1
01fe1f 940f f015         call    KEY
01fe21 d923              rcall   DOLIT
01fe22 001b              .dw     0x1b
01fe23 940f f2e9         call    EQUAL
01fe25 940f f35a         call    ZEROSENSE
01fe27 f419              brne    STARTQ2
                 STARTQ1:
01fe28 d169              rcall   TURNKEY
01fe29 940f f024         call    EXECUTE
                 STARTQ2:
01fe2b 940d f71f         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
01fe2d fb54              fdw     WARM_L
                 VER_L:
01fe2e 7683
01fe2f 7265              .db     NFA|3,"ver"
                 VER:
01fe30 940f f1eb         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
01fe32 4624
01fe33 616c
01fe34 6873
01fe35 6f46
01fe36 7472
01fe37 2068
01fe38 2035
01fe39 5441
01fe3a 656d
01fe3b 6167
01fe3c 3532
01fe3d 3036
01fe3e 3020
01fe3f 2e32
01fe40 3730
01fe41 322e
01fe42 3130
01fe43 0d36
avr/src/ff-atmega.asm(5375): warning: .cseg .db misalignment - padding zero byte
01fe44 000a              .db     partlen+datelen+16,"FlashForth 5 ",partstring," ", DATE,0xd,0xa
01fe45 940d f1de         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
01fe47 fc5c              fdw     VER_L
                 EI_L:
01fe48 65a2
01fe49 0069              .db     NFA|INLINE|2,"ei",0
01fe4a 9478              sei
01fe4b 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
01fe4c fc90              fdw     EI_L
                 DI_L:
01fe4d 64a2
01fe4e 0069              .db     NFA|INLINE|2,"di",0
01fe4f 94f8              cli
01fe50 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
01fe51 fc9a              fdw     DI_L
                 IRQ_SEMI_L:
01fe52 3bc2
01fe53 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
01fe54 d8f0              rcall   DOLIT
                 .ifdef EIND
01fe55 940d              .dw     0x940D     ; jmp
                 .else
                 .endif
01fe56 d162              rcall   ICOMMA
01fe57 d8ed              rcall   DOLIT
01fe58 fc71              .dw     FF_ISR_EXIT
01fe59 d15f              rcall   ICOMMA
01fe5a 940d f804         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
01fe5c fca4              fdw     IRQ_SEMI_L
                 IRQ_V_L:
01fe5d 6984
01fe5e 746e
01fe5f 0021              .db     NFA|4,"int!",0
                 IRQ_V:
01fe60 01fc              movw    zl, tosl
01fe61 9731              sbiw    zl, 1
01fe62 0fee              lsl     zl
                 .if low(ivec) == 0x80
                 .endif
01fe63 e0f3              ldi     zh, high(ivec)
01fe64 9189
01fe65 9199              poptos
01fe66 dacf              rcall   TO_XA
01fe67 940d fe9f         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
01fe69 fcba              fdw     IRQ_V_L
                 LITERAL_L:
01fe6a 6cc7
01fe6b 7469
01fe6c 7265
01fe6d 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
01fe6e d8d6              rcall   DOLIT
01fe6f ee9e              fdw     DUP
01fe70 db58              rcall   INLINE0
01fe71 940f f74f         call    DUP
01fe73 2f98              mov     tosh, tosl
01fe74 9592              swap    tosh
01fe75 709f              andi    tosh, 0xf
01fe76 708f              andi    tosl, 0xf
01fe77 6e90              ori     tosh, 0xe0
01fe78 6880              ori     tosl, 0x80
01fe79 d13f              rcall   ICOMMA
01fe7a 2f89              mov     tosl, tosh
01fe7b 9592              swap    tosh
01fe7c 709f              andi    tosh, 0xf
01fe7d 708f              andi    tosl, 0xf
01fe7e 6e90              ori     tosh, 0xe0
01fe7f 6980              ori     tosl, 0x90
01fe80 940d ffb9         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
01fe82 d039              rcall   LOCKEDQ
01fe83 de9c              rcall   IUPDATEBUF
                 ISTORE1:
01fe84 9189
01fe85 9199              poptos
01fe86 e0a0              ldi     xl, low(ibuf)
01fe87 e0b2              ldi     xh, high(ibuf)
01fe88 9100 03c4         lds     t0, iaddrl
01fe8a 7f0f              andi    t0, (PAGESIZEB-1)
01fe8b 0fa0              add     xl, t0
01fe8c 938d              st      x+, tosl
01fe8d 939d              st      x+, tosh
01fe8e 9189
01fe8f 9199              poptos
01fe90 6061              sbr     FLAGS1, (1<<idirty)
01fe91 9508              ret
                 
01fe92 fcd4              fdw     LITERAL_L
                 TO_A_L:
01fe93 3e82
01fe94 0061              .db     NFA|2, ">a",0
01fe95 ece2              ldi     zl, low(areg)
01fe96 e0f3              ldi     zh, high(areg)
01fe97 c007              rjmp    STORE_RAM_2
                 
01fe98 fd26              fdw     TO_A_L
                 STORE_L:
01fe99 2181              .db     NFA|1, "!"
                 STORE:
01fe9a 3292              cpi     tosh, high(PEEPROM)
01fe9b f440              brcc    STORE1
                 STORE_RAM:
01fe9c 01fc              movw    zl, tosl
01fe9d 9189
01fe9e 9199              poptos
                 STORE_RAM_2:
01fe9f 8391              std     Z+1, tosh
01fea0 8380              std     Z+0, tosl
01fea1 9189
01fea2 9199              poptos
01fea3 9508              ret
                 STORE1:
01fea4 3392              cpi     tosh, high(OFLASH)
01fea5 f6e0              brcc    ISTORE
                 ESTORE:
01fea6 d015              rcall   LOCKEDQ
01fea7 99f9              sbic    eecr, eewe
01fea8 cffd              rjmp    ESTORE
01fea9 5292              subi    tosh, high(PEEPROM)
01feaa bd81              out     eearl, tosl
01feab bd92              out     eearh, tosh
01feac 9189
01fead 9199              poptos
01feae bd80              out     eedr, tosl
01feaf 9afa              sbi     eecr, eemwe
01feb0 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
01feb1 99f9              sbic    eecr, eewe
01feb2 cffe              rjmp    ESTORE1
                 
01feb3 b581              in      tosl, eearl
01feb4 9583              inc     tosl
01feb5 bd81              out     eearl, tosl
                 
01feb6 bd90              out     eedr, tosh
01feb7 9afa              sbi     eecr, eemwe
01feb8 9af9              sbi     eecr, eewe
                 
01feb9 9189
01feba 9199              poptos
01febb 9508              ret
                 LOCKEDQ:
01febc ff62              sbrs    FLAGS1, fLOCK
01febd 9508              ret
01febe da22              rcall   DOTS
01febf 940f f1eb         call    XSQUOTE
01fec1 4103
01fec2 3f44              .db     3,"AD?"
01fec3 940f f1de         call    TYPE
01fec5 cf65              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
01fec6 01fc              movw    z, tosl
                         sub_pflash_z
                 .ifdef RAMPZ
01fec7 9100 03c7 	lds     t0, ibaseu
01fec9 3003      	cpi     t0, RAMPZV
01feca f469      	brne    IIFETCH
                 .endif
01fecb 11fb              cpse    zh, ibaseh
01fecc c00b              rjmp    IIFETCH
01fecd 2f0e              mov     t0, zl
01fece 7000              andi    t0, ~(PAGESIZEB-1)
01fecf 150a              cp      t0, ibasel
01fed0 f439              brne    IIFETCH
01fed1 e0a0              ldi     xl, low(ibuf)
01fed2 e0b2              ldi     xh, high(ibuf)
01fed3 7fef              andi    zl, (PAGESIZEB-1)
01fed4 0fae              add     xl, zl
01fed5 918d              ld      tosl, x+
01fed6 919d              ld      tosh, x+
01fed7 9508              ret
                 IIFETCH:
01fed8 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01fed9 9197              lpm_    tosh, z+
01feda 9508              ret
                                 
01fedb fd32              fdw     STORE_L
                 A_FROM_L:
01fedc 6182
01fedd 003e              .db     NFA|2, "a>",0
01fede 939a
01fedf 938a              pushtos
01fee0 ece2              ldi     zl, low(areg)
01fee1 e0f3              ldi     zh, high(areg)
01fee2 c005              rjmp    FETCH_RAM_2
                 
                 .if FLASHEND > 0x3fff
01fee3 f5a6              fdw     XSTORE_L
                 .else
                 .endif
                 FETCH_L:
01fee4 4081              .db     NFA|1, "@"
                 FETCH:
01fee5 3292              cpi     tosh, high(PEEPROM)
01fee6 f420              brcc    FETCH1
                 FETCH_RAM:
01fee7 01fc              movw    zl, tosl
                 FETCH_RAM_2:
01fee8 9181              ld      tosl, z+
01fee9 9191              ld      tosh, z+
01feea 9508              ret
                 FETCH1:
01feeb 3392              cpi     tosh, high(OFLASH)
01feec f6c8              brcc    IFETCH
                 EFETCH:
01feed 99f9              sbic    eecr, eewe
01feee cffe              rjmp    EFETCH
01feef 5292              subi    tosh, high(PEEPROM)
01fef0 bd81              out     eearl, tosl
01fef1 bd92              out     eearh, tosh
01fef2 9af8              sbi     eecr, eere
01fef3 b580              in      tosl, eedr
01fef4 b591              in      tosh, eearl
01fef5 9593              inc     tosh
01fef6 bd91              out     eearl, tosh
01fef7 9af8              sbi     eecr, eere
01fef8 b590              in      tosh, eedr
01fef9 9508              ret
                 
                 ICFETCH:
01fefa 01fc              movw    z, tosl
                         sub_pflash_z
                 .ifdef RAMPZ
01fefb 9100 03c7 	lds     t0, ibaseu
01fefd 3003      	cpi     t0, RAMPZV
01fefe f469      	brne    IICFETCH
                 .endif
01feff 11fb              cpse    zh, ibaseh
01ff00 c00b              rjmp    IICFETCH
01ff01 2f0e              mov     t0, zl
01ff02 7000              andi    t0, ~(PAGESIZEB-1)
01ff03 150a              cp      t0, ibasel
01ff04 f439              brne    IICFETCH
01ff05 e0a0              ldi     xl, low(ibuf)
01ff06 e0b2              ldi     xh, high(ibuf)
01ff07 7fef              andi    zl, (PAGESIZEB-1)
01ff08 0fae              add     xl, zl
01ff09 918d              ld      tosl, x+
01ff0a 2799              clr     tosh
01ff0b 9508              ret
                 IICFETCH:
01ff0c 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01ff0d 2799              clr     tosh
01ff0e 9508              ret
                 
01ff0f fdc8              fdw     FETCH_L
                 CFETCH_L:
01ff10 6382
01ff11 0040              .db     NFA|2, "c@",0
                 CFETCH:
01ff12 3292              cpi     tosh, high(PEEPROM)
01ff13 f420              brcc    CFETCH1
                 CFETCH_RAM:
01ff14 01fc              movw    zl, tosl
01ff15 9181              ld      tosl, z+
01ff16 2799              clr     tosh
01ff17 9508              ret
                 CFETCH1:
01ff18 3392              cpi     tosh, high(OFLASH)
01ff19 f700              brcc    ICFETCH
                 ECFETCH:
01ff1a 99f9              sbic    eecr, eewe
01ff1b cffe              rjmp    ECFETCH
01ff1c 5292              subi    tosh, high(PEEPROM)
01ff1d bd81              out     eearl, tosl
01ff1e bd92              out     eearh, tosh
01ff1f 9af8              sbi     eecr, eere
01ff20 b580              in      tosl, eedr
01ff21 2799              clr     tosh
01ff22 9508              ret
                 
                 ICSTORE:
01ff23 df98              rcall   LOCKEDQ
01ff24 ddfb              rcall   IUPDATEBUF
01ff25 9189
01ff26 9199              poptos
01ff27 e0a0              ldi     xl, low(ibuf)
01ff28 e0b2              ldi     xh, high(ibuf)
01ff29 9100 03c4         lds     t0, iaddrl
01ff2b 7f0f              andi    t0, (PAGESIZEB-1)
01ff2c 0fa0              add     xl, t0
01ff2d 938d              st      x+, tosl
01ff2e 9189
01ff2f 9199              poptos
01ff30 6061              sbr     FLAGS1, (1<<idirty)
01ff31 9508              ret
                 
01ff32 fe20              fdw     CFETCH_L
                 CSTORE_L:
01ff33 6382
01ff34 0021              .db     NFA|2, "c!",0
                 CSTORE:
01ff35 3292              cpi     tosh, high(PEEPROM)
01ff36 f438              brcc    CSTORE1
                 CSTORE_RAM:
01ff37 01fc              movw zl, tosl
01ff38 9189
01ff39 9199              poptos
01ff3a 8380              std Z+0, tosl
01ff3b 9189
01ff3c 9199              poptos
01ff3d 9508              ret
                 CSTORE1:
01ff3e 3392              cpi     tosh, high(OFLASH)
01ff3f f718              brcc    ICSTORE
                 ECSTORE:
01ff40 df7b              rcall   LOCKEDQ
01ff41 99f9              sbic    eecr, eewe
01ff42 cffd              rjmp    ECSTORE
01ff43 5292              subi    tosh, high(PEEPROM)
01ff44 bd81              out     eearl, tosl
01ff45 bd92              out     eearh, tosh
01ff46 9189
01ff47 9199              poptos
01ff48 bd80              out     eedr, tosl
01ff49 9afa              sbi     eecr, eemwe
01ff4a 9af9              sbi     eecr, eewe
01ff4b 9189
01ff4c 9199              poptos
01ff4d 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
01ff4e fe66              fdw     CSTORE_L
                 
                 FLOCK_L:
01ff4f 6683
01ff50 2d6c              .db     NFA|3,"fl-"
01ff51 6064              sbr     FLAGS1, (1<<fLOCK)
01ff52 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
01ff53 fe9e              fdw     FLOCK_L
                 FUNLOCK_L:
01ff54 6683
01ff55 2b6c              .db     NFA|3,"fl+"
01ff56 7f6b              cbr     FLAGS1, (1<<fLOCK)
01ff57 9508              ret
                 
                 
                 
01ff58 fea8              fdw     FUNLOCK_L
                 VALUE_L:
01ff59 7685
01ff5a 6c61
01ff5b 6575              .db     NFA|5,"value"
                 VALUE:
01ff5c d83b              rcall   CREATE
01ff5d 940f f0df         call    COMMA
01ff5f d888              rcall   XDOES
                 VALUE_DOES:
01ff60 940f f06d         call    DODOES
01ff62 940d fee5         jmp     FETCH
                 
01ff64 feb2              fdw     VALUE_L
                 DEFER_L:
01ff65 6485
01ff66 6665
01ff67 7265              .db     NFA|5,"defer"
                 DEFER:
01ff68 d82f              rcall   CREATE
01ff69 940f f745         call    DOLIT
01ff6b ee3e              fdw     ABORT
01ff6c 940f f0df         call    COMMA
01ff6e d879              rcall   XDOES
                 DEFER_DOES:
01ff6f 940f f06d         call    DODOES
01ff71 940d f02e         jmp     FEXECUTE
                 
01ff73 feca              fdw     DEFER_L
                 IS_L:
01ff74 69c2
01ff75 0073              .db     NFA|IMMED|2,"is",0
                 IS:
01ff76 940f f762         call    TICK
01ff78 940f f2b4         call    TWOPLUS
01ff7a 940f f2b4         call    TWOPLUS
01ff7c df68              rcall   FETCH
01ff7d d8e8              rcall   STATE_
01ff7e 940f f35a         call    ZEROSENSE
01ff80 f029              breq    IS1
01ff81 deec              rcall   LITERAL
01ff82 940f f07f         call    DOCOMMAXT
01ff84 fd34              fdw     STORE
01ff85 c001              rjmp    IS2
                 IS1:
01ff86 df13              rcall   STORE
                 IS2:
01ff87 9508              ret
                 
01ff88 fee8              fdw     IS_L
                 TO_L:
01ff89 74c2
01ff8a 006f              .db     NFA|IMMED|2,"to",0
                 TO:
01ff8b 940d ff76         jmp     IS
                 
01ff8d ff12              fdw     TO_L
                 TURNKEY_L:
01ff8e 7487
01ff8f 7275
01ff90 6b6e
01ff91 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
01ff92 940f ff60         call    VALUE_DOES      ; Must be call for IS to work.
01ff94 03b8              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
01ff95 ff1c              fdw     TURNKEY_L
                 PAUSE_L:
01ff96 7085
01ff97 7561
01ff98 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
01ff99 dc2c              rcall   IDLE_LOAD
                 .endif
01ff9a b71f              in_     t1, SREG
01ff9b 94f8              cli
01ff9c 93df              push    yh        ; SP
01ff9d 93cf              push    yl
01ff9e 939f              push    tosh      ; TOS
01ff9f 938f              push    tosl
01ffa0 935f              push    ph        ; P
01ffa1 934f              push    pl
01ffa2 01f1              movw    zl, upl
01ffa3 b70e              in      t0, sph
01ffa4 9302              st      -z, t0
01ffa5 b70d              in      t0, spl
01ffa6 9302              st      -z, t0
01ffa7 91b2              ld      xh, -z     ; UP
01ffa8 91a2              ld      xl, -z
01ffa9 011d              movw    upl, xl
01ffaa 910e              ld      t0, -x
01ffab bf0e              out     sph, t0
01ffac 910e              ld      t0, -x
01ffad bf0d              out     spl, t0
01ffae 914f              pop     pl
01ffaf 915f              pop     ph
01ffb0 918f              pop     tosl
01ffb1 919f              pop     tosh
01ffb2 91cf              pop     yl
01ffb3 91df              pop     yh
01ffb4 bf1f              out_    SREG, t1
01ffb5 9508              ret
                 
                 
01ffb6 de7c              fdw     OPERATOR_L
                 ICOMMA_L:
01ffb7 6982
01ffb8 002c              .db     NFA|2, "i,",0
                 ICOMMA:
01ffb9 940f f77b         call    IHERE
01ffbb dede              rcall   STORE
01ffbc 940f f0f0         call    CELL
01ffbe 940d f922         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
01ffc0 ff6e              fdw     ICOMMA_L
                 ICCOMMA_L:
01ffc1 6983
01ffc2 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
01ffc3 940f f77b         call    IHERE
01ffc5 df6f              rcall   CSTORE
01ffc6 940f f197         call    ONE
01ffc8 940d f922         jmp     IALLOT
                 
                 L_DOTBASE:
01ffca 2081              .db      NFA|1," "
                 DOTBASE:
01ffcb 940f f475         call    BASE
01ffcd df17              rcall   FETCH
01ffce 3180              cpi     tosl, 0x10
01ffcf f411              brne    DOTBASE1
01ffd0 e284              ldi     tosl,'$'
01ffd1 c009              rjmp    DOTBASEEND
                 DOTBASE1:
01ffd2 308a              cpi     tosl, 0xa
01ffd3 f411              brne    DOTBASE2
01ffd4 e283              ldi     tosl, '#'
01ffd5 c005              rjmp    DOTBASEEND
                 DOTBASE2:
01ffd6 3082              cpi     tosl, 0x2
01ffd7 f411              brne    DOTBASE3
01ffd8 e285              ldi     tosl, '%'
01ffd9 c001              rjmp    DOTBASEEND
                 DOTBASE3:
01ffda e38f              ldi     tosl, '?'
                 DOTBASEEND:
01ffdb 9508              ret
                 
                 MEMQADDR_N:
01ffdc e164              fdw     ROM_N
01ffdd e172              fdw     EROM_N
01ffde e182              fdw     FRAM_N
                 ;*******************************************************
                 umstar0:
01ffdf 920f              push t2
01ffe0 921f              push t3
01ffe1 9109              ld  t0, Y+
01ffe2 9119              ld  t1, Y+
01ffe3 9f80              mul tosl,t0
01ffe4 01d0              movw t4, r0 ; r0=t2, r1=t3
01ffe5 27ee              clr t6
01ffe6 27ff              clr t7
01ffe7 9f90              mul tosh, t0
01ffe8 0db0              add t5, r0
01ffe9 1de1              adc t6, r1
01ffea 1df5              adc t7, zero
01ffeb 9f81              mul tosl, t1
01ffec 0db0              add t5, r0
01ffed 1de1              adc t6, r1
01ffee 1df5              adc t7, zero
01ffef 9f91              mul tosh, t1
01fff0 0de0              add t6, r0
01fff1 1df1              adc t7, r1
01fff2 93ba              st -Y, t5
01fff3 93aa              st -Y, t4
01fff4 01cf              movw tosl, t6
01fff5 901f              pop t3
01fff6 900f              pop t2
01fff7 9508              ret
                 
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
01fff8 0000      STARTV: .dw      0
01fff9 3200      DPC:    .dw      OFLASH
01fffa 220c      DPE:    .dw      ehere
01fffb 04ee      DPD:    .dw      dpdata
01fffc f5e4      LW:     fdw      lastword
01fffd ed52      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega2560 register use summary:
r0 :  16 r1 :  17 r2 :   5 r3 :   1 r4 :   3 r5 :  20 r6 :   8 r7 :   7 
r8 :   4 r9 :   4 r10:   6 r11:   7 r12:   3 r13:   3 r14:   3 r15:   2 
r16: 163 r17:  54 r18:   0 r19:   0 r20:  14 r21:   7 r22:  34 r23:  20 
r24: 234 r25: 186 r26:  82 r27:  49 r28:   9 r29:   5 r30:  77 r31:  66 
x  :  17 y  : 191 z  :  37 
Registers used: 33 out of 35 (94.3%)

ATmega2560 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  19 adiw  :  10 and   :   3 
andi  :  22 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  19 brcs  :   1 break :   0 breq  :  47 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   6 
brne  :  41 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   4 bst   :   0 call  :  94 cbi   :   3 cbr   :  21 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :  23 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   7 cp    :   4 cpc   :   2 
cpi   :  30 cpse  :   8 dec   :   5 eicall:   0 eijmp :  14 elpm  :   9 
eor   :   2 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :  20 inc   :   9 jmp   : 165 ld    : 136 ldd   :   2 ldi   :  81 
lds   :  36 lpm   :   0 lsl   :  11 lsr   :   2 mov   :  16 movw  :  39 
mul   :   4 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :   6 
ori   :   7 out   :  41 pop   : 101 push  :  29 rcall :1021 ret   : 134 
reti  :   1 rjmp  : 101 rol   :  14 ror   :  18 sbc   :   8 sbci  :   3 
sbi   :  11 sbic  :   5 sbis  :   0 sbiw  :   9 sbr   :  19 sbrc  :  13 
sbrs  :  20 sec   :   0 seh   :   0 sei   :   3 sen   :   0 ser   :   7 
ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   1 spm   :   2 
st    :  86 std   :   3 sts   :  39 sub   :   2 subi  :  12 swap  :   2 
tst   :   3 wdr   :   0 
Instructions used: 71 out of 116 (61.2%)

ATmega2560 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x03de00 0x03fffc   6004   2536   8540  262144   3.3%
[.dseg] 0x000200 0x0004f0      0    752    752    8192   9.2%
[.eseg] 0x000000 0x000002      0      2      2    4096   0.0%

Assembly complete, 0 errors, 8 warnings
