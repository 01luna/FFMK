
AVRASM ver. 2.1.30  F:\avr\src\ff-atmega.asm Mon Nov 10 19:30:09 2014

F:\avr\src\ff-atmega.asm(34): Including file 'F:\avr\src\config.inc'
F:\avr\src\config.inc(5): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m2560def.inc'
F:\avr\src\ff-atmega.asm(72): warning: Register r26 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(73): warning: Register r27 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(74): warning: Register r30 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(75): warning: Register r31 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(238): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
F:\avr\src\ff-atmega.asm(239): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
F:\avr\src\ff-atmega.asm(240): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          10.11.2014                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2013  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 .include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega2560.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m2560def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega2560
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega2560
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M2560DEF_INC_
                 #define _M2560DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega2560
                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x98
                 .equ	SIGNATURE_002	= 0x01
                 
                 #pragma AVRPART CORE CORE_VERSION V3
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                 .equ	PINL	= 0x109	; MEMORY MAPPED
                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                 .equ	PINK	= 0x106	; MEMORY MAPPED
                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                 .equ	PINH	= 0x100	; MEMORY MAPPED
                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	EIND	= 0x3c
                 .equ	RAMPZ	= 0x3b
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	OCDR	= 0x31
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR5	= 0x1a
                 .equ	TIFR4	= 0x19
                 .equ	TIFR3	= 0x18
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTG	= 0x14
                 .equ	DDRG	= 0x13
                 .equ	PING	= 0x12
                 .equ	PORTF	= 0x11
                 .equ	DDRF	= 0x10
                 .equ	PINF	= 0x0f
                 .equ	PORTE	= 0x0e
                 .equ	DDRE	= 0x0d
                 .equ	PINE	= 0x0c
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 .equ	PORTA	= 0x02
                 .equ	DDRA	= 0x01
                 .equ	PINA	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** PORTE ************************
                 ; PORTE - Data Register, Port E
                 .equ	PORTE0	= 0	; 
                 .equ	PE0	= 0	; For compatibility
                 .equ	PORTE1	= 1	; 
                 .equ	PE1	= 1	; For compatibility
                 .equ	PORTE2	= 2	; 
                 .equ	PE2	= 2	; For compatibility
                 .equ	PORTE3	= 3	; 
                 .equ	PE3	= 3	; For compatibility
                 .equ	PORTE4	= 4	; 
                 .equ	PE4	= 4	; For compatibility
                 .equ	PORTE5	= 5	; 
                 .equ	PE5	= 5	; For compatibility
                 .equ	PORTE6	= 6	; 
                 .equ	PE6	= 6	; For compatibility
                 .equ	PORTE7	= 7	; 
                 .equ	PE7	= 7	; For compatibility
                 
                 ; DDRE - Data Direction Register, Port E
                 .equ	DDE0	= 0	; 
                 .equ	DDE1	= 1	; 
                 .equ	DDE2	= 2	; 
                 .equ	DDE3	= 3	; 
                 .equ	DDE4	= 4	; 
                 .equ	DDE5	= 5	; 
                 .equ	DDE6	= 6	; 
                 .equ	DDE7	= 7	; 
                 
                 ; PINE - Input Pins, Port E
                 .equ	PINE0	= 0	; 
                 .equ	PINE1	= 1	; 
                 .equ	PINE2	= 2	; 
                 .equ	PINE3	= 3	; 
                 .equ	PINE4	= 4	; 
                 .equ	PINE5	= 5	; 
                 .equ	PINE6	= 6	; 
                 .equ	PINE7	= 7	; 
                 
                 
                 ; ***** PORTF ************************
                 ; PORTF - Data Register, Port F
                 .equ	PORTF0	= 0	; 
                 .equ	PF0	= 0	; For compatibility
                 .equ	PORTF1	= 1	; 
                 .equ	PF1	= 1	; For compatibility
                 .equ	PORTF2	= 2	; 
                 .equ	PF2	= 2	; For compatibility
                 .equ	PORTF3	= 3	; 
                 .equ	PF3	= 3	; For compatibility
                 .equ	PORTF4	= 4	; 
                 .equ	PF4	= 4	; For compatibility
                 .equ	PORTF5	= 5	; 
                 .equ	PF5	= 5	; For compatibility
                 .equ	PORTF6	= 6	; 
                 .equ	PF6	= 6	; For compatibility
                 .equ	PORTF7	= 7	; 
                 .equ	PF7	= 7	; For compatibility
                 
                 ; DDRF - Data Direction Register, Port F
                 .equ	DDF0	= 0	; 
                 .equ	DDF1	= 1	; 
                 .equ	DDF2	= 2	; 
                 .equ	DDF3	= 3	; 
                 .equ	DDF4	= 4	; 
                 .equ	DDF5	= 5	; 
                 .equ	DDF6	= 6	; 
                 .equ	DDF7	= 7	; 
                 
                 ; PINF - Input Pins, Port F
                 .equ	PINF0	= 0	; 
                 .equ	PINF1	= 1	; 
                 .equ	PINF2	= 2	; 
                 .equ	PINF3	= 3	; 
                 .equ	PINF4	= 4	; 
                 .equ	PINF5	= 5	; 
                 .equ	PINF6	= 6	; 
                 .equ	PINF7	= 7	; 
                 
                 
                 ; ***** PORTG ************************
                 ; PORTG - Data Register, Port G
                 .equ	PORTG0	= 0	; 
                 .equ	PG0	= 0	; For compatibility
                 .equ	PORTG1	= 1	; 
                 .equ	PG1	= 1	; For compatibility
                 .equ	PORTG2	= 2	; 
                 .equ	PG2	= 2	; For compatibility
                 .equ	PORTG3	= 3	; 
                 .equ	PG3	= 3	; For compatibility
                 .equ	PORTG4	= 4	; 
                 .equ	PG4	= 4	; For compatibility
                 .equ	PORTG5	= 5	; 
                 .equ	PG5	= 5	; For compatibility
                 
                 ; DDRG - Data Direction Register, Port G
                 .equ	DDG0	= 0	; 
                 .equ	DDG1	= 1	; 
                 .equ	DDG2	= 2	; 
                 .equ	DDG3	= 3	; 
                 .equ	DDG4	= 4	; 
                 .equ	DDG5	= 5	; 
                 
                 ; PING - Input Pins, Port G
                 .equ	PING0	= 0	; 
                 .equ	PING1	= 1	; 
                 .equ	PING2	= 2	; 
                 .equ	PING3	= 3	; 
                 .equ	PING4	= 4	; 
                 .equ	PING5	= 5	; 
                 
                 
                 ; ***** PORTH ************************
                 ; PORTH - PORT H Data Register
                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                 .equ	PH0	= 0	; For compatibility
                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                 .equ	PH1	= 1	; For compatibility
                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                 .equ	PH2	= 2	; For compatibility
                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                 .equ	PH3	= 3	; For compatibility
                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                 .equ	PH4	= 4	; For compatibility
                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                 .equ	PH5	= 5	; For compatibility
                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                 .equ	PH6	= 6	; For compatibility
                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                 .equ	PH7	= 7	; For compatibility
                 
                 ; DDRH - PORT H Data Direction Register
                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                 
                 ; PINH - PORT H Input Pins
                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                 
                 
                 ; ***** PORTJ ************************
                 ; PORTJ - PORT J Data Register
                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                 .equ	PJ0	= 0	; For compatibility
                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                 .equ	PJ1	= 1	; For compatibility
                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                 .equ	PJ2	= 2	; For compatibility
                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                 .equ	PJ3	= 3	; For compatibility
                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                 .equ	PJ4	= 4	; For compatibility
                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                 .equ	PJ5	= 5	; For compatibility
                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                 .equ	PJ6	= 6	; For compatibility
                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                 .equ	PJ7	= 7	; For compatibility
                 
                 ; DDRJ - PORT J Data Direction Register
                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                 
                 ; PINJ - PORT J Input Pins
                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                 
                 
                 ; ***** PORTK ************************
                 ; PORTK - PORT K Data Register
                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                 .equ	PK0	= 0	; For compatibility
                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                 .equ	PK1	= 1	; For compatibility
                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                 .equ	PK2	= 2	; For compatibility
                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                 .equ	PK3	= 3	; For compatibility
                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                 .equ	PK4	= 4	; For compatibility
                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                 .equ	PK5	= 5	; For compatibility
                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                 .equ	PK6	= 6	; For compatibility
                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                 .equ	PK7	= 7	; For compatibility
                 
                 ; DDRK - PORT K Data Direction Register
                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                 
                 ; PINK - PORT K Input Pins
                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                 
                 
                 ; ***** PORTL ************************
                 ; PORTL - PORT L Data Register
                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                 .equ	PL0	= 0	; For compatibility
                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                 .equ	PL1	= 1	; For compatibility
                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                 .equ	PL2	= 2	; For compatibility
                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                 .equ	PL3	= 3	; For compatibility
                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                 .equ	PL4	= 4	; For compatibility
                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                 .equ	PL5	= 5	; For compatibility
                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                 .equ	PL6	= 6	; For compatibility
                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                 .equ	PL7	= 7	; For compatibility
                 
                 ; DDRL - PORT L Data Direction Register
                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                 
                 ; PINL - PORT L Input Pins
                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** USART1 ***********************
                 ; UDR1 - USART I/O Data Register
                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR1A - USART Control and Status Register A
                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                 .equ	U2X1	= 1	; Double the USART transmission speed
                 .equ	UPE1	= 2	; Parity Error
                 .equ	DOR1	= 3	; Data overRun
                 .equ	FE1	= 4	; Framing Error
                 .equ	UDRE1	= 5	; USART Data Register Empty
                 .equ	TXC1	= 6	; USART Transmitt Complete
                 .equ	RXC1	= 7	; USART Receive Complete
                 
                 ; UCSR1B - USART Control and Status Register B
                 .equ	TXB81	= 0	; Transmit Data Bit 8
                 .equ	RXB81	= 1	; Receive Data Bit 8
                 .equ	UCSZ12	= 2	; Character Size
                 .equ	TXEN1	= 3	; Transmitter Enable
                 .equ	RXEN1	= 4	; Receiver Enable
                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR1C - USART Control and Status Register C
                 .equ	UCPOL1	= 0	; Clock Polarity
                 .equ	UCSZ10	= 1	; Character Size
                 .equ	UCPHA1	= UCSZ10	; For compatibility
                 .equ	UCSZ11	= 2	; Character Size
                 .equ	UDORD1	= UCSZ11	; For compatibility
                 .equ	USBS1	= 3	; Stop Bit Select
                 .equ	UPM10	= 4	; Parity Mode Bit 0
                 .equ	UPM11	= 5	; Parity Mode Bit 1
                 .equ	UMSEL10	= 6	; USART Mode Select
                 .equ	UMSEL11	= 7	; USART Mode Select
                 
                 ; UBRR1H - USART Baud Rate Register High Byte
                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR1L - USART Baud Rate Register Low Byte
                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARH - EEPROM Address Register Low Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                 
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_5 **************
                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                 
                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                 .equ	ICF5	= 5	; Input Capture Flag 5
                 
                 ; TCCR5A - Timer/Counter5 Control Register A
                 .equ	WGM50	= 0	; Waveform Generation Mode
                 .equ	WGM51	= 1	; Waveform Generation Mode
                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR5B - Timer/Counter5 Control Register B
                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                 .equ	WGM52	= 3	; Waveform Generation Mode
                 .equ	WGM53	= 4	; Waveform Generation Mode
                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                 
                 ; TCCR5C - Timer/Counter 5 Control Register C
                 .equ	FOC5C	= 5	; Force Output Compare 5C
                 .equ	FOC5B	= 6	; Force Output Compare 5B
                 .equ	FOC5A	= 7	; Force Output Compare 5A
                 
                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                 
                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                 
                 
                 ; ***** TIMER_COUNTER_4 **************
                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                 
                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                 .equ	ICF4	= 5	; Input Capture Flag 4
                 
                 ; TCCR4A - Timer/Counter4 Control Register A
                 .equ	WGM40	= 0	; Waveform Generation Mode
                 .equ	WGM41	= 1	; Waveform Generation Mode
                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR4B - Timer/Counter4 Control Register B
                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                 .equ	WGM42	= 3	; Waveform Generation Mode
                 .equ	WGM43	= 4	; Waveform Generation Mode
                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                 
                 ; TCCR4C - Timer/Counter 4 Control Register C
                 .equ	FOC4C	= 5	; Force Output Compare 4C
                 .equ	FOC4B	= 6	; Force Output Compare 4B
                 .equ	FOC4A	= 7	; Force Output Compare 4A
                 
                 
                 ; ***** TIMER_COUNTER_3 **************
                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                 
                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                 .equ	ICF3	= 5	; Input Capture Flag 3
                 
                 ; TCCR3A - Timer/Counter3 Control Register A
                 .equ	WGM30	= 0	; Waveform Generation Mode
                 .equ	WGM31	= 1	; Waveform Generation Mode
                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR3B - Timer/Counter3 Control Register B
                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                 .equ	WGM32	= 3	; Waveform Generation Mode
                 .equ	WGM33	= 4	; Waveform Generation Mode
                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                 
                 ; TCCR3C - Timer/Counter 3 Control Register C
                 .equ	FOC3C	= 5	; Force Output Compare 3C
                 .equ	FOC3B	= 6	; Force Output Compare 3B
                 .equ	FOC3A	= 7	; Force Output Compare 3A
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter 1 Control Register C
                 .equ	FOC1C	= 5	; Force Output Compare 1C
                 .equ	FOC1B	= 6	; Force Output Compare 1B
                 .equ	FOC1A	= 7	; Force Output Compare 1A
                 
                 
                 ; ***** JTAG *************************
                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                 .equ	IDRD	= OCDR7	; For compatibility
                 
                 ; MCUCR - MCU Control Register
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                 
                 ; EICRB - External Interrupt Control Register B
                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 .equ	INTF2	= 2	; External Interrupt Flag 2
                 .equ	INTF3	= 3	; External Interrupt Flag 3
                 .equ	INTF4	= 4	; External Interrupt Flag 4
                 .equ	INTF5	= 5	; External Interrupt Flag 5
                 .equ	INTF6	= 6	; External Interrupt Flag 6
                 .equ	INTF7	= 7	; External Interrupt Flag 7
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	PUD	= 4	; Pull-up disable
                 ;.equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                 
                 ; XMCRA - External Memory Control Register A
                 .equ	SRW00	= 0	; Wait state select bit lower page
                 .equ	SRW01	= 1	; Wait state select bit lower page
                 .equ	SRW10	= 2	; Wait state select bit upper page
                 .equ	SRW11	= 3	; Wait state select bit upper page
                 .equ	SRL0	= 4	; Wait state page limit
                 .equ	SRL1	= 5	; Wait state page limit
                 .equ	SRL2	= 6	; Wait state page limit
                 .equ	SRE	= 7	; External SRAM Enable
                 
                 ; XMCRB - External Memory Control Register B
                 .equ	XMM0	= 0	; External Memory High Mask
                 .equ	XMM1	= 1	; External Memory High Mask
                 .equ	XMM2	= 2	; External Memory High Mask
                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - 
                 .equ	CLKPS0	= 0	; 
                 .equ	CLKPS1	= 1	; 
                 .equ	CLKPS2	= 2	; 
                 .equ	CLKPS3	= 3	; 
                 .equ	CLKPCE	= 7	; 
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                 
                 ; RAMPZ - RAM Page Z Select Register
                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                 
                 ; EIND - Extended Indirect Register
                 .equ	EIND0	= 0	; Bit 0
                 
                 ; GPIOR2 - General Purpose IO Register 2
                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                 
                 ; GPIOR1 - General Purpose IO Register 1
                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                 
                 ; GPIOR0 - General Purpose IO Register 0
                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                 
                 ; PRR1 - Power Reduction Register1
                 .equ	PRUSART1	= 0	; Power Reduction USART1
                 .equ	PRUSART2	= 1	; Power Reduction USART2
                 .equ	PRUSART3	= 2	; Power Reduction USART3
                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                 
                 ; PRR0 - Power Reduction Register0
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                 ;.equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 .equ	ADC6D	= 6	; 
                 .equ	ADC7D	= 7	; 
                 
                 ; DIDR2 - Digital Input Disable Register
                 .equ	ADC8D	= 0	; 
                 .equ	ADC9D	= 1	; 
                 .equ	ADC10D	= 2	; 
                 .equ	ADC11D	= 3	; 
                 .equ	ADC12D	= 4	; 
                 .equ	ADC13D	= 5	; 
                 .equ	ADC14D	= 6	; 
                 .equ	ADC15D	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write section read enable
                 .equ	SIGRD	= 5	; Signature Row Read
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** USART2 ***********************
                 ; UDR2 - USART I/O Data Register
                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR2A - USART Control and Status Register A
                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                 .equ	U2X2	= 1	; Double the USART transmission speed
                 .equ	UPE2	= 2	; Parity Error
                 .equ	DOR2	= 3	; Data overRun
                 .equ	FE2	= 4	; Framing Error
                 .equ	UDRE2	= 5	; USART Data Register Empty
                 .equ	TXC2	= 6	; USART Transmitt Complete
                 .equ	RXC2	= 7	; USART Receive Complete
                 
                 ; UCSR2B - USART Control and Status Register B
                 .equ	TXB82	= 0	; Transmit Data Bit 8
                 .equ	RXB82	= 1	; Receive Data Bit 8
                 .equ	UCSZ22	= 2	; Character Size
                 .equ	TXEN2	= 3	; Transmitter Enable
                 .equ	RXEN2	= 4	; Receiver Enable
                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR2C - USART Control and Status Register C
                 .equ	UCPOL2	= 0	; Clock Polarity
                 .equ	UCSZ20	= 1	; Character Size
                 .equ	UCSZ21	= 2	; Character Size
                 .equ	USBS2	= 3	; Stop Bit Select
                 .equ	UPM20	= 4	; Parity Mode Bit 0
                 .equ	UPM21	= 5	; Parity Mode Bit 1
                 .equ	UMSEL20	= 6	; USART Mode Select
                 .equ	UMSEL21	= 7	; USART Mode Select
                 
                 ; UBRR2H - USART Baud Rate Register High Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR2L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** USART3 ***********************
                 ; UDR3 - USART I/O Data Register
                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR3A - USART Control and Status Register A
                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                 .equ	U2X3	= 1	; Double the USART transmission speed
                 .equ	UPE3	= 2	; Parity Error
                 .equ	DOR3	= 3	; Data overRun
                 .equ	FE3	= 4	; Framing Error
                 .equ	UDRE3	= 5	; USART Data Register Empty
                 .equ	TXC3	= 6	; USART Transmitt Complete
                 .equ	RXC3	= 7	; USART Receive Complete
                 
                 ; UCSR3B - USART Control and Status Register B
                 .equ	TXB83	= 0	; Transmit Data Bit 8
                 .equ	RXB83	= 1	; Receive Data Bit 8
                 .equ	UCSZ32	= 2	; Character Size
                 .equ	TXEN3	= 3	; Transmitter Enable
                 .equ	RXEN3	= 4	; Receiver Enable
                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR3C - USART Control and Status Register C
                 .equ	UCPOL3	= 0	; Clock Polarity
                 .equ	UCSZ30	= 1	; Character Size
                 .equ	UCSZ31	= 2	; Character Size
                 .equ	USBS3	= 3	; Stop Bit Select
                 .equ	UPM30	= 4	; Parity Mode Bit 0
                 .equ	UPM31	= 5	; Parity Mode Bit 1
                 .equ	UMSEL30	= 6	; USART Mode Select
                 .equ	UMSEL31	= 7	; USART Mode Select
                 
                 ; UBRR3H - USART Baud Rate Register High Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR3L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog timer always on
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                 .equ	IOEND	= 0x01ff
                 .equ	SRAM_START	= 0x0200
                 .equ	SRAM_SIZE	= 8192
                 .equ	RAMEND	= 0x21ff
                 .equ	XRAMEND	= 0xffff
                 .equ	E2END	= 0x0fff
                 .equ	EEPROMEND	= 0x0fff
                 .equ	EEADRBITS	= 12
                 #pragma AVRPART MEMORY PROG_FLASH 262144
                 #pragma AVRPART MEMORY EEPROM 4096
                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x1f000
                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x1efff
                 .equ	PAGESIZE	= 128
                 .equ	FIRSTBOOTSTART	= 0x1fe00
                 .equ	SECONDBOOTSTART	= 0x1fc00
                 .equ	THIRDBOOTSTART	= 0x1f800
                 .equ	FOURTHBOOTSTART	= 0x1f000
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                 
                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                 
                 #endif  /* _M2560DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 ;.include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturbs the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program.
                 .equ BAUDRATE0 = 38400              ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 1
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 7            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 84                   ; 74 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 
                 
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def iaddrl=r12       ; Not in interrupt
                   .def iaddrh=r13       ; Not in interrupt
                   .def ms_count  = r14       ; Not in interrupt
                   .def ms_count1 = r15       ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def il = r18         ; FOR..LOOP INDEX variable
                   .def ih = r19
                   .def pl = r20         ; P Register
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*256/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fBUSY=     7   ; 1 = busy
                 .equ fIDLE=     6   ; 1 = busy
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)              ; 128 Kwords flash
                 .equ OFLASH  = PEEPROM+EEPROMEND+1    ; 56 Kbytes available for FlashForth(atm2560)
                 .equ PFLASH  = 0
                 .equ RAMPZV  = 3
                 .equ KERNEL_SIZE=0x0d00
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                 	
                 ;;; USER AREA for the OPERATOR task
                 ;.equ uaddsize=     0          ; No additional user variables 
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000200           ibuf:         .byte PAGESIZEB
000300           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
000372           rbuf0_wr:    .byte 1
000373           rbuf0_rd:    .byte 1
000374           rbuf0_lv:    .byte 1
000375           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 rxqueue1:
000395           rbuf1_wr:    .byte 1
000396           rbuf1_rd:    .byte 1
000397           rbuf1_lv:    .byte 1
000398           rbuf1:       .byte RX1_BUF_SIZE
                 .endif
                 
0003b8           dpSTART:    .byte 2
0003ba           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0003bc           dpEEPROM:   .byte 2
0003be           dpRAM:      .byte 2
0003c0           dpLATEST:   .byte 2
                 
0003c2           areg:       .byte 2 ; A register data
0003c4           load_acc:   .byte 3 ; Load measurement accumulator
0003c7           load:       .byte 1 ; Cpu load in percent
0003c8           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0003c9           state:      .byte 1 ; Compilation state
0003ca           uvars:      .byte   (-us0)
0003e6           up0:        .byte   2
0003e8           urbuf:      .byte   ursize
000448           usbuf:      .byte   ussize
000488           utibbuf:    .byte   utibsize
0004dc           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
01ef00 94e8              clt
01ef01 2388              tst  tosl
01ef02 f429              brne umslashmodstart
01ef03 2399              tst  tosh
01ef04 f419              brne umslashmodstart
01ef05 9468              set  ; Set T flag
01ef06 940d fd9d         jmp  WARM_
                 umslashmodstart:
01ef08 01dc              movw t4, tosl
                 
01ef09 9019              ld t3, Y+
01ef0a 91e9              ld t6, Y+
                   
01ef0b 9189              ld tosl, Y+
01ef0c 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
01ef0d e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
01ef0e 27ff              clr t7
01ef0f 0f88              lsl tosl
01ef10 1f99              rol tosh
01ef11 1c11              rol t3
01ef12 1fee              rol t6
01ef13 1fff              rol t7
                 
                         ; try subtracting divisor
01ef14 161a              cp  t3, t4
01ef15 07eb              cpc t6, t5
01ef16 05f5              cpc t7,zero
                 
01ef17 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
01ef18 9583              inc tosl
01ef19 1a1a              sub t3, t4
01ef1a 0beb              sbc t6, t5
                 
                 umslashmod2:
01ef1b 950a              dec  t0
01ef1c f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
01ef1d 93ea              st -Y,t6
01ef1e 921a              st -Y,t3
                 
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
01ef1f 9508              ret
                 ; *******************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
01ef20 0000              .dw     0
                 EXIT_L:
01ef21 6584
01ef22 6978
01ef23 0074              .db     NFA|4,"exit",0
                 EXIT:
01ef24 910f              m_pop_t0
01ef25 910f              pop     t0
01ef26 910f              pop     t0
01ef27 9508              ret
                 
                 ; idle
01ef28 de42              fdw(EXIT_L)
                 IDLE_L:
01ef29 6984
01ef2a 6c64
01ef2b 0065              .db     NFA|4,"idle",0
                 IDLE:
01ef2c 7b7f              cbr     FLAGS2, (1<<fIDLE)
01ef2d 9508              ret
                         
                 ; busy
01ef2e de52              fdw(IDLE_L)
                 BUSY_L:
01ef2f 6284
01ef30 7375
01ef31 0079              .db     NFA|4,"busy",0
                 BUSY:
01ef32 6470              sbr     FLAGS2, (1<<fIDLE)
01ef33 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
01ef34 ff4a              fdw     ICCOMMA_L
                 MSET_L:
01ef35 6d84
01ef36 6573
01ef37 0074              .db     NFA|4,"mset",0
                 MSET:
01ef38 01fc              movw    zl, tosl
01ef39 9189
01ef3a 9199              poptos
01ef3b 8100              ld      t0, z
01ef3c 2b08              or      t0, tosl
01ef3d 8300              st      z, t0
01ef3e 9189
01ef3f 9199              poptos
01ef40 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
01ef41 de6a              fdw     MSET_L
                 MCLR_L:
01ef42 6d84
01ef43 6c63
01ef44 0072              .db     NFA|4,"mclr",0
                 MCLR_:
01ef45 01fc              movw    zl, tosl
01ef46 9189
01ef47 9199              poptos
01ef48 8100              ld      t0, z
01ef49 9580              com     tosl
01ef4a 2308              and     t0, tosl
01ef4b 8300              st      z, t0
01ef4c 9189
01ef4d 9199              poptos
01ef4e 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
01ef4f de84              fdw     MCLR_L
                 LSHIFT_L:
01ef50 6c86
01ef51 6873
01ef52 6669
01ef53 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
01ef54 01fc              movw    zl, tosl
01ef55 9189
01ef56 9199              poptos
                 LSHIFT1:
01ef57 9731              sbiw    zl, 1
01ef58 f01a              brmi    LSHIFT2
01ef59 0f88              lsl     tosl
01ef5a 1f99              rol     tosh
01ef5b cffb              rjmp    LSHIFT1
                 LSHIFT2:
01ef5c 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
01ef5d dea0              fdw     LSHIFT_L
                 RSHIFT_L:
01ef5e 7286
01ef5f 6873
01ef60 6669
01ef61 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
01ef62 01fc              movw    zl, tosl
01ef63 9189
01ef64 9199              poptos
                 RSHIFT1:
01ef65 9731              sbiw    zl, 1
01ef66 f01a              brmi    RSHIFT2
01ef67 9596              lsr     tosh
01ef68 9587              ror     tosl
01ef69 cffb              rjmp    RSHIFT1
                 RSHIFT2:
01ef6a 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
01ef6b d551              rcall   CFETCHPP
01ef6c d29d              rcall   ROT
01ef6d d54f              rcall   CFETCHPP
01ef6e 940d f20a         jmp     ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
01ef70 debc              fdw     RSHIFT_L
                 NEQUAL_L:
01ef71 6e82
01ef72 003d              .db     NFA|2,"n=",0
                 NEQUAL:
01ef73 dff7              rcall   NEQUALSFETCH
01ef74 708f              andi    tosl, 0xf
01ef75 d33f              rcall   EQUAL
01ef76 d3b0              rcall   ZEROSENSE
01ef77 f0b1              breq    NEQUAL5
01ef78 d303              rcall   ONEMINUS
01ef79 d543              rcall   CFETCHPP
01ef7a d296              rcall   TOR
01ef7b c00c              rjmp    NEQUAL4
                 NEQUAL2:
01ef7c dfee              rcall   NEQUALSFETCH
01ef7d d330              rcall   NOTEQUAL
01ef7e d3a8              rcall   ZEROSENSE
01ef7f f021              breq    NEQUAL3
01ef80 d741              rcall   TRUE_
01ef81 940f f9d6         call    LEAVE
01ef83 c004              rjmp    NEQUAL4
                 NEQUAL3:
01ef84 d2a2              rcall   RFETCH
01ef85 d3a1              rcall   ZEROSENSE
01ef86 f409              brne    NEQUAL4
01ef87 d731              rcall   FALSE_
                 NEQUAL4:
01ef88 940f f9c5         call    XNEXT
01ef8a f788              brcc    NEQUAL2
01ef8b 911f              pop     t1
01ef8c 910f              pop     t0
01ef8d c001              rjmp    NEQUAL6
                 NEQUAL5:
01ef8e d733              rcall   TRUE_
                 NEQUAL6:
01ef8f d3d8              rcall   NIP
01ef90 940d f368         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
01ef92 dee2              fdw     NEQUAL_L
                 SKIP_L:
01ef93 7384
01ef94 696b
01ef95 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
01ef96 d27a              rcall   TOR
                 SKIP1:
01ef97 d789              rcall   DUP
01ef98 d38e              rcall   ZEROSENSE
01ef99 f049              breq    SKIP2
01ef9a d267              rcall   OVER
01ef9b d3ee              rcall   CFETCH_A
01ef9c d28a              rcall   RFETCH
01ef9d d317              rcall   EQUAL
01ef9e d388              rcall   ZEROSENSE
01ef9f f019              breq    SKIP2
01efa0 d1c4              rcall   ONE
01efa1 d4c6              rcall   SLASHSTRING
01efa2 cff4              rjmp    SKIP1
                 SKIP2:
01efa3 910f              pop     t0
01efa4 910f              pop     t0
01efa5 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
01efa6 df26              fdw     SKIP_L
                 SCAN_L:
01efa7 7384
01efa8 6163
01efa9 006e              .db     NFA|4,"scan",0
                 SCAN:
01efaa d330              rcall   STORE_P_TO_R
01efab d265              rcall   TOR
01efac c008              rjmp    SCAN3
                 SCAN1:
01efad d50f              rcall   CFETCHPP
01efae 940f fa9c         call    FETCH_P
01efb0 d304              rcall   EQUAL
01efb1 d375              rcall   ZEROSENSE
01efb2 f011              breq    SCAN3
01efb3 d2c8              rcall   ONEMINUS
01efb4 c003              rjmp    SCAN4
                 SCAN3:
01efb5 940f f9c5         call    XNEXT
01efb7 f7a8              brcc    SCAN1
                 SCAN4:
01efb8 d263              rcall   RFROM
01efb9 d2bd              rcall   ONEPLUS
01efba d32c              rcall   R_TO_P
01efbb 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
01efbc df4e              fdw     SCAN_L
                 MTST_L:
01efbd 6d84
01efbe 7374
01efbf 0074              .db     NFA|4,"mtst",0
                 MTST:
01efc0 940f feea         call    CFETCH
01efc2 940d f24f         jmp     AND_
                 
01efc4 df7a              fdw     MTST_L
                 FCY_L:
01efc5 4683
01efc6 7963              .db     NFA|3,"Fcy"
01efc7 d069              rcall   DOCREATE
01efc8 3e80              .dw     FREQ_OSC / 1000
                 
                 ;*******************************************************
                 ; Assembler
                 ;*******************************************************
                 ; FIXME
                 ;*******************************************************
                         
                 
                 ;;; Check parameter stack pointer
01efc9 7383
01efca 3f70              .db     NFA|3,"sp?"
                 check_sp:
01efcb d08e              rcall   SPFETCH
01efcc 940f f851         call    R0_
01efce d688              rcall   FETCH_A
01efcf 940f f84c         call    S0
01efd1 d685              rcall   FETCH_A
01efd2 d2a4              rcall   ONEPLUS
01efd3 d2d0              rcall   WITHIN
01efd4 d1e4              rcall   XSQUOTE
01efd5 5303
01efd6 3f50              .db     3,"SP?"
01efd7 d72c              rcall   QABORT
01efd8 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
01efd9 df8a              fdw     FCY_L
                 EMIT_L:
01efda 6584
01efdb 696d
01efdc 0074              .db     NFA|4,"emit",0
                 EMIT:
01efdd d339              rcall   UEMIT_
01efde 940d effc         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
01efe0 dfb4              fdw     EMIT_L
                 KEY_L:
01efe1 6b83
01efe2 7965              .db     NFA|3,"key"
                 KEY:
01efe3 d339              rcall   UKEY_
01efe4 940d effc         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
01efe6 dfc2              fdw     KEY_L
                 KEYQ_L:
01efe7 6b84
01efe8 7965
01efe9 003f              .db     NFA|4,"key?",0
                 KEYQ:
01efea d338              rcall   UKEYQ_
01efeb 940d effc         jmp     FEXECUTE
                 
01efed dfce              fdw     KEYQ_L
                 EXECUTE_L:
01efee 6587
01efef 6578
01eff0 7563
01eff1 6574              .db     NFA|7,"execute"
                 EXECUTE:
01eff2 01fc              movw    zl, tosl
                         sub_pflash_z
01eff3 9189
01eff4 9199              poptos
01eff5 9408              rampv_to_c
01eff6 95f7              ror     zh
01eff7 95e7              ror     zl
01eff8 9419              mijmp
                 
01eff9 dfdc              fdw     EXECUTE_L
                 FEXECUTE_L:
01effa 4083
01effb 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
01effc d65a              rcall   FETCH_A
01effd 940d eff2         jmp     EXECUTE
                 
01efff dff4              fdw     FEXECUTE_L
                 VARIABLE_L:
01f000 7688
01f001 7261
01f002 6169
01f003 6c62
01f004 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
01f005 d0a2              rcall   HERE
01f006 d0b7              rcall   CELL
01f007 d1e2              rcall   ALLOT
01f008 940d f01c 	jmp	CONSTANT_
                 
01f00a e000              fdw     VARIABLE_L
                 TWOVARIABLE_L:
01f00b 3289
01f00c 6176
01f00d 6972
01f00e 6261
01f00f 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
01f010 d097              rcall   HERE
01f011 d705              rcall   DOLIT
01f012 0004              .dw     0x4
01f013 d1d6              rcall   ALLOT
01f014 940d f01c 	jmp	CONSTANT_
                 
01f016 e016              fdw     TWOVARIABLE_L
                 CONSTANT_L:
01f017 6388
01f018 6e6f
01f019 7473
01f01a 6e61
01f01b 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
01f01c d7c7              rcall   COLON
01f01d 940f fe4a         call    LITERAL
01f01f 940d f7f2         jmp     SEMICOLON
                 
01f021 e02e              fdw     CONSTANT_L
                 TWOCONSTANT_L:
01f022 3289
01f023 6f63
01f024 736e
01f025 6174
01f026 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
01f027 d1d0              rcall   SWOP
01f028 d7bb              rcall   COLON
01f029 940f fe4a         call    LITERAL
01f02b 940f fe4a         call    LITERAL
01f02d 940d f7f2         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
01f02f 2883
01f030 2963              .db     NFA|3, "(c)"
                 DOCREATE:
01f031 91ff              m_pop_zh
01f032 91ff              pop     zh
01f033 91ef              pop     zl
01f034 d00f              rcall   FETCHLIT
01f035 91ff              m_pop_zh
01f036 91ff              pop     zh
01f037 91ef              pop     zl
01f038 9419              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
01f039 2883
01f03a 2964              .db     NFA|3, "(d)"
                 DODOES:
01f03b 91bf              m_pop_xh
01f03c 91bf              pop     xh
01f03d 91af              pop     xl
01f03e 91ff              m_pop_zh
01f03f 91ff              pop     zh
01f040 91ef              pop     zl
01f041 d002              rcall   FETCHLIT
01f042 01fd              movw    z, x
01f043 9419              mijmp    ; (z)
                 FETCHLIT:
01f044 939a
01f045 938a              pushtos
01f046 0fee              lsl     zl
01f047 1fff              rol     zh
01f048 9187              lpm_    tosl, z+
01f049 9197              lpm_    tosh, z+
01f04a 9508              ret
                 
01f04b 2883
01f04c 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
01f04d 910f              m_pop_t0
01f04e 91ff              pop     zh
01f04f 91ef              pop     zl
01f050 dff3              rcall   FETCHLIT
01f051 95f7      	ror     zh
01f052 95e7              ror     zl
01f053 93ef              push    zl
01f054 93ff              push    zh
01f055 930f              m_push_t0
01f056 c09a              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
01f057 e044              fdw     TWOCONSTANT_L
                 SPFETCH_L:
01f058 7383
01f059 4070              .db     NFA|3,"sp@"
                 SPFETCH:
01f05a 01fe              movw    z, y
01f05b 939a
01f05c 938a              pushtos
01f05d 01cf              movw    tosl, z
01f05e 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
01f05f 7383
01f060 2170              .db     NFA|3,"sp!"
                 SPSTORE:
01f061 01ec              movw    y, tosl
01f062 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
01f063 7283
01f064 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
01f065 91bf              m_pop_xh
01f066 91bf              pop     xh
01f067 91af              pop     xl
01f068 d7e8              rcall   R0_
01f069 d5ed              rcall   FETCH_A
01f06a bf8d              out     spl, tosl
01f06b bf9e              out     sph, tosh
01f06c 9189
01f06d 9199              poptos
01f06e 01fd              movw    zl, xl
01f06f 9419              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
01f070 e0b0              fdw     SPFETCH_L
                 RPFETCH_L:
01f071 72b3
01f072 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
01f073 939a
01f074 938a              pushtos
01f075 b78d              in      tosl, spl
01f076 b79e              in      tosh, sph
01f077 9508              ret
                 
                 ;   ><  Swap bytes        
01f078 e0e2              fdw     RPFETCH_L
                 SWAPB_L:
01f079 3ea2
01f07a 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
01f07b 2f08              mov     t0, tosl
01f07c 2f89              mov     tosl, tosh
01f07d 2f90              mov     tosh, t0
01f07e 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
01f07f e0f2              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
01f080 6685
01f081 616c
01f082 6873              .db     NFA|5,"flash"
                 ROM_:
01f083 9250 03c8         sts     cse, zero
01f085 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
01f086 e100              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
01f087 6586
01f088 7065
01f089 6f72
01f08a 006d              .db     NFA|6,"eeprom",0
                 EROM:
01f08b 9270 03c8         sts     cse, r_two
01f08d 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
01f08e e10e              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
01f08f 7283
01f090 6d61              .db     NFA|3,"ram"
                 FRAM:
01f091 e004              ldi     t0, 4
01f092 9300 03c8         sts     cse, t0
01f094 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
01f095 e11e              fdw     RAM_L
                 DP_L:
01f096 6482
01f097 0070              .db     NFA|2,"dp",0
                 DP:
01f098 d71d              rcall   IDP
01f099 d004              rcall   CSE_
01f09a 940d f239         jmp     PLUS
                 
                 
                 ;;; 
01f09c 6383
01f09d 6573              .db     NFA|3,"cse"
                 CSE_:
01f09e 939a
01f09f 938a              pushtos
01f0a0 9180 03c8         lds     tosl, cse
01f0a2 2799              clr     tosh
01f0a3 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
01f0a4 e12c              fdw     DP_L
                 HERE_L:
01f0a5 6884
01f0a6 7265
01f0a7 0065              .db     NFA|4,"here",0
                 HERE:
01f0a8 dfef              rcall   DP
01f0a9 940d febf         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
01f0ab e14a              fdw     HERE_L
                 COMMA_L:
01f0ac 2c81              .db     NFA|1,","
                 COMMA:
01f0ad dffa              rcall   HERE
01f0ae d41c              rcall   STORE_A
01f0af d00e              rcall   CELL
01f0b0 940d f1ea         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
01f0b2 e158              fdw     COMMA_L 
                 CCOMMA_L:
01f0b3 6382
01f0b4 002c              .db     NFA|2,"c,",0
                 CCOMMA:
01f0b5 dff2              rcall   HERE
01f0b6 d2d7              rcall   CSTORE_A
01f0b7 d0ad              rcall   ONE
01f0b8 940d f1ea         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
01f0ba e166              fdw     CCOMMA_L
                 CELL_L:
01f0bb 6384
01f0bc 6c65
01f0bd 006c              .db     NFA|4,"cell",0
                 CELL:
01f0be 939a
01f0bf 938a              pushtos
01f0c0 e082              ldi     tosl, 2
01f0c1 e090              ldi     tosh, 0
01f0c2 9508              ret
                 
                 ; ALIGN    --                         align DP
01f0c3 e176              fdw     CELL_L
                 ALIGN_L:
01f0c4 6185
01f0c5 696c
01f0c6 6e67              .db     NFA|5,"align"
                 ALIGN:
01f0c7 dfe0              rcall   HERE
01f0c8 d008              rcall   ALIGNED
01f0c9 dfce              rcall   DP
01f0ca 940d fe76         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
01f0cc e188              fdw     ALIGN_L
                 ALIGNED_L:
01f0cd 6187
01f0ce 696c
01f0cf 6e67
01f0d0 6465              .db     NFA|7,"aligned"
                 ALIGNED:
01f0d1 9601              adiw    tosl, 1
01f0d2 d644              rcall   DOLIT
01f0d3 fffe              .dw     0xfffe
01f0d4 940d f24f         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
01f0d6 e19a              fdw     ALIGNED_L
                 CELLPLUS_L:
01f0d7 63a5
01f0d8 6c65
01f0d9 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
01f0da 9602              adiw    tosl, 2
01f0db 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
01f0dc e1ae              fdw     CELLPLUS_L
                 CELLS_L:
01f0dd 63a5
01f0de 6c65
01f0df 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
01f0e0 0f88              lsl     tosl
01f0e1 1f99              rol     tosh
01f0e2 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
01f0e3 e1ba              fdw     CELLS_L
                 CHARPLUS_L:
01f0e4 63a5
01f0e5 6168
01f0e6 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
01f0e7 9601              adiw    tosl, 1
01f0e8 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
01f0e9 e1c8              fdw     CHARPLUS_L
                 CHARS_L:
01f0ea 63a5
01f0eb 6168
01f0ec 7372              .db     NFA|INLINE|5,"chars"
01f0ed 9508      CHARS:  ret
                 
01f0ee e1d4              fdw     CHARS_L
                 COMMAXT_L:
01f0ef 6383
01f0f0 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
01f0f1 d62f              rcall   DUP
01f0f2 d65c              rcall   IHERE
01f0f3 d152              rcall   MINUS
01f0f4 d13f              rcall   ABS_ 
01f0f5 d621              rcall   DOLIT
01f0f6 0ff0              .dw     0xff0
01f0f7 d1c7              rcall   GREATER
01f0f8 d22e              rcall   ZEROSENSE
01f0f9 f051              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
01f0fa d61c              rcall   DOLIT
                 .ifdef EIND
01f0fb 940f              .dw     0x940F  ; On Atmega 2560 all code is on 128 - 256 Kword area.
                 .else
                 .endif
01f0fc 940f ff9d         call    ICOMMA
                         sub_pflash_tos
01f0fe 9408              rampv_to_c
01f0ff 9597              ror     tosh
01f100 9587              ror     tosl
01f101 940f ff9d         call    ICOMMA
01f103 c008              rjmp    STORECF2
                 STORECF1:
01f104 d64a              rcall   IHERE
01f105 d140              rcall   MINUS
01f106 d727              rcall   TWOMINUS
01f107 d18a              rcall   TWOSLASH
                         ;rcall   RCALL_
01f108 709f              andi    tosh, 0x0f
01f109 6d90              ori     tosh, 0xd0
01f10a 940f ff9d         call    ICOMMA
                 STORECF2:
01f10c 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
01f10d 2186
01f10e 6f63
01f10f 6f6c
01f110 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
01f111 d605              rcall   DOLIT
01f112 fffa              .dw     0xfffa         ;  -6
01f113 940d f8f5         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
01f115 e1de              fdw     COMMAXT_L
                 TWOFETCH_L:
01f116 3282
01f117 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
01f118 d608              rcall   DUP
01f119 d53d              rcall   FETCH_A
01f11a d0dd              rcall   SWOP
01f11b dfbe              rcall   CELLPLUS
01f11c 940d f657         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
01f11e e22c              fdw     TWOFETCH_L
                 TWOSTORE_L:
01f11f 3282
01f120 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
01f121 d0d6              rcall   SWOP
01f122 d0df              rcall   OVER
01f123 dfb6              rcall   CELLPLUS
01f124 d3a6              rcall   STORE_A
01f125 940d fe76         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
01f127 e23e              fdw     TWOSTORE_L
                 TWODROP_L:
01f128 3285
01f129 7264
01f12a 706f              .db     NFA|5,"2drop"
                 TWODROP:
01f12b d0c5              rcall   DROP
01f12c 940d f1f1         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
01f12e e250              fdw     TWODROP_L
                 TWODUP_L:
01f12f 3284
01f130 7564
01f131 0070              .db     NFA|4,"2dup",0
                 TWODUP:
01f132 d0cf              rcall   OVER
01f133 940d f202         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
01f135 e25e              fdw     TWODUP_L
                 TWOSWAP_L:
01f136 3285
01f137 7773
01f138 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
01f139 d0d0              rcall   ROT
01f13a d0d6              rcall   TOR
01f13b d0ce              rcall   ROT
01f13c d0df              rcall   RFROM
01f13d 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
01f13e e26c              fdw     TWOSWAP_L
                 SPACE_L:
01f13f 7385
01f140 6170
01f141 6563              .db     NFA|5,"space"
                 SPACE_:  
01f142 d6f0              rcall   BL
01f143 940d efdd         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
01f145 e27e              fdw     SPACE_L
                 SPACES_L:
01f146 7386
01f147 6170
01f148 6563
01f149 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
01f14a d1e2              rcall   DUPZEROSENSE
01f14b f019              breq    SPCS2
01f14c dff5              rcall   SPACE_
01f14d d12e              rcall   ONEMINUS
01f14e cffb              rjmp    SPCS1
01f14f 940d f1f1 SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
01f151 e28c              fdw     SPACES_L
                 UMIN_L:
01f152 7584
01f153 696d
01f154 006e              .db     NFA|4,"umin",0
                 UMIN:
01f155 dfdc              rcall   TWODUP
01f156 d176              rcall   UGREATER
01f157 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
01f158 e2a4              fdw     UMIN_L
                 UMAX_L:
01f159 7584
01f15a 616d
01f15b 0078              .db     NFA|4,"umax",0
                 UMAX:
01f15c dfd5              rcall   TWODUP
01f15d d167              rcall   ULESS
                 MINMAX:
01f15e d1c8              rcall   ZEROSENSE
01f15f f009              breq    UMAX1
01f160 d097              rcall   SWOP
01f161 940d f1f1 UMAX1:  jmp     DROP
                 
01f163 e2b2              fdw     UMAX_L
                 ONE_L:
01f164 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
01f165 939a
01f166 938a              pushtos
01f167 e081              ldi     tosl, 1
01f168 e090              ldi     tosh, 0
01f169 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
01f16a e2c8              fdw     ONE_L
                 ACCEPT_L:
01f16b 6186
01f16c 6363
01f16d 7065
01f16e 0074              .db     NFA|6,"accept",0
                 ACCEPT:
01f16f d092              rcall   OVER
01f170 d0c8              rcall   PLUS
01f171 d090              rcall   OVER
                 ACC1:
01f172 de70              rcall   KEY
                 
01f173 308d              cpi     tosl, CR_
01f174 f429              brne    ACC_LF
                         
01f175 d54c              rcall   TRUE_
01f176 d02f              rcall   FCR
01f177 d216              rcall   CSTORE_A
01f178 d078              rcall   DROP
01f179 c026              rjmp    ACC6
                 ACC_LF:
01f17a 308a              cpi     tosl, LF_
01f17b f449              brne    ACC2
01f17c d074              rcall   DROP
                 
01f17d d028              rcall   FCR
01f17e d20b              rcall   CFETCH_A
01f17f d1a7              rcall   ZEROSENSE
01f180 f0f9              breq    ACC6
01f181 d537              rcall   FALSE_
01f182 d023              rcall   FCR
01f183 d20a              rcall   CSTORE_A
01f184 cfed              rjmp    ACC1
                 ACC2:
01f185 d533              rcall   FALSE_
01f186 d01f              rcall   FCR
01f187 d206              rcall   CSTORE_A
01f188 d598              rcall   DUP
01f189 de53              rcall   EMIT
01f18a d596              rcall   DUP
01f18b d58b              rcall   DOLIT
01f18c 0008              .dw     BS_
01f18d d127              rcall   EQUAL
01f18e d198              rcall   ZEROSENSE
01f18f f039              breq    ACC3
01f190 d060              rcall   DROP
01f191 d0ea              rcall   ONEMINUS
01f192 d07e              rcall   TOR
01f193 d06e              rcall   OVER
01f194 d087              rcall   RFROM
01f195 dfc6              rcall   UMAX
01f196 cfdb              rjmp    ACC1
                 ACC3:
01f197 d06a              rcall   OVER
01f198 d1f5              rcall   CSTORE_A
01f199 d0dd              rcall   ONEPLUS
01f19a d067              rcall   OVER
01f19b dfb9              rcall   UMIN
01f19c df95              rcall   TWODUP
01f19d d110              rcall   NOTEQUAL
01f19e d188              rcall   ZEROSENSE
01f19f f691              brne     ACC1
                 ACC6:
01f1a0 d1c7              rcall   NIP
01f1a1 d056              rcall   SWOP
01f1a2 940d f246         jmp     MINUS
                 
01f1a4 6683
01f1a5 7263              .db     NFA|3,"fcr"
                 FCR:
01f1a6 d2a8              rcall   DOUSER
01f1a7 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
01f1a8 e2d6              fdw      ACCEPT_L
                 TYPE_L:
01f1a9 7484
01f1aa 7079
01f1ab 0065              .db     NFA|4,"type",0
                 TYPE:
01f1ac d064              rcall   TOR
01f1ad c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
01f1ae d30e              rcall   CFETCHPP
01f1af de2d              rcall   EMIT
                 TYPE2:
01f1b0 940f f9c5         call    XNEXT
01f1b2 f7d8              brcc    TYPE1
01f1b3 911f              pop     t1
01f1b4 910f              pop     t0
01f1b5 940d f1f1         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
01f1b7 2883
01f1b8 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
01f1b9 91ff              m_pop_zh
01f1ba d06c              rcall   RFETCH
01f1bb 0f88              lsl     tosl
01f1bc 1f99              rol     tosh
                         add_pflash_tos
01f1bd d2ff              rcall   CFETCHPP
01f1be d562              rcall   DUP
01f1bf d0b7              rcall   ONEPLUS
01f1c0 df10              rcall   ALIGNED
01f1c1 9596              lsr     tosh
01f1c2 9587              ror     tosl
01f1c3 d058              rcall   RFROM
01f1c4 d074              rcall   PLUS
01f1c5 01fc              movw    zl, tosl
01f1c6 9189
01f1c7 9199              poptos
01f1c8 9419              mijmp
                 
01f1c9 e352              fdw     TYPE_L
                 SQUOTE_L:
01f1ca 73d2
01f1cb 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
01f1cc de80              rcall   DOCOMMAXT
01f1cd e372              fdw     XSQUOTE
01f1ce deb4              rcall   ROM_
01f1cf d005              rcall   CQUOTE
01f1d0 940d f091         jmp     FRAM
                 
01f1d2 e394              fdw     SQUOTE_L
                 CQUOTE_L:
01f1d3 2c82
01f1d4 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
01f1d5 d541              rcall   DOLIT
01f1d6 0022              .dw     0x22
01f1d7 d2a3              rcall   PARSE
01f1d8 decf              rcall   HERE
01f1d9 d028              rcall   OVER
01f1da d09c              rcall   ONEPLUS
01f1db def5              rcall   ALIGNED
01f1dc d00d              rcall   ALLOT
01f1dd 940d f4b4         jmp     PLACE
                 
                 
01f1df e3a6              fdw     CQUOTE_L
                 DOTQUOTE_L:
01f1e0 2ed2
01f1e1 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
01f1e2 dfe9              rcall   SQUOTE
01f1e3 de69              rcall   DOCOMMAXT
01f1e4 e358              fdw     TYPE
01f1e5 9508              ret
                 
01f1e6 e3c0              fdw     DOTQUOTE_L
                 ALLOT_L:
01f1e7 6185
01f1e8 6c6c
01f1e9 746f              .db     NFA|5,"allot"
                 ALLOT:
01f1ea dead              rcall   DP
01f1eb 940d f298         jmp     PLUSSTORE
                 
01f1ed e3ce              fdw     ALLOT_L
                 DROP_L:
01f1ee 64a4
01f1ef 6f72
01f1f0 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
01f1f1 9189
01f1f2 9199              poptos
01f1f3 9508              ret
                 
01f1f4 e3dc              fdw     DROP_L
                 SWOP_L:
01f1f5 7384
01f1f6 6177
01f1f7 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
01f1f8 9109              ld      t0, y+
01f1f9 9119              ld      t1, y+
01f1fa 939a
01f1fb 938a              pushtos
01f1fc 01c8              movw    tosl, t0
01f1fd 9508              ret
                 
01f1fe e3ea              fdw     SWOP_L
                 OVER_L:
01f1ff 6f84
01f200 6576
01f201 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
01f202 939a
01f203 938a              pushtos
01f204 818a              ldd     tosl, y+2
01f205 819b              ldd     tosh, y+3
01f206 9508              ret
                 
01f207 e3fe              fdw     OVER_L
                 ROT_L:
01f208 7283
01f209 746f              .db     NFA|3, "rot"
                 ROT:
01f20a d006              rcall   TOR
01f20b dfec              rcall   SWOP
01f20c d00f              rcall   RFROM
01f20d cfea              rjmp    SWOP
                 
01f20e e410              fdw     ROT_L
                 TOR_L:
01f20f 3e92
01f210 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
01f211 91ff              m_pop_zh
01f212 91ff              pop     zh
01f213 91ef              pop     zl
01f214 938f              push    tosl
01f215 939f              push    tosh
01f216 9189
01f217 9199              poptos
01f218 9419              mijmp
                 
01f219 e41e              fdw     TOR_L
                 RFROM_L:
01f21a 7292
01f21b 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
01f21c 91ff              m_pop_zh
01f21d 91ff              pop     zh
01f21e 91ef              pop     zl
01f21f 939a
01f220 938a              pushtos
01f221 919f              pop     tosh
01f222 918f              pop     tosl
01f223 9419              mijmp
                 
01f224 e434              fdw     RFROM_L
                 RFETCH_L:
01f225 7292
01f226 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
01f227 91ff              m_pop_zh
01f228 91ff              pop     zh
01f229 91ef              pop     zl
01f22a 939a
01f22b 938a              pushtos
01f22c 919f              pop     tosh
01f22d 918f              pop     tosl
01f22e 938f              push    tosl
01f22f 939f              push    tosh
01f230 9419              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
01f231 ee3e              fdw     DUP_L
                 ABS_L:
01f232 6183
01f233 7362              .db     NFA|3,"abs"
                 ABS_:
01f234 d4ec              rcall   DUP
01f235 940d f377         jmp     QNEGATE
                 
01f237 e464              fdw     ABS_L
                 PLUS_L:
01f238 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
01f239 9109              ld      t0, Y+        
01f23a 9119              ld      t1, Y+
01f23b 0f80              add     tosl, t0
01f23c 1f91              adc     tosh, t1
01f23d 9508              ret
                 
                 ; m+  ( d n -- d1 )
01f23e e470              fdw     PLUS_L
                 MPLUS_L:
01f23f 6d82
01f240 002b              .db     NFA|2, "m+",0
                 MPLUS:
01f241 d7a9              rcall   STOD
01f242 940d fa0d         jmp     DPLUS
                 
01f244 e47e              fdw     MPLUS_L
                 MINUS_L:
01f245 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
01f246 9109              ld      t0, Y+
01f247 9119              ld      t1, Y+
01f248 1b08              sub     t0, tosl
01f249 0b19              sbc     t1, tosh
01f24a 01c8              movw    tosl, t0
01f24b 9508              ret
                 
01f24c e48a              fdw     MINUS_L
                 AND_L:
01f24d 6183
01f24e 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
01f24f 9109              ld      t0, Y+
01f250 9119              ld      t1, Y+
01f251 2380              and     tosl, t0
01f252 2391              and     tosh, t1
01f253 9508              ret
                 
01f254 e49a              fdw     AND_L
                 OR_L:
01f255 6f82
01f256 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
01f257 9109              ld      t0, Y+
01f258 9119              ld      t1, Y+
01f259 2b80              or      tosl, t0
01f25a 2b91              or      tosh, t1
01f25b 9508              ret
                 
01f25c e4aa              fdw     OR_L
                 XOR_L:
01f25d 7883
01f25e 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
01f25f 9109              ld      t0, Y+
01f260 9119              ld      t1, Y+
01f261 2780              eor     tosl, t0
01f262 2791              eor     tosh, t1
01f263 9508              ret
                 
01f264 e4ba              fdw     XOR_L
                 INVERT_L:
01f265 69a6
01f266 766e
01f267 7265
01f268 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
01f269 9580              com     tosl
01f26a 9590              com     tosh
01f26b 9508              ret
                 
01f26c e4ca              fdw     INVERT_L
                 NEGATE_L:
01f26d 6e86
01f26e 6765
01f26f 7461
01f270 0065              .db     NFA|6, "negate",0
                 NEGATE:
01f271 dff7              rcall   INVERT
01f272 940d f277         jmp     ONEPLUS
                 
01f274 e4da              fdw     NEGATE_L
                 ONEPLUS_L:
01f275 31a2
01f276 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
01f277 9601              adiw    tosl, 1
01f278 9508              ret
                 
01f279 e4ea              fdw     ONEPLUS_L
                 ONEMINUS_L:
01f27a 31a2
01f27b 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
01f27c 9701              sbiw    tosl, 1
01f27d 9508              ret
                 
01f27e e4f4              fdw     ONEMINUS_L
                 TWOPLUS_L:
01f27f 32a2
01f280 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
01f281 9602              adiw    tosl, 2
01f282 9508              ret
                 
01f283 e4fe              fdw     TWOPLUS_L
                 TOBODY_L:
01f284 3ea5
01f285 6f62
01f286 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
01f287 9604              adiw    tosl, 4
01f288 9508              ret
                 
01f289 e508              fdw     TOBODY_L
                 TWOSTAR_L:
01f28a 32a2
01f28b 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
01f28c 0f88              lsl     tosl
01f28d 1f99              rol     tosh
01f28e 9508              ret
                 
01f28f e514              fdw     TWOSTAR_L
                 TWOSLASH_L:
01f290 32a2
01f291 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
01f292 9595              asr     tosh
01f293 9587              ror     tosl
01f294 9508              ret
                 
01f295 e520              fdw     TWOSLASH_L
                 PLUSSTORE_L:
01f296 2b82
01f297 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
01f298 df5f              rcall   SWOP
01f299 df68              rcall   OVER
01f29a d3bc              rcall   FETCH_A
01f29b df9d              rcall   PLUS
01f29c df5b              rcall   SWOP
01f29d 940d fe76         jmp     STORE
                 
01f29f e52c              fdw     PLUSSTORE_L
                 WITHIN_L:
01f2a0 7786
01f2a1 7469
01f2a2 6968
01f2a3 006e              .db     NFA|6,"within",0
                 WITHIN:
01f2a4 df5d              rcall   OVER
01f2a5 dfa0              rcall   MINUS
01f2a6 df6a              rcall   TOR
01f2a7 df9e              rcall   MINUS
01f2a8 df73              rcall   RFROM
01f2a9 940d f2c5         jmp     ULESS
                 
01f2ab e540              fdw     WITHIN_L
                 NOTEQUAL_L:
01f2ac 3c82
01f2ad 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
01f2ae df97              rcall	MINUS        	; MINUS leaves a valid zero flag
01f2af f409              brne	NOTEQUAL1
01f2b0 c480              rjmp	FALSE_F
                 NOTEQUAL1:
01f2b1 940d f729         jmp	TRUE_F
                 
01f2b3 ee5a              fdw     ZEROLESS_L
                 EQUAL_L:
01f2b4 3d81              .db     NFA|1, "="
                 EQUAL:
01f2b5 df90              rcall   MINUS
01f2b6 940d f727         jmp     ZEROEQUAL
                 
                 
01f2b8 e568              fdw     EQUAL_L
                 LESS_L:
01f2b9 3c81              .db     NFA|1,"<"
                 LESS:
01f2ba df8b              rcall   MINUS
01f2bb 940d f72f         jmp     ZEROLESS
                 
01f2bd e572              fdw     LESS_L
                 GREATER_L:
01f2be 3e81              .db     NFA|1,">"
                 GREATER:
01f2bf df38              rcall   SWOP
01f2c0 940d f2ba         jmp     LESS
                 
01f2c2 e57c              fdw     GREATER_L
                 ULESS_L:
01f2c3 7582
01f2c4 003c              .db     NFA|2,"u<",0
                 ULESS:
01f2c5 df80              rcall   MINUS
01f2c6 f408              brcc    ULESS1        ; Carry test  
01f2c7 c461              rjmp    TRUE_F
                 ULESS1:
01f2c8 940d f731         jmp     FALSE_F
                 
                 
01f2ca e586              fdw     ULESS_L
                 UGREATER_L:
01f2cb 7582
01f2cc 003e              .db     NFA|2, "u>",0
                 UGREATER:
01f2cd df2a              rcall   SWOP
01f2ce 940d f2c5         jmp     ULESS
                 
01f2d0 e596              fdw     UGREATER_L
                 STORE_P_L:
01f2d1 2182
01f2d2 0070              .db     NFA|2,"!p",0
                 STORE_P:
01f2d3 01ac              movw    pl, tosl
01f2d4 9189
01f2d5 9199              poptos
01f2d6 9508              ret
                 
01f2d7 e5a2              fdw     STORE_P_L
                 STORE_P_TO_R_L:
01f2d8 2194
01f2d9 3e70
01f2da 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
01f2db 91ff              m_pop_zh
01f2dc 91ff              pop     zh
01f2dd 91ef              pop     zl
01f2de 934f              push    pl
01f2df 935f              push    ph
01f2e0 01ac              movw    pl, tosl
01f2e1 9189
01f2e2 9199              poptos
01f2e3 9419              mijmp
                 
01f2e4 e5b0              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
01f2e5 7293
01f2e6 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
01f2e7 91ff              m_pop_zh
01f2e8 91ff              pop     zh
01f2e9 91ef              pop     zl
01f2ea 915f              pop     ph
01f2eb 914f              pop     pl
01f2ec 9419              mijmp
                 
01f2ed e5ca              fdw     R_TO_P_L
                 PFETCH_L:
01f2ee 7082
01f2ef 0040              .db     NFA|2,"p@",0
                 PFETCH:
01f2f0 939a
01f2f1 938a              pushtos
01f2f2 01ca              movw    tosl, pl
01f2f3 940d febf         jmp     FETCH
                 
01f2f5 e5dc              fdw     PFETCH_L
                 PSTORE_L:
01f2f6 7082
01f2f7 0021              .db     NFA|2,"p!",0
                 PSTORE:
01f2f8 939a
01f2f9 938a              pushtos
01f2fa 01ca              movw    tosl, pl
01f2fb 940d fe76         jmp     STORE
                 
01f2fd e5ec              fdw     PSTORE_L
                 PCSTORE_L:
01f2fe 7083
01f2ff 2163              .db     NFA|3,"pc!"
                 PCSTORE:
01f300 939a
01f301 938a              pushtos
01f302 01ca              movw    tosl, pl
01f303 940d ff0d         jmp     CSTORE
                 
01f305 e5fc              fdw     PCSTORE_L
                 PPLUS_L:
01f306 70a2
01f307 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
01f308 0d46              add     pl, r_one
01f309 1d55              adc     ph, zero
01f30a 9508              ret   
                 
01f30b e60c              fdw     PPLUS_L
                 PNPLUS_L:
01f30c 7083
01f30d 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
01f30e 0f48              add     pl, tosl
01f30f 1f59              adc     ph, tosh
01f310 9189
01f311 9199              poptos
01f312 9508              ret
                 
01f313 e618              fdw     PNPLUS_L
                 UEMIT_L:
01f314 2785
01f315 6d65
01f316 7469              .db     NFA|5,"'emit"
                 UEMIT_:
01f317 d137              rcall   DOUSER
01f318 ffe8              .dw     uemit
                         
01f319 e628              fdw     UEMIT_L
                 UKEY_L:
01f31a 2784
01f31b 656b
01f31c 0079              .db     NFA|4,"'key",0
                 UKEY_:
01f31d d131              rcall   DOUSER
01f31e ffea              .dw     ukey
                 
01f31f e634              fdw     UKEY_L
                 UKEYQ_L:
01f320 2785
01f321 656b
01f322 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
01f323 d12b              rcall   DOUSER
01f324 ffec              .dw     ukeyq
                 
01f325 3f83
01f326 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
01f327 9700              sbiw    tosl, 0
01f328 9189
01f329 9199              poptos
01f32a 9508              ret
                 
01f32b 6483
01f32c 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
01f32d 9700              sbiw    tosl, 0
01f32e 9508              ret
                 
01f32f e640              fdw     UKEYQ_L
                 UMSTAR_L:
01f330 7583
01f331 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
01f332 940d ffd4         jmp     umstar0
                 
01f334 e660              fdw     UMSTAR_L
                 UMSLASHMOD_L:
01f335 7586
01f336 2f6d
01f337 6f6d
01f338 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
01f339 940d ef00         jmp     umslashmod0
                 
                 
01f33b e66a              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
01f33c 7585
01f33d 6d2f
01f33e 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
01f33f d379              rcall   FALSE_
01f340 deb7              rcall   SWOP
01f341 940d ef00         jmp     umslashmod0
                 
01f343 e678              fdw     USLASHMOD_L
                 STAR_L:
01f344 2a81              .db     NFA|1,"*"
                 STAR: 
01f345 dfec              rcall   UMSTAR
01f346 940d f1f1         jmp     DROP
                 
01f348 e688              fdw     STAR_L
                 USLASH_L:
01f349 7582
01f34a 002f              .db     NFA|2,"u/",0
                 USLASH:
01f34b dff3              rcall   USLASHMOD
01f34c 940d f368         jmp     NIP
                 
01f34e e692              fdw     USLASH_L
                 USSMOD_L:
01f34f 7586
01f350 2f2a
01f351 6f6d
01f352 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
01f353 debd              rcall   TOR
01f354 dfdd              rcall   UMSTAR
01f355 dec6              rcall   RFROM
01f356 940d f339         jmp     UMSLASHMOD
                 
                 
01f358 e69e              fdw     USSMOD_L
                 SLASH_L:
01f359 2f81              .db     NFA|1,"/"
                 SLASH: 
01f35a ddd7              rcall   TWODUP
01f35b df03              rcall   XOR_
01f35c deb4              rcall   TOR
01f35d ded6              rcall   ABS_
01f35e de99              rcall   SWOP
01f35f ded4              rcall   ABS_
01f360 de97              rcall   SWOP
01f361 dfe9              rcall   USLASH
01f362 deb9              rcall   RFROM
01f363 940d f377         jmp     QNEGATE
                 
01f365 e6b2              fdw     SLASH_L
                 NIP_L:
01f366 6e83
01f367 7069              .db     NFA|3,"nip"
                 NIP:
01f368 de8f              rcall   SWOP
01f369 940d f1f1         jmp     DROP
                     
01f36b e6cc              fdw     NIP_L
                 TUCK_L:
01f36c 7484
01f36d 6375
01f36e 006b              .db     NFA|4,"tuck",0
                 TUCK:
01f36f de88              rcall   SWOP
01f370 940d f202         jmp     OVER
                 
01f372 e6d8              fdw     TUCK_L
                 QNEGATE_L:
01f373 3f87
01f374 656e
01f375 6167
01f376 6574              .db     NFA|7,"?negate"
                 QNEGATE:
01f377 d3b7              rcall   ZEROLESS
01f378 dfae              rcall   ZEROSENSE
01f379 f009              breq    QNEGATE1
01f37a def6              rcall   NEGATE
                 QNEGATE1:
01f37b 9508              ret
                 
01f37c e6e6              fdw     QNEGATE_L
                 MAX_L:
01f37d 6d83
01f37e 7861              .db     NFA|3,"max"
01f37f ddb2      MAX:    rcall   TWODUP
01f380 df39              rcall   LESS
01f381 cddc              rjmp    MINMAX
                 
01f382 e6fa              fdw     MAX_L
                 MIN_L:
01f383 6d83
01f384 6e69              .db     NFA|3,"min"
01f385 ddac      MIN:    rcall   TWODUP
01f386 df38              rcall   GREATER
01f387 cdd6              rjmp    MINMAX
                 
01f388 6382
01f389 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
01f38a 940d feea         jmp     CFETCH
                 
01f38c 6382
01f38d 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
01f38e 940d ff0d         jmp     CSTORE
                 
01f390 e706              fdw     MIN_L
                 UPTR_L:
01f391 7582
01f392 0070              .db     NFA|2,"up",0
01f393 dc9d      UPTR:   rcall   DOCREATE
01f394 0002              .dw     2 ; upl
                 
01f395 e722              fdw     UPTR_L
                 HOLD_L:
01f396 6884
01f397 6c6f
01f398 0064              .db     NFA|4,"hold",0
01f399 d328      HOLD:   rcall   TRUE_
01f39a d09a              rcall   HP
01f39b defc              rcall   PLUSSTORE
01f39c d098              rcall   HP
01f39d d2b9              rcall   FETCH_A
01f39e 940d ff0d         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
01f3a0 e72c              fdw     HOLD_L
                 LESSNUM_L:
01f3a1 3c82
01f3a2 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
01f3a3 d096              rcall   PAD
01f3a4 d090              rcall   HP
01f3a5 940d fe76         jmp     STORE
                 
                 ; >digit   n -- c            convert to 0..9a..z
01f3a7 e742              fdw     LESSNUM_L
                 TODIGIT_L:
01f3a8 3e86
01f3a9 6964
01f3aa 6967
01f3ab 0074              .db     NFA|6,">digit",0
                 TODIGIT: 
01f3ac d374              rcall   DUP
01f3ad d369              rcall   DOLIT
01f3ae 0009              .dw     9
01f3af df0f              rcall   GREATER
01f3b0 d366              rcall   DOLIT
01f3b1 0027              .dw     0x27
01f3b2 de9c              rcall   AND_
01f3b3 de85              rcall   PLUS
01f3b4 d362              rcall   DOLIT
01f3b5 0030              .dw     0x30
01f3b6 940d f239         jmp     PLUS
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
01f3b8 e750              fdw     TODIGIT_L
                 NUM_L:
01f3b9 2381              .db     NFA|1,"#"
                 NUM:
01f3ba d087              rcall   BASE
01f3bb d29b              rcall   FETCH_A
01f3bc d199              rcall   UDSLASHMOD
01f3bd de4c              rcall   ROT
01f3be dfed              rcall   TODIGIT
01f3bf 940d f399         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
01f3c1 e772              fdw     NUM_L
                 NUMS_L:
01f3c2 2382
01f3c3 0073              .db     NFA|2,"#s",0
                 NUMS:
01f3c4 dff5              rcall   NUM
01f3c5 dd6c              rcall   TWODUP
01f3c6 de90              rcall   OR_
01f3c7 df5f              rcall   ZEROSENSE
01f3c8 f7d9              brne    NUMS
01f3c9 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
01f3ca e784              fdw     NUMS_L
                 NUMGREATER_L:
01f3cb 2382
01f3cc 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
01f3cd dd5d              rcall   TWODROP
01f3ce d066              rcall   HP
01f3cf d287              rcall   FETCH_A
01f3d0 d069              rcall   PAD
01f3d1 de30              rcall   OVER
01f3d2 940d f246         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
01f3d4 e796              fdw     NUMGREATER_L
                 SIGN_L:
01f3d5 7384
01f3d6 6769
01f3d7 006e              .db     NFA|4,"sign",0
                 SIGN:   
01f3d8 d356              rcall   ZEROLESS
01f3d9 df4d              rcall   ZEROSENSE
01f3da f019              breq    SIGN1
01f3db d33b              rcall   DOLIT
01f3dc 002d              .dw     0x2D
01f3dd dfbb              rcall   HOLD
                 SIGN1:
01f3de 9508              ret
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
01f3df e7aa              fdw     SIGN_L
                 UDOT_L:
01f3e0 7582
01f3e1 002e              .db     NFA|2,"u.",0
                 UDOT:
01f3e2 dfc0              rcall   LESSNUM
01f3e3 d2d5              rcall   FALSE_
01f3e4 dfdf              rcall   NUMS
01f3e5 dfe7              rcall   NUMGREATER
01f3e6 ddc5              rcall   TYPE
01f3e7 940d f142         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
01f3e9 e7c0              fdw     UDOT_L
                 UDOTR_L:
01f3ea 7583
01f3eb 722e              .db     NFA|3,"u.r"
                 UDOTR:
01f3ec dfb6              rcall   LESSNUM
01f3ed de8e              rcall   ONEMINUS
01f3ee de22              rcall   TOR
01f3ef d2c9              rcall   FALSE_
01f3f0 c001              rjmp    UDOTR2
                 UDOTR1:
01f3f1 dfc8              rcall   NUM
                 UDOTR2: 
01f3f2 d5d2              rcall   XNEXT
01f3f3 f7e8              brcc    UDOTR1
01f3f4 911f              pop     t1
01f3f5 910f              pop     t0
01f3f6 dfcd              rcall   NUMS
01f3f7 dfd5              rcall   NUMGREATER
01f3f8 ddb3              rcall   TYPE
01f3f9 940d f142         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
01f3fb e7d4              fdw     UDOTR_L
                 DOT_L:
01f3fc 2e81              .db     NFA|1,"."
01f3fd dfa5      DOT:    rcall   LESSNUM
01f3fe d322              rcall   DUP
01f3ff de34              rcall   ABS_
01f400 d2b8              rcall   FALSE_
01f401 dfc2              rcall   NUMS
01f402 de07              rcall   ROT
01f403 dfd4              rcall   SIGN
01f404 dfc8              rcall   NUMGREATER
01f405 dda6              rcall   TYPE
01f406 940d f142         jmp     SPACE_
                 
01f408 e7f8              FDW     DOT_L
                 DECIMAL_L:
01f409 6487
01f40a 6365
01f40b 6d69
01f40c 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
01f40d d283              rcall   TEN
01f40e d033              rcall   BASE
01f40f 940d fe76         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
01f411 e812              Fdw     DECIMAL_l
                 HEX_L:
01f412 6883
01f413 7865              .db     NFA|3,"hex"
                 HEX:
01f414 d302              rcall   DOLIT
01f415 0010              .dw     16
01f416 d02b              rcall   BASE
01f417 940d fe76         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
01f419 e824              Fdw     HEX_L
                 BIN_L:
01f41a 6283
01f41b 6e69              .db     NFA|3,"bin"
01f41c dca1      BIN:    rcall   CELL
01f41d d024              rcall   BASE
01f41e 940d fe76         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
01f420 e834              fdw     BIN_L
                 RSAVE_L:
01f421 7285
01f422 6173
01f423 6576              .db     NFA|5,"rsave"
01f424 d02a      RSAVE_: rcall   DOUSER
01f425 fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
01f426 e842              fdw     RSAVE_L
                 ULINK_L:
01f427 7585
01f428 696c
01f429 6b6e              .db     NFA|5,"ulink"
01f42a d024      ULINK_: rcall   DOUSER
01f42b fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
01f42c e84e              fdw     ULINK_L
                 TASK_L:
01f42d 7484
01f42e 7361
01f42f 006b              .db     NFA|4,"task",0
01f430 d01e      TASK:   rcall   DOUSER
01f431 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
01f432 e85a              fdw     TASK_L
                 HP_L:
01f433 6882
01f434 0070              .db     NFA|2,"hp",0
01f435 d019      HP:     rcall   DOUSER
01f436 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
01f437 e866              fdw     HP_L
                 PAD_L:
01f438 7083
01f439 6461              .db     NFA|3,"pad"
                 PAD:
01f43a d1a0              rcall   TIB
01f43b d197              rcall   TIBSIZE
01f43c 940d f239         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
01f43e e870              fdw     PAD_L
                 BASE_L:
01f43f 6284
01f440 7361
01f441 0065              .db     NFA|4,"base",0
                 BASE:
01f442 d00c              rcall   DOUSER
01f443 ffee              .dw     ubase
                 
                 ; USER   n --
01f444 e87e              fdw     BASE_L
                 USER_L:
01f445 7584
01f446 6573
01f447 0072              .db     NFA|4,"user",0
                 USER:
01f448 d323              rcall   CREATE
01f449 dc74              rcall   CELL
01f44a de26              rcall	NEGATE
01f44b d4a9              rcall   IALLOT
01f44c 940f ff9d         call    ICOMMA
01f44e d36d              rcall   XDOES
                 DOUSER:
01f44f 939a
01f450 938a              pushtos
01f451 91ff              m_pop_zh
01f452 91ff              pop     zh
01f453 91ef              pop     zl
01f454 0fee              lsl     zl
01f455 1fff              rol     zh
01f456 9187              lpm_    tosl, z+
01f457 9197              lpm_    tosh, z+
01f458 0d82              add     tosl, upl
01f459 1d93              adc     tosh, uph
01f45a 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
01f45b e88a              fdw     USER_L
                 SOURCE_L:
01f45c 7386
01f45d 756f
01f45e 6372
01f45f 0065              .db     NFA|6,"source",0
                 SOURCE:
01f460 d18c              rcall   TICKSOURCE
01f461 940d f118         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
01f463 e8b8              fdw      SOURCE_L
                 SLASHSTRING_L:
01f464 2f87
01f465 7473
01f466 6972
01f467 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
01f468 dd8f              rcall   SWOP
01f469 dd98              rcall   OVER
01f46a dddb              rcall   MINUS
01f46b dda5              rcall   TOR
01f46c ddcc              rcall   PLUS
01f46d ddae              rcall   RFROM
01f46e 9508              ret
                 
                 ; \     Skip the rest of the line
01f46f e8c8              fdw     SLASHSTRING_L
                 BSLASH_L:
01f470 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
01f471 dfee              rcall   SOURCE
01f472 d173              rcall   TOIN
01f473 d057              rcall   STORE_A
01f474 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
01f475 940d f1f1         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
01f477 e8e0              fdw     BSLASH_L
                 PARSE_L:
01f478 7085
01f479 7261
01f47a 6573              .db     NFA|5,"parse"
                 PARSE:
01f47b d2a5              rcall   DUP             ; c c
01f47c dfe3              rcall   SOURCE          ; c c a u
01f47d d168              rcall   TOIN            ; c c a u a
01f47e d1d8              rcall   FETCH_A         ; c c a u n
01f47f dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
01f480 d2a0              rcall   DUP             ; c c a u u
01f481 dd8f              rcall   TOR             ; c c a u                  R: u (new tib len
01f482 dd87              rcall   ROT             ; c a u c
01f483 db12              rcall   SKIP            ; c a u        
01f484 dd7d              rcall   OVER            ; c a u a
01f485 dd8b              rcall   TOR             ; c a u                    R: u a (start of word
01f486 dd83              rcall   ROT             ; a u c
01f487 db22              rcall   SCAN            ; a u      end of word, tib left       
01f488 dea4              rcall   DUPZEROSENSE
01f489 f009              breq    PARSE1
01f48a ddf1              rcall   ONEMINUS
01f48b dd90      PARSE1: rcall   RFROM           ; a u a
01f48c dd8f              rcall   RFROM           ; a u a u
01f48d dd7c              rcall   ROT             ; a a u u
01f48e ddb7              rcall   MINUS           ; a a n  ( addition to toin
01f48f d156              rcall   TOIN
01f490 de07              rcall   PLUSSTORE       ; aend astart
01f491 dedd              rcall   TUCK            ; astart aend astart
01f492 940d f246         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
01f494 e8f0              fdw     PARSE_L
                 WORD_L:
01f495 7784
01f496 726f
01f497 0064              .db     NFA|4,"word",0
                 WORD:
01f498 dfe2              rcall   PARSE           ; c-addr wlen
01f499 dd5e              rcall   SWOP
01f49a dde1              rcall   ONEMINUS
01f49b ded3              rcall   TUCK
01f49c 940d ff0d         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
01f49e e92a              fdw     WORD_L
                 CMOVE_L:
01f49f 6385
01f4a0 6f6d
01f4a1 6576              .db     NFA|5,"cmove"
                 CMOVE:
01f4a2 dd55              rcall   SWOP
01f4a3 de37              rcall   STORE_P_TO_R
01f4a4 dd6c              rcall   TOR
01f4a5 c003              rjmp    CMOVE2
                 CMOVE1:
01f4a6 d016              rcall   CFETCHPP
01f4a7 de58              rcall   PCSTORE
01f4a8 de5f              rcall   PPLUS
                 CMOVE2:
01f4a9 d51b              rcall   XNEXT
01f4aa f7d8              brcc    CMOVE1
01f4ab 911f              pop     t1
01f4ac 910f              pop     t0
01f4ad de39              rcall   R_TO_P
01f4ae 940d f1f1         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
01f4b0 e93e              fdw     CMOVE_L
                 PLACE_L:
01f4b1 7085
01f4b2 616c
01f4b3 6563              .db     NFA|5,"place"
                 PLACE: 
01f4b4 dc7d              rcall   TWODUP
01f4b5 ded8              rcall   CSTORE_A
01f4b6 dc30              rcall   CHARPLUS
01f4b7 dd40              rcall   SWOP
01f4b8 940d f4a2         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
01f4ba e962              fdw     PLACE_L
                 CFETCHPP_L:
01f4bb 6383
01f4bc 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
01f4bd d263              rcall   DUP
01f4be ddb8              rcall   ONEPLUS
01f4bf dd38              rcall   SWOP
01f4c0 940d feea         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
01f4c2 e976              fdw     CFETCHPP_L
                 FETCHPP_L:
01f4c3 4082
01f4c4 002b              .db     NFA|2,"@+",0
                 FETCHPP:
01f4c5 d25b              rcall   DUP
01f4c6 ddba              rcall   TWOPLUS
01f4c7 dd30              rcall   SWOP
01f4c8 940d febf         jmp     FETCH
                 
01f4ca 2181              .db     NFA|1,"!"
                 STORE_A:        
01f4cb 940d fe76         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
01f4cd e986              fdw    FETCHPP_L
                 NTOC_L:
01f4ce 6e83
01f4cf 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
01f4d0 dfec              rcall   CFETCHPP
01f4d1 d245              rcall   DOLIT
01f4d2 000f              .dw     0x0f
01f4d3 dd7b              rcall   AND_
01f4d4 dd64              rcall   PLUS
01f4d5 940d f0d1         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
01f4d7 e99c              fdw    NTOC_L
                 CTON_L:
01f4d8 6383
01f4d9 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
01f4da d353              rcall   TWOMINUS
01f4db d245              rcall   DUP
01f4dc dead              rcall   CFETCH_A
01f4dd d239              rcall   DOLIT
01f4de 007f              .dw     0x007F
01f4df dddf              rcall   GREATER
01f4e0 de46              rcall   ZEROSENSE
01f4e1 f3c1              breq    CFATONFA
01f4e2 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
01f4e3 e9b0              fdw     CTON_L
                 BRACFIND_L:
01f4e4 2883
01f4e5 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
01f4e6 dc4b              rcall   TWODUP
                 ;        rcall   OVER
                 ;        rcall   CFETCH_A
01f4e7 da8b              rcall   NEQUAL
01f4e8 de44              rcall   DUPZEROSENSE
01f4e9 f021              breq    findi2
01f4ea dd06              rcall   DROP
01f4eb d342              rcall   TWOMINUS ;;;      NFATOLFA
01f4ec d16a              rcall   FETCH_A
01f4ed d233              rcall   DUP
                 findi2:
01f4ee de38              rcall   ZEROSENSE
01f4ef f7b1              brne    findi1
01f4f0 de3c              rcall   DUPZEROSENSE
01f4f1 f041              breq    findi3
01f4f2 de75              rcall   NIP
01f4f3 d22d              rcall   DUP
01f4f4 dfdb              rcall   NFATOCFA
01f4f5 dd02              rcall   SWOP
01f4f6 d009              rcall   IMMEDQ
01f4f7 d22f              rcall   ZEROEQUAL
01f4f8 dc6c              rcall   ONE
01f4f9 dd5d              rcall   OR_
                 findi3: 
01f4fa 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
01f4fb e9c8              fdw     BRACFIND_L
                 IMMEDQ_L:
01f4fc 6986
01f4fd 6d6d
01f4fe 6465
01f4ff 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
01f500 de89              rcall   CFETCH_A
01f501 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
01f502 d214              rcall   DOLIT
01f503 0040              .dw     IMMED
01f504 940d f24f         jmp     AND_
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
01f506 e9f8              fdw     IMMEDQ_L
                 FIND_L:
01f507 6684
01f508 6e69
01f509 0064              .db     NFA|4,"find",0
                 FIND:   
01f50a d20c              rcall   DOLIT
01f50b f552              fdw     kernellink
01f50c dfd9              rcall   findi
01f50d de1f              rcall   DUPZEROSENSE
01f50e f421              brne    FIND1
01f50f dce1              rcall   DROP
01f510 d335              rcall   LATEST_
01f511 d145              rcall   FETCH_A
01f512 dfd3              rcall   findi
                 FIND1:
01f513 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
01f514 ea0e              fdw     FIND_L
                 DIGITQ_L:
01f515 6486
01f516 6769
01f517 7469
01f518 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
01f519 d207              rcall   DUP             ; c c       c c
01f51a d1fc              rcall   DOLIT
01f51b 0039              .dw     0x39            ; c c 39    c c 39
01f51c dda2              rcall   GREATER         ; c 0       c ffff
01f51d de09              rcall   ZEROSENSE
01f51e f019              breq    DIGITQ1
01f51f d1f7              rcall   DOLIT
01f520 0027              .dw     0x27
01f521 dd24              rcall   MINUS
                 DIGITQ1:        
01f522 d1f4              rcall   DOLIT
01f523 0030              .dw     0x30            ; c 30
01f524 dd21              rcall   MINUS           ; 1
01f525 d1fb              rcall   DUP             ; 1 1
01f526 df1b              rcall   BASE            ; 1 1 base
01f527 d12f              rcall   FETCH_A         ; 1 1 10
01f528 dd91              rcall   LESS            ; 1 ffff
01f529 dcd8              rcall   OVER            ; 1 ffff 1
01f52a d204              rcall   ZEROLESS        ; 1 ffff 0
01f52b dd3d              rcall   INVERT
01f52c 940d f24f         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
01f52e ea2a              fdw     DIGITQ_L
                 SIGNQ_L:
01f52f 7385
01f530 6769
01f531 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
01f532 dccf              rcall   OVER
01f533 de56              rcall   CFETCH_A
01f534 d1e2              rcall   DOLIT
01f535 002c              .dw     ','
01f536 dd0f              rcall   MINUS
01f537 d1e9              rcall   DUP
01f538 dcfb              rcall   ABS_
01f539 dc2b              rcall   ONE
01f53a dd7a              rcall   EQUAL
01f53b dd13              rcall   AND_
01f53c ddf0              rcall   DUPZEROSENSE
01f53d f029              breq    QSIGN1
01f53e dd38              rcall   ONEPLUS
01f53f dcd1              rcall   TOR
01f540 dc24              rcall   ONE
01f541 df26              rcall   SLASHSTRING
01f542 dcd9              rcall   RFROM
01f543 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
01f544 ea5e              fdw     SIGNQ_L
                 UDSTAR_L:
01f545 7583
01f546 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
01f547 d1d9              rcall   DUP
01f548 dcc8              rcall   TOR
01f549 dde8              rcall   UMSTAR
01f54a dca6              rcall   DROP
01f54b dcac              rcall   SWOP
01f54c dccf              rcall   RFROM
01f54d dde4              rcall   UMSTAR
01f54e dcbb              rcall   ROT
01f54f 940d f239         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
01f551 ea8a              fdw     UDSTAR_L
                 UDSLASHMOD_L:
01f552 7586
01f553 2f64
01f554 6f6d
01f555 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
01f556 dcba              rcall   TOR             ; ud.l ud.h 
01f557 d161              rcall   FALSE_          ; ud.l ud.h 0
01f558 dcce              rcall   RFETCH          ; ud.l ud.h 0 u
01f559 dddf              rcall   UMSLASHMOD      ; ud.l r.h q.h
01f55a dcaf              rcall   ROT             ; r.h q.h ud.l
01f55b dcae              rcall   ROT             ; q.h ud.l r.h
01f55c dcbf              rcall   RFROM           ; q.h ud.l r.h u
01f55d dddb              rcall   UMSLASHMOD      ; q.h r.l q.l
01f55e 940d f20a         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
01f560 eaa4              fdw     UDSLASHMOD_L
                 TONUMBER_L:
01f561 3e87
01f562 756e
01f563 626d
01f564 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
01f565 ddc7              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
01f566 f0b1              breq    TONUM3
01f567 dca9              rcall   TOR
01f568 d1b8              rcall   DUP
01f569 dca7              rcall   TOR             ; ud.l ud.h adr
01f56a de1f              rcall   CFETCH_A
01f56b dfad              rcall   DIGITQ          ; ud.l ud.h digit flag
01f56c ddba              rcall   ZEROSENSE
01f56d f421              brne    TONUM2
01f56e dc82              rcall   DROP
01f56f dcac              rcall   RFROM
01f570 dcab              rcall   RFROM
01f571 c00b              rjmp    TONUM3
                 TONUM2: 
01f572 dc9e              rcall   TOR             ; ud.l ud.h digit
01f573 dece              rcall   BASE
01f574 d0e2              rcall   FETCH_A
01f575 dfd1              rcall   UDSTAR
01f576 dca5              rcall   RFROM
01f577 dcc9              rcall   MPLUS
01f578 dca3              rcall   RFROM
01f579 dca2              rcall   RFROM
                         
01f57a dbea              rcall   ONE
01f57b deec              rcall   SLASHSTRING
01f57c cfe8              rjmp    TONUM1
                 TONUM3: 
01f57d 9508              ret
                 
                 BASEQV:   
01f57e e81a              fdw     DECIMAL
01f57f e828              fdw     HEX
01f580 e838              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
01f581 eac2              fdw     TONUMBER_L
                 NUMBERQ_L:
01f582 6e87
01f583 6d75
01f584 6562
01f585 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
01f586 d19a              rcall   DUP             ; a a
01f587 d131              rcall   FALSE_          ; a a 0 0
01f588 d130              rcall   FALSE_          ; a a 0 0
01f589 dc80              rcall   ROT             ; a 0 0 a
01f58a df32              rcall   CFETCHPP        ; a 0 0 a' u
01f58b dfa6              rcall   SIGNQ           ; a 0 0 a' u f
01f58c dc84              rcall   TOR             ; a 0 0 a' u
                 
01f58d deb4              rcall   BASE
01f58e d0c8              rcall   FETCH_A
01f58f dc81              rcall   TOR             ; a 0 0 a' u
                         
01f590 dc71              rcall   OVER
01f591 ddf8              rcall   CFETCH_A
                         
01f592 d184              rcall   DOLIT
01f593 0023              .dw     '#'
01f594 dcb1              rcall   MINUS
01f595 d18b              rcall   DUP
01f596 d180              rcall   DOLIT
01f597 0003              .dw     3
01f598 dd2c              rcall   ULESS
01f599 dd8d              rcall   ZEROSENSE
01f59a f041              breq    BASEQ1
01f59b db44              rcall   CELLS
                         
01f59c d17a              rcall   DOLIT
01f59d eafc              fdw     BASEQV
01f59e dc9a              rcall   PLUS
01f59f da5c              rcall   FEXECUTE
                 
01f5a0 dbc4              rcall   ONE
01f5a1 dec6              rcall   SLASHSTRING
01f5a2 c001              rjmp    BASEQ2
                 BASEQ1:
01f5a3 dc4d              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
01f5a4 dfc0              rcall   TONUMBER        ; a ud.l ud.h  a' u
01f5a5 dc76              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
01f5a6 de9b              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
01f5a7 df23              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
01f5a8 d178              rcall   DUP
01f5a9 d284              rcall   TWOMINUS
01f5aa d184              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
01f5ab dd7b              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
01f5ac f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
01f5ad dc6e              rcall   RFROM           ; a ud.l ud.h a' u sign
01f5ae dc42              rcall   DROP
01f5af db7b              rcall   TWODROP
                 QNUM_ERR1:      
01f5b0 db7a              rcall   TWODROP
01f5b1 d107              rcall   FALSE_          ; a 0           Not a number
01f5b2 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
01f5b3 db85              rcall   TWOSWAP         ; a a' u ud.l ud.h 
01f5b4 dc67              rcall   RFROM           ; a a' u ud.l ud.d sign
01f5b5 dd71              rcall   ZEROSENSE
01f5b6 f009              breq    QNUMD1
01f5b7 d43b              rcall   DNEGATE
                 QNUMD1: 
01f5b8 db80              rcall   TWOSWAP         ; a d.l d.h a' u
01f5b9 dd6d              rcall   ZEROSENSE       ; a d.l d.h a'
01f5ba f061              breq    QNUM1
01f5bb 940f feea         call    CFETCH
01f5bd d159              rcall   DOLIT
01f5be 002e              .dw     '.'
01f5bf dc86              rcall   MINUS
01f5c0 dd66              rcall   ZEROSENSE       ; a d.l d.h
01f5c1 f771              brne    QNUM_ERR1
01f5c2 dc47              rcall   ROT             ; d.l d.h a
01f5c3 dc2d              rcall   DROP            ; d.l d.h
01f5c4 d152              rcall   DOLIT         ; 
01f5c5 0002              .dw     2               ; d.l ud.h 2    Double number
01f5c6 c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
01f5c7 db63              rcall   TWODROP         ; a n
01f5c8 dd9f              rcall   NIP             ; n
01f5c9 db9b              rcall   ONE             ; n 1           Single number
                 QNUM3:  
01f5ca 9508              ret
                 
                 
01f5cb 7384
01f5cc 6177
01f5cd 0070              .db     NFA|4,"swap",0
                 SWOP_A:
01f5ce 940d f1f8         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
01f5d0 eb04              fdw     NUMBERQ_L
                 TIBSIZE_L:
01f5d1 7483
01f5d2 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
01f5d3 de5c              rcall   TASK
01f5d4 d082              rcall   FETCH_A
01f5d5 9605              adiw    tosl, 5
01f5d6 940d feea         jmp     CFETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
01f5d8 eba2              fdw     TIBSIZE_L
                 TIB_L:
01f5d9 7483
01f5da 6269              .db     NFA|3,"tib"
                 TIB:
01f5db d005              rcall   TIU
01f5dc 940d febf         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
01f5de ebb2              fdw     TIB_L
                 TIU_L:
01f5df 7483
01f5e0 7569              .db     NFA|3,"tiu"
                 TIU:
01f5e1 de6d              rcall   DOUSER
01f5e2 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
01f5e3 ebbe              fdw     TIU_L
                 TOIN_L:
01f5e4 3e83
01f5e5 6e69              .db     NFA|3,">in"
                 TOIN:
01f5e6 de68              rcall   DOUSER
01f5e7 fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
01f5e8 ebc8              fdw     TOIN_L
                 TICKSOURCE_L:
01f5e9 2787
01f5ea 6f73
01f5eb 7275
01f5ec 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
01f5ed de61              rcall   DOUSER
01f5ee fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
01f5ef ebd2              fdw     TICKSOURCE_L
                 INTERPRET_L:
01f5f0 6989
01f5f1 746e
01f5f2 7265
01f5f3 7270
01f5f4 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
01f5f5 dff7              rcall   TICKSOURCE
01f5f6 db2a              rcall   TWOSTORE
01f5f7 d0c1              rcall   FALSE_
01f5f8 dfed              rcall   TOIN
01f5f9 ded1              rcall   STORE_A
                 IPARSEWORD:
01f5fa d238              rcall   BL
01f5fb de9c              rcall   WORD
                 
01f5fc d124              rcall   DUP
01f5fd dd8c              rcall   CFETCH_A
01f5fe dd28              rcall   ZEROSENSE
01f5ff f409              brne    IPARSEWORD1
01f600 c053              rjmp    INOWORD
                 IPARSEWORD1:
01f601 df08              rcall   FIND            ; sets also wflags
01f602 dd2a              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
01f603 f1a1              breq    INUMBER         ; NUMBER?
01f604 dc72              rcall   ONEPLUS         ; 0 = normal 2 = immediate
01f605 d234              rcall   STATE_
01f606 d120              rcall   ZEROEQUAL
01f607 dc4f              rcall   OR_
01f608 dd1e              rcall   ZEROSENSE
01f609 f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
01f60a fe94              sbrs    wflags, 4       ; Compile only check
01f60b c00a              rjmp    IEXECUTE        ; Not a compile only word
01f60c d22d              rcall   STATE_          ; Compile only word check
01f60d dbab              rcall   XSQUOTE
01f60e 430c
01f60f 4d4f
01f610 4950
01f611 454c
01f612 4f20
01f613 4c4e
01f614 0059              .db     12,"COMPILE ONLY",0
01f615 d0ee              rcall   QABORT
                 IEXECUTE:
01f616 7b6f              cbr     FLAGS1, (1<<noclear)
01f617 d9da              rcall   EXECUTE
01f618 fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
01f619 cfe0              rjmp    IPARSEWORD
01f61a 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f61b 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f61c cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
01f61d 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f61e d102              rcall   DUP
01f61f d0f7              rcall   DOLIT
01f620 ee4e              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
01f621 dc93              rcall   EQUAL
01f622 dd04              rcall   ZEROSENSE
01f623 f011              breq    ICOMPILE_2
01f624 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
01f625 c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
01f626 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f627 d0f9              rcall   DUP
01f628 d0ee              rcall   DOLIT
01f629 ee42              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
01f62a dc8a              rcall   EQUAL
01f62b dcfb              rcall   ZEROSENSE
01f62c f009              breq    ICOMPILE
01f62d 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
01f62e fe95              sbrs    wflags, 5       ; Inline check
01f62f c003              rjmp    ICOMMAXT
01f630 940f f99c         call    INLINE0
01f632 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
01f633 d127              rcall   COMMAXT_A
01f634 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
01f635 fc94              sbrc    wflags, 4            ; Compile only ?
01f636 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f637 cfc2              rjmp    IPARSEWORD
                 INUMBER: 
01f638 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f639 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f63a dbb6              rcall   DROP
01f63b df4a              rcall   NUMBERQ
01f63c dcf0              rcall   DUPZEROSENSE
01f63d f081              breq    IUNKNOWN
01f63e d1fb              rcall   STATE_
01f63f dce7              rcall   ZEROSENSE
01f640 f059              breq    INUMBER1
01f641 2f08              mov     t0, tosl
01f642 9189
01f643 9199              poptos
01f644 ff01              sbrs    t0, 1
01f645 c003              rjmp    ISINGLE
                 IDOUBLE:
01f646 df87              rcall   SWOP_A
01f647 940f fe4a         call    LITERAL
                 ISINGLE:        
01f649 940f fe4a         call    LITERAL
01f64b cfae              rjmp    IPARSEWORD
                 
                 INUMBER1:
01f64c dba4              rcall   DROP
01f64d cfac              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
01f64e dba2              rcall   DROP 
01f64f d045              rcall   DP_TO_RAM
01f650 de6c              rcall   CFETCHPP
01f651 db5a              rcall   TYPE
01f652 d066              rcall   FALSE_
01f653 d0a7              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
01f654 940d f1f1         jmp     DROP
                 
01f656 4081              .db     NFA|1,"@"
                 FETCH_A:        
01f657 940d febf         jmp     FETCH
                 
                 ;;;    bitmask -- 
01f659 ebe0              fdw     INTERPRET_L
                 SHB_L:
01f65a 7383
01f65b 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
01f65c d1e9              rcall   LATEST_
01f65d dff9              rcall   FETCH_A
01f65e d0c2              rcall   DUP
01f65f dd2a              rcall   CFETCH_A
01f660 dba9              rcall   ROT
01f661 dbf5              rcall   OR_
01f662 df6b              rcall   SWOP_A
01f663 940d ff0d         jmp     CSTORE
                         
01f665 ecb4              fdw     SHB_L
                 IMMEDIATE_L:
01f666 6989
01f667 6d6d
01f668 6465
01f669 6169
01f66a 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
01f66b d0ab              rcall   DOLIT
01f66c 0040              .dw     IMMED
01f66d 940d f65c         jmp     SHB
                 
                 ;***************************************************************
01f66f eccc              fdw     IMMEDIATE_L
                 INLINED_L:
01f670 6987
01f671 6c6e
01f672 6e69
01f673 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
01f674 d0a2              rcall   DOLIT
01f675 0020              .dw     INLINE
01f676 940d f65c         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
01f678 ece0              fdw     INLINED_L
                 DOTSTATUS_L:
01f679 2e83
01f67a 7473              .db     NFA|3,".st"
                 DOTSTATUS:
01f67b d09b              rcall   DOLIT
01f67c 003c              .dw     '<'
01f67d d95f              rcall   EMIT
01f67e 940f ffaf         call    DOTBASE
01f680 d95c              rcall   EMIT
01f681 d095              rcall   DOLIT
01f682 002c              .dw     ','
01f683 d959              rcall   EMIT
01f684 940f ffc4         call    MEMQ
01f686 db25              rcall   TYPE
01f687 d08f              rcall   DOLIT
01f688 003e              .dw     '>'
01f689 d953              rcall   EMIT
01f68a 940d f8b4         jmp     DOTS
                 
01f68c 3e82
01f68d 0072              .db     NFA|2,">r",0
01f68e 940d f211 TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
01f690 6181              .db     NFA|1,"a"
                 TEN:
01f691 d99f              rcall   DOCREATE
01f692 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
01f693 6483
01f694 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
01f695 d081              rcall   DOLIT
01f696 2200              .dw     dp_start
01f697 d1bd              rcall   INI
01f698 dff8              rcall   TEN
01f699 940d f4a2         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
01f69b 3e83
01f69c 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
01f69d d079              rcall   DOLIT
01f69e 2200              .dw     dp_start
01f69f dc3b              rcall   STORE_P_TO_R
01f6a0 d1b4              rcall   INI
01f6a1 d075              rcall   DOLIT
01f6a2 0004              .dw     4
01f6a3 db6d              rcall   TOR
                 DP_TO_EEPROM_0: 
01f6a4 de20              rcall   FETCHPP
01f6a5 d07b              rcall   DUP
01f6a6 dc49              rcall   PFETCH
01f6a7 dc06              rcall   NOTEQUAL
01f6a8 dc7e              rcall   ZEROSENSE
01f6a9 f011              breq    DP_TO_EEPROM_1
01f6aa dc4d              rcall   PSTORE
01f6ab c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
01f6ac db44              rcall   DROP
                 DP_TO_EEPROM_2:
01f6ad d3fd              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
01f6ae d316              rcall   XNEXT
01f6af f7a0              brcc    DP_TO_EEPROM_0
01f6b0 911f              pop     t1
01f6b1 910f              pop     t0
01f6b2 dc34              rcall   R_TO_P
01f6b3 940d f1f1         jmp     DROP
                 
01f6b5 ecf2              fdw     DOTSTATUS_L
                 FALSE_L:
01f6b6 6685
01f6b7 6c61
01f6b8 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
01f6b9 939a
01f6ba 938a              pushtos
01f6bb 2788              clr     tosl
01f6bc 2799              clr     tosh
01f6bd 9508              ret
                 
01f6be ed6c              fdw     FALSE_L
                 TRUE_L:
01f6bf 7484
01f6c0 7572
01f6c1 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
01f6c2 939a
01f6c3 938a              pushtos
01f6c4 ef8f              ser     tosl
01f6c5 ef9f              ser     tosh
01f6c6 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
01f6c7 ed7e              fdw     TRUE_L
                 QUIT_L:
01f6c8 7184
01f6c9 6975
01f6ca 0074              .db     NFA|4,"quit",0
                 QUIT:
01f6cb d999              rcall   RPEMPTY
01f6cc d10b              rcall   LEFTBRACKET
01f6cd d9c3              rcall   FRAM
                 QUIT0:  
01f6ce d6b9              rcall   IFLUSH
                         ;; Copy INI and DP's from eeprom to ram
01f6cf dfc5              rcall   DP_TO_RAM
                 QUIT1: 
01f6d0 d8fa              rcall   check_sp
01f6d1 d08e              rcall   CR
01f6d2 df08              rcall   TIB
01f6d3 d04d              rcall   DUP
01f6d4 defe              rcall   TIBSIZE
01f6d5 dfbb              rcall   TEN                 ; Reserve 10 bytes for hold buffer
01f6d6 db6f              rcall   MINUS
01f6d7 da97              rcall   ACCEPT
01f6d8 da69              rcall   SPACE_
01f6d9 df1b              rcall   INTERPRET
01f6da d15f              rcall   STATE_
01f6db dc4b              rcall   ZEROSENSE
01f6dc f799              brne    QUIT1
01f6dd dfbf              rcall   DP_TO_EEPROM
                          
01f6de dada              rcall    XSQUOTE
01f6df 2003
01f6e0 6b6f              .db     3," ok"
01f6e1 daca              rcall    TYPE
01f6e2 d007              rcall   PROMPT_
01f6e3 cfea              rjmp    QUIT0
01f6e4 9508              ret
                 
01f6e5 ed90              fdw     QUIT_L
                 PROMPT_L:
01f6e6 7086
01f6e7 6f72
01f6e8 706d
01f6e9 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
01f6ea 940f ff47         call    DEFER_DOES
01f6ec 220a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
01f6ed edcc              fdw     PROMPT_L
                 ABORT_L:
01f6ee 6185
01f6ef 6f62
01f6f0 7472              .db     NFA|5,"abort"
                 ABORT:
01f6f1 d15a              rcall   S0
01f6f2 df64              rcall   FETCH_A
01f6f3 d96d              rcall   SPSTORE
01f6f4 940d f6cb         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
01f6f6 eddc              fdw     ABORT_L
                 QABORTQ_L:
01f6f7 3f87
01f6f8 6261
01f6f9 726f
01f6fa 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
01f6fb dabd              rcall   XSQUOTE
01f6fc 3f01              .db     1,"?"
01f6fd 940d f704         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
01f6ff edee              fdw     QABORTQ_L
                 QABORT_L:
01f700 3f86
01f701 6261
01f702 726f
01f703 0074              .db     NFA|6,"?abort",0
                 QABORT:
01f704 db05              rcall   ROT
01f705 dc21              rcall   ZEROSENSE
01f706 f419              brne    QABO1
                 QABORT1:        
01f707 da3a              rcall   SPACE_
01f708 daa3              rcall   TYPE
01f709 dfe7              rcall   ABORT  ; ABORT never returns
01f70a 940d f12b QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
01f70c ee00              fdw     QABORT_L
                 ABORTQUOTE_L:
01f70d 61d6
01f70e 6f62
01f70f 7472
01f710 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
01f711 daba              rcall   SQUOTE
01f712 d93a              rcall   DOCOMMAXT
01f713 ee08              fdw     QABORT
01f714 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
01f715 6c83
01f716 7469              .db     NFA|3, "lit"
                 DOLIT:
01f717 91ff              m_pop_zh
01f718 91ff              pop     zh
01f719 91ef              pop     zl
01f71a d929              rcall   FETCHLIT
01f71b 95f7              ror     zh
01f71c 95e7              ror     zl
01f71d 9419              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
01f71e e44a              fdw     RFETCH_L
                 DUP_L:
01f71f 64a3
01f720 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
01f721 939a
01f722 938a              pushtos
01f723 9508              ret
                 
01f724 e558              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
01f725 3082
01f726 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:      
01f727 2b98              or      tosh, tosl
01f728 f441              brne    FALSE_F
                 TRUE_F:
01f729 ef9f              ser     tosh
01f72a ef8f              ser     tosl
                 ZEROEQUAL_1:
01f72b 9508              ret
                 
01f72c ee4a              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
01f72d 3082
01f72e 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
01f72f 2399              tst     tosh
01f730 f3c2              brmi    TRUE_F
                 FALSE_F:
01f731 2799              clr     tosh
01f732 2788              clr     tosl
01f733 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
01f734 ee1a              fdw     ABORTQUOTE_L
                 TICK_L:
01f735 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
01f736 d0fc              rcall   BL
01f737 dd60              rcall   WORD
01f738 ddd1              rcall   FIND
01f739 940d f6fb         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
01f73b ee6a              fdw     TICK_L
                 CHAR_L:
01f73c 6384
01f73d 6168
01f73e 0072              .db     NFA|4,"char",0
                 CHAR:
01f73f d0f3              rcall   BL
01f740 dd3a              rcall   PARSE
01f741 daaf              rcall   DROP
01f742 940d feea         jmp     CFETCH
                 
                 ; (    --                     skip input until )
01f744 ee78              fdw     CHAR_L
                 PAREN_L:
01f745 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
01f746 dfd0              rcall   DOLIT
01f747 0029              .dw     ')'
01f748 dd32              rcall   PARSE
01f749 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
01f74a 940d f12b         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
01f74c 6985
01f74d 6568
01f74e 6572              .db     NFA|5,"ihere"
                 IHERE:
01f74f d066              rcall   IDP
01f750 cf06              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
01f751 ee8a              fdw     PAREN_L
                 BRACCHAR_L:
01f752 5bd6
01f753 6863
01f754 7261
01f755 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
01f756 dfe8              rcall   CHAR
01f757 940d fe4a         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
01f759 6383
01f75a 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
01f75b 940d f0f1         jmp     COMMAXT
                 
                 ; CR      --                      output newline
01f75d eea4              fdw     BRACCHAR_L
                 CR_L:
01f75e 6382
01f75f 0072              .db     NFA|2,"cr",0
                 CR:
01f760 dfb6              rcall   DOLIT
01f761 000d              .dw     0x0d       ; CR \r
01f762 d87a              rcall   EMIT
01f763 dfb3              rcall   DOLIT
01f764 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
01f765 940d efdd         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
01f767 eebc              fdw     CR_L
                 CREATE_L:
01f768 6386
01f769 6572
01f76a 7461
01f76b 0065              .db     NFA|6,"create",0
                 CREATE:
01f76c d0c6              rcall   BL
01f76d dd2a              rcall   WORD            ; Parse a word
                 
01f76e dfb2              rcall   DUP             ; Remember parsed word at rhere
01f76f dd9a              rcall   FIND
01f770 dbf7              rcall   NIP
01f771 dfb5              rcall   ZEROEQUAL
01f772 da46              rcall   XSQUOTE
01f773 410f
01f774 524c
01f775 4145
01f776 5944
01f777 4420
01f778 4645
01f779 4e49
01f77a 4445              .db     15,"ALREADY DEFINED"
01f77b df88              rcall   QABORT         ; ABORT if word has already been defined
01f77c dfa4              rcall   DUP             ; Check the word length 
01f77d dc0c              rcall   CFETCH_A
01f77e d9e6              rcall   ONE
01f77f df97              rcall   DOLIT
01f780 0010              .dw     16
01f781 db22              rcall   WITHIN
01f782 df78              rcall   QABORTQ          ; Abort if there is no name for create
                 
01f783 d0c2              rcall   LATEST_
01f784 ded2              rcall   FETCH_A
01f785 940f ff9d         call    ICOMMA          ; Link field
01f787 dd35              rcall   CFETCHPP        ; str len
01f788 dfc6              rcall   IHERE
01f789 df97              rcall   DUP             
01f78a d0bb              rcall   LATEST_         ; new 'latest' link
01f78b dd3f              rcall   STORE_A         ; str len ihere
01f78c dd27              rcall   PLACE           ; 
01f78d dfc1              rcall   IHERE           ; ihere
01f78e dbfb              rcall   CFETCH_A
01f78f df87              rcall   DOLIT
01f790 0080              .dw     NFA
01f791 deca              rcall   SHB
01f792 dae4              rcall   ONEPLUS
01f793 d93d              rcall   ALIGNED
01f794 d160              rcall   IALLOT          ; The header has now been created
01f795 df81              rcall   DOLIT             
01f796 e062              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
01f797 d962              rcall   STORECFF1       ; Append an exeution token, CALL !
01f798 d92e              rcall   ALIGN
01f799 d90e              rcall   HERE            ; compiles the current dataspace dp into the dictionary
01f79a d903              rcall   CSE_
01f79b db8b              rcall   ZEROSENSE
01f79c f409              brne    CREATE2
01f79d dae3              rcall   TWOPLUS
                 CREATE2:
01f79e 940d ff9d         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
01f7a0 eed0              fdw    CREATE_L
                 POSTPONE_L:
01f7a1 70d8
01f7a2 736f
01f7a3 7074
01f7a4 6e6f
01f7a5 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
01f7a6 d08c              rcall   BL
01f7a7 dcf0              rcall   WORD
01f7a8 dd61              rcall   FIND
01f7a9 df77              rcall   DUP
01f7aa df50              rcall   QABORTQ
01f7ab df83              rcall   ZEROLESS
01f7ac db7a              rcall   ZEROSENSE
01f7ad f021              breq    POSTPONE1
01f7ae d89e              rcall   DOCOMMAXT
01f7af e09a              fdw     DOCOMMAXT
01f7b0 940d ff9d         jmp     ICOMMA
                 POSTPONE1:
01f7b2 940d f0f1         jmp     COMMAXT
                 
                 
                 IDP_L:
01f7b4 6983
01f7b5 7064              .db     NFA|3,"idp"
                 IDP:
01f7b6 d87a              rcall   DOCREATE
01f7b7 03ba              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
01f7b8 2887
01f7b9 6f64
01f7ba 7365
01f7bb 293e              .db     NFA|7,"(does>)"
                 XDOES:
01f7bc 91ff              m_pop_zh
01f7bd da5e              rcall   RFROM
01f7be d087              rcall   LATEST_
01f7bf de97              rcall   FETCH_A
01f7c0 dd0f              rcall   NFATOCFA
01f7c1 dff4              rcall   IDP
01f7c2 de94              rcall   FETCH_A
01f7c3 deca              rcall   TOR_A
01f7c4 dff1              rcall   IDP
01f7c5 dd05              rcall   STORE_A
01f7c6 0f88              lsl     tosl
01f7c7 1f99              rol     tosh
01f7c8 d931              rcall   STORECFF1 ; Always stores a 4 byte call
01f7c9 da52              rcall   RFROM
01f7ca dfeb              rcall   IDP
01f7cb 940d fe76         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
01f7cd ef42              fdw     POSTPONE_L
                 DOES_L:
01f7ce 64d5
01f7cf 656f
01f7d0 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
01f7d1 d87b      DOES:   rcall   DOCOMMAXT
01f7d2 ef78              fdw     XDOES
01f7d3 d879              rcall   DOCOMMAXT
01f7d4 e076              fdw     DODOES
01f7d5 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
01f7d6 ef9c              fdw     DOES_L
                 LEFTBRACKET_L:
01f7d7 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
01f7d8 7000              cbr     t0, 0xff
01f7d9 9300 03c9         sts     state, t0
01f7db 9508              ret
                 
                 
                 ; ]        --      enter compiling state
01f7dc efae              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
01f7dd 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
01f7de 6f0f              sbr     t0, 0xff
01f7df 9300 03c9         sts     state, t0
01f7e1 9508              ret
                 
                 ; :        --           begin a colon definition
01f7e2 efba              fdw     RIGHTBRACKET_L
                 COLON_L:
01f7e3 3a81              .db     NFA|1,":"
                 COLON:
01f7e4 df87              rcall   CREATE
01f7e5 dff8              rcall   RIGHTBRACKET
01f7e6 940d f111         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
01f7e8 efc6              fdw     COLON_L
                 NONAME_L:
01f7e9 3a87
01f7ea 6f6e
01f7eb 616e
01f7ec 656d              .db     NFA|7,":noname"
                 NONAME:
01f7ed df61              rcall   IHERE
01f7ee 940d f7de         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
01f7f0 efd2              fdw     NONAME_L
                 SEMICOLON_L:
01f7f1 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
01f7f2 dfe5              rcall   LEFTBRACKET
01f7f3 fd61              sbrc    FLAGS1, fTAILC
01f7f4 c025              rjmp    ADD_RETURN_1
01f7f5 df59              rcall   IHERE
01f7f6 d02a              rcall   MINUS_FETCH
01f7f7 018c              movw    t0, tosl
01f7f8 7f10              andi    t1, 0xf0
01f7f9 5d10              subi    t1, 0xd0
01f7fa f059              breq    RCALL_TO_JMP
01f7fb 9189
01f7fc 9199              poptos
01f7fd d023              rcall   MINUS_FETCH
                 .ifdef EIND
01f7fe 508f              subi    tosl, 0x0f
                 .else
                 .endif
01f7ff 4994              sbci    tosh, 0x94
01f800 f4c1              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
01f801 e08d              ldi     tosl, 0x0d
                 .else
                 .endif
01f802 e994              ldi     tosh, 0x94
01f803 d9f4              rcall   SWOP
01f804 940d fe76         jmp     STORE
                 RCALL_TO_JMP:
01f806 db61              rcall   NIP
01f807 709f              andi    tosh, 0x0f
01f808 fd93              sbrc    tosh, 3
01f809 6f90              ori     tosh, 0xf0
01f80a da81              rcall   TWOSTAR
01f80b df43              rcall   IHERE
01f80c da2c              rcall   PLUS
01f80d df09              rcall   DOLIT
01f80e fffe              .dw     -2
01f80f d0e5              rcall   IALLOT
01f810 df06              rcall   DOLIT
                 .ifdef EIND
01f811 940d              .dw     0x940d
                 .else
                 .endif
01f812 940f ff9d         call    ICOMMA
                         sub_pflash_tos
01f814 9408              rampv_to_c
01f815 9597              ror     tosh
01f816 9587              ror     tosl
01f817 940d ff9d         jmp     ICOMMA
                 ADD_RETURN:
01f819 d911              rcall   TWODROP
                 ADD_RETURN_1:
01f81a defc              rcall   DOLIT   ; Compile a ret
01f81b 9508              .dw     0x9508
01f81c 940d ff9d         jmp    ICOMMA
                 
                 
                 
01f81e efe2              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
01f81f 2d82
01f820 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
01f821 d00c              rcall   TWOMINUS
01f822 defe              rcall   DUP
01f823 940d febf         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
01f825 f03e              fdw     MINUS_FETCH_L
                 BRACTICK_L:
01f826 5bd3
01f827 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
01f828 df0d              rcall   TICK       ; get xt of 'xxx'
01f829 940d fe4a         jmp     LITERAL
                 
                 ; 2-    n -- n-2
01f82b f04c              fdw     BRACTICK_L
                 TWOMINUS_L:
01f82c 32a2
01f82d 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
01f82e 9702              sbiw    tosl, 2
01f82f 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
01f830 f058              fdw     TWOMINUS_L
                 BL_l:
01f831 6282
01f832 006c              .db     NFA|2,"bl",0
                 BL:
01f833 940f f031         call    DOCREATE
01f835 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
01f836 f062              fdw     BL_L
                 STATE_L:
01f837 7385
01f838 6174
01f839 6574              .db     NFA|5,"state"
                 STATE_:
01f83a 939a
01f83b 938a              pushtos
01f83c 9180 03c9         lds     tosl, state
01f83e 9190 03c9         lds     tosh, state
01f840 9508              ret
                 
                 ; LATEST    -- a-addr           
01f841 f06e              fdw     STATE_L
                 LATEST_L:
01f842 6c86
01f843 7461
01f844 7365
01f845 0074              .db     NFA|6,"latest",0
                 LATEST_:
01f846 940f f031         call    DOCREATE
01f848 03c0              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
01f849 f084              fdw     LATEST_L
                 S0_L:
01f84a 7382
01f84b 0030              .db     NFA|2,"s0",0
                 S0:
01f84c dc02              rcall   DOUSER
01f84d ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
01f84e f094              fdw     S0_L
                 R0_L:
01f84f 7282
01f850 0030              .db     NFA|2,"r0",0
                 R0_:
01f851 dbfd              rcall   DOUSER
01f852 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
01f853 6983
01f854 696e              .db     NFA|3,"ini"
                 INI:
01f855 940f f031          call   DOCREATE
01f857 03b8              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
01f858 f09e              fdw     R0_L
                 TICKS_L:
01f859 7485
01f85a 6369
01f85b 736b              .db     NFA|5,"ticks"
                 TICKS:
01f85c 939a
01f85d 938a              pushtos
01f85e b60f              in_     t2, SREG
01f85f 94f8              cli
01f860 2d8e              mov     tosl, ms_count
01f861 2d9f              mov     tosh, ms_count1
01f862 be0f              out_    SREG, t2
01f863 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
01f864 f0b2              fdw     TICKS_L
                 MS_L:
01f865 6d82
01f866 0073              .db     NFA|2,"ms",0
                 MS:
01f867 dff4              rcall   TICKS
01f868 d9d0              rcall   PLUS
                 MS1:    
01f869 d707              rcall   PAUSE
01f86a deb6              rcall   DUP
01f86b dff0              rcall   TICKS
01f86c d9d9              rcall   MINUS
01f86d dec1              rcall   ZEROLESS
01f86e dab8              rcall   ZEROSENSE
01f86f f3c9              breq    MS1
01f870 940d f1f1         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
01f872 f0ca              fdw     MS_L
                 DOTID_L:
01f873 2e83
01f874 6469              .db     NFA|3,".id"
                 DOTID:
01f875 dc47              rcall   CFETCHPP
01f876 dea0              rcall   DOLIT
01f877 000f              .dw     0x0f
01f878 d9d6              rcall   AND_
01f879 d997              rcall   TOR
01f87a c003              rjmp    DOTID3
                 DOTID1:
01f87b dc41              rcall   CFETCHPP
01f87c d00a              rcall   TO_PRINTABLE
01f87d dee7              rcall   EMIT_A
                 DOTID3:
01f87e d146              rcall   XNEXT
01f87f f7d8              brcc    DOTID1  
01f880 911f              pop     t1
01f881 910f              pop     t0
01f882 940d f1f1         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
01f884 f0e6              fdw     DOTID_L
                 TO_PRINTABLE_L:
01f885 3e83
01f886 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:   
01f887 3080              cpi     tosl, 0
01f888 f012              brmi    TO_PRINTABLE1
01f889 3280              cpi     tosl, 0x20
01f88a f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
01f88b e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
01f88c 9508              ret
                 
                  ; WORDS    --          list all words in dict.
01f88d f10a              fdw     TO_PRINTABLE_L
                 WORDS_L:
01f88e 7785
01f88f 726f
01f890 7364              .db     NFA|5,"words"
01f891 de27              rcall   FALSE_
01f892 decd              rcall   CR
01f893 de83              rcall   DOLIT
01f894 f552              fdw     kernellink
01f895 d005              rcall   WDS1
01f896 de22              rcall   FALSE_
01f897 dec8              rcall   CR
01f898 dec7      		rcall   CR
01f899 dfac              rcall   LATEST_
01f89a ddbc              rcall   FETCH_A
01f89b de85      WDS1:   rcall   DUP
01f89c dfd8              rcall   DOTID
01f89d dd30              rcall   SWOP_A
01f89e d9d8              rcall   ONEPLUS
01f89f de81              rcall   DUP
01f8a0 de76              rcall   DOLIT
01f8a1 0007              .dw     7
01f8a2 d9ac              rcall   AND_
01f8a3 da83              rcall   ZEROSENSE
01f8a4 f021              breq    WDS2
01f8a5 de71              rcall   DOLIT
01f8a6 0009              .dw     9
01f8a7 debd              rcall   EMIT_A
01f8a8 c001              rjmp    WDS3
                 WDS2:   
01f8a9 deb6              rcall   CR
                 WDS3:
01f8aa dd23              rcall   SWOP_A
                 
01f8ab df82              rcall   TWOMINUS
01f8ac ddaa              rcall   FETCH_A
01f8ad da7f              rcall   DUPZEROSENSE
01f8ae f761              brne    WDS1
01f8af 940d f12b         jmp     TWODROP
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
01f8b1 f11c              fdw     WORDS_L
                 DOTS_L:
01f8b2 2e82
01f8b3 0073              .db     NFA|2,".s",0
                 DOTS:
01f8b4 d88d              rcall   SPACE_
01f8b5 de6b              rcall   DUP          ; push tosl:tosh to memory
01f8b6 940f f05a         call    SPFETCH
01f8b8 df93              rcall   S0
01f8b9 dd9d              rcall   FETCH_A
01f8ba df73              rcall   TWOMINUS
                 DOTS1:
01f8bb d876              rcall   TWODUP
01f8bc d9fd              rcall   LESS
01f8bd da69              rcall   ZEROSENSE
01f8be f019              breq    DOTS2
01f8bf df61              rcall   MINUS_FETCH
01f8c0 db21              rcall   UDOT
01f8c1 cff9              rjmp    DOTS1
                 DOTS2:  
01f8c2 d92e              rcall   DROP
01f8c3 940d f12b         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
01f8c5 f164              fdw     DOTS_L
                 DUMP_L:
01f8c6 6484
01f8c7 6d75
01f8c8 0070              .db     NFA|4,"dump",0
                 DUMP:
01f8c9 de4d              rcall   DOLIT
01f8ca 0010              .dw     16
01f8cb da7f              rcall   USLASH
01f8cc d944              rcall   TOR
01f8cd c020              rjmp    DUMP7
                 DUMP1:  
01f8ce de91              rcall   CR
01f8cf de51              rcall   DUP
01f8d0 de46              rcall   DOLIT
01f8d1 0004              .dw     4
01f8d2 db19              rcall   UDOTR
01f8d3 de43              rcall   DOLIT
01f8d4 003a              .dw     ':'
01f8d5 de8f              rcall   EMIT_A
01f8d6 de40              rcall   DOLIT
01f8d7 000f              .dw     15
01f8d8 d938              rcall   TOR
                 DUMP2:
01f8d9 dbe3              rcall   CFETCHPP
01f8da de3c              rcall   DOLIT
01f8db 0002              .dw     2
01f8dc db0f              rcall   UDOTR
01f8dd d0e7              rcall   XNEXT
01f8de f7d0              brcc    DUMP2
01f8df 911f              pop     t1
01f8e0 910f              pop     t0
                 
01f8e1 de35              rcall   DOLIT
01f8e2 0010              .dw     16
01f8e3 d962              rcall   MINUS
01f8e4 de32              rcall   DOLIT
01f8e5 000f              .dw     15
01f8e6 d92a              rcall   TOR
                 DUMP4:  
01f8e7 dbd5              rcall   CFETCHPP
01f8e8 df9e              rcall   TO_PRINTABLE
01f8e9 de7b              rcall   EMIT_A
01f8ea d0da              rcall   XNEXT
01f8eb f7d8              brcc    DUMP4
01f8ec 911f              pop     t1
01f8ed 910f              pop     t0
                 DUMP7:
01f8ee d0d6              rcall   XNEXT
01f8ef f6f0              brcc    DUMP1
01f8f0 911f              pop     t1
01f8f1 910f              pop     t0
01f8f2 940d f1f1         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
01f8f4 2081              .db     NFA|1," "
                 IALLOT:
01f8f5 dec0              rcall   IDP
01f8f6 940d f298         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
01f8f8 f18c              fdw     DUMP_L
                 X_TO_R_L:
01f8f9 7883
01f8fa 723e              .db     NFA|3,"x>r"
                 X_TO_R:
01f8fb 01fc              movw    zl, tosl
01f8fc 9189
01f8fd 9199              poptos
01f8fe d00a              rcall   TO_XA
01f8ff 9631              adiw    zl, 1
01f900 9382              st      -z, tosl
01f901 9392              st      -z, tosh
                 .ifdef EIND
01f902 9262              st      -z, r_one
                 .endif
01f903 9252              st      -z, zero
01f904 01cf              movw    tosl, zl
01f905 9508              ret
                 ;***************************************************************
01f906 f1f2              fdw     X_TO_R_L
                 TO_XA_L:
01f907 3e83
01f908 6178              .db NFA|3,">xa"
                 TO_XA:
                          sub_pflash_tos
01f909 9408               rampv_to_c
01f90a 9597               ror tosh
01f90b 9587               ror tosl
01f90c 9508               ret
                 
01f90d f20e               fdw     TO_XA_L
                 XA_FROM_L:
01f90e 7883
01f90f 3e61              .db NFA|3,"xa>"
                 XA_FROM:
01f910 0f88               lsl     tosl
01f911 1f99               rol     tosh
                          add_pflash_tos
01f912 9508               ret
                 ;***************************************************************
01f913 f21c               fdw    XA_FROM_L
                 PFL_L:
01f914 7083
01f915 6c66              .db     NFA|3,"pfl"
                 PFL:
01f916 940f f031          call   DOCREATE
01f918 0000              .dw     PFLASH
                 ;***************************************************************
01f919 f228              fdw    PFL_L
                 ZFL_L:
01f91a 7a83
01f91b 6c66              .db     NFA|3, "zfl"
                 ZFL:
01f91c 940f f031          call   DOCREATE
01f91e 0003              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
01f91f 2c84
01f920 303f
01f921 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
01f922 fd65              sbrc    FLAGS1, idup
01f923 c003              rjmp    COMMAZEROSENSE1
01f924 ddf2              rcall   DOLIT
01f925 e64e              fdw     ZEROSENSE
01f926 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
01f927 d004              rcall   IDPMINUS
01f928 ddee              rcall   DOLIT
01f929 e65a              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
01f92a 7d6f              cbr     FLAGS1, (1<<idup)
01f92b c070              rjmp    INLINE0
                 
                 IDPMINUS:
01f92c ddea              rcall   DOLIT
01f92d fffc              .dw     -4
01f92e cfc6              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
01f92f d962              rcall   TWOSLASH
01f930 709f              andi    tosh, 0x0f
01f931 6c90              ori     tosh, 0xc0
01f932 940d ff9d         jmp     ICOMMA
                 
                 
                 BRCCC:
01f934 dde2              rcall   DOLIT
01f935 f008              .dw     0xf008      ; brcc pc+2
01f936 940d ff9d         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
01f938 ddde              rcall   DOLIT
01f939 f409              .dw     0xf409      ; brne pc+2
01f93a fd64              sbrc    FLAGS1, izeroeq
01f93b 7f9b              andi    tosh, ~4
01f93c 940d ff9d         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
01f93e f234              fdw     ZFL_L
                 IF_L:
01f93f 69d2
01f940 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
01f941 fd64              sbrc    FLAGS1, izeroeq
01f942 dfe9              rcall   IDPMINUS
01f943 dfde              rcall   COMMAZEROSENSE
01f944 dff3              rcall   BRNEC
01f945 7e6f              cbr     FLAGS1, (1<<izeroeq)
01f946 de08              rcall   IHERE
01f947 dd71              rcall   FALSE_
01f948 940d f92f         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
01f94a f27e              fdw     IF_L
                 ELSE_L:
01f94b 65d4
01f94c 736c
01f94d 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
01f94e de00              rcall   IHERE
01f94f dd69              rcall   FALSE_
01f950 dfde              rcall   RJMPC
01f951 dc7c              rcall   SWOP_A      ; else-addr  if-addr 
01f952 940d f958         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
01f954 f296              fdw     ELSE_L
                 THEN_L:
01f955 74d4
01f956 6568
01f957 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
01f958 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f959 ddf5              rcall   IHERE
01f95a d8a7              rcall   OVER
01f95b d8ea              rcall   MINUS
01f95c ded1              rcall   TWOMINUS
01f95d d934              rcall   TWOSLASH
01f95e ddb8              rcall   DOLIT
01f95f c000              .dw     0xc000      ;  back-addr mask 
01f960 d8f6              rcall   OR_
01f961 dc6c              rcall   SWOP_A
01f962 940d fe76         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
01f964 f2aa              fdw     THEN_L
                 BEGIN_L:
01f965 62d5
01f966 6765
01f967 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
01f968 940d f74f         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
01f96a f2ca              fdw     BEGIN_L
                 UNTIL_L:
01f96b 75d5
01f96c 746e
01f96d 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
01f96e 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f96f fd64              sbrc    FLAGS1, izeroeq
01f970 dfbb              rcall   IDPMINUS
01f971 dfb0              rcall   COMMAZEROSENSE
01f972 dfc5              rcall   BRNEC
01f973 7e6f              cbr     FLAGS1, (1<<izeroeq)
01f974 940d f97a 	    jmp     AGAIN_
                 
                 				; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
01f976 f2d6              fdw     UNTIL_L
                 AGAIN_L:
01f977 61d5
01f978 6167
01f979 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
01f97a 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f97b ddd3              rcall   IHERE
01f97c d8c9              rcall   MINUS
01f97d deb0              rcall   TWOMINUS
01f97e 940d f92f         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
01f980 f2ee              fdw     AGAIN_L
                 WHILE_L:
01f981 77d5
01f982 6968
01f983 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
01f984 dfbc              rcall   IF_
01f985 940d f1f8         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
01f987 f302              fdw     WHILE_L
                 REPEAT_L:
01f988 72d6
01f989 7065
01f98a 6165
01f98b 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
01f98c dfed              rcall   AGAIN_
01f98d 940d f958         jmp     THEN_
                 
01f98f f310              fdw     REPEAT_L
                 INLINE_L:
01f990 69d6
01f991 6c6e
01f992 6e69
01f993 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
01f994 7e6f              cbr      FLAGS1, (1<<izeroeq)
01f995 7d6f              cbr      FLAGS1, (1<<idup)
01f996 dd9f              rcall    TICK
01f997 940d f99c         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
01f999 f320              fdw      INLINE_L
                 INLINEC_L:
01f99a 6983
01f99b 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
01f99c db28              rcall   FETCHPP
01f99d dd83              rcall   DUP
01f99e dd78              rcall   DOLIT
01f99f 9508              .dw     0x9508
01f9a0 d90d              rcall   NOTEQUAL
01f9a1 d985              rcall   ZEROSENSE
01f9a2 f011              breq    INLINE1
01f9a3 d5f9              rcall   ICOMMA
01f9a4 cff7              rjmp    INLINE0
                 INLINE1:
01f9a5 940d f12b         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
01f9a7 f334              fdw     INLINEC_L
                 FOR_L:
01f9a8 66d3
01f9a9 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
01f9aa 940f f04d         call    DOCOMMAXT
01f9ac e422              fdw     TOR
01f9ad dda1              rcall   IHERE
01f9ae dd0a              rcall   FALSE_
01f9af df7f              rcall   RJMPC
01f9b0 dd9e              rcall   IHERE
01f9b1 940d f1f8         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
01f9b3 f350              fdw     FOR_L
                 NEXT_L:
01f9b4 6ed4
01f9b5 7865
01f9b6 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
01f9b7 dfa0              rcall   THEN_
01f9b8 940f f04d         call    DOCOMMAXT
01f9ba f38a              fdw     XNEXT
01f9bb df78              rcall   BRCCC
                 
01f9bc dfbd              rcall   AGAIN_
                 
01f9bd dd59              rcall   DOLIT
01f9be f39e              fdw     XNEXT1
01f9bf 940d f99c         jmp     INLINE0
                 ; (next) decrement top of return stack
01f9c1 2887
01f9c2 656e
01f9c3 7478
01f9c4 2029              .db     NFA|7,"(next) "
                 XNEXT:  
01f9c5 91ff              m_pop_zh
01f9c6 91ff              pop     zh
01f9c7 91ef              pop     zl
01f9c8 91bf              pop     xh
01f9c9 91af              pop     xl
01f9ca 9711              sbiw    xl, 1
01f9cb 93af              push    xl
01f9cc 93bf              push    xh
01f9cd 9419              mijmp
01f9ce 9508              ret
                 XNEXT1:
01f9cf 911f              pop     t1
01f9d0 910f              pop     t0
01f9d1 9508              ret
                 
                 ; leave clear top of return stack
01f9d2 f368              fdw     NEXT_L
                 LEAVE_L:
01f9d3 6595
01f9d4 646e
01f9d5 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
01f9d6 91ff              m_pop_zh
01f9d7 91ff              pop     zh
01f9d8 91ef              pop     zl
01f9d9 911f              pop     t1
01f9da 910f              pop     t0
01f9db 2700              clr     t0
01f9dc 2711              clr     t1
01f9dd 930f              push    t0
01f9de 931f              push    t1
01f9df 9419              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
01f9e0 f3a6              fdw      LEAVE_L
                 RDROP_L:
01f9e1 72d5
01f9e2 7264
01f9e3 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
01f9e4 dd32              rcall   DOLIT
01f9e5 f39e              fdw     XNEXT1
01f9e6 940d f99c         jmp     INLINE0
                 ;***************************************************
01f9e8 f3c2              fdw     RDROP_L
                 STOD_L:
01f9e9 7383
01f9ea 643e              .db     NFA|3,"s>d"
                 STOD:
01f9eb ff97              sbrs    tosh, 7
01f9ec cccc              rjmp    FALSE_
01f9ed ccd4              rjmp    TRUE_
                 ;***************************************************
01f9ee f3d2              fdw     STOD_L
                 DNEGATE_L:
01f9ef 6487
01f9f0 656e
01f9f1 6167
01f9f2 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
01f9f3 d049              rcall   DINVERT
01f9f4 940f f165         call    ONE
01f9f6 940d f241         jmp     MPLUS
                 ;***************************************************
01f9f8 f3de              fdw     DNEGATE_L
                 QDNEGATE_L:
01f9f9 3f88
01f9fa 6e64
01f9fb 6765
01f9fc 7461
01f9fd 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
01f9fe dd30              rcall   ZEROLESS
01f9ff d927              rcall   ZEROSENSE
01fa00 f009              breq    QDNEGATE1
01fa01 dff1              rcall   DNEGATE
                 QDNEGATE1:
01fa02 9508              ret
                 
                 ;***************************************************
01fa03 f3f2              fdw     QDNEGATE_L
                 DABS_L:
01fa04 6484
01fa05 6261
01fa06 0073              .db     NFA|4,"dabs",0
                 DABS:
01fa07 dd19              rcall   DUP
01fa08 940d f9fe         jmp     QDNEGATE
                 ;***************************************************
01fa0a f408              fdw     DABS_L
                 DPLUS_L:
01fa0b 6482
01fa0c 002b              .db     NFA|2,"d+",0
                 DPLUS:
01fa0d 91a9              ld      xl, Y+
01fa0e 91b9              ld      xh, Y+
01fa0f 9009              ld      t2, Y+
01fa10 9019              ld      t3, Y+
01fa11 9109              ld      t0, Y+
01fa12 9119              ld      t1, Y+
01fa13 0fa0              add     xl, t0
01fa14 1fb1              adc     xh, t1
01fa15 1d80              adc     tosl, t2
01fa16 1d91              adc     tosh, t3
01fa17 93ba              st      -Y, xh
01fa18 93aa              st      -Y, xl
01fa19 9508              ret
                 
                 ;***************************************************
01fa1a f416              fdw     DPLUS_L
                 DMINUS_L:
01fa1b 6482
01fa1c 002d              .db     NFA|2,"d-",0
                 DMINUS:
01fa1d dfd5              rcall   DNEGATE
01fa1e 940d fa0d         jmp     DPLUS
                 ;***************************************************
01fa20 f436              fdw     DMINUS_L
                 DTWOSLASH_L:
01fa21 6483
01fa22 2f32              .db     NFA|3,"d2/"
01fa23 9109              ld      t0, y+
01fa24 9119              ld      t1, y+
01fa25 9595              asr     tosh
01fa26 9587              ror     tosl
01fa27 9517              ror     t1
01fa28 9507              ror     t0
01fa29 931a              st      -y, t1
01fa2a 930a              st      -y, t0
01fa2b 9508              ret
                 ;***************************************************
01fa2c f442              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
01fa2d 6483
01fa2e 2a32              .db     NFA|3,"d2*"
01fa2f 9109              ld      t0, y+
01fa30 9119              ld      t1, y+
01fa31 0f00              lsl     t0
01fa32 1f11              rol     t1
01fa33 1f88              rol     tosl
01fa34 1f99              rol     tosh
01fa35 931a              st      -y, t1
01fa36 930a              st      -y, t0
01fa37 9508              ret
                 ;***************************************************
01fa38 f45a              fdw     DTWOSTAR_L
                 DINVERT_L:
01fa39 6487
01fa3a 6e69
01fa3b 6576
01fa3c 7472              .db     NFA|7,"dinvert"
                 DINVERT:
01fa3d 91a9              ld      xl, y+
01fa3e 91b9              ld      xh, y+
01fa3f 95a0              com     xl
01fa40 95b0              com     xh
01fa41 9580              com     tosl
01fa42 9590              com     tosh
01fa43 93ba              st      -y, xh
01fa44 93aa              st      -y, xl
01fa45 9508              ret
                 ;***************************************************
01fa46 f472              fdw     DINVERT_L
                 DZEROEQUAL_L:
01fa47 6483
01fa48 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
01fa49 91a9              ld      xl, y+
01fa4a 91b9              ld      xh, y+
01fa4b 2b89              or      tosl, tosh
01fa4c 2b8a              or      tosl, xl
01fa4d 2b8b              or      tosl, xh
01fa4e f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
01fa4f ef8f              ser     tosl
01fa50 ef9f              ser     tosh
01fa51 9508              ret
                 
                 ;***************************************************
01fa52 f48e              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
01fa53 6483
01fa54 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
01fa55 91a9              ld      xl, y+
01fa56 91b9              ld      xh, y+
01fa57 3090              cpi     tosh, 0
01fa58 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
01fa59 2788              clr     tosl
01fa5a 2799              clr     tosh
01fa5b 9508              ret
                 ;***************************************************
01fa5c f4a6              fdw     DZEROLESS_L
                 DEQUAL_L:
01fa5d 6482
01fa5e 003d              .db     NFA|2,"d=",0
01fa5f dfbd              rcall   DMINUS
01fa60 940d fa49         jmp     DZEROEQUAL
                 ;***************************************************
01fa62 f4ba              fdw     DEQUAL_L
                 DLESS_L:
01fa63 6482
01fa64 003c              .db     NFA|2,"d<",0
                 DLESS:
01fa65 dfb7              rcall   DMINUS
01fa66 940d fa55         jmp     DZEROLESS
                 ;***************************************************
01fa68 f4c6              fdw     DLESS_L
                 DGREATER_L:
01fa69 6482
01fa6a 003e              .db     NFA|2,"d>",0
                 DGREATER:
01fa6b 940f f139         call    TWOSWAP
01fa6d 940d fa65         jmp     DLESS
                 ;***************************************************
01fa6f f4d2              fdw     DGREATER_L
                 UDDOT_L:
01fa70 7583
01fa71 2e64              .db     NFA|3,"ud."
01fa72 d930              rcall   LESSNUM
01fa73 d950              rcall   NUMS
01fa74 d958              rcall   NUMGREATER
01fa75 940f f1ac         call    TYPE
01fa77 940d f142         jmp     SPACE_
                 ;***************************************************
01fa79 f4e0              fdw     UDDOT_L
                 DDOT_L:
01fa7a 6482
01fa7b 002e              .db     NFA|2,"d.",0
01fa7c d926              rcall   LESSNUM
01fa7d 940f f721         call    DUP
01fa7f 940f f211         call    TOR
01fa81 df85              rcall   DABS
01fa82 d941              rcall   NUMS
01fa83 940f f21c         call    RFROM
01fa85 d952              rcall   SIGN
01fa86 d946              rcall   NUMGREATER
01fa87 940f f1ac         call    TYPE
01fa89 940d f142         jmp     SPACE_
                 ;****************************************************
01fa8b f4f4              fdw      DDOT_L
                 MEMHI_L:
01fa8c 6882
01fa8d 0069              .db     NFA|2,"hi",0
                 MEMHI:
01fa8e dc88              rcall   DOLIT
01fa8f f52c              fdw     FLASHHI
01fa90 940f f09e         call    CSE_
01fa92 940f f239         call    PLUS
01fa94 940d febf         jmp     FETCH
                 FLASHHI:
01fa96 ddff              .dw      FLASH_HI
01fa97 31ff              .dw      EEPROM_HI
01fa98 21ff              .dw      RAM_HI
                 ;***************************************************
                 
01fa99 f518              fdw      MEMHI_L
                 L_FETCH_P:
01fa9a 40a2
01fa9b 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
01fa9c 939a
01fa9d 938a              pushtos
01fa9e 01ca              movw    tosl, pl
01fa9f 9508              ret
                 ;***************************************************
01faa0 f534              fdw     L_FETCH_P
                 L_PCFETCH:
01faa1 7083
01faa2 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
01faa3 939a
01faa4 938a              pushtos
01faa5 01ca              movw    tosl, pl
01faa6 940d feea         jmp     CFETCH
                 ;***************************************************
01faa8 f542              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
01faa9 70a3
01faaa 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
01faab 0d47              add     pl, r_two
01faac 1d55              adc     ph, zero
01faad 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
01faae 0000              .dw     0
                 L_MARKER:
                 lastword:
01faaf 6d86
01fab0 7261
01fab1 656b
01fab2 0072              .db     NFA|6,"marker",0
                 MARKER:
01fab3 940f f083         call    ROM_
01fab5 dcb6              rcall   CREATE
01fab6 dc60              rcall   DOLIT
01fab7 2200              .dw     dp_start
01fab8 940f f0a8         call    HERE
01faba dbd6              rcall   TEN
01fabb d9e6              rcall   CMOVE
01fabc dbd4              rcall   TEN
01fabd 940f f1ea         call    ALLOT
01fabf 940f f091         call    FRAM
01fac1 dcfa              rcall   XDOES
01fac2 940f f03b         call    DODOES
01fac4 dd90              rcall   INI
01fac5 dbcb              rcall   TEN
01fac6 940d f4a2         jmp     CMOVE
                 
                 
                 .ifdef UCSR1A
                 ;***************************************************
                 ; TX1   c --    output character to UART 1
01fac8 fa3e              fdw     RX0Q_L
                 TX1_L:
01fac9 7483
01faca 3178              .db     NFA|3,"tx1"
                 TX1_:
01facb 3181              cpi     tosl, XON
01facc f071              breq    XXON_TX1_TOS
01facd 3183              cpi     tosl, XOFF
01face f0a1              breq    XXOFF_TX1_TOS
                 TX1_LOOP:
01facf 6870              sbr     FLAGS2, (1<<fBUSY)
01fad0 d4a0              rcall   PAUSE
01fad1 9100 00c8         in_     t0, UCSR1A
01fad3 ff05              sbrs    t0, UDRE1
01fad4 cffa              rjmp    TX1_LOOP
01fad5 9380 00ce         out_    UDR1, tosl
01fad7 9189
01fad8 9199              poptos
01fad9 777f              cbr     FLAGS2, (1<<fBUSY)
01fada 9508              ret
                 
                 XXON_TX1_TOS:
01fadb 9189
01fadc 9199              poptos
01fadd c002              rjmp    XXON_TX1_1
                 XXON_TX1:
01fade ff71              sbrs    FLAGS2, ixoff_tx1
01fadf 9508              ret
                 XXON_TX1_1:
01fae0 7f7d              cbr     FLAGS2, (1<<ixoff_tx1)
01fae1 e1f1              ldi     zh, XON
01fae2 c007              rjmp    TX1_SEND
                 
                 XXOFF_TX1_TOS:
01fae3 9189
01fae4 9199              poptos
01fae5 c002              rjmp    XXOFF_TX1_1
                 XXOFF_TX1:
01fae6 fd71              sbrc    FLAGS2, ixoff_tx1
01fae7 9508              ret     
                 XXOFF_TX1_1:
01fae8 6072              sbr     FLAGS2, (1<<ixoff_tx1)
01fae9 e1f3              ldi     zh, XOFF
                 TX1_SEND:
01faea 91e0 00c8         in_     zl, UCSR1A
01faec ffe5              sbrs    zl, UDRE1
01faed cffc              rjmp    TX1_SEND
01faee 93f0 00ce         out_    UDR1, zh
01faf0 9508              ret
                 ;***************************************************
                 ; RX1    -- c    get character from the serial line
01faf1 f592              fdw     TX1_L
                 RX1_L:
01faf2 7283
01faf3 3178              .db     NFA|3,"rx1"
                 RX1_:
01faf4 d47c              rcall   PAUSE
01faf5 d01e              rcall   RX1Q
01faf6 940f f327         call    ZEROSENSE
01faf8 f3d9              breq    RX1_
01faf9 939a
01fafa 938a              pushtos
01fafb e9e8              ldi     zl, low(rbuf1)
01fafc e0f3              ldi     zh, high(rbuf1)
01fafd 91a0 0396         lds     xl, rbuf1_rd
01faff 0fea              add     zl, xl
01fb00 1df5              adc     zh, zero
01fb01 8180              ld      tosl, z
01fb02 2799              clr     tosh
01fb03 b60f              in_     t2, SREG
01fb04 94f8              cli
01fb05 95a3              inc     xl
01fb06 71af              andi    xl, (RX1_BUF_SIZE-1)
01fb07 93a0 0396         sts     rbuf1_rd, xl
01fb09 91a0 0397         lds     xl, rbuf1_lv
01fb0b 95aa              dec     xl
01fb0c 93a0 0397         sts     rbuf1_lv, xl
01fb0e be0f              out_    SREG, t2
01fb0f 9508              ret
                 ;***************************************************
                 ; RX1?  -- n    return the number of characters in queue
01fb10 f5e4              fdw     RX1_L
                 RX1Q_L:
01fb11 7284
01fb12 3178
01fb13 003f              .db     NFA|4,"rx1?",0
                 RX1Q:
01fb14 91a0 0397         lds     xl, rbuf1_lv
01fb16 11a5              cpse    xl, zero
01fb17 940d f6c2         jmp     TRUE_
                 .if U1FC_TYPE == 1
01fb19 dfc4              rcall   XXON_TX1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
01fb1a 940d f6b9         jmp     FALSE_
                 
                 ;****************************************************
                 RX1_ISRR:
01fb1c e9e8              ldi     zl, low(rbuf1)
01fb1d e0f3              ldi     zh, high(rbuf1)
01fb1e 91a0 0395         lds     xl, rbuf1_wr
01fb20 0fea              add     zl, xl
01fb21 1df5              adc     zh, zero
01fb22 91b0 00ce         in_     xh, UDR1
                 .if OPERATOR_UART == 1
                 .endif
01fb24 83b0              st      z, xh
01fb25 95a3              inc     xl
01fb26 71af              andi    xl, (RX1_BUF_SIZE-1)
01fb27 93a0 0395         sts     rbuf1_wr, xl
01fb29 91a0 0397         lds     xl, rbuf1_lv
01fb2b 95a3              inc     xl
01fb2c 93a0 0397         sts     rbuf1_lv, xl
01fb2e 31ae              cpi     xl, RX1_BUF_SIZE-2
01fb2f f409              brne    PC+2
01fb30 d004              rcall   RX1_OVF
01fb31 30a4              cpi     xl, RX0_OFF_FILL
01fb32 f00a              brmi    RX1_ISR_SKIP_XOFF
                 .if U1FC_TYPE == 1
01fb33 dfb4              rcall   XXOFF_TX1_1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 RX1_ISR_SKIP_XOFF:
01fb34 c146              rjmp    FF_ISR_EXIT2
                 RX1_OVF:
01fb35 e7fc              ldi     zh, '|'
01fb36 cfb3              rjmp    TX1_SEND
                 TX1_ISR:
                 .endif
                 ;***************************************************
                 RQ_EMIT:
01fb37 fe00              sbrs    t2, PORF
01fb38 c003              rjmp    RQ_EXTR
01fb39 dbdd              rcall   DOLIT
01fb3a 0050              .dw     'P'
01fb3b dc29              rcall   EMIT_A
                 RQ_EXTR:
01fb3c fe01              sbrs    t2, EXTRF
01fb3d c003              rjmp    RQ_BORF
01fb3e dbd8              rcall   DOLIT
01fb3f 0045              .dw     'E'
01fb40 dc24              rcall   EMIT_A
                 RQ_BORF:
01fb41 fe02              sbrs    t2, BORF
01fb42 c003              rjmp    RQ_WDRF
01fb43 dbd3              rcall   DOLIT
01fb44 0042              .dw     'B'
01fb45 dc1f              rcall   EMIT_A
                 RQ_WDRF:
01fb46 fe03              sbrs    t2, WDRF
01fb47 c003              rjmp    RQ_DIVZERO
01fb48 dbce              rcall   DOLIT
01fb49 0057              .dw     'W'
01fb4a dc1a              rcall   EMIT_A
                 RQ_DIVZERO:
01fb4b fe16              sbrs    t3, 6 ; T bit MATH error
01fb4c c003              rjmp    RQ_END
01fb4d dbc9              rcall   DOLIT
01fb4e 004d              .dw     'M'
01fb4f dc15              rcall   EMIT_A
                 RQ_END: 
01fb50 940d f142         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1	
01fb52 ff75              sbrs    FLAGS2, fLOAD
01fb53 c01f              rjmp    CPU_LOAD_END
01fb54 939a
01fb55 938a              pushtos
01fb56 b60f              in_     t2, SREG
01fb57 94f8              cli
01fb58 7d7f              cbr     FLAGS2, (1<<fLOAD)
01fb59 9180 03c4         lds     tosl, load_acc
01fb5b 9190 03c5         lds     tosh, load_acc+1
01fb5d 939a
01fb5e 938a              pushtos
01fb5f 9180 03c6         lds     tosl, load_acc+2
01fb61 9250 03c4         sts     load_acc, zero
01fb63 9250 03c5         sts     load_acc+1, zero
01fb65 9250 03c6         sts     load_acc+2, zero
01fb67 be0f              out_    SREG, t2
01fb68 2799              clr     tosh
01fb69 939a
01fb6a 938a              pushtos
01fb6b e080              ldi     tosl, low(CPU_LOAD_VAL)
01fb6c ea90              ldi     tosh, high(CPU_LOAD_VAL)
01fb6d 940f f339         call    UMSLASHMOD
01fb6f 9380 03c7         sts     load, tosl
01fb71 940f f12b         call    TWODROP 
                 CPU_LOAD_END:
                 .endif
                 .if CPU_LOAD_LED == 1
01fb73 ff74              sbrs    FLAGS2, fLOADled
01fb74 c002              rjmp    LOAD_LED_END
01fb75 9a27              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
01fb76 982f              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
01fb77 fd76              sbrc    FLAGS2, fIDLE
01fb78 c00b              rjmp    IDLE_LOAD1
01fb79 fd77              sbrc    FLAGS2, fBUSY
01fb7a c009              rjmp    IDLE_LOAD1
01fb7b ee06              ldi	    t0, low(up0)
01fb7c 1620              cp      upl, t0
01fb7d f431              brne    IDLE_LOAD1
                 .ifdef SMCR
01fb7e e001              ldi     t0, (1<<SE)
01fb7f bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
01fb80 9250 0081         out_    TCCR1B, zero	; Stop load counter
                 .endif
01fb82 9588              sleep               ; IDLE mode
                 .ifdef SMCR
01fb83 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
01fb84 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
01fb85 9a2f              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
01fb86 9508              ret
                 .endif
                 
                 .if CPU_LOAD == 1	
                 LOAD_ADD:
01fb87 91e0 03c4         lds     zl, load_acc
01fb89 91f0 03c5         lds     zh, load_acc+1
01fb8b 9100 03c6         lds     t0, load_acc+2
01fb8d 91b0 0084         in_     xh, TCNT1L
01fb8f 0feb              add     zl, xh
01fb90 91b0 0085         in_     xh, TCNT1H
01fb92 1ffb              adc     zh, xh
01fb93 1d05              adc     t0, zero
01fb94 9250 0085         out_    TCNT1H, zero
01fb96 9250 0084         out_    TCNT1L, zero
01fb98 93e0 03c4         sts     load_acc, zl
01fb9a 93f0 03c5         sts     load_acc+1, zh
01fb9c 9300 03c6         sts     load_acc+2, t0
01fb9e 20ee              tst     ms_count
01fb9f f409              brne    LOAD_ADD_END
01fba0 6270              sbr     FLAGS2, (1<<fLOAD)
                 LOAD_ADD_END:
01fba1 c0d9              rjmp    FF_ISR_EXIT2
                 .endif
                 
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
01fc00 940d fd9d RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
01fc02 d080                  rcall FF_ISR
                 .org BOOT_START + 0x04
01fc04 d07e                  rcall FF_ISR
                 .org BOOT_START + 0x06
01fc06 d07c                  rcall FF_ISR
                 .org BOOT_START + 0x08
01fc08 d07a                  rcall FF_ISR
                 .org BOOT_START + 0x0a
01fc0a d078                  rcall FF_ISR
                 .org BOOT_START + 0x0c
01fc0c d076                  rcall FF_ISR
                 .org BOOT_START + 0x0e
01fc0e d074                  rcall FF_ISR
                 .org BOOT_START + 0x10
01fc10 d072                  rcall FF_ISR
                 .org BOOT_START + 0x12
01fc12 d070                  rcall FF_ISR
                 .org BOOT_START + 0x14
01fc14 d06e                  rcall FF_ISR
                 .org BOOT_START + 0x16
01fc16 d06c                  rcall FF_ISR
                 .org BOOT_START + 0x18
01fc18 d06a                  rcall FF_ISR
                 .org BOOT_START + 0x1a
01fc1a d068                  rcall FF_ISR
                 .org BOOT_START + 0x1c
01fc1c d066                  rcall FF_ISR
                 .org BOOT_START + 0x1e
01fc1e d064                  rcall FF_ISR
                 .org BOOT_START + 0x20
01fc20 d062                  rcall FF_ISR
                 .org BOOT_START + 0x22
01fc22 d060                  rcall FF_ISR
                 .org BOOT_START + 0x24
01fc24 d05e                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
01fc26 d05c                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
01fc28 d05a                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
01fc2a d058                  rcall FF_ISR
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
01fc2c d056                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
01fc2e d054                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
01fc30 d052                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
01fc32 d050                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x34
01fc34 d04e                  rcall FF_ISR
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x36
01fc36 d04c                  rcall FF_ISR
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x38
01fc38 d04a                  rcall FF_ISR
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3a
01fc3a d048                  rcall FF_ISR
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3c
01fc3c d046                  rcall FF_ISR
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3e
01fc3e d044                  rcall FF_ISR
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x40
01fc40 d042                  rcall FF_ISR
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x42
01fc42 d040                  rcall FF_ISR
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x44
01fc44 d03e                  rcall FF_ISR
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x46
01fc46 d03c                  rcall FF_ISR
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x48
01fc48 d03a                  rcall FF_ISR
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4a
01fc4a d038                  rcall FF_ISR
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4c
01fc4c d036                  rcall FF_ISR
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4e
01fc4e d034                  rcall FF_ISR
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x50
01fc50 d032                  rcall FF_ISR
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x52
01fc52 d030                  rcall FF_ISR
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x54
01fc54 d02e                  rcall FF_ISR
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x56
01fc56 d02c                  rcall FF_ISR
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x58
01fc58 d02a                  rcall FF_ISR
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5a
01fc5a d028                  rcall FF_ISR
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5c
01fc5c d026                  rcall FF_ISR
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5e
01fc5e d024                  rcall FF_ISR
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x60
01fc60 d022                  rcall FF_ISR
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x62
01fc62 d020                  rcall FF_ISR
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x64
01fc64 d01e                  rcall FF_ISR
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x66
01fc66 d01c                  rcall FF_ISR
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x68
01fc68 d01a                  rcall FF_ISR
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6a
01fc6a d018                  rcall FF_ISR
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6c
01fc6c d016                  rcall FF_ISR
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6e
01fc6e d014                  rcall FF_ISR
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x70
01fc70 d012                  rcall FF_ISR
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE
                 FF_ISR_EXIT:
01fc72 919f              pop     tosh
01fc73 918f              pop     tosl
01fc74 901f              pop     t3
01fc75 900f              pop     t2
                 
01fc76 911f              pop     t1
01fc77 c003              rjmp    FF_ISR_EXIT2
                 MS_TIMER_ISR:
01fc78 0ce6              add     ms_count,  r_one
01fc79 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
01fc7a cf0c              rjmp    LOAD_ADD	
                 .endif
                 FF_ISR_EXIT2:
01fc7b 910f              pop     t0
01fc7c 91ff              pop     zh
01fc7d 91ef              pop     zl
                 FF_ISR_EXIT3:
01fc7e 91a9              ld      xl, y+
01fc7f 91b9              ld      xh, y+
01fc80 bfbf              out_    SREG, xh
01fc81 91b9              ld      xh, y+
01fc82 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
01fc83 9260 0081         out_    TCCR1B, r_one	; Start load counter
                 .endif
                 .endif
01fc85 93ba              st      -y, xh
01fc86 b7bf              in_     xh, SREG
01fc87 93ba              st      -y, xh
01fc88 93aa              st      -y, xl
01fc89 91bf              m_pop_xh
01fc8a 91bf              pop     xh
01fc8b 91af              pop     xl
01fc8c 93ef              push    zl
01fc8d 93ff              push    zh
01fc8e 930f              push    t0
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
01fc8f 32ab              cpi     xl, low(OC0Aaddr+1)
                 .endif
                 .ifdef OC0addr
                 .endif
01fc90 f339              breq    MS_TIMER_ISR
                 .endif
                 .if MS_TIMER == 1
                 .endif
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .endif
                 .ifdef OC2addr
                 .endif
                 .endif
                 
                 
                 .ifdef URXC0addr
01fc91 33a3              cpi     xl, low(URXC0addr+1)
                 .else
                 .endif
01fc92 f061              breq    RX0_ISR
                 .ifdef URXC1addr
01fc93 34a9              cpi     xl, low(URXC1addr+1)
01fc94 f141              breq    RX1_ISR
                 .endif
                 
01fc95 931f              push    t1
01fc96 920f              push    t2
01fc97 921f              push    t3
01fc98 938f              push    tosl
01fc99 939f              push    tosh
                 
01fc9a 50a1              subi    xl, 1
                 .if low(ivec) == 0x80
                 .endif
01fc9b e0b3              ldi     xh, high(ivec)
01fc9c 91ed              ld      zl, x+
01fc9d 91fd              ld      zh, x+
01fc9e 9419              mijmp    ;(z)
                 
                 ;;; *************************************************
                 RX0_ISR:
01fc9f e7e5              ldi     zl, low(rbuf0)
01fca0 e0f3              ldi     zh, high(rbuf0)
01fca1 91a0 0372         lds     xl, rbuf0_wr
01fca3 0fea              add     zl, xl
01fca4 1df5              adc     zh, zero
01fca5 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
01fca7 30bf              cpi     xh, 0xf
01fca8 f409              brne    pc+2
01fca9 cf56              rjmp    RESET_
                 .endif
01fcaa 83b0              st      z, xh
01fcab 95a3              inc     xl
01fcac 71af              andi    xl, (RX0_BUF_SIZE-1)
01fcad 93a0 0372         sts     rbuf0_wr, xl
01fcaf 91a0 0374         lds     xl, rbuf0_lv
01fcb1 95a3              inc     xl
01fcb2 93a0 0374         sts     rbuf0_lv, xl
01fcb4 31ae              cpi     xl, RX0_BUF_SIZE-2
01fcb5 f409              brne    PC+2
01fcb6 d004              rcall   RX0_OVF
01fcb7 30a4              cpi     xl, RX0_OFF_FILL
01fcb8 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
01fcb9 d03c              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
01fcba cfc0              rjmp    FF_ISR_EXIT2
                 RX0_OVF:
01fcbb e7fc              ldi     zh, '|'
01fcbc c03b              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
01fcbd ce5e      RX1_ISR: rjmp   RX1_ISRR
                 .endif
                 ;;; Enable load led
01fcbe de5e              fdw     BUSY_L
                 LOADON_L:
01fcbf 6c85
01fcc0 616f
01fcc1 2b64              .db     NFA|5,"load+"
01fcc2 6170              sbr     FLAGS2, (1<<fLOADled)
01fcc3 9508              ret
                 
                 ;;; Disable load led
01fcc4 f97e              fdw     LOADON_L
                 LOADOFF_L:
01fcc5 6c85
01fcc6 616f
01fcc7 2d64              .db     NFA|5,"load-"
01fcc8 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
01fcc9 9827              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
01fcca 982f              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
01fccb 9508              ret
                 ;;; Enable load led
01fccc f98a              fdw     LOADOFF_L
                 LOAD_L:
01fccd 6c84
01fcce 616f
01fccf 0064              .db     NFA|4,"load",0
01fcd0 939a
01fcd1 938a              pushtos
01fcd2 2799              clr     tosh
01fcd3 9180 03c7         lds     tosl, load
01fcd5 9508              ret
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
01fcd6 f99a              fdw(LOAD_L)
                 TX0_L:
01fcd7 7483
01fcd8 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
01fcd9 3181              cpi     tosl, XON
01fcda f071              breq    XXON_TX0_TOS
01fcdb 3183              cpi     tosl, XOFF
01fcdc f0a1              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
01fcdd 6870              sbr     FLAGS2, (1<<fBUSY)
01fcde d292              rcall   PAUSE
01fcdf 9100 00c0         in_     t0, UCSR0A
01fce1 ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
01fce2 cffa              rjmp    TX0_LOOP
01fce3 9380 00c6         out_    UDR0_, tosl
01fce5 9189
01fce6 9199              poptos
01fce7 777f              cbr     FLAGS2, (1<<fBUSY)
01fce8 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
01fce9 9189
01fcea 9199              poptos
01fceb c002              rjmp    XXON_TX0_1
                 XXON_TX0:
01fcec ff70              sbrs    FLAGS2, ixoff_tx0
01fced 9508              ret
                 XXON_TX0_1:
01fcee 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
01fcef e1f1              ldi     zh, XON
01fcf0 c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
01fcf1 9189
01fcf2 9199              poptos
01fcf3 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
01fcf4 fd70              sbrc    FLAGS2, ixoff_tx0
01fcf5 9508              ret     
                 XXOFF_TX0_1:
01fcf6 6071              sbr     FLAGS2, (1<<ixoff_tx0)
01fcf7 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
01fcf8 91e0 00c0         in_     zl, UCSR0A
01fcfa ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
01fcfb cffc              rjmp    TX0_SEND
01fcfc 93f0 00c6         out_    UDR0_, zh
01fcfe 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
01fcff f9ae              fdw(TX0_L)
                 RX0_L:
01fd00 7283
01fd01 3078              .db     NFA|3,"rx0"
                 RX0_:
01fd02 d26e              rcall   PAUSE
01fd03 d01e              rcall   RX0Q
01fd04 940f f327         call    ZEROSENSE
01fd06 f3d9              breq    RX0_
01fd07 939a
01fd08 938a              pushtos
01fd09 e7e5              ldi     zl, low(rbuf0)
01fd0a e0f3              ldi     zh, high(rbuf0)
01fd0b 91a0 0373         lds     xl, rbuf0_rd
01fd0d 0fea              add     zl, xl
01fd0e 1df5              adc     zh, zero
01fd0f 8180              ld      tosl, z
01fd10 2799              clr     tosh
01fd11 b60f              in_     t2, SREG
01fd12 94f8              cli
01fd13 95a3              inc     xl
01fd14 71af              andi    xl, (RX0_BUF_SIZE-1)
01fd15 93a0 0373         sts     rbuf0_rd, xl
01fd17 91a0 0374         lds     xl, rbuf0_lv
01fd19 95aa              dec     xl
01fd1a 93a0 0374         sts     rbuf0_lv, xl
01fd1c be0f              out_    SREG, t2
01fd1d 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
01fd1e fa00              fdw     RX0_L
                 RX0Q_L:
01fd1f 7284
01fd20 3078
01fd21 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
01fd22 91a0 0374         lds     xl, rbuf0_lv
01fd24 11a5              cpse    xl, zero
01fd25 940d f6c2         jmp     TRUE_
                 .if U0FC_TYPE == 1
01fd27 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
01fd28 940d f6b9         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
01fd2a db89              rcall   DOTS
01fd2b 940f f1b9         call    XSQUOTE
01fd2d 4103
01fd2e 3f44              .db     3,"AD?"
01fd2f 940f f1ac         call    TYPE
01fd31 c9bf              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibasehi != iaddrhi)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
01fd32 2d0d              mov     t0, iaddrh
01fd33 3d0e              cpi     t0, high(FLASH_HI+1)       ; Dont allow kernel writes
01fd34 f7a8              brcc    ISTORERR
01fd35 2d0c              mov     t0, iaddrl
01fd36 7000              andi    t0, ~(PAGESIZEB-1)
01fd37 110a              cpse    t0, ibasel
01fd38 c003              rjmp    IFILL_BUFFER
01fd39 10db              cpse    iaddrh, ibaseh
01fd3a c001              rjmp    IFILL_BUFFER
01fd3b 9508              ret
                 
                 IFILL_BUFFER:
01fd3c d04b              rcall   IFLUSH
01fd3d 2d0c              mov     t0, iaddrl
01fd3e 7000              andi    t0, ~(PAGESIZEB-1)
01fd3f 2ea0              mov     ibasel, t0
01fd40 2cbd              mov     ibaseh, iaddrh
                 IFILL_BUFFER_1:
01fd41 e000              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
01fd42 01f5              movw    zl, ibasel
                         sub_pflash_z
01fd43 e0a0              ldi     xl, low(ibuf)
01fd44 e0b2              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
01fd45 9117              lpm_    t1, z+
01fd46 931d              st      x+, t1
01fd47 950a              dec     t0
01fd48 f7e1              brne    IFILL_BUFFER_2
01fd49 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
01fd4a d9cc              rcall   DOLIT
01fd4b 0013              .dw     XOFF
01fd4c 940f efdd         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fd4e d9c8              rcall   DOLIT
01fd4f 000a              .dw     10
01fd50 db16              rcall   MS
                         ; Disable interrupts
01fd51 94f8              cli
01fd52 01f5              movw    zl, ibasel
                         sub_pflash_z
01fd53 e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
01fd54 d028              rcall   DO_SPM
01fd55 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
01fd56 d026              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
01fd57 e000              ldi     t0, low(PAGESIZEB);init loop variable
01fd58 e0a0              ldi     xl, low(ibuf)
01fd59 e0b2              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
01fd5a 900d              ld      r0, x+
01fd5b 901d              ld      r1, x+
01fd5c e011              ldi     t1, (1<<SPMEN)
01fd5d d01f              rcall   DO_SPM
01fd5e 9632              adiw    zl, 2
01fd5f 5002              subi    t0, 2
01fd60 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
01fd61 50e0              subi    zl, low(PAGESIZEB) ;restore pointer
01fd62 40f1              sbci    zh, high(PAGESIZEB)
01fd63 e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
01fd64 d018              rcall   DO_SPM
                         ; re-enable the RWW section
01fd65 d011              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
01fd66 e000              ldi     t0, low(PAGESIZEB);init loop variable
01fd67 50a0              subi    xl, low(PAGESIZEB) ;restore pointer
01fd68 40b1              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
01fd69 9007              lpm_    r0, z+
01fd6a 901d              ld      r1, x+
01fd6b 1001              cpse    r0, r1
01fd6c c030              rjmp    WARM_     ; reset
01fd6d 5001              subi    t0, 1
01fd6e f7d1              brne    IWRITE_BUFFER2
                 
01fd6f 24bb              clr     ibaseh
01fd70 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
01fd71 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
01fd72 d9a4              rcall   DOLIT
01fd73 0011              .dw     XON
01fd74 940f efdd         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fd76 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
01fd77 b687              in_     t8, SPMCSR
01fd78 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
01fd79 9508              ret
                         ; re-enable the RWW section
01fd7a e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
01fd7b d001              rcall   DO_SPM
01fd7c cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
01fd7d b687              in_     t8, SPMCSR
01fd7e fc80              sbrc    t8, SPMEN
01fd7f cffd              rjmp    DO_SPM       ; Wait for previous write to complete
01fd80 bf17              out_    SPMCSR, t1
01fd81 95e8              spm
01fd82 9508              ret
                 
                                 
01fd83 fedc              fdw     PAUSE_L
                 IFLUSH_L:
01fd84 6986
01fd85 6c66
01fd86 7375
01fd87 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
01fd88 fd60              sbrc    FLAGS1, idirty
01fd89 cfc0              rjmp    IWRITE_BUFFER
01fd8a 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
01fd8b f622              fdw     RX1Q_L
                 .else
                 .endif
                 EMPTY_L:
01fd8c 6585
01fd8d 706d
01fd8e 7974              .db     NFA|5,"empty"
                 EMPTY:
01fd8f d987              rcall   DOLIT
01fd90 ffee              fdw     COLDLIT
01fd91 d985              rcall   DOLIT
01fd92 2200              .dw     dp_start
01fd93 d983              rcall   DOLIT
01fd94 000c              .dw     coldlitsize
01fd95 940f f4a2         call    CMOVE
01fd97 940d f695         jmp     DP_TO_RAM
                         
                 ;*******************************************************
01fd99 fb18              fdw     EMPTY_L
                 WARM_L:
01fd9a 7784
01fd9b 7261
01fd9c 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
01fd9d 94f8              cli           ; Disable interrupts
01fd9e 27aa              clr     xl
01fd9f 27bb              clr     xh
01fda0 e1c9              ldi     yl, 25
01fda1 e0d0              ldi     yh, 0
                 WARM_1:
01fda2 93dd              st      x+, yh
01fda3 50c1              subi    yl, 1
01fda4 f7e9              brne    WARM_1
                 
01fda5 b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
01fda6 b604              in_     t2, MCUSR
01fda7 9250 0034         sts     MCUSR, zero
                 .endif
01fda9 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
01fdaa 925d              st      x+, zero
01fdab 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
01fdac f7e9              brne    WARM_2
01fdad e0c1              ldi     yl, 1
01fdae 2e6c              mov     r_one, yl
01fdaf e0c2              ldi     yl, 2
01fdb0 2e7c              mov     r_two, yl
                 ; Init Stack pointer
01fdb1 e8c4              ldi     yl, low(utibbuf-4)
01fdb2 e0d4              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
01fdb3 e407              ldi     t0, low(usbuf-1)
01fdb4 e014              ldi     t1, high(usbuf-1)
01fdb5 bf0d              out     spl, t0
01fdb6 bf1e              out     sph, t1
                 ; Init user pointer
01fdb7 ee06              ldi     t0, low(up0)
01fdb8 e013              ldi     t1, high(up0)
01fdb9 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
01fdba e003              ldi     t0, RAMPZV
01fdbb bf0b              out_    RAMPZ, t0
                 .endif
                 .ifdef EIND
01fdbc be6c              out_    EIND, r_one
                 .endif
                 ; init warm literals
01fdbd d959              rcall   DOLIT
01fdbe ffd2              fdw     WARMLIT
01fdbf d957              rcall   DOLIT
01fdc0 03c8              .dw     cse
01fdc1 d955              rcall   DOLIT
01fdc2 001c              .dw     warmlitsize
01fdc3 940f f4a2         call    CMOVE
                 ; init cold data to eeprom
01fdc5 d951              rcall   DOLIT
01fdc6 2200              .dw     dp_start
01fdc7 d0f7              rcall   FETCH
01fdc8 d8f9              rcall   TRUE_
01fdc9 940f f2b5         call    EQUAL
01fdcb 940f f327         call    ZEROSENSE
01fdcd f009              breq    WARM_3  
01fdce dfc0              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
01fdcf be65              out_    MCUCR, r_one   ; (1<<IVCE)
01fdd0 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 ; Init ms timer
                 .ifdef TIMSK0
01fdd1 bc74              out_    TCCR0A, r_two  ; CTC
01fdd2 e003              ldi     t0, ms_pre_tmr0
01fdd3 bd05              out_    TCCR0B, t0
01fdd4 ef09              ldi     t0, ms_value_tmr0
01fdd5 bd07              out_    OCR0A, t0
01fdd6 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
                         ; Set baud rate
                 ;        out_    UBRR0H, zero
01fdd8 e109              ldi     t0, ubrr0val
01fdd9 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
01fddb e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
01fddc 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
01fdde e006              ldi     t0, (3<<UCSZ00)|URSEL_
01fddf 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
01fde1 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                         ; Set baud rate
                 ;        out_    UBRR1H, zero
01fde2 e109              ldi     t0, ubrr1val
01fde3 9300 00cc         out_    UBRR1L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
01fde5 e908              ldi     t0, (1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1)
01fde6 9300 00c9         out_    UCSR1B,t0
                         ; Set frame format: 8data, 1stop bit
01fde8 e006              ldi     t0, (3<<UCSZ10)
01fde9 9300 00ca         out_    UCSR1C,t0
                 .if U1FC_TYPE == 1
01fdeb 6072              sbr     FLAGS2, (1<<ixoff_tx1)
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fdec d8a8              rcall   DP_TO_RAM
01fded 9478              sei
                 
01fdee dd48              rcall   RQ_EMIT
01fdef d023              rcall   VER
                 ; Turnkey ?
01fdf0 d179              rcall   TURNKEY
01fdf1 940f f327         call    ZEROSENSE
01fdf3 f0d1              breq    STARTQ2
01fdf4 940f f1b9         call    XSQUOTE
01fdf6 4503
01fdf7 4353              .db     3,"ESC"
01fdf8 940f f1ac         call    TYPE
01fdfa d91c              rcall   DOLIT
01fdfb 07d0              .dw     TURNKEY_DELAY
01fdfc da6a              rcall   MS
01fdfd 940f efea         call    KEYQ
01fdff 940f f327         call    ZEROSENSE
01fe01 f049              breq    STARTQ1
01fe02 940f efe3         call    KEY
01fe04 d912              rcall   DOLIT
01fe05 001b              .dw     0x1b
01fe06 940f f2b5         call    EQUAL
01fe08 940f f327         call    ZEROSENSE
01fe0a f419              brne    STARTQ2
                 STARTQ1:
01fe0b d15e              rcall   TURNKEY
01fe0c 940f eff2         call    EXECUTE
                 STARTQ2:
01fe0e 940d f6f1         jmp     ABORT
                 
01fe10 fb34              fdw     WARM_L
                 VER_L:
01fe11 7683
01fe12 7265              .db     NFA|3,"ver"
                 VER:
01fe13 940f f1b9         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
01fe15 4617
01fe16 616c
01fe17 6873
01fe18 6f46
01fe19 7472
01fe1a 2068
01fe1b 7441
01fe1c 656d
01fe1d 6167
01fe1e 3520
01fe1f 302e
01fe20 0a0d              .db 23,"FlashForth Atmega 5.0",0xd,0xa
01fe21 940d f1ac         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
01fe23 fc22              fdw     VER_L
                 EI_L:
01fe24 65a2
01fe25 0069              .db     NFA|INLINE|2,"ei",0
01fe26 9478              sei
01fe27 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
01fe28 fc48              fdw     EI_L
                 DI_L:
01fe29 64a2
01fe2a 0069              .db     NFA|INLINE|2,"di",0
01fe2b 94f8              cli
01fe2c 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
01fe2d fc52              fdw     DI_L
                 IRQ_SEMI_L:
01fe2e 3bc2
01fe2f 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
01fe30 d8e6              rcall   DOLIT
                 .ifdef EIND
01fe31 940d              .dw     0x940D     ; jmp
                 .else
                 .endif
01fe32 d16a              rcall   ICOMMA
01fe33 d8e3              rcall   DOLIT
01fe34 fc72              .dw     FF_ISR_EXIT
01fe35 d167              rcall   ICOMMA
01fe36 940d f7d8         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
01fe38 fc5c              fdw     IRQ_SEMI_L
                 IRQ_V_L:
01fe39 6984
01fe3a 746e
01fe3b 0021              .db     NFA|4,"int!",0
                 IRQ_V:
01fe3c 01fc              movw    zl, tosl
01fe3d 9731              sbiw    zl, 1
01fe3e 0fee              lsl     zl
                 .if low(ivec) == 0x80
                 .endif
01fe3f e0f3              ldi     zh, high(ivec)
01fe40 9189
01fe41 9199              poptos
01fe42 dac6              rcall   TO_XA
01fe43 940d fe7b         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
01fe45 fc72              fdw     IRQ_V_L
                 LITERAL_L:
01fe46 6cc7
01fe47 7469
01fe48 7265
01fe49 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
01fe4a d8cc              rcall   DOLIT
01fe4b ee42              fdw     DUP
01fe4c db4f              rcall   INLINE0
01fe4d 940f f721         call    DUP
01fe4f 2f98              mov     tosh, tosl
01fe50 9592              swap    tosh
01fe51 709f              andi    tosh, 0xf
01fe52 708f              andi    tosl, 0xf
01fe53 6e90              ori     tosh, 0xe0
01fe54 6880              ori     tosl, 0x80
01fe55 d147              rcall   ICOMMA
01fe56 2f89              mov     tosl, tosh
01fe57 9592              swap    tosh
01fe58 709f              andi    tosh, 0xf
01fe59 708f              andi    tosl, 0xf
01fe5a 6e90              ori     tosh, 0xe0
01fe5b 6980              ori     tosl, 0x90
01fe5c 940d ff9d         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
01fe5e d039              rcall   LOCKEDQ
01fe5f 016c              movw    iaddrl, tosl
01fe60 ded1              rcall   IUPDATEBUF
01fe61 9189
01fe62 9199              poptos
01fe63 e0a0              ldi     xl, low(ibuf)
01fe64 e0b2              ldi     xh, high(ibuf)
01fe65 2d0c              mov     t0, iaddrl
01fe66 7f0f              andi    t0, (PAGESIZEB-1)
01fe67 0fa0              add     xl, t0
01fe68 938d              st      x+, tosl
01fe69 939d              st      x+, tosh
01fe6a 9189
01fe6b 9199              poptos
01fe6c 6061              sbr     FLAGS1, (1<<idirty)
01fe6d 9508              ret
                 
01fe6e fc8c              fdw     LITERAL_L
                 TO_A_L:
01fe6f 3e82
01fe70 0061              .db     NFA|2, ">a",0
01fe71 ece2              ldi     zl, low(areg)
01fe72 e0f3              ldi     zh, high(areg)
01fe73 c007              rjmp    STORE_RAM_2
                 
01fe74 fcde              fdw     TO_A_L
                 STORE_L:
01fe75 2181              .db     NFA|1, "!"
                 STORE:
01fe76 3292              cpi     tosh, high(PEEPROM)
01fe77 f440              brcc    STORE1
                 STORE_RAM:
01fe78 01fc              movw    zl, tosl
01fe79 9189
01fe7a 9199              poptos
                 STORE_RAM_2:
01fe7b 8391              std     Z+1, tosh
01fe7c 8380              std     Z+0, tosl
01fe7d 9189
01fe7e 9199              poptos
01fe7f 9508              ret
                 STORE1:
01fe80 3392              cpi     tosh, high(OFLASH)
01fe81 f6e0              brcc    ISTORE
                 ESTORE:
01fe82 d015              rcall   LOCKEDQ
01fe83 99f9              sbic    eecr, eewe
01fe84 cffd              rjmp    ESTORE
01fe85 5292              subi    tosh, high(PEEPROM)
01fe86 bd81              out     eearl, tosl
01fe87 bd92              out     eearh, tosh
01fe88 9189
01fe89 9199              poptos
01fe8a bd80              out     eedr, tosl
01fe8b 9afa              sbi     eecr, eemwe
01fe8c 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
01fe8d 99f9              sbic    eecr, eewe
01fe8e cffe              rjmp    ESTORE1
                 
01fe8f b581              in      tosl, eearl
01fe90 9583              inc     tosl
01fe91 bd81              out     eearl, tosl
                 
01fe92 bd90              out     eedr, tosh
01fe93 9afa              sbi     eecr, eemwe
01fe94 9af9              sbi     eecr, eewe
                 
01fe95 9189
01fe96 9199              poptos
01fe97 9508              ret
                 LOCKEDQ:
01fe98 ff62              sbrs    FLAGS1, fLOCK
01fe99 9508              ret
01fe9a da19              rcall   DOTS
01fe9b 940f f1b9         call    XSQUOTE
01fe9d 4103
01fe9e 3f44              .db     3,"AD?"
01fe9f 940f f1ac         call    TYPE
01fea1 cf6c              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
01fea2 01fc              movw    z, tosl
01fea3 11fb              cpse    zh, ibaseh
01fea4 c00b              rjmp    IIFETCH
01fea5 2f0e              mov     t0, zl
01fea6 7000              andi    t0, ~(PAGESIZEB-1)
01fea7 150a              cp      t0, ibasel
01fea8 f439              brne    IIFETCH
01fea9 e0a0              ldi     xl, low(ibuf)
01feaa e0b2              ldi     xh, high(ibuf)
01feab 7fef              andi    zl, (PAGESIZEB-1)
01feac 0fae              add     xl, zl
01fead 918d              ld      tosl, x+
01feae 919d              ld      tosh, x+
01feaf 9508              ret
                 IIFETCH:
                         sub_pflash_z
01feb0 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01feb1 9197              lpm_    tosh, z+
                 .ifdef RAMPZ
01feb2 e003              ldi     t0, RAMPZV
01feb3 bf0b              out_    RAMPZ, t0
                 .endif
01feb4 9508              ret
                                 
01feb5 fcea              fdw     STORE_L
                 A_FROM_L:
01feb6 6182
01feb7 003e              .db     NFA|2, "a>",0
01feb8 939a
01feb9 938a              pushtos
01feba ece2              ldi     zl, low(areg)
01febb e0f3              ldi     zh, high(areg)
01febc c005              rjmp    FETCH_RAM_2
                 
01febd fd6c              fdw     A_FROM_L
                 FETCH_L:
01febe 4081              .db     NFA|1, "@"
                 FETCH:
01febf 3292              cpi     tosh, high(PEEPROM)
01fec0 f420              brcc    FETCH1
                 FETCH_RAM:
01fec1 01fc              movw    zl, tosl
                 FETCH_RAM_2:
01fec2 9181              ld      tosl, z+
01fec3 9191              ld      tosh, z+
01fec4 9508              ret
                 FETCH1:
01fec5 3392              cpi     tosh, high(OFLASH)
01fec6 f6d8              brcc    IFETCH
                 EFETCH:
01fec7 99f9              sbic    eecr, eewe
01fec8 cffe              rjmp    EFETCH
01fec9 5292              subi    tosh, high(PEEPROM)
01feca bd81              out     eearl, tosl
01fecb bd92              out     eearh, tosh
01fecc 9af8              sbi     eecr, eere
01fecd b580              in      tosl, eedr
01fece b591              in      tosh, eearl
01fecf 9593              inc     tosh
01fed0 bd91              out     eearl, tosh
01fed1 9af8              sbi     eecr, eere
01fed2 b590              in      tosh, eedr
01fed3 9508              ret
                 
                 ICFETCH:
01fed4 01fc              movw    z, tosl
01fed5 11fb              cpse    zh, ibaseh
01fed6 c00b              rjmp    IICFETCH
01fed7 2f0e              mov     t0, zl
01fed8 7000              andi    t0, ~(PAGESIZEB-1)
01fed9 150a              cp      t0, ibasel
01feda f439              brne    IICFETCH
01fedb e0a0              ldi     xl, low(ibuf)
01fedc e0b2              ldi     xh, high(ibuf)
01fedd 7fef              andi    zl, (PAGESIZEB-1)
01fede 0fae              add     xl, zl
01fedf 918d              ld      tosl, x+
01fee0 2799              clr     tosh
01fee1 9508              ret
                 IICFETCH:
                         sub_pflash_z
01fee2 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01fee3 2799              clr     tosh
                 .ifdef RAMPZ
01fee4 e003              ldi     t0, RAMPZV
01fee5 bf0b              out_    RAMPZ, t0
                 .endif
01fee6 9508              ret
                 
01fee7 fd7c              fdw     FETCH_L
                 CFETCH_L:
01fee8 6382
01fee9 0040              .db     NFA|2, "c@",0
                 CFETCH:
01feea 3292              cpi     tosh, high(PEEPROM)
01feeb f420              brcc    CFETCH1
                 CFETCH_RAM:
01feec 01fc              movw    zl, tosl
01feed 9181              ld      tosl, z+
01feee 2799              clr     tosh
01feef 9508              ret
                 CFETCH1:
01fef0 3392              cpi     tosh, high(OFLASH)
01fef1 f710              brcc    ICFETCH
                 ECFETCH:
01fef2 99f9              sbic    eecr, eewe
01fef3 cffe              rjmp    ECFETCH
01fef4 5292              subi    tosh, high(PEEPROM)
01fef5 bd81              out     eearl, tosl
01fef6 bd92              out     eearh, tosh
01fef7 9af8              sbi     eecr, eere
01fef8 b580              in      tosl, eedr
01fef9 2799              clr     tosh
01fefa 9508              ret
                 
                 ICSTORE:
01fefb df9c              rcall   LOCKEDQ
01fefc 016c              movw    iaddrl, tosl
01fefd de34              rcall   IUPDATEBUF
01fefe 9189
01feff 9199              poptos
01ff00 e0a0              ldi     xl, low(ibuf)
01ff01 e0b2              ldi     xh, high(ibuf)
01ff02 2d0c              mov     t0, iaddrl
01ff03 7f0f              andi    t0, (PAGESIZEB-1)
01ff04 0fa0              add     xl, t0
01ff05 938d              st      x+, tosl
01ff06 9189
01ff07 9199              poptos
01ff08 6061              sbr     FLAGS1, (1<<idirty)
01ff09 9508              ret
                 
01ff0a fdd0              fdw     CFETCH_L
                 CSTORE_L:
01ff0b 6382
01ff0c 0021              .db     NFA|2, "c!",0
                 CSTORE:
01ff0d 3292              cpi     tosh, high(PEEPROM)
01ff0e f438              brcc    CSTORE1
                 CSTORE_RAM:
01ff0f 01fc              movw zl, tosl
01ff10 9189
01ff11 9199              poptos
01ff12 8380              std Z+0, tosl
01ff13 9189
01ff14 9199              poptos
01ff15 9508              ret
                 CSTORE1:
01ff16 3392              cpi     tosh, high(OFLASH)
01ff17 f718              brcc    ICSTORE
                 ECSTORE:
01ff18 df7f              rcall   LOCKEDQ
01ff19 99f9              sbic    eecr, eewe
01ff1a cffd              rjmp    ECSTORE
01ff1b 5292              subi    tosh, high(PEEPROM)
01ff1c bd81              out     eearl, tosl
01ff1d bd92              out     eearh, tosh
01ff1e 9189
01ff1f 9199              poptos
01ff20 bd80              out     eedr, tosl
01ff21 9afa              sbi     eecr, eemwe
01ff22 9af9              sbi     eecr, eewe
01ff23 9189
01ff24 9199              poptos
01ff25 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
01ff26 fe16              fdw     CSTORE_L
                 
                 FLOCK_L:
01ff27 6683
01ff28 2d6c              .db     NFA|3,"fl-"
01ff29 6064              sbr     FLAGS1, (1<<fLOCK)
01ff2a 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
01ff2b fe4e              fdw     FLOCK_L
                 FUNLOCK_L:
01ff2c 6683
01ff2d 2b6c              .db     NFA|3,"fl+"
01ff2e 7f6b              cbr     FLAGS1, (1<<fLOCK)
01ff2f 9508              ret
                 
                 
                 
01ff30 fe58              fdw     FUNLOCK_L
                 VALUE_L:
01ff31 7685
01ff32 6c61
01ff33 6575              .db     NFA|5,"value"
                 VALUE:
01ff34 d837              rcall   CREATE
01ff35 940f f0ad         call    COMMA
01ff37 d884              rcall   XDOES
                 VALUE_DOES:
01ff38 940f f03b         call    DODOES
01ff3a 940d febf         jmp     FETCH
                 
01ff3c fe62              fdw     VALUE_L
                 DEFER_L:
01ff3d 6485
01ff3e 6665
01ff3f 7265              .db     NFA|5,"defer"
                 DEFER:
01ff40 d82b              rcall   CREATE
01ff41 940f f717         call    DOLIT
01ff43 ede2              fdw     ABORT
01ff44 940f f0ad         call    COMMA
01ff46 d875              rcall   XDOES
                 DEFER_DOES:
01ff47 940f f03b         call    DODOES
01ff49 940d effc         jmp     FEXECUTE
                 
01ff4b fe7a              fdw     DEFER_L
                 IS_L:
01ff4c 69c2
01ff4d 0073              .db     NFA|IMMED|2,"is",0
                 IS:
01ff4e 940f f736         call    TICK
01ff50 940f f281         call    TWOPLUS
01ff52 940f f281         call    TWOPLUS
01ff54 df6a              rcall   FETCH
01ff55 d8e4              rcall   STATE_
01ff56 940f f327         call    ZEROSENSE
01ff58 f029              breq    IS1
01ff59 def0              rcall   LITERAL
01ff5a 940f f04d         call    DOCOMMAXT
01ff5c fcec              fdw     STORE
01ff5d c001              rjmp    IS2
                 IS1:
01ff5e df17              rcall   STORE
                 IS2:
01ff5f 9508              ret
                 
01ff60 fe98              fdw     IS_L
                 TO_L:
01ff61 74c2
01ff62 006f              .db     NFA|IMMED|2,"to",0
                 TO:
01ff63 940d ff4e         jmp     IS
                 
01ff65 fec2              fdw     TO_L
                 TURNKEY_L:
01ff66 7487
01ff67 7275
01ff68 6b6e
01ff69 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
01ff6a 940f ff38         call    VALUE_DOES      ; Must be call for IS to work.
01ff6c 03b8              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
01ff6d fecc              fdw     TURNKEY_L
                 PAUSE_L:
01ff6e 7085
01ff6f 7561
01ff70 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
01ff71 dbe0              rcall   IDLE_LOAD
                 .endif
01ff72 b60f              in_     t2, SREG
01ff73 94f8              cli
01ff74 93df              push    yh        ; SP
01ff75 93cf              push    yl
01ff76 939f              push    tosh      ; TOS
01ff77 938f              push    tosl
01ff78 935f              push    ph        ; P
01ff79 934f              push    pl
01ff7a 01f1              movw    zl, upl
01ff7b b70e              in      t0, sph
01ff7c 9302              st      -z, t0
01ff7d b70d              in      t0, spl
01ff7e 9302              st      -z, t0
01ff7f 91b2              ld      xh, -z     ; UP
01ff80 91a2              ld      xl, -z
01ff81 011d              movw    upl, xl
01ff82 910e              ld      t0, -x
01ff83 bf0e              out     sph, t0
01ff84 910e              ld      t0, -x
01ff85 bf0d              out     spl, t0
01ff86 914f              pop     pl
01ff87 915f              pop     ph
01ff88 918f              pop     tosl
01ff89 919f              pop     tosh
01ff8a 91cf              pop     yl
01ff8b 91df              pop     yh
01ff8c be0f              out_    SREG, t2
01ff8d 9508              ret
                 
                 
01ff8e fb08              fdw     IFLUSH_L
                 OPERATOR_L:
01ff8f 6f88
01ff90 6570
01ff91 6172
01ff92 6f74
01ff93 0072              .db     NFA|8,"operator",0
                 OPERATOR:
01ff94 940f f031         call    DOCREATE
01ff96 ff2e              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
01ff97 03e6              .dw     up0
01ff98 6000              .db     0, ursize
01ff99 5440              .db     ussize, utibsize
                 
01ff9a ff1e              fdw     OPERATOR_L
                 ICOMMA_L:
01ff9b 6982
01ff9c 002c              .db     NFA|2, "i,",0
                 ICOMMA:
01ff9d 940f f74f         call    IHERE
01ff9f ded6              rcall   STORE
01ffa0 940f f0be         call    CELL
01ffa2 940d f8f5         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
01ffa4 ff36              fdw     ICOMMA_L
                 ICCOMMA_L:
01ffa5 6983
01ffa6 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
01ffa7 940f f74f         call    IHERE
01ffa9 df63              rcall   CSTORE
01ffaa 940f f165         call    ONE
01ffac 940d f8f5         jmp     IALLOT
                 
                 L_DOTBASE:
01ffae 2081              .db      NFA|1," "
                 DOTBASE:
01ffaf 940f f442         call    BASE
01ffb1 df0d              rcall   FETCH
01ffb2 3180              cpi     tosl, 0x10
01ffb3 f411              brne    DOTBASE1
01ffb4 e284              ldi     tosl,'$'
01ffb5 c009              rjmp    DOTBASEEND
                 DOTBASE1:
01ffb6 308a              cpi     tosl, 0xa
01ffb7 f411              brne    DOTBASE2
01ffb8 e283              ldi     tosl, '#'
01ffb9 c005              rjmp    DOTBASEEND
                 DOTBASE2:
01ffba 3082              cpi     tosl, 0x2
01ffbb f411              brne    DOTBASE3
01ffbc e285              ldi     tosl, '%'
01ffbd c001              rjmp    DOTBASEEND
                 DOTBASE3:
01ffbe e38f              ldi     tosl, '?'
                 DOTBASEEND:
01ffbf 9508              ret
                 
                 MEMQADDR_N:
01ffc0 e100              fdw     ROM_N
01ffc1 e10e              fdw     EROM_N
01ffc2 e11e              fdw     FRAM_N
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
01ffc3 2081              .db     NFA|1," "
                 MEMQ:
01ffc4 940f f09e         call    CSE_
01ffc6 940f f717         call    DOLIT
01ffc8 ff80              fdw     MEMQADDR_N
01ffc9 940f f239         call    PLUS
01ffcb 940f f657         call    FETCH_A
01ffcd 940f f4bd         call    CFETCHPP
01ffcf 940f f717         call    DOLIT
01ffd1 000f              .dw     NFAmask
01ffd2 940d f24f         jmp     AND_
                 
                 ;*******************************************************
                 umstar0:
01ffd4 9109              ld  t0, Y+
01ffd5 9119              ld  t1, Y+
01ffd6 9f80              mul tosl,t0
01ffd7 01d0              movw t4, r0 ; r0=t2, r1=t3
01ffd8 27ee              clr t6
01ffd9 27ff              clr t7
01ffda 9f90              mul tosh, t0
01ffdb 0db0              add t5, r0
01ffdc 1de1              adc t6, r1
01ffdd 1df5              adc t7, zero
01ffde 9f81              mul tosl, t1
01ffdf 0db0              add t5, r0
01ffe0 1de1              adc t6, r1
01ffe1 1df5              adc t7, zero
01ffe2 9f91              mul tosh, t1
01ffe3 0de0              add t6, r0
01ffe4 1df1              adc t7, r1
01ffe5 93ba              st -Y, t5
01ffe6 93aa              st -Y, t4
01ffe7 01cf              movw tosl, t6
01ffe8 9508              ret
                 
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
01ffe9 0200              .dw      0x0200                ; cse, state
01ffea 0484              .dw      utibbuf-4             ; S0
01ffeb 0447              .dw      usbuf-1               ; R0
01ffec f9b2              fdw      OP_TX_
01ffed fa04              fdw      OP_RX_
01ffee fa44              fdw      OP_RXQ
01ffef 000a              .dw      BASE_DEFAULT          ; BASE
01fff0 0488              .dw      utibbuf               ; TIB
01fff1 ff2e              fdw      OPERATOR_AREA         ; TASK
01fff2 0000              .dw      0                     ; ustatus & uflg
01fff3 0000              .dw      0                     ; source
01fff4 0000              .dw      0                     ; source
01fff5 0000              .dw      0                     ; TOIN
01fff6 03e6              .dw      up0                   ; Task link
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 .equ coldlitsize=12
                 ;.section user_eedata
                 COLDLIT:
01fff7 0000      STARTV: .dw      0
01fff8 3200      DPC:    .dw      OFLASH
01fff9 220c      DPE:    .dw      ehere
01fffa 04dc      DPD:    .dw      dpdata
01fffb f55e      LW:     fdw      lastword
01fffc ecf6      STAT:   fdw      DOTSTATUS
                 
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega2560 register use summary:
r0 :  26 r1 :  17 r2 :   5 r3 :   1 r4 :   0 r5 :  24 r6 :   7 r7 :   6 
r8 :   4 r9 :   4 r10:   6 r11:   5 r12:   6 r13:   3 r14:   3 r15:   2 
r16: 136 r17:  50 r18:   0 r19:   0 r20:  14 r21:   7 r22:  34 r23:  25 
r24: 228 r25: 180 r26:  82 r27:  48 r28:   9 r29:   5 r30:  79 r31:  68 
x  :  17 y  : 186 z  :  36 
Registers used: 32 out of 35 (91.4%)

ATmega2560 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  19 adiw  :   9 and   :   3 
andi  :  22 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  20 brcs  :   1 break :   0 breq  :  49 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   7 
brne  :  38 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   4 bst   :   0 call  :  94 cbi   :   3 cbr   :  23 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :  23 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   7 cp    :   4 cpc   :   2 
cpi   :  30 cpse  :   7 dec   :   4 eicall:   0 eijmp :  14 elpm  :   9 
eor   :   2 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :  19 inc   :   9 jmp   : 165 ld    : 130 ldd   :   2 ldi   :  79 
lds   :  28 lpm   :   0 lsl   :  11 lsr   :   2 mov   :  20 movw  :  40 
mul   :   4 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :   7 
ori   :   7 out   :  37 pop   :  99 push  :  27 rcall :1007 ret   : 131 
reti  :   1 rjmp  : 103 rol   :  15 ror   :  18 sbc   :   2 sbci  :   3 
sbi   :  11 sbic  :   5 sbis  :   0 sbiw  :   8 sbr   :  21 sbrc  :  15 
sbrs  :  19 sec   :   0 seh   :   0 sei   :   3 sen   :   0 ser   :   6 
ses   :   0 set   :   1 sev   :   0 sez   :   0 sleep :   1 spm   :   2 
st    :  87 std   :   3 sts   :  36 sub   :   2 subi  :  12 swap  :   2 
tst   :   4 wdr   :   0 
Instructions used: 71 out of 116 (61.2%)

ATmega2560 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x03de00 0x03fffa   5904   2494   8398  262144   3.2%
[.dseg] 0x000200 0x0004de      0    734    734    8192   9.0%
[.eseg] 0x000000 0x000002      0      2      2    4096   0.0%

Assembly complete, 0 errors, 7 warnings
