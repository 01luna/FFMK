
AVRASM ver. 2.1.30  avr/src/ff-atmega.asm Sun Jan 13 09:51:39 2019

avr/src/ff-atmega.asm(34): Including file 'avr/src/config.inc'
avr/src/config.inc(5): Including file 'avrasm2/inc\m2560def.inc'
avr/src/ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
avr/src/ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
avr/src/ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
avr/src/ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
avr/src/ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
avr/src/ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
avr/src/ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          13.01.2019                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2019  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 .include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega2560.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m2560def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega2560
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega2560
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M2560DEF_INC_
                 #define _M2560DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega2560
                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x98
                 .equ	SIGNATURE_002	= 0x01
                 
                 #pragma AVRPART CORE CORE_VERSION V3
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                 .equ	PINL	= 0x109	; MEMORY MAPPED
                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                 .equ	PINK	= 0x106	; MEMORY MAPPED
                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                 .equ	PINH	= 0x100	; MEMORY MAPPED
                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	EIND	= 0x3c
                 .equ	RAMPZ	= 0x3b
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	OCDR	= 0x31
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR5	= 0x1a
                 .equ	TIFR4	= 0x19
                 .equ	TIFR3	= 0x18
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTG	= 0x14
                 .equ	DDRG	= 0x13
                 .equ	PING	= 0x12
                 .equ	PORTF	= 0x11
                 .equ	DDRF	= 0x10
                 .equ	PINF	= 0x0f
                 .equ	PORTE	= 0x0e
                 .equ	DDRE	= 0x0d
                 .equ	PINE	= 0x0c
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 .equ	PORTA	= 0x02
                 .equ	DDRA	= 0x01
                 .equ	PINA	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** PORTE ************************
                 ; PORTE - Data Register, Port E
                 .equ	PORTE0	= 0	; 
                 .equ	PE0	= 0	; For compatibility
                 .equ	PORTE1	= 1	; 
                 .equ	PE1	= 1	; For compatibility
                 .equ	PORTE2	= 2	; 
                 .equ	PE2	= 2	; For compatibility
                 .equ	PORTE3	= 3	; 
                 .equ	PE3	= 3	; For compatibility
                 .equ	PORTE4	= 4	; 
                 .equ	PE4	= 4	; For compatibility
                 .equ	PORTE5	= 5	; 
                 .equ	PE5	= 5	; For compatibility
                 .equ	PORTE6	= 6	; 
                 .equ	PE6	= 6	; For compatibility
                 .equ	PORTE7	= 7	; 
                 .equ	PE7	= 7	; For compatibility
                 
                 ; DDRE - Data Direction Register, Port E
                 .equ	DDE0	= 0	; 
                 .equ	DDE1	= 1	; 
                 .equ	DDE2	= 2	; 
                 .equ	DDE3	= 3	; 
                 .equ	DDE4	= 4	; 
                 .equ	DDE5	= 5	; 
                 .equ	DDE6	= 6	; 
                 .equ	DDE7	= 7	; 
                 
                 ; PINE - Input Pins, Port E
                 .equ	PINE0	= 0	; 
                 .equ	PINE1	= 1	; 
                 .equ	PINE2	= 2	; 
                 .equ	PINE3	= 3	; 
                 .equ	PINE4	= 4	; 
                 .equ	PINE5	= 5	; 
                 .equ	PINE6	= 6	; 
                 .equ	PINE7	= 7	; 
                 
                 
                 ; ***** PORTF ************************
                 ; PORTF - Data Register, Port F
                 .equ	PORTF0	= 0	; 
                 .equ	PF0	= 0	; For compatibility
                 .equ	PORTF1	= 1	; 
                 .equ	PF1	= 1	; For compatibility
                 .equ	PORTF2	= 2	; 
                 .equ	PF2	= 2	; For compatibility
                 .equ	PORTF3	= 3	; 
                 .equ	PF3	= 3	; For compatibility
                 .equ	PORTF4	= 4	; 
                 .equ	PF4	= 4	; For compatibility
                 .equ	PORTF5	= 5	; 
                 .equ	PF5	= 5	; For compatibility
                 .equ	PORTF6	= 6	; 
                 .equ	PF6	= 6	; For compatibility
                 .equ	PORTF7	= 7	; 
                 .equ	PF7	= 7	; For compatibility
                 
                 ; DDRF - Data Direction Register, Port F
                 .equ	DDF0	= 0	; 
                 .equ	DDF1	= 1	; 
                 .equ	DDF2	= 2	; 
                 .equ	DDF3	= 3	; 
                 .equ	DDF4	= 4	; 
                 .equ	DDF5	= 5	; 
                 .equ	DDF6	= 6	; 
                 .equ	DDF7	= 7	; 
                 
                 ; PINF - Input Pins, Port F
                 .equ	PINF0	= 0	; 
                 .equ	PINF1	= 1	; 
                 .equ	PINF2	= 2	; 
                 .equ	PINF3	= 3	; 
                 .equ	PINF4	= 4	; 
                 .equ	PINF5	= 5	; 
                 .equ	PINF6	= 6	; 
                 .equ	PINF7	= 7	; 
                 
                 
                 ; ***** PORTG ************************
                 ; PORTG - Data Register, Port G
                 .equ	PORTG0	= 0	; 
                 .equ	PG0	= 0	; For compatibility
                 .equ	PORTG1	= 1	; 
                 .equ	PG1	= 1	; For compatibility
                 .equ	PORTG2	= 2	; 
                 .equ	PG2	= 2	; For compatibility
                 .equ	PORTG3	= 3	; 
                 .equ	PG3	= 3	; For compatibility
                 .equ	PORTG4	= 4	; 
                 .equ	PG4	= 4	; For compatibility
                 .equ	PORTG5	= 5	; 
                 .equ	PG5	= 5	; For compatibility
                 
                 ; DDRG - Data Direction Register, Port G
                 .equ	DDG0	= 0	; 
                 .equ	DDG1	= 1	; 
                 .equ	DDG2	= 2	; 
                 .equ	DDG3	= 3	; 
                 .equ	DDG4	= 4	; 
                 .equ	DDG5	= 5	; 
                 
                 ; PING - Input Pins, Port G
                 .equ	PING0	= 0	; 
                 .equ	PING1	= 1	; 
                 .equ	PING2	= 2	; 
                 .equ	PING3	= 3	; 
                 .equ	PING4	= 4	; 
                 .equ	PING5	= 5	; 
                 
                 
                 ; ***** PORTH ************************
                 ; PORTH - PORT H Data Register
                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                 .equ	PH0	= 0	; For compatibility
                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                 .equ	PH1	= 1	; For compatibility
                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                 .equ	PH2	= 2	; For compatibility
                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                 .equ	PH3	= 3	; For compatibility
                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                 .equ	PH4	= 4	; For compatibility
                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                 .equ	PH5	= 5	; For compatibility
                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                 .equ	PH6	= 6	; For compatibility
                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                 .equ	PH7	= 7	; For compatibility
                 
                 ; DDRH - PORT H Data Direction Register
                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                 
                 ; PINH - PORT H Input Pins
                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                 
                 
                 ; ***** PORTJ ************************
                 ; PORTJ - PORT J Data Register
                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                 .equ	PJ0	= 0	; For compatibility
                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                 .equ	PJ1	= 1	; For compatibility
                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                 .equ	PJ2	= 2	; For compatibility
                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                 .equ	PJ3	= 3	; For compatibility
                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                 .equ	PJ4	= 4	; For compatibility
                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                 .equ	PJ5	= 5	; For compatibility
                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                 .equ	PJ6	= 6	; For compatibility
                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                 .equ	PJ7	= 7	; For compatibility
                 
                 ; DDRJ - PORT J Data Direction Register
                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                 
                 ; PINJ - PORT J Input Pins
                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                 
                 
                 ; ***** PORTK ************************
                 ; PORTK - PORT K Data Register
                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                 .equ	PK0	= 0	; For compatibility
                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                 .equ	PK1	= 1	; For compatibility
                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                 .equ	PK2	= 2	; For compatibility
                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                 .equ	PK3	= 3	; For compatibility
                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                 .equ	PK4	= 4	; For compatibility
                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                 .equ	PK5	= 5	; For compatibility
                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                 .equ	PK6	= 6	; For compatibility
                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                 .equ	PK7	= 7	; For compatibility
                 
                 ; DDRK - PORT K Data Direction Register
                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                 
                 ; PINK - PORT K Input Pins
                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                 
                 
                 ; ***** PORTL ************************
                 ; PORTL - PORT L Data Register
                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                 .equ	PL0	= 0	; For compatibility
                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                 .equ	PL1	= 1	; For compatibility
                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                 .equ	PL2	= 2	; For compatibility
                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                 .equ	PL3	= 3	; For compatibility
                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                 .equ	PL4	= 4	; For compatibility
                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                 .equ	PL5	= 5	; For compatibility
                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                 .equ	PL6	= 6	; For compatibility
                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                 .equ	PL7	= 7	; For compatibility
                 
                 ; DDRL - PORT L Data Direction Register
                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                 
                 ; PINL - PORT L Input Pins
                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** USART1 ***********************
                 ; UDR1 - USART I/O Data Register
                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR1A - USART Control and Status Register A
                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                 .equ	U2X1	= 1	; Double the USART transmission speed
                 .equ	UPE1	= 2	; Parity Error
                 .equ	DOR1	= 3	; Data overRun
                 .equ	FE1	= 4	; Framing Error
                 .equ	UDRE1	= 5	; USART Data Register Empty
                 .equ	TXC1	= 6	; USART Transmitt Complete
                 .equ	RXC1	= 7	; USART Receive Complete
                 
                 ; UCSR1B - USART Control and Status Register B
                 .equ	TXB81	= 0	; Transmit Data Bit 8
                 .equ	RXB81	= 1	; Receive Data Bit 8
                 .equ	UCSZ12	= 2	; Character Size
                 .equ	TXEN1	= 3	; Transmitter Enable
                 .equ	RXEN1	= 4	; Receiver Enable
                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR1C - USART Control and Status Register C
                 .equ	UCPOL1	= 0	; Clock Polarity
                 .equ	UCSZ10	= 1	; Character Size
                 .equ	UCPHA1	= UCSZ10	; For compatibility
                 .equ	UCSZ11	= 2	; Character Size
                 .equ	UDORD1	= UCSZ11	; For compatibility
                 .equ	USBS1	= 3	; Stop Bit Select
                 .equ	UPM10	= 4	; Parity Mode Bit 0
                 .equ	UPM11	= 5	; Parity Mode Bit 1
                 .equ	UMSEL10	= 6	; USART Mode Select
                 .equ	UMSEL11	= 7	; USART Mode Select
                 
                 ; UBRR1H - USART Baud Rate Register High Byte
                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR1L - USART Baud Rate Register Low Byte
                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARH - EEPROM Address Register Low Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                 
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_5 **************
                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                 
                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                 .equ	ICF5	= 5	; Input Capture Flag 5
                 
                 ; TCCR5A - Timer/Counter5 Control Register A
                 .equ	WGM50	= 0	; Waveform Generation Mode
                 .equ	WGM51	= 1	; Waveform Generation Mode
                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR5B - Timer/Counter5 Control Register B
                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                 .equ	WGM52	= 3	; Waveform Generation Mode
                 .equ	WGM53	= 4	; Waveform Generation Mode
                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                 
                 ; TCCR5C - Timer/Counter 5 Control Register C
                 .equ	FOC5C	= 5	; Force Output Compare 5C
                 .equ	FOC5B	= 6	; Force Output Compare 5B
                 .equ	FOC5A	= 7	; Force Output Compare 5A
                 
                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                 
                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                 
                 
                 ; ***** TIMER_COUNTER_4 **************
                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                 
                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                 .equ	ICF4	= 5	; Input Capture Flag 4
                 
                 ; TCCR4A - Timer/Counter4 Control Register A
                 .equ	WGM40	= 0	; Waveform Generation Mode
                 .equ	WGM41	= 1	; Waveform Generation Mode
                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR4B - Timer/Counter4 Control Register B
                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                 .equ	WGM42	= 3	; Waveform Generation Mode
                 .equ	WGM43	= 4	; Waveform Generation Mode
                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                 
                 ; TCCR4C - Timer/Counter 4 Control Register C
                 .equ	FOC4C	= 5	; Force Output Compare 4C
                 .equ	FOC4B	= 6	; Force Output Compare 4B
                 .equ	FOC4A	= 7	; Force Output Compare 4A
                 
                 
                 ; ***** TIMER_COUNTER_3 **************
                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                 
                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                 .equ	ICF3	= 5	; Input Capture Flag 3
                 
                 ; TCCR3A - Timer/Counter3 Control Register A
                 .equ	WGM30	= 0	; Waveform Generation Mode
                 .equ	WGM31	= 1	; Waveform Generation Mode
                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR3B - Timer/Counter3 Control Register B
                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                 .equ	WGM32	= 3	; Waveform Generation Mode
                 .equ	WGM33	= 4	; Waveform Generation Mode
                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                 
                 ; TCCR3C - Timer/Counter 3 Control Register C
                 .equ	FOC3C	= 5	; Force Output Compare 3C
                 .equ	FOC3B	= 6	; Force Output Compare 3B
                 .equ	FOC3A	= 7	; Force Output Compare 3A
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter 1 Control Register C
                 .equ	FOC1C	= 5	; Force Output Compare 1C
                 .equ	FOC1B	= 6	; Force Output Compare 1B
                 .equ	FOC1A	= 7	; Force Output Compare 1A
                 
                 
                 ; ***** JTAG *************************
                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                 .equ	IDRD	= OCDR7	; For compatibility
                 
                 ; MCUCR - MCU Control Register
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register A
                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                 
                 ; EICRB - External Interrupt Control Register B
                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 .equ	INTF2	= 2	; External Interrupt Flag 2
                 .equ	INTF3	= 3	; External Interrupt Flag 3
                 .equ	INTF4	= 4	; External Interrupt Flag 4
                 .equ	INTF5	= 5	; External Interrupt Flag 5
                 .equ	INTF6	= 6	; External Interrupt Flag 6
                 .equ	INTF7	= 7	; External Interrupt Flag 7
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	PUD	= 4	; Pull-up disable
                 ;.equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                 
                 ; XMCRA - External Memory Control Register A
                 .equ	SRW00	= 0	; Wait state select bit lower page
                 .equ	SRW01	= 1	; Wait state select bit lower page
                 .equ	SRW10	= 2	; Wait state select bit upper page
                 .equ	SRW11	= 3	; Wait state select bit upper page
                 .equ	SRL0	= 4	; Wait state page limit
                 .equ	SRL1	= 5	; Wait state page limit
                 .equ	SRL2	= 6	; Wait state page limit
                 .equ	SRE	= 7	; External SRAM Enable
                 
                 ; XMCRB - External Memory Control Register B
                 .equ	XMM0	= 0	; External Memory High Mask
                 .equ	XMM1	= 1	; External Memory High Mask
                 .equ	XMM2	= 2	; External Memory High Mask
                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - 
                 .equ	CLKPS0	= 0	; 
                 .equ	CLKPS1	= 1	; 
                 .equ	CLKPS2	= 2	; 
                 .equ	CLKPS3	= 3	; 
                 .equ	CLKPCE	= 7	; 
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                 
                 ; RAMPZ - RAM Page Z Select Register
                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                 
                 ; EIND - Extended Indirect Register
                 .equ	EIND0	= 0	; Bit 0
                 
                 ; GPIOR2 - General Purpose IO Register 2
                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                 
                 ; GPIOR1 - General Purpose IO Register 1
                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                 
                 ; GPIOR0 - General Purpose IO Register 0
                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                 
                 ; PRR1 - Power Reduction Register1
                 .equ	PRUSART1	= 0	; Power Reduction USART1
                 .equ	PRUSART2	= 1	; Power Reduction USART2
                 .equ	PRUSART3	= 2	; Power Reduction USART3
                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                 
                 ; PRR0 - Power Reduction Register0
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                 ;.equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 .equ	ADC6D	= 6	; 
                 .equ	ADC7D	= 7	; 
                 
                 ; DIDR2 - Digital Input Disable Register
                 .equ	ADC8D	= 0	; 
                 .equ	ADC9D	= 1	; 
                 .equ	ADC10D	= 2	; 
                 .equ	ADC11D	= 3	; 
                 .equ	ADC12D	= 4	; 
                 .equ	ADC13D	= 5	; 
                 .equ	ADC14D	= 6	; 
                 .equ	ADC15D	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write section read enable
                 .equ	SIGRD	= 5	; Signature Row Read
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** USART2 ***********************
                 ; UDR2 - USART I/O Data Register
                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR2A - USART Control and Status Register A
                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                 .equ	U2X2	= 1	; Double the USART transmission speed
                 .equ	UPE2	= 2	; Parity Error
                 .equ	DOR2	= 3	; Data overRun
                 .equ	FE2	= 4	; Framing Error
                 .equ	UDRE2	= 5	; USART Data Register Empty
                 .equ	TXC2	= 6	; USART Transmitt Complete
                 .equ	RXC2	= 7	; USART Receive Complete
                 
                 ; UCSR2B - USART Control and Status Register B
                 .equ	TXB82	= 0	; Transmit Data Bit 8
                 .equ	RXB82	= 1	; Receive Data Bit 8
                 .equ	UCSZ22	= 2	; Character Size
                 .equ	TXEN2	= 3	; Transmitter Enable
                 .equ	RXEN2	= 4	; Receiver Enable
                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR2C - USART Control and Status Register C
                 .equ	UCPOL2	= 0	; Clock Polarity
                 .equ	UCSZ20	= 1	; Character Size
                 .equ	UCSZ21	= 2	; Character Size
                 .equ	USBS2	= 3	; Stop Bit Select
                 .equ	UPM20	= 4	; Parity Mode Bit 0
                 .equ	UPM21	= 5	; Parity Mode Bit 1
                 .equ	UMSEL20	= 6	; USART Mode Select
                 .equ	UMSEL21	= 7	; USART Mode Select
                 
                 ; UBRR2H - USART Baud Rate Register High Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR2L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** USART3 ***********************
                 ; UDR3 - USART I/O Data Register
                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR3A - USART Control and Status Register A
                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                 .equ	U2X3	= 1	; Double the USART transmission speed
                 .equ	UPE3	= 2	; Parity Error
                 .equ	DOR3	= 3	; Data overRun
                 .equ	FE3	= 4	; Framing Error
                 .equ	UDRE3	= 5	; USART Data Register Empty
                 .equ	TXC3	= 6	; USART Transmitt Complete
                 .equ	RXC3	= 7	; USART Receive Complete
                 
                 ; UCSR3B - USART Control and Status Register B
                 .equ	TXB83	= 0	; Transmit Data Bit 8
                 .equ	RXB83	= 1	; Receive Data Bit 8
                 .equ	UCSZ32	= 2	; Character Size
                 .equ	TXEN3	= 3	; Transmitter Enable
                 .equ	RXEN3	= 4	; Receiver Enable
                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR3C - USART Control and Status Register C
                 .equ	UCPOL3	= 0	; Clock Polarity
                 .equ	UCSZ30	= 1	; Character Size
                 .equ	UCSZ31	= 2	; Character Size
                 .equ	USBS3	= 3	; Stop Bit Select
                 .equ	UPM30	= 4	; Parity Mode Bit 0
                 .equ	UPM31	= 5	; Parity Mode Bit 1
                 .equ	UMSEL30	= 6	; USART Mode Select
                 .equ	UMSEL31	= 7	; USART Mode Select
                 
                 ; UBRR3H - USART Baud Rate Register High Byte
                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR3L - USART Baud Rate Register Low Byte
                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog timer always on
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                 .equ	IOEND	= 0x01ff
                 .equ	SRAM_START	= 0x0200
                 .equ	SRAM_SIZE	= 8192
                 .equ	RAMEND	= 0x21ff
                 .equ	XRAMEND	= 0xffff
                 .equ	E2END	= 0x0fff
                 .equ	EEPROMEND	= 0x0fff
                 .equ	EEADRBITS	= 12
                 #pragma AVRPART MEMORY PROG_FLASH 262144
                 #pragma AVRPART MEMORY EEPROM 4096
                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x1f000
                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x1efff
                 .equ	PAGESIZE	= 128
                 .equ	FIRSTBOOTSTART	= 0x1fe00
                 .equ	SECONDBOOTSTART	= 0x1fc00
                 .equ	THIRDBOOTSTART	= 0x1f800
                 .equ	FOURTHBOOTSTART	= 0x1f000
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                 
                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                 
                 #endif  /* _M2560DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 ;.include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program. Or use the ff-shell.py which adds CR LF flow control.
                 .equ BAUDRATE0 = 38400               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 0
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 7            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 32 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 90                   ; 80 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 ; Debug flash and eeprom writes
                 ; Prints F=Write to FLASH E=Write to EEPROM
                 .equ DEBUG_FLASH = 0
                 
                 #if defined(__ATmega2560__)
                 #define partstring "ATmega2560"
                 #elif defined(__ATmega328P__)
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "13.01.2019"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def r_zero = r5      ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def al = r18
                   .def ah = r19
                   .def pl = r20         ; P Register and FOR..LOOP INDEX variable
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ; Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*255/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fIDLE=     6   ; 0 = busy, 1 = idle
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ fLIT=    7     ; Literal compiled
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords flash
                 .equ OFLASH  = PEEPROM+EEPROMEND+1    ; 52 Kbytes available for FlashForth(atm2560)
                 .equ PFLASH  = 0
                 .equ RAMPZV  = 3
                 .equ KERNEL_SIZE=0x0d80
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000200           ibuf:         .byte PAGESIZEB
000300           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
000372           rbuf0_wr:    .byte 1
000373           rbuf0_rd:    .byte 1
000374           rbuf0_lv:    .byte 1
000375           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 rxqueue1:
000395           rbuf1_wr:    .byte 1
000396           rbuf1_rd:    .byte 1
000397           rbuf1_lv:    .byte 1
000398           rbuf1:       .byte RX1_BUF_SIZE
                 .endif
                 
0003b8           litbuf0:    .byte 1
0003b9           litbuf1:    .byte 1
                 
0003ba           dpSTART:    .byte 2
0003bc           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0003be           dpEEPROM:   .byte 2
0003c0           dpRAM:      .byte 2
0003c2           dpLATEST:   .byte 2
                 
0003c4           iaddrl:     .byte 1
0003c5           iaddrh:     .byte 1
                 .ifdef RAMPZ
0003c6           iaddru:	    .byte 1
0003c7           ibaseu:	    .byte 1
                 .endif
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1       
                 .endif
                 .endif
                 
0003c8           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0003c9           state:      .byte 1 ; Compilation state
0003ca           uvars:      .byte   (-us0)
0003e6           up0:        .byte   2
0003e8           urbuf:      .byte   ursize
000448           usbuf:      .byte   ussize
000488           utibbuf:    .byte   utibsize
0004e2           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .if (FLASHEND == 0x1ffff)
                 .org 0x17e80
                 .else
                 .endif
                 ;***********************************************************
                 CMP:
017e80 940f f1d3         call    TOR
017e82 c009              rjmp    CMP2
                 CMP1:
017e83 940f ef1b         call    NEQUALSFETCH
017e85 940f f208         call    MINUS
017e87 940f f319         call    ZEROSENSE
017e89 f011              breq    CMP2
017e8a 940d f886         jmp     TWODROPZ
                 CMP2:
017e8c 940f f9b6         call    XNEXT
017e8e f7a0              brcc    CMP1
017e8f 940d f882         jmp     TWODROPNZ
                 
                 .if (FLASHEND == 0x1ffff)
                 .org KERNEL_START+0x0
                 .endif
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
01ee80 0200              .dw      0x0200                ; cse, state
01ee81 0484              .dw      utibbuf-4             ; S0
01ee82 0447              .dw      usbuf-1               ; R0
01ee83 f96e              fdw      OP_TX_
01ee84 f9bc              fdw      OP_RX_
01ee85 f9fc              fdw      OP_RXQ
01ee86 000a              .dw      BASE_DEFAULT          ; BASE
01ee87 0488              .dw      utibbuf               ; TIB
01ee88 dda6              fdw      OPERATOR_AREA         ; TASK
01ee89 0000              .dw      0                     ; ustatus & uflg
01ee8a 0000              .dw      0                     ; source
01ee8b 0000              .dw      0                     ; source
01ee8c 0000              .dw      0                     ; TOIN
01ee8d 03e6              .dw      up0                   ; Task link
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
01ee8e 2081              .db     NFA|1," "
                 MEMQ:
01ee8f 940f f060         call    CSE_
01ee91 940f f6f9         call    DOLIT
01ee93 ff68              fdw     MEMQADDR_N
01ee94 940f f1fb         call    PLUS
01ee96 940f f63a         call    FETCH_A
01ee98 940f f4a1         call    CFETCHPP
01ee9a 940f f6f9         call    DOLIT
01ee9c 000f              .dw     NFAmask
01ee9d 940d f243         jmp     AND_
                 
                 .if (FLASHEND == 0x1ffff)
01ee9f feda              fdw     PAUSE_L
                 WDON_L:
01eea0 7783
01eea1 2b64              .db     NFA|3,"wd+"
                 WDON:
01eea2 94f8              cli
01eea3 95a8              wdr
01eea4 9190 0060         lds     tosh, WDTCSR
01eea6 6198              ori     tosh, (1<<WDCE)|(1<<WDE)
01eea7 9390 0060         sts     WDTCSR, tosh
01eea9 7087              andi    tosl, 7
01eeaa 6088              ori     tosl, (1<<WDE)
01eeab 9380 0060         sts     WDTCSR, tosl
01eead 9478              sei
01eeae 940d f1b2         jmp     DROP
                 
                 ; WD- ( -- )    stop the watchdog
01eeb0 dd40              fdw     WDON_L
                 WDOFF_L:
01eeb1 7783
01eeb2 2d64              .db     NFA|3,"wd-"
                 WDOFF:
01eeb3 94f8              cli
01eeb4 95a8              wdr
                 .ifdef MCUSR
01eeb5 be54              out     MCUSR, r_zero
                 .else
                 .endif
01eeb6 e108              ldi     t0, (1<<WDCE)|(1<<WDE)
01eeb7 9300 0060         sts     WDTCSR, t0
01eeb9 9250 0060         sts     WDTCSR, r_zero
01eebb 9478              sei
01eebc 9508              ret
                 
                 ; WDR ( -- )    kick the dog
01eebd dd62              fdw     WDOFF_L
                 CWD_L:
01eebe 63a3
01eebf 6477              .db     NFA|INLINE|3,"cwd"
                 CWD:
01eec0 95a8              wdr
01eec1 9508              ret
                 .endif
                 ;*********************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
01eec2 0000              .dw     0
                 EXIT_L:
01eec3 6584
01eec4 6978
01eec5 0074              .db     NFA|4,"exit",0
                 EXIT:
01eec6 910f              m_pop_t0
01eec7 910f              pop     t0
01eec8 910f              pop     t0
01eec9 9508              ret
                 
01eeca fb0c              fdw     IFLUSH_L
                 OPERATOR_L:
01eecb 6f88
01eecc 6570
01eecd 6172
01eece 6f74
01eecf 0072              .db     NFA|8,"operator",0
                 OPERATOR:
01eed0 940f eff2         call    DOCREATE
01eed2 dda6              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
01eed3 03e6              .dw     up0
01eed4 0000
01eed5 0060              .dw     0, ursize
01eed6 0040
01eed7 005a              .dw     ussize, utibsize
                 
                 ; idle
01eed8 dd86              fdw(EXIT_L)
                 IDLE_L:
01eed9 6984
01eeda 6c64
01eedb 0065              .db     NFA|4,"idle",0
                 IDLE:
01eedc 6470              sbr     FLAGS2, (1<<fIDLE)
01eedd 9508              ret
                         
                 ; busy
01eede ddb2              fdw(IDLE_L)
                 BUSY_L:
01eedf 6284
01eee0 7375
01eee1 0079              .db     NFA|4,"busy",0
                 BUSY:
01eee2 7b7f              cbr     FLAGS2, (1<<fIDLE)
01eee3 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
01eee4 ff32              fdw     ICCOMMA_L
                 MSET_L:
01eee5 6d84
01eee6 6573
01eee7 0074              .db     NFA|4,"mset",0
                 MSET:
01eee8 01fc              movw    zl, tosl
01eee9 9189
01eeea 9199              poptos
01eeeb 8100              ld      t0, z
01eeec 2b08              or      t0, tosl
01eeed 8300              st      z, t0
01eeee 9189
01eeef 9199              poptos
01eef0 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
01eef1 ddca              fdw     MSET_L
                 MCLR_L:
01eef2 6d84
01eef3 6c63
01eef4 0072              .db     NFA|4,"mclr",0
                 MCLR_:
01eef5 01fc              movw    zl, tosl
01eef6 9189
01eef7 9199              poptos
01eef8 8100              ld      t0, z
01eef9 9580              com     tosl
01eefa 2308              and     t0, tosl
01eefb 8300              st      z, t0
01eefc 9189
01eefd 9199              poptos
01eefe 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
01eeff dde4              fdw     MCLR_L
                 LSHIFT_L:
01ef00 6c86
01ef01 6873
01ef02 6669
01ef03 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
01ef04 01fc              movw    zl, tosl
01ef05 9189
01ef06 9199              poptos
                 LSHIFT1:
01ef07 9731              sbiw    zl, 1
01ef08 f01a              brmi    LSHIFT2
01ef09 0f88              lsl     tosl
01ef0a 1f99              rol     tosh
01ef0b cffb              rjmp    LSHIFT1
                 LSHIFT2:
01ef0c 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
01ef0d de00              fdw     LSHIFT_L
                 RSHIFT_L:
01ef0e 7286
01ef0f 6873
01ef10 6669
01ef11 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
01ef12 01fc              movw    zl, tosl
01ef13 9189
01ef14 9199              poptos
                 RSHIFT1:
01ef15 9731              sbiw    zl, 1
01ef16 f01a              brmi    RSHIFT2
01ef17 9596              lsr     tosh
01ef18 9587              ror     tosl
01ef19 cffb              rjmp    RSHIFT1
                 RSHIFT2:
01ef1a 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
01ef1b d585              rcall   CFETCHPP
01ef1c d2ae              rcall   ROT
01ef1d d583              rcall   CFETCHPP
01ef1e c2ac              rjmp    ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
01ef1f de1c              fdw     RSHIFT_L
                 NEQUAL_L:
01ef20 6e82
01ef21 003d              .db     NFA|2,"n=",0
                 NEQUAL:
01ef22 dff8              rcall   NEQUALSFETCH
01ef23 708f              andi    tosl, 0xf
01ef24 d383              rcall   EQUAL
01ef25 d3f3              rcall   ZEROSENSE
01ef26 f0b1              breq    NEQUAL5
01ef27 d349              rcall   ONEMINUS
01ef28 d578              rcall   CFETCHPP
01ef29 d2a9              rcall   TOR
01ef2a c00c              rjmp    NEQUAL4
                 NEQUAL2:
01ef2b dfef              rcall   NEQUALSFETCH
01ef2c d376              rcall   NOTEQUAL
01ef2d d3eb              rcall   ZEROSENSE
01ef2e f021              breq    NEQUAL3
01ef2f d774              rcall   TRUE_
01ef30 940f f9c7         call    LEAVE
01ef32 c004              rjmp    NEQUAL4
                 NEQUAL3:
01ef33 d2b5              rcall   RFETCH
01ef34 d3e4              rcall   ZEROSENSE
01ef35 f409              brne    NEQUAL4
01ef36 d764              rcall   FALSE_
                 NEQUAL4:
01ef37 940f f9b6         call    XNEXT
01ef39 f788              brcc    NEQUAL2
01ef3a 911f              pop     t1
01ef3b 910f              pop     t0
01ef3c c001              rjmp    NEQUAL6
                 NEQUAL5:
01ef3d d766              rcall   TRUE_
                 NEQUAL6:
01ef3e d41b              rcall   NIP
01ef3f 940d f35a         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
01ef41 de40              fdw     NEQUAL_L
                 SKIP_L:
01ef42 7384
01ef43 696b
01ef44 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
01ef45 d28d              rcall   TOR
                 SKIP0:
01ef46 d3d8              rcall   DUPZEROSENSE
01ef47 f089              breq    SKIP2
                 
01ef48 d27a              rcall   OVER
01ef49 d432              rcall   CFETCH_A
                 
01ef4a d7b8              rcall   DUP
01ef4b d7ad              rcall   DOLIT
01ef4c 0009              .dw     TAB_
01ef4d d35a              rcall   EQUAL
01ef4e d3ca              rcall   ZEROSENSE
01ef4f f429              brne    SKIP05    
01ef50 d298              rcall   RFETCH
01ef51 d356              rcall   EQUAL
01ef52 d3c6              rcall   ZEROSENSE
01ef53 f029              breq    SKIP2
01ef54 c001                      rjmp    SKIP1
                 SKIP05:
01ef55 d25c              rcall   DROP
                 SKIP1:
01ef56 d1c9              rcall   ONE
01ef57 d4f4              rcall   SLASHSTRING
01ef58 cfed              rjmp    SKIP0
                 SKIP2:
01ef59 910f              pop     t0
01ef5a 910f              pop     t0
01ef5b 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
01ef5c de84              fdw     SKIP_L
                 SCAN_L:
01ef5d 7384
01ef5e 6163
01ef5f 006e              .db     NFA|4,"scan",0
                 SCAN:
01ef60 d36c              rcall   STORE_P_TO_R
01ef61 d271              rcall   TOR
01ef62 c010              rjmp    SCAN3
                 SCAN1:
01ef63 d53d              rcall   CFETCHPP
01ef64 d79e              rcall   DUP
01ef65 d793              rcall   DOLIT
01ef66 0009              .dw     TAB_
01ef67 d340              rcall   EQUAL
01ef68 d3b0              rcall   ZEROSENSE
01ef69 f011              breq    SCAN2
01ef6a d247              rcall   DROP
01ef6b c005              rjmp    SCAN25
                 SCAN2:
01ef6c 940f fa9c         call    FETCH_P
01ef6e d339              rcall   EQUAL
01ef6f d3a9              rcall   ZEROSENSE
01ef70 f011              breq    SCAN3
                 SCAN25:
01ef71 d2ff              rcall   ONEMINUS
01ef72 c003              rjmp    SCAN4
                 SCAN3:
01ef73 940f f9b6         call    XNEXT
01ef75 f768              brcc    SCAN1
                 SCAN4:
01ef76 d267              rcall   RFROM
01ef77 d2f4              rcall   ONEPLUS
01ef78 d360              rcall   R_TO_P
01ef79 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
01ef7a deba              fdw     SCAN_L
                 MTST_L:
01ef7b 6d84
01ef7c 7374
01ef7d 0074              .db     NFA|4,"mtst",0
                 MTST:
01ef7e 01fc              movw    zl, tosl
01ef7f 9181              ld      tosl, z+
01ef80 9109              ld      t0, Y+
01ef81 9119              ld      t1, Y+
01ef82 2380              and     tosl, t0
01ef83 2799              clr     tosh
01ef84 9508              ret
                 
                 
01ef85 def6              fdw     MTST_L
                 FCY_L:
01ef86 4683
01ef87 7963              .db     NFA|3,"Fcy"
01ef88 d069              rcall   DOCREATE
01ef89 3e80              .dw     FREQ_OSC / 1000
                 
                 ;;; Check parameter stack pointer
01ef8a 7383
01ef8b 3f70              .db     NFA|3,"sp?"
                 check_sp:
01ef8c d08e              rcall   SPFETCH
01ef8d 940f f830         call    R0_
01ef8f d6aa              rcall   FETCH_A
01ef90 940f f82b         call    S0
01ef92 d6a7              rcall   FETCH_A
01ef93 d2d8              rcall   ONEPLUS
01ef94 d304              rcall   WITHIN
01ef95 d1e0              rcall   XSQUOTE
01ef96 5303
01ef97 3f50              .db     3,"SP?"
01ef98 d74c              rcall   QABORT
01ef99 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
01ef9a df0c              fdw     FCY_L
                 EMIT_L:
01ef9b 6584
01ef9c 696d
01ef9d 0074              .db     NFA|4,"emit",0
                 EMIT:
01ef9e d36a              rcall   UEMIT_
01ef9f 940d efbd         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
01efa1 df36              fdw     EMIT_L
                 KEY_L:
01efa2 6b83
01efa3 7965              .db     NFA|3,"key"
                 KEY:
01efa4 d36a              rcall   UKEY_
01efa5 940d efbd         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
01efa7 df44              fdw     KEY_L
                 KEYQ_L:
01efa8 6b84
01efa9 7965
01efaa 003f              .db     NFA|4,"key?",0
                 KEYQ:
01efab d369              rcall   UKEYQ_
01efac 940d efbd         jmp     FEXECUTE
                 
01efae df50              fdw     KEYQ_L
                 EXECUTE_L:
01efaf 6587
01efb0 6578
01efb1 7563
01efb2 6574              .db     NFA|7,"execute"
                 EXECUTE:
01efb3 01fc              movw    zl, tosl
                         sub_pflash_z
01efb4 9189
01efb5 9199              poptos
01efb6 9408              rampv_to_c
01efb7 95f7              ror     zh
01efb8 95e7              ror     zl
01efb9 9419              mijmp
                 
01efba df5e              fdw     EXECUTE_L
                 FEXECUTE_L:
01efbb 4083
01efbc 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
01efbd d67c              rcall   FETCH_A
01efbe 940d efb3         jmp     EXECUTE
                 
01efc0 df76              fdw     FEXECUTE_L
                 VARIABLE_L:
01efc1 7688
01efc2 7261
01efc3 6169
01efc4 6c62
01efc5 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
01efc6 d0a3              rcall   HERE
01efc7 d0b8              rcall   CELL
01efc8 d1e2              rcall   ALLOT
01efc9 940d efdd         jmp     CONSTANT_
                 
01efcb df82              fdw     VARIABLE_L
                 TWOVARIABLE_L:
01efcc 3289
01efcd 6176
01efce 6972
01efcf 6261
01efd0 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
01efd1 d098              rcall   HERE
01efd2 d726              rcall   DOLIT
01efd3 0004              .dw     0x4
01efd4 d1d6              rcall   ALLOT
01efd5 940d efdd         jmp     CONSTANT_
                 
01efd7 df98              fdw     TWOVARIABLE_L
                 CONSTANT_L:
01efd8 6388
01efd9 6e6f
01efda 7473
01efdb 6e61
01efdc 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
01efdd d7e7              rcall   COLON
01efde 940f fe6d         call    LITERAL
01efe0 940d f7d3         jmp     SEMICOLON
                 
01efe2 dfb0              fdw     CONSTANT_L
                 TWOCONSTANT_L:
01efe3 3289
01efe4 6f63
01efe5 736e
01efe6 6174
01efe7 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
01efe8 d1d0              rcall   SWOP
01efe9 d7db              rcall   COLON
01efea 940f fe6d         call    LITERAL
01efec 940f fe6d         call    LITERAL
01efee 940d f7d3         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
01eff0 2883
01eff1 2963              .db     NFA|3, "(c)"
                 DOCREATE:
01eff2 91ff              m_pop_zh
01eff3 91ff              pop     zh
01eff4 91ef              pop     zl
01eff5 d00f              rcall   FETCHLIT
01eff6 91ff              m_pop_zh
01eff7 91ff              pop     zh
01eff8 91ef              pop     zl
01eff9 9419              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
01effa 2883
01effb 2964              .db     NFA|3, "(d)"
                 DODOES:
01effc 91bf              m_pop_xh
01effd 91bf              pop     xh
01effe 91af              pop     xl
01efff 91ff              m_pop_zh
01f000 91ff              pop     zh
01f001 91ef              pop     zl
01f002 d002              rcall   FETCHLIT
01f003 01fd              movw    z, x
01f004 9419              mijmp    ; (z)
                 
                 FETCHLIT:
01f005 939a
01f006 938a              pushtos
01f007 0fee              lsl     zl
01f008 1fff              rol     zh
01f009 9187              lpm_    tosl, z+
01f00a 9197              lpm_    tosh, z+
01f00b 9508              ret
                 
01f00c 2883
01f00d 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
01f00e 910f              m_pop_t0
01f00f 91ff              pop     zh
01f010 91ef              pop     zl
01f011 dff3              rcall   FETCHLIT
01f012 95f7              ror     zh
01f013 95e7              ror     zl
01f014 93ef              push    zl
01f015 93ff              push    zh
01f016 930f              m_push_t0
01f017 c099              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
01f018 dfc6              fdw     TWOCONSTANT_L
                 SPFETCH_L:
01f019 7383
01f01a 4070              .db     NFA|3,"sp@"
                 SPFETCH:
01f01b 01fe              movw    z, y
01f01c 939a
01f01d 938a              pushtos
01f01e 01cf              movw    tosl, z
01f01f 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
01f020 7383
01f021 2170              .db     NFA|3,"sp!"
                 SPSTORE:
01f022 01ec              movw    y, tosl
01f023 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
01f024 7283
01f025 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
01f026 91bf              m_pop_xh
01f027 91bf              pop     xh
01f028 91af              pop     xl
01f029 940f f830         call    R0_
01f02b d60e              rcall   FETCH_A
01f02c bf8d              out     spl, tosl
01f02d bf9e              out     sph, tosh
01f02e 9189
01f02f 9199              poptos
01f030 01fd              movw    zl, xl
01f031 9419              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
01f032 e032              fdw     SPFETCH_L
                 RPFETCH_L:
01f033 72b3
01f034 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
01f035 939a
01f036 938a              pushtos
01f037 b78d              in      tosl, spl
01f038 b79e              in      tosh, sph
01f039 9508              ret
                 
                 ;   ><  Swap bytes        
01f03a e066              fdw     RPFETCH_L
                 SWAPB_L:
01f03b 3ea2
01f03c 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
01f03d 2f08              mov     t0, tosl
01f03e 2f89              mov     tosl, tosh
01f03f 2f90              mov     tosh, t0
01f040 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
01f041 e076              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
01f042 6685
01f043 616c
01f044 6873              .db     NFA|5,"flash"
                 ROM_:
01f045 9250 03c8         sts     cse, r_zero
01f047 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
01f048 e084              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
01f049 6586
01f04a 7065
01f04b 6f72
01f04c 006d              .db     NFA|6,"eeprom",0
                 EROM:
01f04d 9270 03c8         sts     cse, r_two
01f04f 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
01f050 e092              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
01f051 7283
01f052 6d61              .db     NFA|3,"ram"
                 FRAM:
01f053 e004              ldi     t0, 4
01f054 9300 03c8         sts     cse, t0
01f056 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
01f057 e0a2              fdw     RAM_L
                 DP_L:
01f058 6482
01f059 0070              .db     NFA|2,"dp",0
                 DP:
01f05a d73e              rcall   IDP
01f05b d004              rcall   CSE_
01f05c 940d f1fb         jmp     PLUS
                 
                 
                 ;;; 
01f05e 6383
01f05f 6573              .db     NFA|3,"cse"
                 CSE_:
01f060 939a
01f061 938a              pushtos
01f062 9180 03c8         lds     tosl, cse
01f064 2799              clr     tosh
01f065 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
01f066 e0b0              fdw     DP_L
                 HERE_L:
01f067 6884
01f068 7265
01f069 0065              .db     NFA|4,"here",0
                 HERE:
01f06a dfef              rcall   DP
01f06b 940d fed9         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
01f06d e0ce              fdw     HERE_L
                 COMMA_L:
01f06e 2c81              .db     NFA|1,","
                 COMMA:
01f06f dffa              rcall   HERE
01f070 d43e              rcall   STORE_A
01f071 d00e              rcall   CELL
01f072 940d f1ab         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
01f074 e0dc              fdw     COMMA_L 
                 CCOMMA_L:
01f075 6382
01f076 002c              .db     NFA|2,"c,",0
                 CCOMMA:
01f077 dff2              rcall   HERE
01f078 d307              rcall   CSTORE_A
01f079 d0a6              rcall   ONE
01f07a 940d f1ab         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
01f07c e0ea              fdw     CCOMMA_L
                 CELL_L:
01f07d 6384
01f07e 6c65
01f07f 006c              .db     NFA|4,"cell",0
                 CELL:
01f080 939a
01f081 938a              pushtos
01f082 e082              ldi     tosl, 2
01f083 e090              ldi     tosh, 0
01f084 9508              ret
                 
                 ; ALIGN    --                         align DP
01f085 e0fa              fdw     CELL_L
                 ALIGN_L:
01f086 6185
01f087 696c
01f088 6e67              .db     NFA|5,"align"
                 ALIGN:
01f089 dfe0              rcall   HERE
01f08a d008              rcall   ALIGNED
01f08b dfce              rcall   DP
01f08c 940d fe9c         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
01f08e e10c              fdw     ALIGN_L
                 ALIGNED_L:
01f08f 6187
01f090 696c
01f091 6e67
01f092 6465              .db     NFA|7,"aligned"
                 ALIGNED:
01f093 9601              adiw    tosl, 1
01f094 7f8e              cbr     tosl, 1
01f095 9508              ret
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
01f096 e11e              fdw     ALIGNED_L
                 CELLPLUS_L:
01f097 63a5
01f098 6c65
01f099 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
01f09a 9602              adiw    tosl, 2
01f09b 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
01f09c e12e              fdw     CELLPLUS_L
                 CELLS_L:
01f09d 63a5
01f09e 6c65
01f09f 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
01f0a0 0f88              lsl     tosl
01f0a1 1f99              rol     tosh
01f0a2 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
01f0a3 e13a              fdw     CELLS_L
                 CHARPLUS_L:
01f0a4 63a5
01f0a5 6168
01f0a6 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
01f0a7 9601              adiw    tosl, 1
01f0a8 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
01f0a9 e148              fdw     CHARPLUS_L
                 CHARS_L:
01f0aa 63a5
01f0ab 6168
01f0ac 7372              .db     NFA|INLINE|5,"chars"
01f0ad 9508      CHARS:  ret
                 
01f0ae e154              fdw     CHARS_L
                 COMMAXT_L:
01f0af 6383
01f0b0 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
01f0b1 d651              rcall   DUP
01f0b2 d67d              rcall   IHERE
01f0b3 d154              rcall   MINUS
01f0b4 d141              rcall   ABS_ 
01f0b5 d643              rcall   DOLIT
01f0b6 0ff0              .dw     0xff0
01f0b7 d1fa              rcall   GREATER
01f0b8 d260              rcall   ZEROSENSE
01f0b9 f041              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
01f0ba d63e              rcall   DOLIT
                 .ifdef EIND
01f0bb 940f              .dw     0x940F  ; On Atmega 2560 all code is on 128 - 256 Kword area.
                 .else
                 .endif
01f0bc 940f ff91         call    ICOMMA
                         sub_pflash_tos
01f0be 9408              rampv_to_c
01f0bf 9597              ror     tosh
01f0c0 9587              ror     tosl
01f0c1 c006              rjmp    STORECF2
                 STORECF1:
01f0c2 d66d              rcall   IHERE
01f0c3 d144              rcall   MINUS
01f0c4 d748              rcall   TWOMINUS
01f0c5 d1c1              rcall   TWOSLASH
                         ;rcall   RCALL_
01f0c6 709f              andi    tosh, 0x0f
01f0c7 6d90              ori     tosh, 0xd0
                 STORECF2:
01f0c8 940d ff91         jmp    ICOMMA
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
01f0ca 2182
01f0cb 003a              .db     NFA|2,"!:",0
                 STORCOLON:
01f0cc d62c              rcall   DOLIT
01f0cd fffa              .dw     0xfffa         ;  -6
01f0ce 940d f8e9         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
01f0d0 e15e              fdw     COMMAXT_L
                 TWOFETCH_L:
01f0d1 3282
01f0d2 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
01f0d3 d62f              rcall   DUP
01f0d4 d565              rcall   FETCH_A
01f0d5 d0e3              rcall   SWOP
01f0d6 dfc3              rcall   CELLPLUS
01f0d7 940d f63a         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
01f0d9 e1a2              fdw     TWOFETCH_L
                 TWOSTORE_L:
01f0da 3282
01f0db 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
01f0dc d0dc              rcall   SWOP
01f0dd d0e5              rcall   OVER
01f0de dfbb              rcall   CELLPLUS
01f0df d3cf              rcall   STORE_A
01f0e0 940d fe9c         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
01f0e2 e1b4              fdw     TWOSTORE_L
                 TWODROP_L:
01f0e3 3285
01f0e4 7264
01f0e5 706f              .db     NFA|5,"2drop"
                 TWODROP:
01f0e6 d0cb              rcall   DROP
01f0e7 940d f1b2         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
01f0e9 e1c6              fdw     TWODROP_L
                 TWODUP_L:
01f0ea 3284
01f0eb 7564
01f0ec 0070              .db     NFA|4,"2dup",0
                 TWODUP:
01f0ed d0d5              rcall   OVER
01f0ee 940d f1c3         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
01f0f0 e1d4              fdw     TWODUP_L
                 TWOSWAP_L:
01f0f1 3285
01f0f2 7773
01f0f3 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
01f0f4 d0d6              rcall   ROT
01f0f5 d0dd              rcall   TOR
01f0f6 d0d4              rcall   ROT
01f0f7 d0e6              rcall   RFROM
01f0f8 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
01f0f9 e1e2              fdw     TWOSWAP_L
                 SPACE_L:
01f0fa 7385
01f0fb 6170
01f0fc 6563              .db     NFA|5,"space"
                 SPACE_:  
01f0fd d714              rcall   BL
01f0fe 940d ef9e         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
01f100 e1f4              fdw     SPACE_L
                 SPACES_L:
01f101 7386
01f102 6170
01f103 6563
01f104 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
01f105 d219              rcall   DUPZEROSENSE
01f106 f019              breq    SPCS2
01f107 dff5              rcall   SPACE_
01f108 d168              rcall   ONEMINUS
01f109 cffb              rjmp    SPCS1
01f10a 940d f1b2 SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
01f10c e202              fdw     SPACES_L
                 UMIN_L:
01f10d 7584
01f10e 696d
01f10f 006e              .db     NFA|4,"umin",0
                 UMIN:
01f110 dfdc              rcall   TWODUP
01f111 d1ad              rcall   UGREATER
01f112 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
01f113 e21a              fdw     UMIN_L
                 UMAX_L:
01f114 7584
01f115 616d
01f116 0078              .db     NFA|4,"umax",0
                 UMAX:
01f117 dfd5              rcall   TWODUP
01f118 d19f              rcall   ULESS
                 MINMAX:
01f119 d1ff              rcall   ZEROSENSE
01f11a f009              breq    UMAX1
01f11b d09d              rcall   SWOP
01f11c 940d f1b2 UMAX1:  jmp     DROP
                 
01f11e e228              fdw     UMAX_L
                 ONE_L:
01f11f 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
01f120 939a
01f121 938a              pushtos
01f122 e081              ldi     tosl, 1
01f123 e090              ldi     tosh, 0
01f124 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
01f125 e23e              fdw     ONE_L
                 ACCEPT_L:
01f126 6186
01f127 6363
01f128 7065
01f129 0074              .db     NFA|6,"accept",0
                 ACCEPT:
01f12a d098              rcall   OVER
01f12b d0cf              rcall   PLUS
01f12c d0a6              rcall   TOR
01f12d d5d5              rcall   DUP
                 ACC1:
01f12e de75              rcall   KEY
01f12f 308d              cpi     tosl, CR_
01f130 f039              breq    ACC_CR
01f131 308a              cpi     tosl, LF_
01f132 f041              breq    ACC_LF
01f133 3088              cpi     tosl, BS_
01f134 f079              breq    ACC_BS_DEL
01f135 378f              cpi     tosl, 127
01f136 f069              breq    ACC_BS_DEL
01f137 c01a              rjmp    ACC3
                 ACC_CR:
01f138 d02a              rcall   FCR
01f139 d246              rcall   CSTORE_A
01f13a c021              rjmp    ACC6
                 ACC_LF:
01f13b d076              rcall   DROP
                 
01f13c d026              rcall   FCR
01f13d d23e              rcall   CFETCH_A
01f13e d1da              rcall   ZEROSENSE
01f13f f0e1              breq    ACC6
01f140 d55a              rcall   FALSE_
01f141 d021              rcall   FCR
01f142 d23d              rcall   CSTORE_A
01f143 cfea              rjmp    ACC1
                 ACC_BS_DEL:
01f144 d556              rcall   FALSE_
01f145 d01d              rcall   FCR
01f146 d239              rcall   CSTORE_A
01f147 d06a              rcall   DROP
01f148 dfa4              rcall   TWODUP
01f149 d15e              rcall   EQUAL
01f14a d1ce              rcall   ZEROSENSE
01f14b f711              brne    ACC1
01f14c d124              rcall   ONEMINUS
01f14d d028              rcall   XSQUOTE
01f14e 0803
01f14f 0820              .db     3,8,0x20,8
01f150 d018              rcall   TYPE
01f151 cfdc              rjmp    ACC1
                 ACC3:
01f152 d5b0              rcall   DUP
01f153 de4a              rcall   EMIT
01f154 d06e              rcall   OVER
01f155 d22a              rcall   CSTORE_A
01f156 d115              rcall   ONEPLUS
01f157 d091              rcall   RFETCH
01f158 d06a              rcall   OVER
01f159 d14e              rcall   EQUAL
01f15a d1be              rcall   ZEROSENSE
01f15b f291              breq    ACC1
                 ACC6:
01f15c 910f              pop     t0
01f15d 910f              pop     t0
                 
01f15e d05a              rcall   SWOP
01f15f 940d f208         jmp     MINUS
                 
01f161 6683
01f162 7263              .db     NFA|3,"fcr"
                 FCR:
01f163 d2d4              rcall   DOUSER
01f164 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
01f165 e24c              fdw      ACCEPT_L
                 TYPE_L:
01f166 7484
01f167 7079
01f168 0065              .db     NFA|4,"type",0
                 TYPE:
01f169 d069              rcall   TOR
01f16a c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
01f16b d335              rcall   CFETCHPP
01f16c de31              rcall   EMIT
                 TYPE2:
01f16d 940f f9b6         call    XNEXT
01f16f f7d8              brcc    TYPE1
01f170 911f              pop     t1
01f171 910f              pop     t0
01f172 940d f1b2         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
01f174 2883
01f175 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
01f176 91ff              m_pop_zh
01f177 91ff              pop     zh
01f178 91ef              pop     zl
01f179 0fee              lsl     zl
01f17a 1fff              rol     zh
01f17b 9107              lpm_    t0, z+
01f17c 939a
01f17d 938a              pushtos
01f17e 01cf              movw    tosl, zl
                         add_pflash_tos
01f17f 939a
01f180 938a              pushtos
01f181 2f80              mov     tosl, t0
01f182 2799              clr     tosh
01f183 0fe0              add     zl, t0
01f184 1ff9              adc     zh, tosh
01f185 9631              adiw    zl, 1
01f186 9408              rampv_to_c
01f187 95f7              ror     zh
01f188 95e7              ror     zl
01f189 9419              mijmp
                 
01f18a e2cc              fdw     TYPE_L
                 SQUOTE_L:
01f18b 73d2
01f18c 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
01f18d de80              rcall   DOCOMMAXT
01f18e e2ec              fdw     XSQUOTE
01f18f deb5              rcall   ROM_
01f190 d005              rcall   CQUOTE
01f191 940d f053         jmp     FRAM
                 
01f193 e316              fdw     SQUOTE_L
                 CQUOTE_L:
01f194 2c82
01f195 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
01f196 d562              rcall   DOLIT
01f197 0022              .dw     0x22
01f198 d2c6              rcall   PARSE
01f199 ded0              rcall   HERE
01f19a d028              rcall   OVER
01f19b d0d0              rcall   ONEPLUS
01f19c def6              rcall   ALIGNED
01f19d d00d              rcall   ALLOT
01f19e 940d f498         jmp     PLACE
                 
                 
01f1a0 e328              fdw     CQUOTE_L
                 DOTQUOTE_L:
01f1a1 2ed2
01f1a2 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
01f1a3 dfe9              rcall   SQUOTE
01f1a4 de69              rcall   DOCOMMAXT
01f1a5 e2d2              fdw     TYPE
01f1a6 9508              ret
                 
01f1a7 e342              fdw     DOTQUOTE_L
                 ALLOT_L:
01f1a8 6185
01f1a9 6c6c
01f1aa 746f              .db     NFA|5,"allot"
                 ALLOT:
01f1ab deae              rcall   DP
01f1ac 940d f28d         jmp     PLUSSTORE
                 
01f1ae e350              fdw     ALLOT_L
                 DROP_L:
01f1af 64a4
01f1b0 6f72
01f1b1 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
01f1b2 9189
01f1b3 9199              poptos
01f1b4 9508              ret
                 
01f1b5 e35e              fdw     DROP_L
                 SWOP_L:
01f1b6 7384
01f1b7 6177
01f1b8 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
01f1b9 9109              ld      t0, y+
01f1ba 9119              ld      t1, y+
01f1bb 939a
01f1bc 938a              pushtos
01f1bd 01c8              movw    tosl, t0
01f1be 9508              ret
                 
01f1bf e36c              fdw     SWOP_L
                 OVER_L:
01f1c0 6f84
01f1c1 6576
01f1c2 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
01f1c3 939a
01f1c4 938a              pushtos
01f1c5 818a              ldd     tosl, y+2
01f1c6 819b              ldd     tosh, y+3
01f1c7 9508              ret
                 
01f1c8 e380              fdw     OVER_L
                 ROT_L:
01f1c9 7283
01f1ca 746f              .db     NFA|3, "rot"
                 ROT:
01f1cb d007              rcall   TOR
01f1cc dfec              rcall   SWOP
01f1cd d010              rcall   RFROM
01f1ce 940d f1b9         jmp     SWOP
                 
01f1d0 e392              fdw     ROT_L
                 TOR_L:
01f1d1 3e92
01f1d2 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
01f1d3 91ff              m_pop_zh
01f1d4 91ff              pop     zh
01f1d5 91ef              pop     zl
01f1d6 938f              push    tosl
01f1d7 939f              push    tosh
01f1d8 9189
01f1d9 9199              poptos
01f1da 9419              mijmp
                 
01f1db e3a2              fdw     TOR_L
                 RFROM_L:
01f1dc 7292
01f1dd 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
01f1de 91ff              m_pop_zh
01f1df 91ff              pop     zh
01f1e0 91ef              pop     zl
01f1e1 939a
01f1e2 938a              pushtos
01f1e3 919f              pop     tosh
01f1e4 918f              pop     tosl
01f1e5 9419              mijmp
                 
01f1e6 e3b8              fdw     RFROM_L
                 RFETCH_L:
01f1e7 7292
01f1e8 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
01f1e9 91ff              m_pop_zh
01f1ea 91ff              pop     zh
01f1eb 91ef              pop     zl
01f1ec 939a
01f1ed 938a              pushtos
01f1ee 919f              pop     tosh
01f1ef 918f              pop     tosl
01f1f0 938f              push    tosl
01f1f1 939f              push    tosh
01f1f2 9419              mijmp
                 
                 ;   ABS     n   --- n1      absolute value of n
01f1f3 ee02              fdw     DUP_L
                 ABS_L:
01f1f4 6183
01f1f5 7362              .db     NFA|3,"abs"
                 ABS_:
01f1f6 d50c              rcall   DUP
01f1f7 940d f369         jmp     QNEGATE
                 
01f1f9 e3e8              fdw     ABS_L
                 PLUS_L:
01f1fa 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
01f1fb 9109              ld      t0, Y+        
01f1fc 9119              ld      t1, Y+
01f1fd 0f80              add     tosl, t0
01f1fe 1f91              adc     tosh, t1
01f1ff 9508              ret
                 
                 ; m+  ( d n -- d1 )
01f200 e3f4              fdw     PLUS_L
                 MPLUS_L:
01f201 6d82
01f202 002b              .db     NFA|2, "m+",0
                 MPLUS:
01f203 d7d5              rcall   STOD
01f204 940d f9fb         jmp     DPLUS
                 
01f206 e402              fdw     MPLUS_L
                 MINUS_L:
01f207 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
01f208 9109              ld      t0, Y+
01f209 9119              ld      t1, Y+
01f20a 1b08              sub     t0, tosl
01f20b 0b19              sbc     t1, tosh
01f20c 01c8              movw    tosl, t0
01f20d 9508              ret
                 
                 FROM_LITBUF:
01f20e 9000 03b8         lds     r0, litbuf0
01f210 9010 03b9         lds     r1, litbuf1
01f212 9508              ret
                 PLUSC_:
01f213 dffa              rcall   FROM_LITBUF
01f214 9400              com     r0
01f215 9410              com     r1
01f216 0c06              add     r0, r_one
01f217 1c15              adc     r1, r_zero
01f218 d00b              rcall   ANDIC1
01f219 c001              rjmp    MINUSC_1
                 MINUSC_:
01f21a d008              rcall   ANDIC0
                 MINUSC_1:
01f21b 6590              ori     tosh, 0x50
01f21c d021              rcall   ICOMMA_
01f21d d4e5              rcall   DUP
01f21e 2d81              mov     tosl, r1
01f21f d007              rcall   ANDIC2
01f220 6980              ori     tosl, 0x90
01f221 6490              ori     tosh, 0x40
01f222 c01b              rjmp    ICOMMA_
                 ANDIC0:
01f223 dfea              rcall   FROM_LITBUF
                 ANDIC1:
01f224 d6fb              rcall   IDPMINUS
01f225 d6fa              rcall   IDPMINUS
01f226 2d80              mov     tosl, r0
                 ANDIC2:
01f227 2f98              mov     tosh, tosl
01f228 9592              swap    tosh
01f229 708f              andi    tosl, 0x0f
01f22a 709f              andi    tosh, 0x0f
01f22b 6880              ori     tosl, 0x80
01f22c 9508              ret
                 ANDIC_:
01f22d dff5              rcall   ANDIC0
01f22e 6790              ori     tosh, 0x70
01f22f d00e              rcall   ICOMMA_
01f230 d4d2              rcall   DUP
01f231 2d81              mov     tosl, r1
01f232 dff4              rcall   ANDIC2
01f233 6980              ori     tosl, 0x90
01f234 6790              ori     tosh, 0x70
01f235 c008              rjmp    ICOMMA_
                 ORIC_:
01f236 dfec              rcall   ANDIC0
01f237 6690              ori     tosh, 0x60
01f238 d005              rcall   ICOMMA_
01f239 d4c9              rcall   DUP
01f23a 2d81              mov     tosl, r1
01f23b dfeb              rcall   ANDIC2
01f23c 6980              ori     tosl, 0x90
01f23d 6690              ori     tosh, 0x60
                 ICOMMA_:
01f23e 940d ff91         jmp     ICOMMA
                 
01f240 e40e              fdw     MINUS_L
                 AND_L:
01f241 6183
01f242 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
01f243 9109              ld      t0, Y+
01f244 9119              ld      t1, Y+
01f245 2380              and     tosl, t0
01f246 2391              and     tosh, t1
01f247 9508              ret
                 
01f248 e482              fdw     AND_L
                 OR_L:
01f249 6f82
01f24a 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
01f24b 9109              ld      t0, Y+
01f24c 9119              ld      t1, Y+
01f24d 2b80              or      tosl, t0
01f24e 2b91              or      tosh, t1
01f24f 9508              ret
                 
01f250 e492              fdw     OR_L
                 XOR_L:
01f251 7883
01f252 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
01f253 9109              ld      t0, Y+
01f254 9119              ld      t1, Y+
01f255 2780              eor     tosl, t0
01f256 2791              eor     tosh, t1
01f257 9508              ret
                 
01f258 e4a2              fdw     XOR_L
                 INVERT_L:
01f259 69a6
01f25a 766e
01f25b 7265
01f25c 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
01f25d 9580              com     tosl
01f25e 9590              com     tosh
01f25f 9508              ret
                 
01f260 e4b2              fdw     INVERT_L
                 NEGATE_L:
01f261 6e86
01f262 6765
01f263 7461
01f264 0065              .db     NFA|6, "negate",0
                 NEGATE:
01f265 9580              com     tosl
01f266 9590              com     tosh
01f267 9601              adiw    tosl, 1
01f268 9508              ret
                 
01f269 e4c2              fdw     NEGATE_L
                 ONEPLUS_L:
01f26a 31a2
01f26b 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
01f26c 9601              adiw    tosl, 1
01f26d 9508              ret
                 
01f26e e4d4              fdw     ONEPLUS_L
                 ONEMINUS_L:
01f26f 31a2
01f270 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
01f271 9701              sbiw    tosl, 1
01f272 9508              ret
                 
01f273 e4de              fdw     ONEMINUS_L
                 TWOPLUS_L:
01f274 32a2
01f275 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
01f276 9602              adiw    tosl, 2
01f277 9508              ret
                 
01f278 e4e8              fdw     TWOPLUS_L
                 TOBODY_L:
01f279 3ea5
01f27a 6f62
01f27b 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
01f27c 9604              adiw    tosl, 4
01f27d 9508              ret
                 
01f27e e4f2              fdw     TOBODY_L
                 TWOSTAR_L:
01f27f 32a2
01f280 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
01f281 0f88              lsl     tosl
01f282 1f99              rol     tosh
01f283 9508              ret
                 
01f284 e4fe              fdw     TWOSTAR_L
                 TWOSLASH_L:
01f285 32a2
01f286 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
01f287 9595              asr     tosh
01f288 9587              ror     tosl
01f289 9508              ret
                 
01f28a e50a              fdw     TWOSLASH_L
                 PLUSSTORE_L:
01f28b 2b82
01f28c 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
01f28d df2b              rcall   SWOP
01f28e df34              rcall   OVER
01f28f d3aa              rcall   FETCH_A
01f290 df6a              rcall   PLUS
01f291 df27              rcall   SWOP
01f292 940d fe9c         jmp     STORE
                 
01f294 e516              fdw     PLUSSTORE_L
                 WITHIN_L:
01f295 7786
01f296 7469
01f297 6968
01f298 006e              .db     NFA|6,"within",0
                 WITHIN:
01f299 df29              rcall   OVER
01f29a df6d              rcall   MINUS
01f29b df37              rcall   TOR
01f29c df6b              rcall   MINUS
01f29d df40              rcall   RFROM
01f29e 940d f2b8         jmp     ULESS
                 
01f2a0 e52a              fdw     WITHIN_L
                 NOTEQUAL_L:
01f2a1 3c82
01f2a2 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
01f2a3 d004              rcall   EQUAL
01f2a4 940d f709         jmp     ZEROEQUAL
                 
01f2a6 ee1c              fdw     ZEROLESS_L
                 EQUAL_L:
01f2a7 3d81              .db     NFA|1, "="
                 EQUAL:
01f2a8 df5f              rcall   MINUS
01f2a9 940d f709         jmp     ZEROEQUAL
                 
                 
01f2ab e54e              fdw     EQUAL_L
                 LESS_L:
01f2ac 3c81              .db     NFA|1,"<"
                 LESS:
01f2ad df5a              rcall   MINUS
01f2ae 940d f710         jmp     ZEROLESS
                 
01f2b0 e558              fdw     LESS_L
                 GREATER_L:
01f2b1 3e81              .db     NFA|1,">"
                 GREATER:
01f2b2 df06              rcall   SWOP
01f2b3 940d f2ad         jmp     LESS
                 
01f2b5 e562              fdw     GREATER_L
                 ULESS_L:
01f2b6 7582
01f2b7 003c              .db     NFA|2,"u<",0
                 ULESS:
01f2b8 df4f              rcall   MINUS       ; Carry is valid after MINUS
01f2b9 0b88              sbc     tosl, tosl
01f2ba 0b99              sbc     tosh, tosh
01f2bb 9508              ret
                 
01f2bc e56c              fdw     ULESS_L
                 UGREATER_L:
01f2bd 7582
01f2be 003e              .db     NFA|2, "u>",0
                 UGREATER:
01f2bf def9              rcall   SWOP
01f2c0 940d f2b8         jmp     ULESS
                 
01f2c2 e57a              fdw     UGREATER_L
                 STORE_P_L:
01f2c3 2182
01f2c4 0070              .db     NFA|2,"!p",0
                 STORE_P:
01f2c5 01ac              movw    pl, tosl
01f2c6 9189
01f2c7 9199              poptos
01f2c8 9508              ret
                 
01f2c9 e586              fdw     STORE_P_L
                 STORE_P_TO_R_L:
01f2ca 2194
01f2cb 3e70
01f2cc 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
01f2cd 91ff              m_pop_zh
01f2ce 91ff              pop     zh
01f2cf 91ef              pop     zl
01f2d0 934f              push    pl
01f2d1 935f              push    ph
01f2d2 01ac              movw    pl, tosl
01f2d3 9189
01f2d4 9199              poptos
01f2d5 9419              mijmp
                 
01f2d6 e594              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
01f2d7 7293
01f2d8 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
01f2d9 91ff              m_pop_zh
01f2da 91ff              pop     zh
01f2db 91ef              pop     zl
01f2dc 915f              pop     ph
01f2dd 914f              pop     pl
01f2de 9419              mijmp
                 
01f2df e5ae              fdw     R_TO_P_L
                 PFETCH_L:
01f2e0 7082
01f2e1 0040              .db     NFA|2,"p@",0
                 PFETCH:
01f2e2 939a
01f2e3 938a              pushtos
01f2e4 01ca              movw    tosl, pl
01f2e5 940d fed9         jmp     FETCH
                 
01f2e7 e5c0              fdw     PFETCH_L
                 PSTORE_L:
01f2e8 7082
01f2e9 0021              .db     NFA|2,"p!",0
                 PSTORE:
01f2ea 939a
01f2eb 938a              pushtos
01f2ec 01ca              movw    tosl, pl
01f2ed 940d fe9c         jmp     STORE
                 
01f2ef e5d0              fdw     PSTORE_L
                 PCSTORE_L:
01f2f0 7083
01f2f1 2163              .db     NFA|3,"pc!"
                 PCSTORE:
01f2f2 939a
01f2f3 938a              pushtos
01f2f4 01ca              movw    tosl, pl
01f2f5 940d ff0e         jmp     CSTORE
                 
01f2f7 e5e0              fdw     PCSTORE_L
                 PPLUS_L:
01f2f8 70a2
01f2f9 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
01f2fa 0d46              add     pl, r_one
01f2fb 1d55              adc     ph, r_zero
01f2fc 9508              ret   
                 
01f2fd e5f0              fdw     PPLUS_L
                 PNPLUS_L:
01f2fe 7083
01f2ff 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
01f300 0f48              add     pl, tosl
01f301 1f59              adc     ph, tosh
01f302 9189
01f303 9199              poptos
01f304 9508              ret
                 
01f305 e5fc              fdw     PNPLUS_L
                 UEMIT_L:
01f306 2785
01f307 6d65
01f308 7469              .db     NFA|5,"'emit"
                 UEMIT_:
01f309 d12e              rcall   DOUSER
01f30a ffe8              .dw     uemit
                         
01f30b e60c              fdw     UEMIT_L
                 UKEY_L:
01f30c 2784
01f30d 656b
01f30e 0079              .db     NFA|4,"'key",0
                 UKEY_:
01f30f d128              rcall   DOUSER
01f310 ffea              .dw     ukey
                 
01f311 e618              fdw     UKEY_L
                 UKEYQ_L:
01f312 2785
01f313 656b
01f314 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
01f315 d122              rcall   DOUSER
01f316 ffec              .dw     ukeyq
                 
01f317 3f83
01f318 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
01f319 9700              sbiw    tosl, 0
01f31a 9189
01f31b 9199              poptos
01f31c 9508              ret
                 
01f31d 6483
01f31e 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
01f31f 9700              sbiw    tosl, 0
01f320 9508              ret
                 
01f321 e624              fdw     UKEYQ_L
                 UMSTAR_L:
01f322 7583
01f323 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
01f324 940d ffb7         jmp     umstar0
                 
01f326 e644              fdw     UMSTAR_L
                 UMSLASHMOD_L:
01f327 7586
01f328 2f6d
01f329 6f6d
01f32a 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
01f32b 940d ffd0         jmp     umslashmod0
                 
                 
01f32d e64e              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
01f32e 7585
01f32f 6d2f
01f330 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
01f331 d369              rcall   FALSE_
01f332 de86              rcall   SWOP
01f333 940d ffd0         jmp     umslashmod0
                 
01f335 e65c              fdw     USLASHMOD_L
                 STAR_L:
01f336 2a81              .db     NFA|1,"*"
                 STAR: 
01f337 dfec              rcall   UMSTAR
01f338 940d f1b2         jmp     DROP
                 
01f33a e66c              fdw     STAR_L
                 USLASH_L:
01f33b 7582
01f33c 002f              .db     NFA|2,"u/",0
                 USLASH:
01f33d dff3              rcall   USLASHMOD
01f33e 940d f35a         jmp     NIP
                 
01f340 e676              fdw     USLASH_L
                 USSMOD_L:
01f341 7586
01f342 2f2a
01f343 6f6d
01f344 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
01f345 de8d              rcall   TOR
01f346 dfdd              rcall   UMSTAR
01f347 de96              rcall   RFROM
01f348 940d f32b         jmp     UMSLASHMOD
                 
                 
01f34a e682              fdw     USSMOD_L
                 SLASH_L:
01f34b 2f81              .db     NFA|1,"/"
                 SLASH: 
01f34c dda0              rcall   TWODUP
01f34d df05              rcall   XOR_
01f34e de84              rcall   TOR
01f34f dea6              rcall   ABS_
01f350 de68              rcall   SWOP
01f351 dea4              rcall   ABS_
01f352 de66              rcall   SWOP
01f353 dfe9              rcall   USLASH
01f354 de89              rcall   RFROM
01f355 940d f369         jmp     QNEGATE
                 
01f357 e696              fdw     SLASH_L
                 NIP_L:
01f358 6ea3
01f359 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
01f35a 9109              ld      t0, y+
01f35b 9109              ld      t0, y+
01f35c 9508              ret
                     
01f35d e6b0              fdw     NIP_L
                 TUCK_L:
01f35e 7484
01f35f 6375
01f360 006b              .db     NFA|4,"tuck",0
                 TUCK:
01f361 de57              rcall   SWOP
01f362 940d f1c3         jmp     OVER
                 
01f364 e6bc              fdw     TUCK_L
                 QNEGATE_L:
01f365 3f87
01f366 656e
01f367 6167
01f368 6574              .db     NFA|7,"?negate"
                 QNEGATE:
01f369 d3a6              rcall   ZEROLESS
01f36a dfae              rcall   ZEROSENSE
01f36b f009              breq    QNEGATE1
01f36c def8              rcall   NEGATE
                 QNEGATE1:
01f36d 9508              ret
                 
01f36e e6ca              fdw     QNEGATE_L
                 MAX_L:
01f36f 6d83
01f370 7861              .db     NFA|3,"max"
01f371 dd7b      MAX:    rcall   TWODUP
01f372 df3a              rcall   LESS
01f373 cda5              rjmp    MINMAX
                 
01f374 e6de              fdw     MAX_L
                 MIN_L:
01f375 6d83
01f376 6e69              .db     NFA|3,"min"
01f377 dd75      MIN:    rcall   TWODUP
01f378 df39              rcall   GREATER
01f379 cd9f              rjmp    MINMAX
                 
01f37a 6382
01f37b 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
01f37c 940d fef4         jmp     CFETCH
                 
01f37e 6382
01f37f 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
01f380 940d ff0e         jmp     CSTORE
                 
01f382 e6ea              fdw     MIN_L
                 UPTR_L:
01f383 7582
01f384 0070              .db     NFA|2,"up",0
01f385 dc6c      UPTR:   rcall   DOCREATE
01f386 0002              .dw     2 ; upl
                 
01f387 e706              fdw     UPTR_L
                 HOLD_L:
01f388 6884
01f389 6c6f
01f38a 0064              .db     NFA|4,"hold",0
01f38b d318      HOLD:   rcall   TRUE_
01f38c d092              rcall   HP
01f38d deff              rcall   PLUSSTORE
01f38e d090              rcall   HP
01f38f d2aa              rcall   FETCH_A
01f390 940d ff0e         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
01f392 e710              fdw     HOLD_L
                 LESSNUM_L:
01f393 3c82
01f394 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
01f395 d08e              rcall   PAD
01f396 d088              rcall   HP
01f397 940d fe9c         jmp     STORE
                 
                 ; digit   n -- c            convert to 0..9a..z
01f399 e726              fdw     LESSNUM_L
                 TODIGIT_L:
01f39a 6485
01f39b 6769
01f39c 7469              .db     NFA|5,"digit"
                 TODIGIT:
01f39d 308a              cpi     tosl, 0xa
01f39e f00c              brlt    TODIGIT1
01f39f 9687              adiw    tosl, 0x27
                 TODIGIT1:
01f3a0 96c0              adiw    tosl, 0x30
01f3a1 9508              ret
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
01f3a2 e734              fdw     TODIGIT_L
                 NUM_L:
01f3a3 2381              .db     NFA|1,"#"
                 NUM:
01f3a4 d087              rcall   BASE
01f3a5 d294              rcall   FETCH_A
01f3a6 d183              rcall   UDSLASHMOD
01f3a7 de23              rcall   ROT
01f3a8 dff4              rcall   TODIGIT
01f3a9 940d f38b         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
01f3ab e746              fdw     NUM_L
                 NUMS_L:
01f3ac 2382
01f3ad 0073              .db     NFA|2,"#s",0
                 NUMS:
01f3ae dff5              rcall   NUM
01f3af dd3d              rcall   TWODUP
01f3b0 de9a              rcall   OR_
01f3b1 df67              rcall   ZEROSENSE
01f3b2 f7d9              brne    NUMS
01f3b3 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
01f3b4 e758              fdw     NUMS_L
                 NUMGREATER_L:
01f3b5 2382
01f3b6 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
01f3b7 dd2e              rcall   TWODROP
01f3b8 d066              rcall   HP
01f3b9 d280              rcall   FETCH_A
01f3ba d069              rcall   PAD
01f3bb de07              rcall   OVER
01f3bc 940d f208         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
01f3be e76a              fdw     NUMGREATER_L
                 SIGN_L:
01f3bf 7384
01f3c0 6769
01f3c1 006e              .db     NFA|4,"sign",0
                 SIGN:
01f3c2 3090              cpi     tosh, 0
01f3c3 f41a              brpl    SIGN1
01f3c4 d334              rcall   DOLIT
01f3c5 002d              .dw     0x2D
01f3c6 dfc4              rcall   HOLD
                 SIGN1:
01f3c7 940d f1b2         jmp     DROP
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
01f3c9 e77e              fdw     SIGN_L
                 UDOT_L:
01f3ca 7582
01f3cb 002e              .db     NFA|2,"u.",0
                 UDOT:
01f3cc dfc8              rcall   LESSNUM
01f3cd d2cd              rcall   FALSE_
01f3ce dfdf              rcall   NUMS
01f3cf dfe7              rcall   NUMGREATER
01f3d0 dd98              rcall   TYPE
01f3d1 940d f0fd         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
01f3d3 e794              fdw     UDOT_L
                 UDOTR_L:
01f3d4 7583
01f3d5 722e              .db     NFA|3,"u.r"
                 UDOTR:
01f3d6 dfbe              rcall   LESSNUM
01f3d7 de99              rcall   ONEMINUS
01f3d8 ddfa              rcall   TOR
01f3d9 d2c1              rcall   FALSE_
01f3da c001              rjmp    UDOTR2
                 UDOTR1:
01f3db dfc8              rcall   NUM
                 UDOTR2: 
01f3dc d5d9              rcall   XNEXT
01f3dd f7e8              brcc    UDOTR1
01f3de 911f              pop     t1
01f3df 910f              pop     t0
01f3e0 dfcd              rcall   NUMS
01f3e1 dfd5              rcall   NUMGREATER
01f3e2 dd86              rcall   TYPE
01f3e3 940d f0fd         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
01f3e5 e7a8              fdw     UDOTR_L
                 DOT_L:
01f3e6 2e81              .db     NFA|1,"."
01f3e7 dfad      DOT:    rcall   LESSNUM
01f3e8 d31a              rcall   DUP
01f3e9 de0c              rcall   ABS_
01f3ea d2b0              rcall   FALSE_
01f3eb dfc2              rcall   NUMS
01f3ec ddde              rcall   ROT
01f3ed dfd4              rcall   SIGN
01f3ee dfc8              rcall   NUMGREATER
01f3ef dd79              rcall   TYPE
01f3f0 940d f0fd         jmp     SPACE_
                 
01f3f2 e7cc              FDW     DOT_L
                 DECIMAL_L:
01f3f3 6487
01f3f4 6365
01f3f5 6d69
01f3f6 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
01f3f7 d27b              rcall   TEN
01f3f8 d033              rcall   BASE
01f3f9 940d fe9c         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
01f3fb e7e6              Fdw     DECIMAL_l
                 HEX_L:
01f3fc 6883
01f3fd 7865              .db     NFA|3,"hex"
                 HEX:
01f3fe d2fa              rcall   DOLIT
01f3ff 0010              .dw     16
01f400 d02b              rcall   BASE
01f401 940d fe9c         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
01f403 e7f8              Fdw     HEX_L
                 BIN_L:
01f404 6283
01f405 6e69              .db     NFA|3,"bin"
01f406 dc79      BIN:    rcall   CELL
01f407 d024              rcall   BASE
01f408 940d fe9c         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
01f40a e808              fdw     BIN_L
                 RSAVE_L:
01f40b 7285
01f40c 6173
01f40d 6576              .db     NFA|5,"rsave"
01f40e d029      RSAVE_: rcall   DOUSER
01f40f fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
01f410 e816              fdw     RSAVE_L
                 ULINK_L:
01f411 7585
01f412 696c
01f413 6b6e              .db     NFA|5,"ulink"
01f414 d023      ULINK_: rcall   DOUSER
01f415 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
01f416 e822              fdw     ULINK_L
                 TASK_L:
01f417 7484
01f418 7361
01f419 006b              .db     NFA|4,"task",0
01f41a d01d      TASK:   rcall   DOUSER
01f41b fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
01f41c e82e              fdw     TASK_L
                 HP_L:
01f41d 6882
01f41e 0070              .db     NFA|2,"hp",0
01f41f d018      HP:     rcall   DOUSER
01f420 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
01f421 e83a              fdw     HP_L
                 PAD_L:
01f422 7083
01f423 6461              .db     NFA|3,"pad"
                 PAD:
01f424 d17c              rcall   TIB
01f425 d173              rcall   TIBSIZE
01f426 940d f1fb         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
01f428 e844              fdw     PAD_L
                 BASE_L:
01f429 6284
01f42a 7361
01f42b 0065              .db     NFA|4,"base",0
                 BASE:
01f42c d00b              rcall   DOUSER
01f42d ffee              .dw     ubase
                 
                 ; USER   n --
01f42e e852              fdw     BASE_L
                 USER_L:
01f42f 7584
01f430 6573
01f431 0072              .db     NFA|4,"user",0
                 USER:
01f432 d31a              rcall   CREATE
01f433 dc4c              rcall   CELL
01f434 de30              rcall   NEGATE
01f435 d4b3              rcall   IALLOT
01f436 de07              rcall   ICOMMA_
01f437 d367              rcall   XDOES
                 DOUSER:
01f438 91ff              m_pop_zh
01f439 91ff              pop     zh
01f43a 91ef              pop     zl
01f43b dbc9              rcall   FETCHLIT
01f43c 0d82              add     tosl, upl
01f43d 1d93              adc     tosh, uph
01f43e 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
01f43f e85e              fdw     USER_L
                 SOURCE_L:
01f440 7386
01f441 756f
01f442 6372
01f443 0065              .db     NFA|6,"source",0
                 SOURCE:
01f444 d16e              rcall   TICKSOURCE
01f445 940d f0d3         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
01f447 e880              fdw      SOURCE_L
                 SLASHSTRING_L:
01f448 2f87
01f449 7473
01f44a 6972
01f44b 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
01f44c dd6c              rcall   SWOP
01f44d dd75              rcall   OVER
01f44e ddb9              rcall   MINUS
01f44f dd83              rcall   TOR
01f450 ddaa              rcall   PLUS
01f451 dd8c              rcall   RFROM
01f452 9508              ret
                 
                 ; \     Skip the rest of the line
01f453 e890              fdw     SLASHSTRING_L
                 BSLASH_L:
01f454 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
01f455 dfee              rcall   SOURCE
01f456 d155              rcall   TOIN
01f457 d057              rcall   STORE_A
01f458 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
01f459 940d f1b2         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
01f45b e8a8              fdw     BSLASH_L
                 PARSE_L:
01f45c 7085
01f45d 7261
01f45e 6573              .db     NFA|5,"parse"
                 PARSE:
01f45f d2a3              rcall   DUP             ; c c
01f460 dfe3              rcall   SOURCE          ; c c a u
01f461 d14a              rcall   TOIN            ; c c a u a
01f462 d1d7              rcall   FETCH_A         ; c c a u n
01f463 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
01f464 938f              push    tosl
01f465 939f              push    tosh            ; c c a u                  R: u (new tib len
01f466 dd64              rcall   ROT             ; c a u c
01f467 dadd              rcall   SKIP            ; c a u        
01f468 dd5a              rcall   OVER            ; c a u a
01f469 dd69              rcall   TOR             ; c a u                    R: u a (start of word
01f46a dd60              rcall   ROT             ; a u c
01f46b daf4              rcall   SCAN            ; a u      end of word, tib left       
01f46c deb2              rcall   DUPZEROSENSE
01f46d f009              breq    PARSE1
01f46e de02              rcall   ONEMINUS
01f46f dd6e      PARSE1: rcall   RFROM           ; a u a
01f470 dd6d              rcall   RFROM           ; a u a u
01f471 dd59              rcall   ROT             ; a a u u
01f472 dd95              rcall   MINUS           ; a a n  ( addition to toin
01f473 d138              rcall   TOIN
01f474 de18              rcall   PLUSSTORE       ; aend astart
01f475 deeb              rcall   TUCK            ; astart aend astart
01f476 940d f208         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
01f478 e8b8              fdw     PARSE_L
                 WORD_L:
01f479 7784
01f47a 726f
01f47b 0064              .db     NFA|4,"word",0
                 WORD:
01f47c dfe2              rcall   PARSE           ; c-addr wlen
01f47d dd3b              rcall   SWOP
01f47e ddf2              rcall   ONEMINUS
01f47f dee1              rcall   TUCK
01f480 940d ff0e         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
01f482 e8f2              fdw     WORD_L
                 CMOVE_L:
01f483 6385
01f484 6f6d
01f485 6576              .db     NFA|5,"cmove"
                 CMOVE:
01f486 dd32              rcall   SWOP
01f487 de45              rcall   STORE_P_TO_R
01f488 dd4a              rcall   TOR
01f489 c003              rjmp    CMOVE2
                 CMOVE1:
01f48a d016              rcall   CFETCHPP
01f48b de66              rcall   PCSTORE
01f48c de6d              rcall   PPLUS
                 CMOVE2:
01f48d d528              rcall   XNEXT
01f48e f7d8              brcc    CMOVE1
01f48f 911f              pop     t1
01f490 910f              pop     t0
01f491 de47              rcall   R_TO_P
01f492 940d f1b2         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
01f494 e906              fdw     CMOVE_L
                 PLACE_L:
01f495 7085
01f496 616c
01f497 6563              .db     NFA|5,"place"
                 PLACE: 
01f498 dc54              rcall   TWODUP
01f499 dee6              rcall   CSTORE_A
01f49a dc0c              rcall   CHARPLUS
01f49b dd1d              rcall   SWOP
01f49c 940d f486         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
01f49e e92a              fdw     PLACE_L
                 CFETCHPP_L:
01f49f 6383
01f4a0 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
01f4a1 d261              rcall   DUP
01f4a2 ddc9              rcall   ONEPLUS
01f4a3 dd15              rcall   SWOP
01f4a4 940d fef4         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
01f4a6 e93e              fdw     CFETCHPP_L
                 FETCHPP_L:
01f4a7 4082
01f4a8 002b              .db     NFA|2,"@+",0
                 FETCHPP:
01f4a9 d259              rcall   DUP
01f4aa ddcb              rcall   TWOPLUS
01f4ab dd0d              rcall   SWOP
01f4ac 940d fed9         jmp     FETCH
                 
01f4ae 2181              .db     NFA|1,"!"
                 STORE_A:        
01f4af 940d fe9c         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
01f4b1 e94e              fdw    FETCHPP_L
                 NTOC_L:
01f4b2 6e83
01f4b3 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
01f4b4 dfec              rcall   CFETCHPP
01f4b5 708f              andi    tosl, 0x0f
01f4b6 dd44              rcall   PLUS
01f4b7 940d f093         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
01f4b9 e964              fdw    NTOC_L
                 CTON_L:
01f4ba 6383
01f4bb 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
01f4bc d350              rcall   TWOMINUS
01f4bd d245              rcall   DUP
01f4be debd              rcall   CFETCH_A
01f4bf 940f fe95         call    TO_A
01f4c1 ff27              sbrs    al, 7
01f4c2 f3c9              breq    CFATONFA
01f4c3 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
01f4c4 e974              fdw     CTON_L
                 BRACFIND_L:
01f4c5 2883
01f4c6 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
01f4c7 dc25              rcall   TWODUP
01f4c8 da59              rcall   NEQUAL
01f4c9 de55              rcall   DUPZEROSENSE
01f4ca f021              breq    findi2
01f4cb dce6              rcall   DROP
01f4cc d340              rcall   TWOMINUS ;;;      NFATOLFA
01f4cd d16c              rcall   FETCH_A
01f4ce d234              rcall   DUP
                 findi2:
01f4cf de49              rcall   ZEROSENSE
01f4d0 f7b1              brne    findi1
01f4d1 de4d              rcall   DUPZEROSENSE
01f4d2 f041              breq    findi3
01f4d3 de86              rcall   NIP
01f4d4 d22e              rcall   DUP
01f4d5 dfde              rcall   NFATOCFA
01f4d6 dce2              rcall   SWOP
01f4d7 d009              rcall   IMMEDQ
01f4d8 d230              rcall   ZEROEQUAL
01f4d9 dc46              rcall   ONE
01f4da dd70              rcall   OR_
                 findi3: 
01f4db 9508              ret
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
01f4dc e98a              fdw     BRACFIND_L
                 IMMEDQ_L:
01f4dd 6986
01f4de 6d6d
01f4df 6465
01f4e0 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
01f4e1 de9a              rcall   CFETCH_A
01f4e2 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
01f4e3 7480              andi    tosl, IMMED
01f4e4 9508              ret
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
01f4e5 e9ba              fdw     IMMEDQ_L
                 FIND_L:
01f4e6 6684
01f4e7 6e69
01f4e8 0064              .db     NFA|4,"find",0
                 FIND:   
01f4e9 d20f              rcall   DOLIT
01f4ea f552              fdw     kernellink
01f4eb dfdb              rcall   findi
01f4ec de32              rcall   DUPZEROSENSE
01f4ed f421              brne    FIND1
01f4ee dcc3              rcall   DROP
01f4ef d335              rcall   LATEST_
01f4f0 d149              rcall   FETCH_A
01f4f1 dfd5              rcall   findi
                 FIND1:
01f4f2 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
01f4f3 e9cc              fdw     FIND_L
                 DIGITQ_L:
01f4f4 6486
01f4f5 6769
01f4f6 7469
01f4f7 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 0x31    a = 0x61
01f4f8 3480              cpi     tosl, 0x40
01f4f9 f00c              brlt    DIGITQ1
01f4fa 9787              sbiw    tosl, 0x27
                 DIGITQ1:        
01f4fb 97c0              sbiw    tosl, 0x30      ; 1
01f4fc f40a              brpl    DIGITQ2
01f4fd c19d              rjmp    FALSE_
                 DIGITQ2:
01f4fe d204              rcall   DUP             ; 1 1
01f4ff df2c              rcall   BASE            ; 1 1 base
01f500 d139              rcall   FETCH_A         ; 1 1 10
01f501 940d f2ad         jmp     LESS            ; 1 ffff
                 
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
01f503 e9e8              fdw     DIGITQ_L
                 SIGNQ_L:
01f504 7385
01f505 6769
01f506 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
01f507 dcbb              rcall   OVER
01f508 de73              rcall   CFETCH_A
01f509 2f08              mov     t0, tosl
01f50a dca7              rcall   DROP
01f50b 320d              cpi     t0, '-'
01f50c f019              breq    SIGNQMINUS
01f50d 320b              cpi     t0, '+'
01f50e f019              breq    SIGNQPLUS
01f50f c003              rjmp    SIGNQEND
                 SIGNQMINUS:
01f510 d004              rcall   SLASHONE
01f511 c192              rjmp    TRUE_
                 SIGNQPLUS:
01f512 d002              rcall   SLASHONE
                 SIGNQEND:
01f513 940d f69b         jmp     FALSE_
                 SLASHONE:
01f515 dc0a              rcall   ONE
01f516 940d f44c         jmp     SLASHSTRING
                 
                 ; UD*  ud u -- ud
01f518 ea08              fdw     SIGNQ_L
                 UDSTAR_L:
01f519 7583
01f51a 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
01f51b 938f              push    tosl
01f51c 939f              push    tosh
01f51d de06              rcall   UMSTAR
01f51e dc93              rcall   DROP
01f51f dc99              rcall   SWOP
01f520 dcbd              rcall   RFROM
01f521 de02              rcall   UMSTAR
01f522 dca8              rcall   ROT
01f523 940d f1fb         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
01f525 ea32              fdw     UDSTAR_L
                 UDSLASHMOD_L:
01f526 7586
01f527 2f64
01f528 6f6d
01f529 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
01f52a dca8              rcall   TOR             ; ud.l ud.h 
01f52b d16f              rcall   FALSE_          ; ud.l ud.h 0
01f52c dcbc              rcall   RFETCH          ; ud.l ud.h 0 u
01f52d ddfd              rcall   UMSLASHMOD      ; ud.l r.h q.h
01f52e dc9c              rcall   ROT             ; r.h q.h ud.l
01f52f dc9b              rcall   ROT             ; q.h ud.l r.h
01f530 dcad              rcall   RFROM           ; q.h ud.l r.h u
01f531 ddf9              rcall   UMSLASHMOD      ; q.h r.l q.l
01f532 940d f1cb         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
01f534 ea4c              fdw     UDSLASHMOD_L
                 TONUMBER_L:
01f535 3e87
01f536 756e
01f537 626d
01f538 7265              .db     NFA|7,">number"
                 TONUMBER:
01f539 e021              ldi     al, 1
                 TONUM1:
01f53a dde4              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
01f53b f0d1              breq    TONUM3
01f53c dc96              rcall   TOR
01f53d 938f              push    tosl             ; dup >r
01f53e 939f              push    tosh             ; ud.l ud.h adr
01f53f de3c              rcall   CFETCH_A
01f540 328e              cpi     tosl, '.'
01f541 f079              breq    TONUM_SKIP
01f542 dfb5              rcall   DIGITQ          ; ud.l ud.h digit flag
01f543 ddd5              rcall   ZEROSENSE
01f544 f421              brne    TONUM2
01f545 dc6c              rcall   DROP
01f546 dc97              rcall   RFROM
01f547 dc96              rcall   RFROM
01f548 c00d              rjmp    TONUM3
                 TONUM2: 
01f549 dc89              rcall   TOR             ; ud.l ud.h digit
01f54a dee1              rcall   BASE
01f54b d0ee              rcall   FETCH_A
01f54c dfce              rcall   UDSTAR
01f54d dc90              rcall   RFROM
01f54e dcb4              rcall   MPLUS
01f54f e020              ldi     al, 0
01f550 c001              rjmp    TONUM_CONT
                 TONUM_SKIP:
01f551 dc60              rcall   DROP
                 TONUM_CONT:
01f552 dc8b              rcall   RFROM
01f553 dc8a              rcall   RFROM
01f554 dfc0              rcall   SLASHONE
01f555 cfe4              rjmp    TONUM1
                 TONUM3:
01f556 0f82              add     tosl, al
01f557 9508              ret
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
01f558 ea6a              fdw     TONUMBER_L
                 NUMBERQ_L:
01f559 6e87
01f55a 6d75
01f55b 6562
01f55c 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
01f55d d1a5              rcall   DUP             ; a a
01f55e d13c              rcall   FALSE_          ; a a 0 0
01f55f d13b              rcall   FALSE_          ; a a 0 0
01f560 dc6a              rcall   ROT             ; a 0 0 a
01f561 df3f              rcall   CFETCHPP        ; a 0 0 a' u
01f562 dfa4              rcall   SIGNQ           ; a 0 0 a' u f
01f563 dc6f              rcall   TOR             ; a 0 0 a' u
                 
01f564 dec7              rcall   BASE
01f565 d0d4              rcall   FETCH_A
01f566 dc6c              rcall   TOR             ; a 0 0 a' u
                         
01f567 dc5b              rcall   OVER
01f568 de13              rcall   CFETCH_A
                         
01f569 9783              sbiw    tosl, '#'
01f56a 3083              cpi     tosl, 3
01f56b f438              brsh    BASEQ1
                 
01f56c db33              rcall   CELLS
01f56d d18b              rcall   DOLIT
01f56e ffe0              fdw     BASEQV
01f56f dc8b              rcall   PLUS
01f570 da4c              rcall   FEXECUTE
                 
01f571 dfa3              rcall   SLASHONE
01f572 c001              rjmp    BASEQ2
                 BASEQ1:
01f573 dc3e              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
01f574 dfc4              rcall   TONUMBER        ; a ud.l ud.h  a' u
01f575 dc68              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
01f576 deb5              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
01f577 df37              rcall   STORE_A         ; a ud.l ud.h  a' u
01f578 dda0              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
01f579 f029              breq    QNUMD
                 QNUM_ERR:                       ; Not a number
01f57a dc63              rcall   RFROM           ; a ud.l ud.h a' u sign
01f57b db6a              rcall   TWODROP
01f57c db69              rcall   TWODROP
01f57d d11d              rcall   FALSE_          ; a 0           Not a number
01f57e c011              rjmp    QNUM3
                 QNUMD:                          ; Single or Double number
                                                 ; a ud.l ud.h a'
01f57f 9701              sbiw    tosl, 1
01f580 ddfb              rcall   CFETCH_A        ; a ud.l ud.h c
01f581 940f fe95         call    TO_A
01f583 dc5a              rcall   RFROM           ; a a' u ud.l ud.d sign
01f584 dd94              rcall   ZEROSENSE
01f585 f009              breq    QNUMD1
01f586 d45a              rcall   DNEGATE
                 QNUMD1:
01f587 322e              cpi     al, '.'         ; a d.l d.h
01f588 f421              brne    QNUM1
01f589 dc41              rcall   ROT             ; d.l d.h a
01f58a e082              ldi     tosl, 2
01f58b e090              ldi     tosh, 0         ; d.l d.h 2    Double number
01f58c c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a d.l d.h
01f58d dc24              rcall   DROP            ; a n
01f58e ddcb              rcall   NIP             ; n
01f58f db90              rcall   ONE             ; n 1           Single number
                 QNUM3:  
01f590 9508              ret
                 
                 
01f591 7384
01f592 6177
01f593 0070              .db     NFA|4,"swap",0
                 SWOP_A:
01f594 940d f1b9         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
01f596 eab2              fdw     NUMBERQ_L
                 TIBSIZE_L:
01f597 7483
01f598 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
01f599 de80              rcall   TASK
01f59a d09f              rcall   FETCH_A
01f59b 9608              adiw    tosl, 8
01f59c 940d fed9         jmp     FETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
01f59e eb2e              fdw     TIBSIZE_L
                 TIB_L:
01f59f 7483
01f5a0 6269              .db     NFA|3,"tib"
                 TIB:
01f5a1 d005              rcall   TIU
01f5a2 940d fed9         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
01f5a4 eb3e              fdw     TIB_L
                 TIU_L:
01f5a5 7483
01f5a6 7569              .db     NFA|3,"tiu"
                 TIU:
01f5a7 de90              rcall   DOUSER
01f5a8 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
01f5a9 eb4a              fdw     TIU_L
                 TOIN_L:
01f5aa 3e83
01f5ab 6e69              .db     NFA|3,">in"
                 TOIN:
01f5ac de8b              rcall   DOUSER
01f5ad fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
01f5ae eb54              fdw     TOIN_L
                 TICKSOURCE_L:
01f5af 2787
01f5b0 6f73
01f5b1 7275
01f5b2 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
01f5b3 de84              rcall   DOUSER
01f5b4 fff6              .dw     usource       ; two cells !!!!!!
                 
                 WORDQ:
01f5b5 d14d              rcall   DUP
01f5b6 910f              m_pop_t0
01f5b7 91ff              pop     zh
01f5b8 91ef              pop     zl
01f5b9 da4b              rcall   FETCHLIT
01f5ba 95f7              ror     zh
01f5bb 95e7              ror     zl
01f5bc dceb              rcall   EQUAL
01f5bd dd5b              rcall   ZEROSENSE
01f5be 9419              mijmp
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
01f5bf eb5e              fdw     TICKSOURCE_L
                 INTERPRET_L:
01f5c0 6989
01f5c1 746e
01f5c2 7265
01f5c3 7270
01f5c4 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
01f5c5 dfed              rcall   TICKSOURCE
01f5c6 db15              rcall   TWOSTORE
01f5c7 d0d3              rcall   FALSE_
01f5c8 dfe3              rcall   TOIN
01f5c9 dee5              rcall   STORE_A
                 IPARSEWORD:
01f5ca d7d0              rcall   INIT_012
01f5cb d246              rcall   BL
01f5cc deaf              rcall   WORD
                 
01f5cd d135              rcall   DUP
01f5ce ddad              rcall   CFETCH_A
01f5cf dd49              rcall   ZEROSENSE
01f5d0 f409              brne    IPARSEWORD1
01f5d1 c064              rjmp    INOWORD
                 IPARSEWORD1:
01f5d2 df16              rcall   FIND            ; sets also wflags
01f5d3 dd4b              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
01f5d4 f409              brne    IPARSEWORD2     ; NUMBER?
01f5d5 c045              rjmp    INUMBER
                 IPARSEWORD2:
01f5d6 dc95              rcall   ONEPLUS         ; 0 = normal 2 = immediate
01f5d7 d241              rcall   STATE_
01f5d8 d130              rcall   ZEROEQUAL
01f5d9 dc71              rcall   OR_
01f5da dd3e              rcall   ZEROSENSE
01f5db f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
01f5dc fe94              sbrs    wflags, 4       ; Compile only check
01f5dd c00a              rjmp    IEXECUTE        ; Not a compile only word
01f5de d23a              rcall   STATE_          ; Compile only word check
01f5df db96              rcall   XSQUOTE
01f5e0 430c
01f5e1 4d4f
01f5e2 4950
01f5e3 454c
01f5e4 4f20
01f5e5 4c4e
01f5e6 0059              .db     12,"COMPILE ONLY",0
01f5e7 d0fd              rcall   QABORT
                 IEXECUTE:
01f5e8 7b6f              cbr     FLAGS1, (1<<noclear)
01f5e9 d9c9              rcall   EXECUTE
01f5ea fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
01f5eb cfde              rjmp    IPARSEWORD
01f5ec 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f5ed 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f5ee c02a              rjmp    ICLRFLIT
                 ICOMPILE_1:
01f5ef 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
01f5f0 dfc4              rcall   WORDQ
01f5f1 ee12              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
01f5f2 f011              breq    ICOMPILE_2
01f5f3 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
01f5f4 c020              rjmp    ICOMMAXT
                 ICOMPILE_2:
01f5f5 ff67              sbrs    FLAGS1, fLIT
01f5f6 c014              rjmp    ICOMPILE_6
01f5f7 dfbd              rcall   WORDQ
01f5f8 e486              fdw     AND_    
01f5f9 f011              breq    ICOMPILE_3
01f5fa dc32              rcall   ANDIC_
01f5fb c01d              rjmp    ICLRFLIT
                 ICOMPILE_3:
01f5fc dfb8              rcall   WORDQ
01f5fd e496              fdw     OR_
01f5fe f011              breq    ICOMPILE_4
01f5ff dc36              rcall   ORIC_
01f600 c018              rjmp    ICLRFLIT
                 ICOMPILE_4:
01f601 dfb3              rcall   WORDQ
01f602 e3f6              fdw     PLUS
01f603 f011              breq    ICOMPILE_5
01f604 dc0e              rcall   PLUSC_
01f605 c013              rjmp    ICLRFLIT
                 ICOMPILE_5:
01f606 dfae              rcall   WORDQ
01f607 e410              fdw     MINUS
01f608 f011              breq    ICOMPILE_6
01f609 dc10              rcall   MINUSC_
01f60a c00e              rjmp    ICLRFLIT
                 ICOMPILE_6:
01f60b 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
01f60c dfa8              rcall   WORDQ
01f60d ee06              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
01f60e f009              breq    ICOMPILE
01f60f 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
01f610 fe95              sbrs    wflags, 5       ; Inline check
01f611 c003              rjmp    ICOMMAXT
01f612 940f f98d         call    INLINE0
01f614 c004              rjmp    ICLRFLIT
                 ICOMMAXT:
01f615 d126              rcall   COMMAXT_A
01f616 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
01f617 fc94              sbrc    wflags, 4            ; Compile only ?
01f618 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
                 ICLRFLIT:
01f619 776f              cbr     FLAGS1, (1<<fLIT)
01f61a cfaf              rjmp    IPARSEWORD
                 INUMBER: 
01f61b 746f              cbr     FLAGS1, (1<<izeroeq) | (1<<idup) | (1<<fLIT)
01f61c db95              rcall   DROP
01f61d df3f              rcall   NUMBERQ
01f61e dd00              rcall   DUPZEROSENSE
01f61f f081              breq    IUNKNOWN
01f620 d1f8              rcall   STATE_
01f621 dcf7              rcall   ZEROSENSE
01f622 f059              breq    INUMBER1
01f623 2f08              mov     t0, tosl
01f624 9189
01f625 9199              poptos
01f626 ff01              sbrs    t0, 1
01f627 c003              rjmp    ISINGLE
                 IDOUBLE:
01f628 df6b              rcall   SWOP_A
01f629 940f fe6d         call    LITERAL
                 ISINGLE:        
01f62b 940f fe6d         call    LITERAL
01f62d cf9c              rjmp    IPARSEWORD
                 
                 INUMBER1:
01f62e db83              rcall   DROP
01f62f cfe9              rjmp    ICLRFLIT
                 
                 IUNKNOWN:
01f630 db81              rcall   DROP 
01f631 d045              rcall   DP_TO_RAM
01f632 de6e              rcall   CFETCHPP
01f633 db35              rcall   TYPE
01f634 d066              rcall   FALSE_
01f635 d0a6              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
01f636 d764              rcall   INIT_012
01f637 940d f1b2         jmp     DROP
                 
01f639 4081              .db     NFA|1,"@"
                 FETCH_A:        
01f63a 940d fed9         jmp     FETCH
                 
                 ;;;    bitmask -- 
01f63c eb80              fdw     INTERPRET_L
                 SHB_L:
01f63d 7383
01f63e 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
01f63f d1e5              rcall   LATEST_
01f640 dff9              rcall   FETCH_A
01f641 d0c1              rcall   DUP
01f642 dd39              rcall   CFETCH_A
01f643 db87              rcall   ROT
01f644 dc06              rcall   OR_
01f645 df4e              rcall   SWOP_A
01f646 940d ff0e         jmp     CSTORE
                         
01f648 ec7a              fdw     SHB_L
                 IMMEDIATE_L:
01f649 6989
01f64a 6d6d
01f64b 6465
01f64c 6169
01f64d 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
01f64e d0aa              rcall   DOLIT
01f64f 0040              .dw     IMMED
01f650 940d f63f         jmp     SHB
                 
                 ;***************************************************************
01f652 ec92              fdw     IMMEDIATE_L
                 INLINED_L:
01f653 6987
01f654 6c6e
01f655 6e69
01f656 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
01f657 d0a1              rcall   DOLIT
01f658 0020              .dw     INLINE
01f659 940d f63f         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
01f65b eca6              fdw     INLINED_L
                 DOTSTATUS_L:
01f65c 2e83
01f65d 7473              .db     NFA|3,".st"
                 DOTSTATUS:
01f65e d09a              rcall   DOLIT
01f65f 003c              .dw     '<'
01f660 d93d              rcall   EMIT
01f661 940f ffa3         call    DOTBASE
01f663 d93a              rcall   EMIT
01f664 d094              rcall   DOLIT
01f665 002c              .dw     ','
01f666 d937              rcall   EMIT
01f667 940f ee8f         call    MEMQ
01f669 daff              rcall   TYPE
01f66a d08e              rcall   DOLIT
01f66b 003e              .dw     '>'
01f66c d931              rcall   EMIT
01f66d 940d f8a8         jmp     DOTS
                 
01f66f 3e82
01f670 0072              .db     NFA|2,">r",0
01f671 940d f1d3 TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
                 ;        .db     NFA|1,"a"
                 TEN:
01f673 d97e              rcall   DOCREATE
01f674 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
01f675 6483
01f676 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
01f677 d081              rcall   DOLIT
01f678 2200              .dw     dp_start
01f679 d1ba              rcall   INI
01f67a dff8              rcall   TEN
01f67b 940d f486         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
01f67d 3e83
01f67e 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
01f67f d079              rcall   DOLIT
01f680 2200              .dw     dp_start
01f681 dc4b              rcall   STORE_P_TO_R
01f682 d1b1              rcall   INI
01f683 d075              rcall   DOLIT
01f684 0004              .dw     4
01f685 db4d              rcall   TOR
                 DP_TO_EEPROM_0: 
01f686 de22              rcall   FETCHPP
01f687 d07b              rcall   DUP
01f688 dc59              rcall   PFETCH
01f689 dc19              rcall   NOTEQUAL
01f68a dc8e              rcall   ZEROSENSE
01f68b f011              breq    DP_TO_EEPROM_1
                 .if DEBUG_FLASH == 1
                 .endif
01f68c dc5d              rcall   PSTORE
01f68d c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
01f68e db23              rcall   DROP
                 DP_TO_EEPROM_2:
01f68f d41b              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
01f690 d325              rcall   XNEXT
01f691 f7a0              brcc    DP_TO_EEPROM_0
01f692 911f              pop     t1
01f693 910f              pop     t0
01f694 dc44              rcall   R_TO_P
01f695 940d f1b2         jmp     DROP
                 
01f697 ecb8              fdw     DOTSTATUS_L
                 FALSE_L:
01f698 6685
01f699 6c61
01f69a 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
01f69b 939a
01f69c 938a              pushtos
01f69d 2788              clr     tosl
01f69e 2799              clr     tosh
01f69f 9508              ret
                 
01f6a0 ed30              fdw     FALSE_L
                 TRUE_L:
01f6a1 7484
01f6a2 7572
01f6a3 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
01f6a4 939a
01f6a5 938a              pushtos
01f6a6 ef8f              ser     tosl
01f6a7 ef9f              ser     tosh
01f6a8 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
01f6a9 ed42              fdw     TRUE_L
                 QUIT_L:
01f6aa 7184
01f6ab 6975
01f6ac 0074              .db     NFA|4,"quit",0
                 QUIT:
01f6ad d978              rcall   RPEMPTY
01f6ae d10c              rcall   LEFTBRACKET
01f6af d9a3              rcall   FRAM
                 QUIT0:  
                         ;; Copy INI and DP's from eeprom to ram
01f6b0 dfc6              rcall   DP_TO_RAM
                 QUIT1: 
01f6b1 d8da              rcall   check_sp
01f6b2 d08e              rcall   CR
01f6b3 deed              rcall   TIB
01f6b4 d04e              rcall   DUP
01f6b5 dee3              rcall   TIBSIZE
01f6b6 970a              sbiw    tosl, 10     ; Reserve 10 bytes for hold buffer
01f6b7 da72              rcall   ACCEPT
01f6b8 da44              rcall   SPACE_
01f6b9 df0b              rcall   INTERPRET
01f6ba d15e              rcall   STATE_
01f6bb dc5d              rcall   ZEROSENSE
01f6bc f7a1              brne    QUIT1
01f6bd d6cc              rcall   IFLUSH
01f6be dfc0              rcall   DP_TO_EEPROM
                          
01f6bf dab6              rcall    XSQUOTE
01f6c0 2003
01f6c1 6b6f              .db     3," ok"
01f6c2 daa6              rcall    TYPE
01f6c3 d007              rcall   PROMPT_
01f6c4 940d f6b0         jmp     QUIT0
                 
                 
01f6c6 ed54              fdw     QUIT_L
                 PROMPT_L:
01f6c7 7086
01f6c8 6f72
01f6c9 706d
01f6ca 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
01f6cb 940f ff46         call    DEFER_DOES
01f6cd 220a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
01f6ce ed8e              fdw     PROMPT_L
                 ABORT_L:
01f6cf 6185
01f6d0 6f62
01f6d1 7472              .db     NFA|5,"abort"
                 ABORT:
01f6d2 d158              rcall   S0
01f6d3 df66              rcall   FETCH_A
01f6d4 d94d              rcall   SPSTORE
01f6d5 940d f6ad         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
01f6d7 ed9e              fdw     ABORT_L
                 QABORTQ_L:
01f6d8 3f87
01f6d9 6261
01f6da 726f
01f6db 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
01f6dc da99              rcall   XSQUOTE
01f6dd 3f01              .db     1,"?"
01f6de 940d f6e5         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
01f6e0 edb0              fdw     QABORTQ_L
                 QABORT_L:
01f6e1 3f86
01f6e2 6261
01f6e3 726f
01f6e4 0074              .db     NFA|6,"?abort",0
                 QABORT:
01f6e5 dae5              rcall   ROT
01f6e6 dc32              rcall   ZEROSENSE
01f6e7 f419              brne    QABO1
                 QABORT1:        
01f6e8 da14              rcall   SPACE_
01f6e9 da7f              rcall   TYPE
01f6ea dfe7              rcall   ABORT  ; ABORT never returns
01f6eb 940d f0e6 QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
01f6ed edc2              fdw     QABORT_L
                 ABORTQUOTE_L:
01f6ee 61d6
01f6ef 6f62
01f6f0 7472
01f6f1 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
01f6f2 da9a              rcall   SQUOTE
01f6f3 d91a              rcall   DOCOMMAXT
01f6f4 edca              fdw     QABORT
01f6f5 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
01f6f6 eddc              fdw     ABORTQUOTE_L
                 DOLIT_L:
01f6f7 6c83
01f6f8 7469              .db     NFA|3, "lit"
                 DOLIT:
01f6f9 91ff              m_pop_zh
01f6fa 91ff              pop     zh
01f6fb 91ef              pop     zl
01f6fc d908              rcall   FETCHLIT
01f6fd 95f7              ror     zh
01f6fe 95e7              ror     zl
01f6ff 9419              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
01f700 e3ce              fdw     RFETCH_L
                 DUP_L:
01f701 64a3
01f702 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
01f703 939a
01f704 938a              pushtos
01f705 9508              ret
                 
01f706 e542              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
01f707 3082
01f708 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:
01f709 9701              sbiw    tosl, 1
01f70a 0b88              sbc     tosl, tosl
01f70b 0b99              sbc     tosh, tosh
01f70c 9508              ret
                 
01f70d ee0e              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
01f70e 3082
01f70f 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
01f710 0f99              lsl     tosh
01f711 0b88              sbc     tosl, tosl
01f712 0b99              sbc     tosh, tosh
01f713 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
01f714 edee              fdw     DOLIT_L
                 TICK_L:
01f715 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
01f716 d0fb              rcall   BL
01f717 dd64              rcall   WORD
01f718 ddd0              rcall   FIND
01f719 940d f6dc         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
01f71b ee2a              fdw     TICK_L
                 CHAR_L:
01f71c 6384
01f71d 6168
01f71e 0072              .db     NFA|4,"char",0
                 CHAR:
01f71f d0f2              rcall   BL
01f720 dd3e              rcall   PARSE
01f721 da90              rcall   DROP
01f722 940d fef4         jmp     CFETCH
                 
                 ; (    --                     skip input until )
01f724 ee38              fdw     CHAR_L
                 PAREN_L:
01f725 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
01f726 dfd2              rcall   DOLIT
01f727 0029              .dw     ')'
01f728 dd36              rcall   PARSE
01f729 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
01f72a 940d f0e6         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
01f72c ee4a              fdw     PAREN_L
                 IHERE_L:
01f72d 6985
01f72e 6568
01f72f 6572              .db     NFA|5,"ihere"
                 IHERE:
01f730 d068              rcall   IDP
01f731 cf08              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
01f732 ee5a              fdw     IHERE_L
                 BRACCHAR_L:
01f733 5bd6
01f734 6863
01f735 7261
01f736 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
01f737 dfe7              rcall   CHAR
01f738 940d fe6d         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
01f73a 6383
01f73b 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
01f73c 940d f0b1         jmp     COMMAXT
                 
                 ; CR      --                      output newline
01f73e ee66              fdw     BRACCHAR_L
                 CR_L:
01f73f 6382
01f740 0072              .db     NFA|2,"cr",0
                 CR:
01f741 dfb7              rcall   DOLIT
01f742 000d              .dw     0x0d       ; CR \r
01f743 d85a              rcall   EMIT
01f744 dfb4              rcall   DOLIT
01f745 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
01f746 940d ef9e         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
01f748 ee7e              fdw     CR_L
                 CREATE_L:
01f749 6386
01f74a 6572
01f74b 7461
01f74c 0065              .db     NFA|6,"create",0
                 CREATE:
01f74d d0c4              rcall   BL
01f74e dd2d              rcall   WORD            ; Parse a word
                 
01f74f dfb3              rcall   DUP             ; Remember parsed word at rhere
01f750 dd98              rcall   FIND
01f751 dc08              rcall   NIP
01f752 dfb6              rcall   ZEROEQUAL
01f753 da22              rcall   XSQUOTE
01f754 410f
01f755 524c
01f756 4145
01f757 5944
01f758 4420
01f759 4645
01f75a 4e49
01f75b 4445              .db     15,"ALREADY DEFINED"
01f75c df88              rcall   QABORT         ; ABORT if word has already been defined
01f75d dfa5              rcall   DUP             ; Check the word length 
01f75e dc1d              rcall   CFETCH_A
01f75f d9c0              rcall   ONE
01f760 df98              rcall   DOLIT
01f761 0010              .dw     16
01f762 db36              rcall   WITHIN
01f763 df78              rcall   QABORTQ          ; Abort if there is no name for create
                 
01f764 dfcb              rcall   IHERE
01f765 d92d              rcall   ALIGNED
01f766 d032              rcall   IDP             ; Align the flash DP.
01f767 dd47              rcall   STORE_A
                 
01f768 d0bc              rcall   LATEST_
01f769 ded0              rcall   FETCH_A
01f76a dad3              rcall   ICOMMA_          ; Link field
01f76b dd35              rcall   CFETCHPP        ; str len
01f76c dfc3              rcall   IHERE
01f76d df95              rcall   DUP             
01f76e d0b6              rcall   LATEST_         ; new 'latest' link
01f76f dd3f              rcall   STORE_A         ; str len ihere
01f770 dd27              rcall   PLACE           ; 
01f771 dfbe              rcall   IHERE           ; ihere
01f772 dc09              rcall   CFETCH_A
01f773 df85              rcall   DOLIT
01f774 0080              .dw     NFA
01f775 dec9              rcall   SHB
01f776 daf5              rcall   ONEPLUS
01f777 d91b              rcall   ALIGNED
01f778 d170              rcall   IALLOT          ; The header has now been created
01f779 df7f              rcall   DOLIT             
01f77a dfe4              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
01f77b d93e              rcall   STORECFF1       ; Append an exeution token, CALL !
01f77c d90c              rcall   ALIGN
01f77d d8ec              rcall   HERE            ; compiles the current dataspace dp into the dictionary
01f77e d8e1              rcall   CSE_
01f77f db99              rcall   ZEROSENSE
01f780 f409              brne    CREATE2
01f781 daf4              rcall   TWOPLUS
                 CREATE2:
01f782 940d ff91         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
01f784 ee92              fdw    CREATE_L
                 POSTPONE_L:
01f785 70d8
01f786 736f
01f787 7074
01f788 6e6f
01f789 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
01f78a d087              rcall   BL
01f78b dcf0              rcall   WORD
01f78c dd5c              rcall   FIND
01f78d df75              rcall   DUP
01f78e df4d              rcall   QABORTQ
01f78f df80              rcall   ZEROLESS
01f790 db88              rcall   ZEROSENSE
01f791 f019              breq    POSTPONE1
01f792 d87b              rcall   DOCOMMAXT
01f793 e01c              fdw     DOCOMMAXT
01f794 caa9              rjmp    ICOMMA_
                 POSTPONE1:
01f795 940d f0b1         jmp     COMMAXT
                 
                 
                 IDP_L:
01f797 6983
01f798 7064              .db     NFA|3,"idp"
                 IDP:
01f799 d858              rcall   DOCREATE
01f79a 03bc              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
01f79b 2887
01f79c 6f64
01f79d 7365
01f79e 293e              .db     NFA|7,"(does>)"
                 XDOES:
01f79f 91ff              m_pop_zh
01f7a0 da3d              rcall   RFROM
01f7a1 d083              rcall   LATEST_
01f7a2 de97              rcall   FETCH_A
01f7a3 dd10              rcall   NFATOCFA
01f7a4 dff4              rcall   IDP
01f7a5 de94              rcall   FETCH_A
01f7a6 deca              rcall   TOR_A
01f7a7 dff1              rcall   IDP
01f7a8 dd06              rcall   STORE_A
01f7a9 0f88              lsl     tosl
01f7aa 1f99              rol     tosh
01f7ab d90e              rcall   STORECFF1 ; Always stores a 4 byte call
01f7ac da31              rcall   RFROM
01f7ad dfeb              rcall   IDP
01f7ae 940d fe9c         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
01f7b0 ef0a              fdw     POSTPONE_L
                 DOES_L:
01f7b1 64d5
01f7b2 656f
01f7b3 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
01f7b4 d859      DOES:   rcall   DOCOMMAXT
01f7b5 ef3e              fdw     XDOES
01f7b6 d857              rcall   DOCOMMAXT
01f7b7 dff8              fdw     DODOES
01f7b8 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
01f7b9 ef62              fdw     DOES_L
                 LEFTBRACKET_L:
01f7ba 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
01f7bb 9250 03c9         sts     state, r_zero
01f7bd 9508              ret
                 
                 
                 ; ]        --      enter compiling state
01f7be ef74              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
01f7bf 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
01f7c0 9260 03c9         sts     state, r_one
01f7c2 9508              ret
                 
                 ; :        --           begin a colon definition
01f7c3 ef7e              fdw     RIGHTBRACKET_L
                 COLON_L:
01f7c4 3a81              .db     NFA|1,":"
                 COLON:
01f7c5 df87              rcall   CREATE
01f7c6 dff9              rcall   RIGHTBRACKET
01f7c7 940d f0cc         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
01f7c9 ef88              fdw     COLON_L
                 NONAME_L:
01f7ca 3a87
01f7cb 6f6e
01f7cc 616e
01f7cd 656d              .db     NFA|7,":noname"
                 NONAME:
01f7ce df61              rcall   IHERE
01f7cf 940d f7c0         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
01f7d1 ef94              fdw     NONAME_L
                 SEMICOLON_L:
01f7d2 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
01f7d3 dfe7              rcall   LEFTBRACKET
01f7d4 fd61              sbrc    FLAGS1, fTAILC
01f7d5 c023              rjmp    ADD_RETURN_1
01f7d6 df59              rcall   IHERE
01f7d7 d028              rcall   MINUS_FETCH
01f7d8 018c              movw    t0, tosl
01f7d9 7f10              andi    t1, 0xf0
01f7da 5d10              subi    t1, 0xd0
01f7db f059              breq    RCALL_TO_JMP
01f7dc 9189
01f7dd 9199              poptos
01f7de d021              rcall   MINUS_FETCH
                 .ifdef EIND
01f7df 508f              subi    tosl, 0x0f
                 .else
                 .endif
01f7e0 4994              sbci    tosh, 0x94
01f7e1 f4b1              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
01f7e2 e08d              ldi     tosl, 0x0d
                 .else
                 .endif
01f7e3 e994              ldi     tosh, 0x94
01f7e4 d9d4              rcall   SWOP
01f7e5 940d fe9c         jmp     STORE
                 RCALL_TO_JMP:
01f7e7 db72              rcall   NIP
01f7e8 709f              andi    tosh, 0x0f
01f7e9 fd93              sbrc    tosh, 3
01f7ea 6f90              ori     tosh, 0xf0
01f7eb da95              rcall   TWOSTAR
01f7ec df43              rcall   IHERE
01f7ed da0d              rcall   PLUS
01f7ee df0a              rcall   DOLIT
01f7ef fffe              .dw     -2
01f7f0 d0f8              rcall   IALLOT
01f7f1 df07              rcall   DOLIT
                 .ifdef EIND
01f7f2 940d              .dw     0x940d
                 .else
                 .endif
01f7f3 d007              rcall   ICOMMA__
                         sub_pflash_tos
01f7f4 9408              rampv_to_c
01f7f5 9597              ror     tosh
01f7f6 9587              ror     tosl
01f7f7 c003              rjmp    ICOMMA__
                 ADD_RETURN:
01f7f8 d8ed              rcall   TWODROP
                 ADD_RETURN_1:
01f7f9 deff              rcall   DOLIT   ; Compile a ret
01f7fa 9508              .dw     0x9508
                 ICOMMA__:
01f7fb 940d ff91         jmp    ICOMMA
                 
                 
                 
01f7fd efa4              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
01f7fe 2d82
01f7ff 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
01f800 d00c              rcall   TWOMINUS
01f801 df01              rcall   DUP
01f802 940d fed9         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
01f804 effc              fdw     MINUS_FETCH_L
                 BRACTICK_L:
01f805 5bd3
01f806 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
01f807 df0e              rcall   TICK       ; get xt of 'xxx'
01f808 940d fe6d         jmp     LITERAL
                 
                 ; 2-    n -- n-2
01f80a f00a              fdw     BRACTICK_L
                 TWOMINUS_L:
01f80b 32a2
01f80c 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
01f80d 9702              sbiw    tosl, 2
01f80e 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
01f80f f016              fdw     TWOMINUS_L
                 BL_l:
01f810 6282
01f811 006c              .db     NFA|2,"bl",0
                 BL:
01f812 940f eff2         call    DOCREATE
01f814 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
01f815 f020              fdw     BL_L
                 STATE_L:
01f816 7385
01f817 6174
01f818 6574              .db     NFA|5,"state"
                 STATE_:
01f819 939a
01f81a 938a              pushtos
01f81b 9180 03c9         lds     tosl, state
01f81d 9190 03c9         lds     tosh, state
01f81f 9508              ret
                 
                 ; LATEST    -- a-addr           
01f820 f02c              fdw     STATE_L
                 LATEST_L:
01f821 6c86
01f822 7461
01f823 7365
01f824 0074              .db     NFA|6,"latest",0
                 LATEST_:
01f825 940f eff2         call    DOCREATE
01f827 03c2              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
01f828 f042              fdw     LATEST_L
                 S0_L:
01f829 7382
01f82a 0030              .db     NFA|2,"s0",0
                 S0:
01f82b dc0c              rcall   DOUSER
01f82c ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
01f82d f052              fdw     S0_L
                 R0_L:
01f82e 7282
01f82f 0030              .db     NFA|2,"r0",0
                 R0_:
01f830 dc07              rcall   DOUSER
01f831 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
01f832 6983
01f833 696e              .db     NFA|3,"ini"
                 INI:
01f834 940f eff2          call   DOCREATE
01f836 03ba              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
01f837 f05c              fdw     R0_L
                 TICKS_L:
01f838 7485
01f839 6369
01f83a 736b              .db     NFA|5,"ticks"
                 TICKS:  
01f83b 939a
01f83c 938a              pushtos
01f83d b70f              in_     t0, SREG
01f83e 94f8              cli
01f83f 2d8e              mov     tosl, ms_count
01f840 2d9f              mov     tosh, ms_count1
01f841 bf0f              out_    SREG, t0
01f842 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
01f843 f070              fdw     TICKS_L
                 MS_L:
01f844 6d82
01f845 0073              .db     NFA|2,"ms",0
                 MS:
01f846 dff4              rcall   TICKS
01f847 d9b3              rcall   PLUS
                 MS1:    
01f848 d727              rcall   PAUSE
01f849 deb9              rcall   DUP
01f84a dff0              rcall   TICKS
01f84b d9bc              rcall   MINUS
01f84c dec3              rcall   ZEROLESS
01f84d dacb              rcall   ZEROSENSE
01f84e f3c9              breq    MS1
01f84f 940d f1b2         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
01f851 f088              fdw     MS_L
                 DOTID_L:
01f852 2e83
01f853 6469              .db     NFA|3,".id"
                 DOTID:
01f854 dc4c              rcall   CFETCHPP
01f855 708f              andi    tosl, 0x0f
01f856 d97c              rcall   TOR
01f857 c003              rjmp    DOTID3
                 DOTID1:
01f858 dc48              rcall   CFETCHPP
01f859 d00a              rcall   TO_PRINTABLE
01f85a deeb              rcall   EMIT_A
                 DOTID3:
01f85b d15a              rcall   XNEXT
01f85c f7d8              brcc    DOTID1  
01f85d 911f              pop     t1
01f85e 910f              pop     t0
01f85f 940d f1b2         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
01f861 f0a4              fdw     DOTID_L
                 TO_PRINTABLE_L:
01f862 3e83
01f863 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:
01f864 2799              clr     tosh   
01f865 3080              cpi     tosl, 0
01f866 f012              brmi    TO_PRINTABLE1
01f867 3280              cpi     tosl, 0x20
01f868 f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
01f869 e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
01f86a 9508              ret
                 
                 ;;;;;;;;;;;;;;
                 LIKEQ:
01f86b dc35              rcall   CFETCHPP
01f86c de8c              rcall   DOLIT
01f86d 000f              .dw     0x0f
01f86e d9d4              rcall   AND_
01f86f d949              rcall   SWOP
01f870 da54              rcall   STORE_P
01f871 d947              rcall   SWOP
01f872 dc2e              rcall   CFETCHPP
01f873 d957              rcall   ROT
01f874 d94e              rcall   OVER
01f875 d992              rcall   MINUS
01f876 d9f5              rcall   ONEPLUS
01f877 de23              rcall   FALSE_
01f878 daf8              rcall   MAX
01f879 d959              rcall   TOR
01f87a c009              rjmp    LIKEQ3
                 LIKEQ1:
01f87b d871              rcall   TWODUP
01f87c d21f              rcall   FETCH_P
01f87d da7c              rcall   PPLUS
01f87e d93a              rcall   SWOP
01f87f 940f 7e80         call    CMP
01f881 f011              breq    LIKEQ3
                 TWODROPNZ:
01f882 9498              clz
01f883 c003              rjmp    LIKEQ4
                 LIKEQ3:
01f884 d131              rcall   XNEXT
01f885 f7a8              brcc    LIKEQ1
                 TWODROPZ:
01f886 9418              sez
                 LIKEQ4:
01f887 911f              pop     t1
01f888 910f              pop     t0
01f889 c00a              rjmp    TWODROP__
                 
                 ;;;;;;;;;;;;;;;;;;;;
                 LIKES:
01f88a d862              rcall   TWODUP
01f88b dfdf              rcall   LIKEQ
01f88c f019              breq    LIKES1
01f88d de75              rcall   DUP
01f88e dfc5              rcall   DOTID
01f88f d86d              rcall   SPACE_
                 LIKES1:
01f890 df7c              rcall   TWOMINUS
01f891 dda8              rcall   FETCH_A
01f892 da8c              rcall   DUPZEROSENSE
01f893 f7b1              brne    LIKES
                 TWODROP__:
01f894 940d f0e6         jmp     TWODROP
                 
                  ; WORDS    -- filter
01f896 f0c4              fdw     TO_PRINTABLE_L
                 WORDS_L:
01f897 7785
01f898 726f
01f899 7364              .db     NFA|5,"words"
01f89a df77              rcall   BL
01f89b dbe0              rcall   WORD
01f89c de66              rcall   DUP
01f89d de5b              rcall   DOLIT
01f89e f552              fdw     kernellink
01f89f d002              rcall   WDS1
01f8a0 df84              rcall   LATEST_
01f8a1 dd98              rcall   FETCH_A
01f8a2 de9e      WDS1:   rcall   CR
01f8a3 940d f88a         jmp     LIKES
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
01f8a5 f12e              fdw     WORDS_L
                 DOTS_L:
01f8a6 2e82
01f8a7 0073              .db     NFA|2,".s",0
                 DOTS:
01f8a8 d854              rcall   SPACE_
01f8a9 de59              rcall   DUP
01f8aa 940f f01b         call    SPFETCH
01f8ac df7e              rcall   S0
01f8ad dd8c              rcall   FETCH_A
01f8ae df5e              rcall   TWOMINUS
                 DOTS1:
01f8af d83d              rcall   TWODUP
01f8b0 d9fc              rcall   LESS
01f8b1 da67              rcall   ZEROSENSE
01f8b2 f019              breq    DOTS2
01f8b3 df4c              rcall   MINUS_FETCH
01f8b4 db17              rcall   UDOT
01f8b5 cff9              rjmp    DOTS1
                 DOTS2:  
01f8b6 d8fb              rcall   DROP
01f8b7 940d f0e6         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
01f8b9 f14c              fdw     DOTS_L
                 DUMP_L:
01f8ba 6484
01f8bb 6d75
01f8bc 0070              .db     NFA|4,"dump",0
                 DUMP:
01f8bd de3b              rcall   DOLIT
01f8be 0010              .dw     16
01f8bf da7d              rcall   USLASH
01f8c0 d912              rcall   TOR
01f8c1 c020              rjmp    DUMP7
                 DUMP1:  
01f8c2 de7e              rcall   CR
01f8c3 de3f              rcall   DUP
01f8c4 de34              rcall   DOLIT
01f8c5 0004              .dw     4
01f8c6 db0f              rcall   UDOTR
01f8c7 de31              rcall   DOLIT
01f8c8 003a              .dw     ':'
01f8c9 de7c              rcall   EMIT_A
01f8ca de2e              rcall   DOLIT
01f8cb 000f              .dw     15
01f8cc d906              rcall   TOR
                 DUMP2:
01f8cd dbd3              rcall   CFETCHPP
01f8ce de2a              rcall   DOLIT
01f8cf 0002              .dw     2
01f8d0 db05              rcall   UDOTR
01f8d1 d0e4              rcall   XNEXT
01f8d2 f7d0              brcc    DUMP2
01f8d3 911f              pop     t1
01f8d4 910f              pop     t0
                 
01f8d5 de23              rcall   DOLIT
01f8d6 0010              .dw     16
01f8d7 d930              rcall   MINUS
01f8d8 de20              rcall   DOLIT
01f8d9 000f              .dw     15
01f8da d8f8              rcall   TOR
                 DUMP4:  
01f8db dbc5              rcall   CFETCHPP
01f8dc df87              rcall   TO_PRINTABLE
01f8dd de68              rcall   EMIT_A
01f8de d0d7              rcall   XNEXT
01f8df f7d8              brcc    DUMP4
01f8e0 911f              pop     t1
01f8e1 910f              pop     t0
                 DUMP7:
01f8e2 d0d3              rcall   XNEXT
01f8e3 f6f0              brcc    DUMP1
01f8e4 911f              pop     t1
01f8e5 910f              pop     t0
01f8e6 940d f1b2         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
01f8e8 2081              .db     NFA|1," "
                 IALLOT:
01f8e9 deaf              rcall   IDP
01f8ea 940d f28d         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
01f8ec f174              fdw     DUMP_L
                 X_TO_R_L:
01f8ed 7883
01f8ee 723e              .db     NFA|3,"x>r"
                 X_TO_R:
01f8ef 01fc              movw    zl, tosl
01f8f0 9189
01f8f1 9199              poptos
01f8f2 d00a              rcall   TO_XA
01f8f3 9631              adiw    zl, 1
01f8f4 9382              st      -z, tosl
01f8f5 9392              st      -z, tosh
                 .ifdef EIND
01f8f6 9262              st      -z, r_one
                 .endif
01f8f7 9252              st      -z, r_zero
01f8f8 01cf              movw    tosl, zl
01f8f9 9508              ret
                 ;***************************************************************
01f8fa f1da              fdw     X_TO_R_L
                 TO_XA_L:
01f8fb 3e83
01f8fc 6178              .db NFA|3,">xa"
                 TO_XA:
                          sub_pflash_tos
01f8fd 9408               rampv_to_c
01f8fe 9597               ror tosh
01f8ff 9587               ror tosl
01f900 9508               ret
                 
01f901 f1f6               fdw     TO_XA_L
                 XA_FROM_L:
01f902 7883
01f903 3e61              .db NFA|3,"xa>"
                 XA_FROM:
01f904 0f88               lsl     tosl
01f905 1f99               rol     tosh
                          add_pflash_tos
01f906 9508               ret
                 ;***************************************************************
01f907 f204               fdw    XA_FROM_L
                 PFL_L:
01f908 7083
01f909 6c66              .db     NFA|3,"pfl"
                 PFL:
01f90a 940f eff2          call   DOCREATE
01f90c 3200              .dw     OFLASH
                 ;***************************************************************
01f90d f210              fdw    PFL_L
                 ZFL_L:
01f90e 7a83
01f90f 6c66              .db     NFA|3, "zfl"
                 ZFL:
01f910 940f eff2          call   DOCREATE
01f912 0003              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
01f913 2c84
01f914 303f
01f915 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
01f916 fd65              sbrc    FLAGS1, idup
01f917 c003              rjmp    COMMAZEROSENSE1
01f918 dde0              rcall   DOLIT
01f919 e632              fdw     ZEROSENSE
01f91a c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
01f91b d004              rcall   IDPMINUS
01f91c dddc              rcall   DOLIT
01f91d e63e              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
01f91e 7d6f              cbr     FLAGS1, (1<<idup)
01f91f c06d              rjmp    INLINE0
                 
                 IDPMINUS:
01f920 ddd8              rcall   DOLIT
01f921 fffc              .dw     -4
01f922 cfc6              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
01f923 d963              rcall   TWOSLASH
01f924 709f              andi    tosh, 0x0f
01f925 6c90              ori     tosh, 0xc0
01f926 ced4              rjmp    ICOMMA__
                 
                 
                 BRCCC:
01f927 ddd1              rcall   DOLIT
01f928 f008              .dw     0xf008      ; brcc pc+2
01f929 ced1              rjmp    ICOMMA__
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
01f92a ddce              rcall   DOLIT
01f92b f409              .dw     0xf409      ; brne pc+2
01f92c fd64              sbrc    FLAGS1, izeroeq
01f92d 7f9b              andi    tosh, ~4
01f92e cecc              rjmp    ICOMMA__
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
01f92f f21c              fdw     ZFL_L
                 IF_L:
01f930 69d2
01f931 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
01f932 fd64              sbrc    FLAGS1, izeroeq
01f933 dfec              rcall   IDPMINUS
01f934 dfe1              rcall   COMMAZEROSENSE
01f935 dff4              rcall   BRNEC
01f936 7e6f              cbr     FLAGS1, (1<<izeroeq)
01f937 ddf8              rcall   IHERE
01f938 dd62              rcall   FALSE_
01f939 940d f923         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
01f93b f260              fdw     IF_L
                 ELSE_L:
01f93c 65d4
01f93d 736c
01f93e 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
01f93f ddf0              rcall   IHERE
01f940 dd5a              rcall   FALSE_
01f941 dfe1              rcall   RJMPC
01f942 dc51              rcall   SWOP_A      ; else-addr  if-addr 
01f943 940d f949         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
01f945 f278              fdw     ELSE_L
                 THEN_L:
01f946 74d4
01f947 6568
01f948 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
01f949 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f94a dde5              rcall   IHERE
01f94b d877              rcall   OVER
01f94c d8bb              rcall   MINUS
01f94d debf              rcall   TWOMINUS
01f94e d938              rcall   TWOSLASH
01f94f dda9              rcall   DOLIT
01f950 c000              .dw     0xc000      ;  back-addr mask 
01f951 d8f9              rcall   OR_
01f952 dc41              rcall   SWOP_A
01f953 940d fe9c         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
01f955 f28c              fdw     THEN_L
                 BEGIN_L:
01f956 62d5
01f957 6765
01f958 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
01f959 940d f730         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
01f95b f2ac              fdw     BEGIN_L
                 UNTIL_L:
01f95c 75d5
01f95d 746e
01f95e 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
01f95f 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f960 fd64              sbrc    FLAGS1, izeroeq
01f961 dfbe              rcall   IDPMINUS
01f962 dfb3              rcall   COMMAZEROSENSE
01f963 dfc6              rcall   BRNEC
01f964 7e6f              cbr     FLAGS1, (1<<izeroeq)
01f965 940d f96b         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
01f967 f2b8              fdw     UNTIL_L
                 AGAIN_L:
01f968 61d5
01f969 6167
01f96a 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
01f96b 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
01f96c ddc3              rcall   IHERE
01f96d d89a              rcall   MINUS
01f96e de9e              rcall   TWOMINUS
01f96f 940d f923         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
01f971 f2d0              fdw     AGAIN_L
                 WHILE_L:
01f972 77d5
01f973 6968
01f974 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
01f975 dfbc              rcall   IF_
01f976 940d f1b9         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
01f978 f2e4              fdw     WHILE_L
                 REPEAT_L:
01f979 72d6
01f97a 7065
01f97b 6165
01f97c 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
01f97d dfed              rcall   AGAIN_
01f97e 940d f949         jmp     THEN_
                 
01f980 f2f2              fdw     REPEAT_L
                 INLINE_L:
01f981 69d6
01f982 6c6e
01f983 6e69
01f984 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
01f985 7e6f              cbr      FLAGS1, (1<<izeroeq)
01f986 7d6f              cbr      FLAGS1, (1<<idup)
01f987 dd8e              rcall    TICK
01f988 940d f98d         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
01f98a f302              fdw      INLINE_L
                 INLINEC_L:
01f98b 6983
01f98c 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
01f98d db1b              rcall   FETCHPP
01f98e dd74              rcall   DUP
01f98f dd69              rcall   DOLIT
01f990 9508              .dw     0x9508
01f991 d911              rcall   NOTEQUAL
01f992 d986              rcall   ZEROSENSE
01f993 f011              breq    INLINE1
01f994 d5fc              rcall   ICOMMA
01f995 cff7              rjmp    INLINE0
                 INLINE1:
01f996 940d f0e6         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
01f998 f316              fdw     INLINEC_L
                 FOR_L:
01f999 66d3
01f99a 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
01f99b 940f f00e         call    DOCOMMAXT
01f99d e3a6              fdw     TOR
01f99e dd91              rcall   IHERE
01f99f dcfb              rcall   FALSE_
01f9a0 df82              rcall   RJMPC
01f9a1 dd8e              rcall   IHERE
01f9a2 940d f1b9         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
01f9a4 f332              fdw     FOR_L
                 NEXT_L:
01f9a5 6ed4
01f9a6 7865
01f9a7 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
01f9a8 dfa0              rcall   THEN_
01f9a9 940f f00e         call    DOCOMMAXT
01f9ab f36c              fdw     XNEXT
01f9ac df7a              rcall   BRCCC
                 
01f9ad dfbd              rcall   AGAIN_
                 
01f9ae dd4a              rcall   DOLIT
01f9af f380              fdw     XNEXT1
01f9b0 940d f98d         jmp     INLINE0
                 ; (next) decrement top of return stack
01f9b2 2887
01f9b3 656e
01f9b4 7478
01f9b5 2029              .db     NFA|7,"(next) "
                 XNEXT:  
01f9b6 91ff              m_pop_zh
01f9b7 91ff              pop     zh
01f9b8 91ef              pop     zl
01f9b9 91bf              pop     xh
01f9ba 91af              pop     xl
01f9bb 9711              sbiw    xl, 1
01f9bc 93af              push    xl
01f9bd 93bf              push    xh
01f9be 9419              mijmp
01f9bf 9508              ret
                 XNEXT1:
01f9c0 911f              pop     t1
01f9c1 910f              pop     t0
01f9c2 9508              ret
                 
                 ; leave clear top of return stack
01f9c3 f34a              fdw     NEXT_L
                 LEAVE_L:
01f9c4 6595
01f9c5 646e
01f9c6 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
01f9c7 91ff              m_pop_zh
01f9c8 91ff              pop     zh
01f9c9 91ef              pop     zl
01f9ca 911f              pop     t1
01f9cb 910f              pop     t0
01f9cc 925f              push    r_zero
01f9cd 925f              push    r_zero
01f9ce 9419              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
01f9cf f388              fdw      LEAVE_L
                 RDROP_L:
01f9d0 72f5
01f9d1 7264
01f9d2 706f              .db      NFA|IMMED|COMPILE|INLINE|5,"rdrop"
                 RDROP:
01f9d3 910f              pop     t0
01f9d4 910f              pop     t0
01f9d5 9508              ret
                 ;***************************************************
01f9d6 f3a0              fdw     RDROP_L
                 STOD_L:
01f9d7 7383
01f9d8 643e              .db     NFA|3,"s>d"
                 STOD:
01f9d9 ff97              sbrs    tosh, 7
01f9da ccc0              rjmp    FALSE_
01f9db ccc8              rjmp    TRUE_
                 ;***************************************************
01f9dc f3ae              fdw     STOD_L
                 DNEGATE_L:
01f9dd 6487
01f9de 656e
01f9df 6167
01f9e0 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
01f9e1 d049              rcall   DINVERT
01f9e2 940f f120         call    ONE
01f9e4 940d f203         jmp     MPLUS
                 ;***************************************************
01f9e6 f3ba              fdw     DNEGATE_L
                 QDNEGATE_L:
01f9e7 3f88
01f9e8 6e64
01f9e9 6765
01f9ea 7461
01f9eb 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
01f9ec dd23              rcall   ZEROLESS
01f9ed d92b              rcall   ZEROSENSE
01f9ee f009              breq    QDNEGATE1
01f9ef dff1              rcall   DNEGATE
                 QDNEGATE1:
01f9f0 9508              ret
                 
                 ;***************************************************
01f9f1 f3ce              fdw     QDNEGATE_L
                 DABS_L:
01f9f2 6484
01f9f3 6261
01f9f4 0073              .db     NFA|4,"dabs",0
                 DABS:
01f9f5 dd0d              rcall   DUP
01f9f6 940d f9ec         jmp     QDNEGATE
                 ;***************************************************
01f9f8 f3e4              fdw     DABS_L
                 DPLUS_L:
01f9f9 6482
01f9fa 002b              .db     NFA|2,"d+",0
                 DPLUS:
01f9fb 91a9              ld      xl, Y+
01f9fc 91b9              ld      xh, Y+
01f9fd 91e9              ld      t6, Y+
01f9fe 91f9              ld      t7, Y+
01f9ff 9109              ld      t0, Y+
01fa00 9119              ld      t1, Y+
01fa01 0fa0              add     xl, t0
01fa02 1fb1              adc     xh, t1
01fa03 1f8e              adc     tosl, t6
01fa04 1f9f              adc     tosh, t7
01fa05 93ba              st      -Y, xh
01fa06 93aa              st      -Y, xl
01fa07 9508              ret
                 
                 ;***************************************************
01fa08 f3f2              fdw     DPLUS_L
                 DMINUS_L:
01fa09 6482
01fa0a 002d              .db     NFA|2,"d-",0
                 DMINUS:
01fa0b dfd5              rcall   DNEGATE
01fa0c 940d f9fb         jmp     DPLUS
                 ;***************************************************
01fa0e f412              fdw     DMINUS_L
                 DTWOSLASH_L:
01fa0f 6483
01fa10 2f32              .db     NFA|3,"d2/"
01fa11 9109              ld      t0, y+
01fa12 9119              ld      t1, y+
01fa13 9595              asr     tosh
01fa14 9587              ror     tosl
01fa15 9517              ror     t1
01fa16 9507              ror     t0
01fa17 931a              st      -y, t1
01fa18 930a              st      -y, t0
01fa19 9508              ret
                 ;***************************************************
01fa1a f41e              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
01fa1b 6483
01fa1c 2a32              .db     NFA|3,"d2*"
01fa1d 9109              ld      t0, y+
01fa1e 9119              ld      t1, y+
01fa1f 0f00              lsl     t0
01fa20 1f11              rol     t1
01fa21 1f88              rol     tosl
01fa22 1f99              rol     tosh
01fa23 931a              st      -y, t1
01fa24 930a              st      -y, t0
01fa25 9508              ret
                 ;***************************************************
01fa26 f436              fdw     DTWOSTAR_L
                 DINVERT_L:
01fa27 6487
01fa28 6e69
01fa29 6576
01fa2a 7472              .db     NFA|7,"dinvert"
                 DINVERT:
01fa2b 9109              ld      t0, y+
01fa2c 9119              ld      t1, y+
01fa2d 9500              com     t0
01fa2e 9510              com     t1
01fa2f 9580              com     tosl
01fa30 9590              com     tosh
01fa31 931a              st      -y, t1
01fa32 930a              st      -y, t0
01fa33 9508              ret
                 ;***************************************************
01fa34 f44e              fdw     DINVERT_L
                 DZEROEQUAL_L:
01fa35 6483
01fa36 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
01fa37 91a9              ld      xl, y+
01fa38 91b9              ld      xh, y+
01fa39 2b89              or      tosl, tosh
01fa3a 2b8a              or      tosl, xl
01fa3b 2b8b              or      tosl, xh
01fa3c f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
01fa3d ef8f              ser     tosl
01fa3e ef9f              ser     tosh
01fa3f 9508              ret
                 
                 ;***************************************************
01fa40 f46a              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
01fa41 6483
01fa42 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
01fa43 91a9              ld      xl, y+
01fa44 91b9              ld      xh, y+
01fa45 3090              cpi     tosh, 0
01fa46 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
01fa47 2788              clr     tosl
01fa48 2799              clr     tosh
01fa49 9508              ret
                 ;***************************************************
01fa4a f482              fdw     DZEROLESS_L
                 DEQUAL_L:
01fa4b 6482
01fa4c 003d              .db     NFA|2,"d=",0
01fa4d dfbd              rcall   DMINUS
01fa4e 940d fa37         jmp     DZEROEQUAL
                 ;***************************************************
01fa50 f496              fdw     DEQUAL_L
                 DLESS_L:
01fa51 6482
01fa52 003c              .db     NFA|2,"d<",0
                 DLESS:
01fa53 dfb7              rcall   DMINUS
01fa54 940d fa43         jmp     DZEROLESS
                 ;***************************************************
01fa56 f4a2              fdw     DLESS_L
                 DGREATER_L:
01fa57 6482
01fa58 003e              .db     NFA|2,"d>",0
                 DGREATER:
01fa59 940f f0f4         call    TWOSWAP
01fa5b 940d fa53         jmp     DLESS
                 ;***************************************************
01fa5d f4ae              fdw     DGREATER_L
                 UDDOT_L:
01fa5e 7583
01fa5f 2e64              .db     NFA|3,"ud."
01fa60 d934              rcall   LESSNUM
01fa61 d94c              rcall   NUMS
01fa62 d954              rcall   NUMGREATER
01fa63 940f f169         call    TYPE
01fa65 940d f0fd         jmp     SPACE_
                 ;***************************************************
01fa67 f4bc              fdw     UDDOT_L
                 DDOT_L:
01fa68 6482
01fa69 002e              .db     NFA|2,"d.",0
01fa6a d92a              rcall   LESSNUM
01fa6b 938f              push    tosl     ; dup >r
01fa6c 939f              push    tosh
01fa6d df87              rcall   DABS
01fa6e d93f              rcall   NUMS
01fa6f 940f f1de         call    RFROM
01fa71 d950              rcall   SIGN
01fa72 d944              rcall   NUMGREATER
01fa73 940f f169         call    TYPE
01fa75 940d f0fd         jmp     SPACE_
                 ;****************************************************
01fa77 f4d0              fdw      DDOT_L
                 MEMHI_L:
01fa78 6882
01fa79 0069              .db     NFA|2,"hi",0
                 MEMHI:
01fa7a dc7e              rcall   DOLIT
01fa7b f504              fdw     FLASHHI
01fa7c 940f f060         call    CSE_
01fa7e 940f f1fb         call    PLUS
01fa80 940d fed9         jmp     FETCH
                 FLASHHI:
01fa82 dcff              .dw      FLASH_HI
01fa83 31ff              .dw      EEPROM_HI
01fa84 21ff              .dw      RAM_HI
                 
                 .if FLASHEND > 0x3fff
                 ;;; x@ ( addrl addru -- x )
01fa85 fda0              fdw     A_FROM_L
                 XFETCH_L:
01fa86 7882
01fa87 0040              .db     NFA|2, "x@",0
                 .ifdef RAMPZ
01fa88 bf8b      	out_    RAMPZ, tosl
                 .endif
01fa89 9189
01fa8a 9199      	poptos
01fa8b 01fc              movw    z, tosl
01fa8c 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01fa8d 9197              lpm_    tosh, z+
                 .ifdef RAMPZ
01fa8e e003              ldi     t0, RAMPZV
01fa8f bf0b              out_    RAMPZ, t0
                 .endif
01fa90 9508      	ret
                 	
                 ;;; x! ( x addrl addru -- )
01fa91 f50c              fdw     XFETCH_L
                 XSTORE_L:
01fa92 7882
01fa93 0021              .db     NFA|2, "x!",0
01fa94 2f08          	mov     t0, tosl
01fa95 940f f1b2         call    DROP
01fa97 d277              rcall   XUPDATEBUF
01fa98 c3ee              rjmp    ISTORE1
                 .endif
                 
                 ;***************************************************
                 
01fa99 f4f0              fdw      MEMHI_L
                 L_FETCH_P:
01fa9a 40a2
01fa9b 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
01fa9c 939a
01fa9d 938a              pushtos
01fa9e 01ca              movw    tosl, pl
01fa9f 9508              ret
                 ;***************************************************
01faa0 f534              fdw     L_FETCH_P
                 L_PCFETCH:
01faa1 7083
01faa2 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
01faa3 939a
01faa4 938a              pushtos
01faa5 01ca              movw    tosl, pl
01faa6 940d fef4         jmp     CFETCH
                 ;***************************************************
01faa8 f542              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
01faa9 70a3
01faaa 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
01faab 0d47              add     pl, r_two
01faac 1d55              adc     ph, r_zero
01faad 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
01faae 0000              .dw     0
                 L_MARKER:
                 lastword:
01faaf 6d86
01fab0 7261
01fab1 656b
01fab2 0072              .db     NFA|6,"marker",0
                 MARKER:
01fab3 940f f045         call    ROM_
01fab5 dc97              rcall   CREATE
01fab6 dc42              rcall   DOLIT
01fab7 2200              .dw     dp_start
01fab8 940f f06a         call    HERE
01faba dbb8              rcall   TEN
01fabb d9ca              rcall   CMOVE
01fabc dbb6              rcall   TEN
01fabd 940f f1ab         call    ALLOT
01fabf 940f f053         call    FRAM
01fac1 dcdd              rcall   XDOES
01fac2 940f effc         call    DODOES
01fac4 dd6f              rcall   INI
01fac5 dbad              rcall   TEN
01fac6 940d f486         jmp     CMOVE
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD_LED == 1
                 ;;; Enable load led
01fac8 ddbe              fdw     BUSY_L
                 LOADON_L:
01fac9 6c85
01faca 616f
01facb 2b64              .db     NFA|5,"load+"
01facc 6170              sbr     FLAGS2, (1<<fLOADled)
01facd 9508              ret
                 
                 ;;; Disable load led
01face f592              fdw     LOADON_L
                 LOADOFF_L:
01facf 6c85
01fad0 616f
01fad1 2d64              .db     NFA|5,"load-"
01fad2 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
                 .if CPU_LOAD_LED_POLARITY == 1
01fad3 982f              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
01fad4 9508              ret
                 .endif
                 ;;; 
                 .if CPU_LOAD == 1
                 .if CPU_LOAD_LED == 1
                 .else
                 .endif
                 .endif
                 .endif
                 
                 .ifdef UCSR1A
                 ;***************************************************
                 ; TX1   c --    output character to UART 1
01fad5 f9f6              fdw     RX0Q_L
                 TX1_L:
01fad6 7483
01fad7 3178              .db     NFA|3,"tx1"
                 TX1_:
01fad8 3181              cpi     tosl, XON
01fad9 f061              breq    XXON_TX1_TOS
01fada 3183              cpi     tosl, XOFF
01fadb f091              breq    XXOFF_TX1_TOS
                 TX1_LOOP:
01fadc d493              rcall   PAUSE
01fadd 9100 00c8         in_     t0, UCSR1A
01fadf ff05              sbrs    t0, UDRE1
01fae0 cffb              rjmp    TX1_LOOP
01fae1 9380 00ce         out_    UDR1, tosl
01fae3 9189
01fae4 9199              poptos
01fae5 9508              ret
                 
                 XXON_TX1_TOS:
01fae6 9189
01fae7 9199              poptos
01fae8 c002              rjmp    XXON_TX1_1
                 XXON_TX1:
01fae9 ff71              sbrs    FLAGS2, ixoff_tx1
01faea 9508              ret
                 XXON_TX1_1:
01faeb 7f7d              cbr     FLAGS2, (1<<ixoff_tx1)
01faec e1f1              ldi     zh, XON
01faed c007              rjmp    TX1_SEND
                 
                 XXOFF_TX1_TOS:
01faee 9189
01faef 9199              poptos
01faf0 c002              rjmp    XXOFF_TX1_1
                 XXOFF_TX1:
01faf1 fd71              sbrc    FLAGS2, ixoff_tx1
01faf2 9508              ret     
                 XXOFF_TX1_1:
01faf3 6072              sbr     FLAGS2, (1<<ixoff_tx1)
01faf4 e1f3              ldi     zh, XOFF
                 TX1_SEND:
01faf5 91e0 00c8         in_     zl, UCSR1A
01faf7 ffe5              sbrs    zl, UDRE1
01faf8 cffc              rjmp    TX1_SEND
01faf9 93f0 00ce         out_    UDR1, zh
01fafb 9508              ret
                 ;***************************************************
                 ; RX1    -- c    get character from the serial line
01fafc f5ac              fdw     TX1_L
                 RX1_L:
01fafd 7283
01fafe 3178              .db     NFA|3,"rx1"
                 RX1_:
01faff d470              rcall   PAUSE
01fb00 d01e              rcall   RX1Q
01fb01 940f f319         call    ZEROSENSE
01fb03 f3d9              breq    RX1_
01fb04 939a
01fb05 938a              pushtos
01fb06 e9e8              ldi     zl, low(rbuf1)
01fb07 e0f3              ldi     zh, high(rbuf1)
01fb08 91a0 0396         lds     xl, rbuf1_rd
01fb0a 0fea              add     zl, xl
01fb0b 1df5              adc     zh, r_zero
01fb0c 8180              ld      tosl, z
01fb0d 2799              clr     tosh
01fb0e b70f              in_     t0, SREG
01fb0f 94f8              cli
01fb10 95a3              inc     xl
01fb11 71af              andi    xl, (RX1_BUF_SIZE-1)
01fb12 93a0 0396         sts     rbuf1_rd, xl
01fb14 91a0 0397         lds     xl, rbuf1_lv
01fb16 95aa              dec     xl
01fb17 93a0 0397         sts     rbuf1_lv, xl
01fb19 bf0f              out_    SREG, t0
01fb1a 9508              ret
                 ;***************************************************
                 ; RX1?  -- n    return the number of characters in queue
01fb1b f5fa              fdw     RX1_L
                 RX1Q_L:
01fb1c 7284
01fb1d 3178
01fb1e 003f              .db     NFA|4,"rx1?",0
                 RX1Q:
01fb1f 91a0 0397         lds     xl, rbuf1_lv
01fb21 11a5              cpse    xl, r_zero
01fb22 940d f6a4         jmp     TRUE_
                 .if U1FC_TYPE == 1
01fb24 dfc4              rcall   XXON_TX1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
01fb25 940d f69b         jmp     FALSE_
                 
                 ;****************************************************
                 RX1_ISRR:
01fb27 91b0 00ce         in_     xh, UDR1
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
01fb29 91a0 0397         lds     xl, rbuf1_lv
01fb2b 31ae              cpi     xl, RX1_BUF_SIZE-2
01fb2c f091              breq    RX1_OVF
01fb2d 95a3              inc     xl
01fb2e 93a0 0397         sts     rbuf1_lv, xl
01fb30 30a4              cpi     xl, RX0_OFF_FILL
01fb31 f00a              brmi    RX1_ISR_SKIP_XOFF
                 .if U1FC_TYPE == 1
01fb32 dfc0              rcall   XXOFF_TX1_1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 RX1_ISR_SKIP_XOFF:
01fb33 e9e8              ldi     zl, low(rbuf1)
01fb34 e0f3              ldi     zh, high(rbuf1)
01fb35 91a0 0395         lds     xl, rbuf1_wr
01fb37 0fea              add     zl, xl
01fb38 1df5              adc     zh, r_zero
01fb39 83b0              st      z, xh
01fb3a 95a3              inc     xl
01fb3b 71af              andi    xl, (RX1_BUF_SIZE-1)
01fb3c 93a0 0395         sts     rbuf1_wr, xl
01fb3e c132              rjmp    FF_ISR_EXIT
                 RX1_OVF:
01fb3f e7fc              ldi     zh, '|'
01fb40 dfb4              rcall   TX1_SEND
01fb41 c12f              rjmp    FF_ISR_EXIT
                 TX1_ISR:
                 .endif
                 ;***************************************************
                 RQ_EMIT:
01fb42 fe00              sbrs    t2, PORF
01fb43 c003              rjmp    RQ_EXTR
01fb44 dbb4              rcall   DOLIT
01fb45 0050              .dw     'P'
01fb46 dbff              rcall   EMIT_A
                 RQ_EXTR:
01fb47 fe01              sbrs    t2, EXTRF
01fb48 c003              rjmp    RQ_BORF
01fb49 dbaf              rcall   DOLIT
01fb4a 0045              .dw     'E'
01fb4b dbfa              rcall   EMIT_A
                 RQ_BORF:
01fb4c fe02              sbrs    t2, BORF
01fb4d c003              rjmp    RQ_WDRF
01fb4e dbaa              rcall   DOLIT
01fb4f 0042              .dw     'B'
01fb50 dbf5              rcall   EMIT_A
                 RQ_WDRF:
01fb51 fe03              sbrs    t2, WDRF
01fb52 c003              rjmp    RQ_DIVZERO
01fb53 dba5              rcall   DOLIT
01fb54 0057              .dw     'W'
01fb55 dbf0              rcall   EMIT_A
                 RQ_DIVZERO:
01fb56 fe16              sbrs    t3, 6 ; T bit MATH error
01fb57 c003              rjmp    RQ_END
01fb58 dba0              rcall   DOLIT
01fb59 004d              .dw     'M'
01fb5a dbeb              rcall   EMIT_A
                 RQ_END: 
01fb5b 940d f0fd         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
                 .endif
                 .if CPU_LOAD_LED == 1
01fb5d ff74              sbrs    FLAGS2, fLOADled
01fb5e c001              rjmp    LOAD_LED_END
                 .if CPU_LOAD_LED_POLARITY == 1
01fb5f 982f              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
01fb60 ff76              sbrs    FLAGS2, fIDLE
01fb61 c00c              rjmp    IDLE_LOAD1
01fb62 ee06              ldi     t0, low(up0)
01fb63 1620              cp      upl, t0
01fb64 f449              brne    IDLE_LOAD1
                 .ifdef SMCR
01fb65 91e0 0374         lds     zl, rbuf0_lv
                 .ifdef rbuf1_lv
01fb67 91f0 0397         lds     zh, rbuf1_lv
01fb69 2bef              or      zl, zh
                 .else
                 .endif
01fb6a f419              brne    IDLE_LOAD1
01fb6b be63              out_    SMCR, r_one
                 .else
                 .endif
                 .if CPU_LOAD == 1
                 .endif
01fb6c 9588              sleep               ; IDLE mode
                 .ifdef SMCR
01fb6d be53              out_    SMCR, r_zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
01fb6e fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
01fb6f 9a2f              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
01fb70 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
01fc00 940d fda4 RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
01fc02 d079                  rcall FF_ISR
                 .org BOOT_START + 0x04
01fc04 d077                  rcall FF_ISR
                 .org BOOT_START + 0x06
01fc06 d075                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
01fc08 d073                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
01fc0a d071                  rcall FF_ISR
                 .org BOOT_START + 0x0c
01fc0c d06f                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
01fc0e d06d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
01fc10 d06b                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
01fc12 d069                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
01fc14 d067                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
01fc16 d065                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
01fc18 d063                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
01fc1a d061                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
                 .else
01fc1c d05f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
01fc1e d05d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
01fc20 d05b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
01fc22 d059                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
01fc24 d057                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
01fc26 d055                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
01fc28 d053                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
01fc2a c063                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
01fc2c d04f                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
01fc2e d04d                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
01fc30 d04b                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
01fc32 d049                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x34
01fc34 d047                  rcall FF_ISR
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x36
01fc36 d045                  rcall FF_ISR
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x38
01fc38 d043                  rcall FF_ISR
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3a
01fc3a d041                  rcall FF_ISR
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3c
01fc3c d03f                  rcall FF_ISR
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x3e
01fc3e d03d                  rcall FF_ISR
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x40
01fc40 d03b                  rcall FF_ISR
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x42
01fc42 d039                  rcall FF_ISR
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x44
01fc44 d037                  rcall FF_ISR
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x46
01fc46 d035                  rcall FF_ISR
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x48
01fc48 d033                  rcall FF_ISR
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4a
01fc4a d031                  rcall FF_ISR
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4c
01fc4c d02f                  rcall FF_ISR
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x4e
01fc4e d02d                  rcall FF_ISR
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x50
01fc50 d02b                  rcall FF_ISR
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x52
01fc52 d029                  rcall FF_ISR
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x54
01fc54 d027                  rcall FF_ISR
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x56
01fc56 d025                  rcall FF_ISR
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x58
01fc58 d023                  rcall FF_ISR
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5a
01fc5a d021                  rcall FF_ISR
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5c
01fc5c d01f                  rcall FF_ISR
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x5e
01fc5e d01d                  rcall FF_ISR
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x60
01fc60 d01b                  rcall FF_ISR
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x62
01fc62 d019                  rcall FF_ISR
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x64
01fc64 d017                  rcall FF_ISR
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x66
01fc66 d015                  rcall FF_ISR
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x68
01fc68 d013                  rcall FF_ISR
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6a
01fc6a d011                  rcall FF_ISR
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6c
01fc6c d00f                  rcall FF_ISR
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x6e
01fc6e d00d                  rcall FF_ISR
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x70
01fc70 d00b                  rcall FF_ISR
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
01fc71 919f              pop     tosh
01fc72 918f              pop     tosl
01fc73 911f              pop     t1
01fc74 910f              pop     t0
01fc75 91ff              pop     zh
01fc76 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
01fc77 91a9              ld      xl, y+
01fc78 91b9              ld      xh, y+
01fc79 bfbf              out_    SREG, xh
01fc7a 91b9              ld      xh, y+
01fc7b 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
01fc7c 93ba              st      -y, xh
01fc7d b7bf              in_     xh, SREG
01fc7e 93ba              st      -y, xh
01fc7f 93aa              st      -y, xl
01fc80 91bf              m_pop_xh
01fc81 91bf              pop     xh
01fc82 91af              pop     xl
01fc83 93ef              push    zl
01fc84 93ff              push    zh
01fc85 930f              push    t0
01fc86 931f              push    t1
01fc87 938f              push    tosl
01fc88 939f              push    tosh
                 .if low(ivec) == 0x80
                 .else
01fc89 50a1              subi    xl, 1
                 .endif
01fc8a e0b3              ldi     xh, high(ivec)
01fc8b 91ed              ld      zl, x+
01fc8c 91fd              ld      zh, x+
01fc8d 9419              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
01fc8e 93ba              st      -y, xh
01fc8f b7bf              in_     xh, SREG
01fc90 93ba              st      -y, xh
01fc91 93aa              st      -y, xl
01fc92 0ce6              add     ms_count,  r_one
01fc93 1cf5              adc     ms_count1, r_zero
                 .if CPU_LOAD == 1
                 .endif
01fc94 cfe2              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
01fc95 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
01fc97 30bf              cpi     xh, 0xf
01fc98 f409              brne    pc+2
01fc99 cf66              rjmp    RESET_
                 .endif
                 .endif
01fc9a 91a0 0374         lds     xl, rbuf0_lv
01fc9c 31ae              cpi     xl, RX0_BUF_SIZE-2
01fc9d f091              breq    RX0_OVF
01fc9e 95a3              inc     xl
01fc9f 93a0 0374         sts     rbuf0_lv, xl
                 
01fca1 30a4              cpi     xl, RX0_OFF_FILL
01fca2 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
01fca3 d02e              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
                 
01fca4 e7e5              ldi     zl, low(rbuf0)
01fca5 e0f3              ldi     zh, high(rbuf0)
                 
01fca6 91a0 0372         lds     xl, rbuf0_wr
01fca8 0fea              add     zl, xl
01fca9 1df5              adc     zh, r_zero
01fcaa 83b0              st      z, xh
01fcab 95a3              inc     xl
01fcac 71af              andi    xl, (RX0_BUF_SIZE-1)
01fcad 93a0 0372         sts     rbuf0_wr, xl
01fcaf cfc1              rjmp    FF_ISR_EXIT
                 RX0_OVF:
01fcb0 e7fc              ldi     zh, '|'
01fcb1 d022              rcall   TX0_SEND
01fcb2 cfbe              rjmp    FF_ISR_EXIT
                 TX0_ISR:
                 
                 .ifdef UCSR1A
01fcb3 ce73      RX1_ISR: rjmp   RX1_ISRR
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .else
                 .if CPU_LOAD_LED == 1
01fcb4 f59e              fdw(LOADOFF_L)
                 .else
                 .endif
                 .endif
                 .else
                 .endif
                 TX0_L:
01fcb5 7483
01fcb6 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
01fcb7 3181              cpi     tosl, XON
01fcb8 f061              breq    XXON_TX0_TOS
01fcb9 3183              cpi     tosl, XOFF
01fcba f091              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
01fcbb d2b4              rcall   PAUSE
01fcbc 9100 00c0         in_     t0, UCSR0A
01fcbe ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
01fcbf cffb              rjmp    TX0_LOOP
01fcc0 9380 00c6         out_    UDR0_, tosl
01fcc2 9189
01fcc3 9199              poptos
01fcc4 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
01fcc5 9189
01fcc6 9199              poptos
01fcc7 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
01fcc8 ff70              sbrs    FLAGS2, ixoff_tx0
01fcc9 9508              ret
                 XXON_TX0_1:
01fcca 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
01fccb e1f1              ldi     zh, XON
01fccc c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
01fccd 9189
01fcce 9199              poptos
01fccf c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
01fcd0 fd70              sbrc    FLAGS2, ixoff_tx0
01fcd1 9508              ret     
                 XXOFF_TX0_1:
01fcd2 6071              sbr     FLAGS2, (1<<ixoff_tx0)
01fcd3 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
01fcd4 91e0 00c0         in_     zl, UCSR0A
01fcd6 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
01fcd7 cffc              rjmp    TX0_SEND
01fcd8 93f0 00c6         out_    UDR0_, zh
01fcda 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
01fcdb f96a              fdw(TX0_L)
                 RX0_L:
01fcdc 7283
01fcdd 3078              .db     NFA|3,"rx0"
                 RX0_:
01fcde d291              rcall   PAUSE
01fcdf d01e              rcall   RX0Q
01fce0 940f f319         call    ZEROSENSE
01fce2 f3d9              breq    RX0_
01fce3 939a
01fce4 938a              pushtos
01fce5 e7e5              ldi     zl, low(rbuf0)
01fce6 e0f3              ldi     zh, high(rbuf0)
01fce7 91a0 0373         lds     xl, rbuf0_rd
01fce9 0fea              add     zl, xl
01fcea 1df5              adc     zh, r_zero
01fceb 8180              ld      tosl, z
01fcec 2799              clr     tosh
01fced b70f              in_     t0, SREG
01fcee 94f8              cli
01fcef 95a3              inc     xl
01fcf0 71af              andi    xl, (RX0_BUF_SIZE-1)
01fcf1 93a0 0373         sts     rbuf0_rd, xl
01fcf3 91a0 0374         lds     xl, rbuf0_lv
01fcf5 95aa              dec     xl
01fcf6 93a0 0374         sts     rbuf0_lv, xl
01fcf8 bf0f              out_    SREG, t0
01fcf9 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
01fcfa f9b8              fdw     RX0_L
                 RX0Q_L:
01fcfb 7284
01fcfc 3078
01fcfd 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
01fcfe 91a0 0374         lds     xl, rbuf0_lv
01fd00 11a5              cpse    xl, r_zero
01fd01 940d f6a4         jmp     TRUE_
                 .if U0FC_TYPE == 1
01fd03 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
01fd04 940d f69b         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
01fd06 dba1              rcall   DOTS
01fd07 940f f176         call    XSQUOTE
01fd09 4103
01fd0a 3f44              .db     3,"AD?"
01fd0b 940f f169         call    TYPE
01fd0d c9c4              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
                 	sub_pflash_tos
                 .ifdef  RAMPZ
01fd0e e003      	ldi     t0, RAMPZV
                 .endif
                 XUPDATEBUF:
01fd0f 9380 03c4         sts     iaddrl, tosl
01fd11 9390 03c5         sts     iaddrh, tosh
                 .ifdef RAMPZ
01fd13 9300 03c6         sts     iaddru, t0
01fd15 3003      	cpi     t0, RAMPZV
01fd16 f411      	brne    XUPDATEBUF2
                 .endif
01fd17 3d9d              cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
01fd18 f768              brcc    ISTORERR
                 XUPDATEBUF2:	
01fd19 9100 03c4         lds     t0, iaddrl
01fd1b 7000              andi    t0, ~(PAGESIZEB-1)
01fd1c 110a              cpse    t0, ibasel
01fd1d c00b              rjmp    IFILL_BUFFER
01fd1e 9100 03c5         lds     t0, iaddrh
01fd20 110b              cpse    t0, ibaseh
01fd21 c007              rjmp    IFILL_BUFFER
                 .ifdef RAMPZ
01fd22 9100 03c6         lds     t0, iaddru
01fd24 9110 03c7         lds     t1, ibaseu
01fd26 1301              cpse    t0, t1
01fd27 c001              rjmp    IFILL_BUFFER
                 .endif
01fd28 9508              ret
                 
                 IFILL_BUFFER:
01fd29 d060              rcall   IFLUSH
01fd2a 9100 03c4         lds     t0, iaddrl
01fd2c 7000              andi    t0, ~(PAGESIZEB-1)
01fd2d 2ea0              mov     ibasel, t0
01fd2e 90b0 03c5         lds     ibaseh, iaddrh
                 .ifdef RAMPZ
01fd30 9100 03c6 	lds     t0, iaddru
01fd32 9300 03c7 	sts     ibaseu, t0
01fd34 bf0b      	out_    RAMPZ, t0
                 .endif
                 IFILL_BUFFER_1:
01fd35 e000              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
01fd36 01f5              movw    zl, ibasel
01fd37 e0a0              ldi     xl, low(ibuf)
01fd38 e0b2              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
01fd39 9117              lpm_    t1, z+
01fd3a 931d              st      x+, t1
01fd3b 950a              dec     t0
01fd3c f7e1              brne    IFILL_BUFFER_2
                 .ifdef RAMPZ
01fd3d e003              ldi     t0, RAMPZV
01fd3e bf0b              out_    RAMPZ, t0
                 .endif
01fd3f 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
01fd40 d9b8              rcall   DOLIT
01fd41 0013              .dw     XOFF
01fd42 940f ef9e         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fd44 d9b4              rcall   DOLIT
01fd45 000a              .dw     10
01fd46 daff              rcall   MS
                         ; Disable interrupts
01fd47 94f8              cli
01fd48 01f5              movw    zl, ibasel
                 .ifdef RAMPZ
01fd49 9100 03c7 	lds     t0, ibaseu
01fd4b bf0b      	out_    RAMPZ, t0
                 .endif
01fd4c e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
01fd4d d031              rcall   DO_SPM
01fd4e e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
01fd4f d02f              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
01fd50 e000              ldi     t0, low(PAGESIZEB);init loop variable
01fd51 e0a0              ldi     xl, low(ibuf)
01fd52 e0b2              ldi     xh, high(ibuf)
01fd53 920f              push    r0
01fd54 921f              push    r1
                 IWRITE_BUFFER1:
01fd55 900d              ld      r0, x+
01fd56 901d              ld      r1, x+
01fd57 e011              ldi     t1, (1<<SPMEN)
01fd58 d026              rcall   DO_SPM
01fd59 9632              adiw    zl, 2
01fd5a 5002              subi    t0, 2
01fd5b f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
01fd5c 50e0              subi    zl, low(PAGESIZEB) ;restore pointer
01fd5d 40f1              sbci    zh, high(PAGESIZEB)
01fd5e e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
01fd5f d01f              rcall   DO_SPM
                         ; re-enable the RWW section
01fd60 d018              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
01fd61 e000              ldi     t0, low(PAGESIZEB);init loop variable
01fd62 50a0              subi    xl, low(PAGESIZEB) ;restore pointer
01fd63 40b1              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
01fd64 9007              lpm_    r0, z+
01fd65 901d              ld      r1, x+
01fd66 1001              cpse    r0, r1
01fd67 c03c              rjmp    WARM_     ; reset
01fd68 5001              subi    t0, 1
01fd69 f7d1              brne    IWRITE_BUFFER2
01fd6a 901f              pop     r1
01fd6b 900f              pop     r0
01fd6c ef0f      	ser     t0
01fd6d 2eb0      	mov     ibaseh, t0
                 .ifdef RAMPZ
01fd6e 9300 03c7 	sts     ibaseu, t0
                 .endif
                 .ifdef RAMPZ
01fd70 e003              ldi     t0, RAMPZV
01fd71 bf0b              out_    RAMPZ, t0
                 .endif
01fd72 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
01fd73 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
01fd74 d984              rcall   DOLIT
01fd75 0011              .dw     XON
01fd76 940f ef9e         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 .if DEBUG_FLASH == 1
                 .endif
01fd78 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
01fd79 b687              in_     t8, SPMCSR
01fd7a fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
01fd7b 9508              ret
                         ; re-enable the RWW section
01fd7c e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
01fd7d d001              rcall   DO_SPM
01fd7e cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
01fd7f b687              in_     t8, SPMCSR
01fd80 fc80              sbrc    t8, SPMEN
01fd81 cffd              rjmp    DO_SPM       ; Wait for previous write to complete
01fd82 bf17              out_    SPMCSR, t1
01fd83 95e8              spm
01fd84 9508              ret
                 ; WD+ ( n -- )  n < 8 start watchdog timer
                 .if (FLASHEND < 0x1ffff)
                 .ifdef MCUSR
                 .else
                 .endif
                 .endif
01fd85 dd7c              fdw     CWD_L
                 IFLUSH_L:
01fd86 6986
01fd87 6c66
01fd88 7375
01fd89 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
01fd8a fd60              sbrc    FLAGS1, idirty
01fd8b cfb4              rjmp    IWRITE_BUFFER
01fd8c 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
01fd8d f638              fdw     RX1Q_L
                 .else
                 .endif
                 EMPTY_L:
01fd8e 6585
01fd8f 706d
01fd90 7974              .db     NFA|5,"empty"
                 EMPTY:
01fd91 d967              rcall   DOLIT
01fd92 ffe6              fdw     COLDLIT
01fd93 d965              rcall   DOLIT
01fd94 2200              .dw     dp_start
01fd95 d963              rcall   DOLIT
01fd96 000c              .dw     coldlitsize
01fd97 940f f486         call    CMOVE
01fd99 940d f677         jmp     DP_TO_RAM
                 
                 ; Init constant registers
                 INIT_012:
01fd9b 2455              clr     r_zero
01fd9c e0e1              ldi     zl, 1
01fd9d e0f2              ldi     zh, 2
01fd9e 013f              movw    r_one, zl
01fd9f 9508              ret
                 ;*******************************************************
01fda0 fb1c              fdw     EMPTY_L
                 WARM_L:
01fda1 7784
01fda2 7261
01fda3 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
01fda4 94f8              cli           ; Disable interrupts
01fda5 27aa              clr     xl
01fda6 27bb              clr     xh
01fda7 e1c9              ldi     yl, 25
01fda8 e0d0              ldi     yh, 0
                 WARM_1:
01fda9 93dd              st      x+, yh
01fdaa 50c1              subi    yl, 1
01fdab f7e9              brne    WARM_1
                 
01fdac b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
01fdad b604              in_     t2, MCUSR
01fdae 9250 0034         sts     MCUSR, r_zero
                 .endif
01fdb0 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
01fdb1 925d              st      x+, r_zero
01fdb2 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
01fdb3 f7e9              brne    WARM_2
                 
                 ; Init empty flash buffer
01fdb4 94ba      	    dec     ibaseh
                 .ifdef RAMPZ
01fdb5 92b0 03c7 	sts     ibaseu, ibaseh
                 .endif
                 
                 ; Init Stack pointer
01fdb7 e8c4              ldi     yl, low(utibbuf-4)
01fdb8 e0d4              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
01fdb9 e407              ldi     t0, low(usbuf-1)
01fdba e014              ldi     t1, high(usbuf-1)
01fdbb bf0d              out     spl, t0
01fdbc bf1e              out     sph, t1
                 
01fdbd dfdd              rcall   INIT_012
01fdbe 940f eeb3         call    WDOFF
                 
                 ; Init user pointer
01fdc0 ee06              ldi     t0, low(up0)
01fdc1 e013              ldi     t1, high(up0)
01fdc2 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
01fdc3 e003              ldi     t0, RAMPZV
01fdc4 bf0b              out_    RAMPZ, t0
                 .endif
                 .ifdef EIND
01fdc5 be6c              out_    EIND, r_one
                 .endif
                 ; init warm literals
01fdc6 d932              rcall   DOLIT
01fdc7 dd00              fdw     WARMLIT
01fdc8 d930              rcall   DOLIT
01fdc9 03c8              .dw     cse
01fdca d92e              rcall   DOLIT
01fdcb 001c              .dw     warmlitsize
01fdcc 940f f486         call    CMOVE
                 ; init cold data to eeprom
01fdce d92a              rcall   DOLIT
01fdcf 2200              .dw     dp_start
01fdd0 d108              rcall   FETCH
01fdd1 d8d2              rcall   TRUE_
01fdd2 940f f2a8         call    EQUAL
01fdd4 940f f319         call    ZEROSENSE
01fdd6 f009              breq    WARM_3  
01fdd7 dfb9              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
01fdd8 be65              out_    MCUCR, r_one   ; (1<<IVCE)
01fdd9 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 ; Start watchdog timer
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
01fdda bc74              out_    TCCR0A, r_two  ; CTC
01fddb e003              ldi     t0, ms_pre_tmr0
01fddc bd05              out_    TCCR0B, t0
01fddd ef09              ldi     t0, ms_value_tmr0
01fdde bd07              out_    OCR0A, t0
01fddf 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
01fde1 d917              rcall   DOLIT
01fde2 fc95              .dw     RX0_ISR
01fde3 d915              rcall   DOLIT
                 .ifdef URXC0addr
01fde4 0332              .dw     URXC0addr+ivec
                 .else
                 .endif
01fde5 d0b6              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, r_zero
01fde6 e109              ldi     t0, ubrr0val
01fde7 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
01fde9 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
01fdea 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
01fdec e006              ldi     t0, (3<<UCSZ00)|URSEL_
01fded 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
01fdef 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
01fdf0 d908              rcall   DOLIT
01fdf1 fcb3              .dw     RX1_ISR
01fdf2 d906              rcall   DOLIT
01fdf3 0348              .dw     URXC1addr+ivec
01fdf4 d0a7              rcall   STORE
                         ; Set baud rate
                 ;        out_    UBRR1H, r_zero
01fdf5 e109              ldi     t0, ubrr1val
01fdf6 9300 00cc         out_    UBRR1L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
01fdf8 e908              ldi     t0, (1<<RXEN1)|(1<<TXEN1)|(1<<RXCIE1)
01fdf9 9300 00c9         out_    UCSR1B,t0
                         ; Set frame format: 8data, 1stop bit
01fdfb e006              ldi     t0, (3<<UCSZ10)
01fdfc 9300 00ca         out_    UCSR1C,t0
                 .if U1FC_TYPE == 1
01fdfe 6072              sbr     FLAGS2, (1<<ixoff_tx1)
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
01fdff d877              rcall   DP_TO_RAM
01fe00 9478              sei
                 
01fe01 dd40              rcall   RQ_EMIT
01fe02 d02c              rcall   VER
01fe03 9250 0374         sts     rbuf0_lv, r_zero
01fe05 9250 0372         sts     rbuf0_wr, r_zero
                 .ifdef rbuf1_lv
01fe07 9250 0397         sts     rbuf1_lv, r_zero
01fe09 9250 0395         sts     rbuf1_wr, r_zero
                 .endif
                 .if CPU_LOAD_LED == 1
01fe0b 9a27              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .endif
                 ; Turnkey ?
01fe0c d15c              rcall   TURNKEY
01fe0d 940f f319         call    ZEROSENSE
01fe0f f0d1              breq    STARTQ2
01fe10 940f f176         call    XSQUOTE
01fe12 4503
01fe13 4353              .db     3,"ESC"
01fe14 940f f169         call    TYPE
01fe16 d8e2              rcall   DOLIT
01fe17 07d0              .dw     TURNKEY_DELAY
01fe18 da2d              rcall   MS
01fe19 940f efab         call    KEYQ
01fe1b 940f f319         call    ZEROSENSE
01fe1d f049              breq    STARTQ1
01fe1e 940f efa4         call    KEY
01fe20 d8d8              rcall   DOLIT
01fe21 001b              .dw     0x1b
01fe22 940f f2a8         call    EQUAL
01fe24 940f f319         call    ZEROSENSE
01fe26 f419              brne    STARTQ2
                 STARTQ1:
01fe27 d141              rcall   TURNKEY
01fe28 940f efb3         call    EXECUTE
                 STARTQ2:
01fe2a 940d f6d2         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
01fe2c fb42              fdw     WARM_L
                 VER_L:
01fe2d 7683
01fe2e 7265              .db     NFA|3,"ver"
                 VER:
01fe2f 940f f176         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
01fe31 4624
01fe32 616c
01fe33 6873
01fe34 6f46
01fe35 7472
01fe36 2068
01fe37 2035
01fe38 5441
01fe39 656d
01fe3a 6167
01fe3b 3532
01fe3c 3036
01fe3d 3120
01fe3e 2e33
01fe3f 3130
01fe40 322e
01fe41 3130
01fe42 0d39
avr/src/ff-atmega.asm(5563): warning: .cseg .db misalignment - padding zero byte
01fe43 000a              .db     partlen+datelen+16,"FlashForth 5 ",partstring," ", DATE,0xd,0xa
01fe44 940d f169         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
01fe46 fc5a              fdw     VER_L
                 EI_L:
01fe47 65a2
01fe48 0069              .db     NFA|INLINE|2,"ei",0
01fe49 9478              sei
01fe4a 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
01fe4b fc8e              fdw     EI_L
                 DI_L:
01fe4c 64a2
01fe4d 0069              .db     NFA|INLINE|2,"di",0
01fe4e 94f8              cli
01fe4f 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
01fe50 fc98              fdw     DI_L
                 IRQ_SEMI_L:
01fe51 3bc2
01fe52 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
01fe53 d8a5              rcall   DOLIT
                 .ifdef EIND
01fe54 940d              .dw     0x940D     ; jmp
                 .else
                 .endif
01fe55 d13b              rcall   ICOMMA
01fe56 d8a2              rcall   DOLIT
01fe57 fc71              .dw     FF_ISR_EXIT
01fe58 d138              rcall   ICOMMA
01fe59 940d f7bb         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
01fe5b fca2              fdw     IRQ_SEMI_L
                 IRQ_V_L:
01fe5c 6984
01fe5d 746e
01fe5e 0021              .db     NFA|4,"int!",0
                 IRQ_V:
01fe5f 01fc              movw    zl, tosl
01fe60 9731              sbiw    zl, 1
01fe61 0fee              lsl     zl
                 .if low(ivec) == 0x80
                 .endif
01fe62 e0f3              ldi     zh, high(ivec)
01fe63 9189
01fe64 9199              poptos
01fe65 da97              rcall   TO_XA
01fe66 940d fea1         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
01fe68 fcb8              fdw     IRQ_V_L
                 LITERAL_L:
01fe69 6cc7
01fe6a 7469
01fe6b 7265
01fe6c 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
01fe6d d88b              rcall   DOLIT
01fe6e ee06              fdw     DUP
01fe6f db1d              rcall   INLINE0
01fe70 9380 03b8         sts     litbuf0, tosl
01fe72 9390 03b9         sts     litbuf1, tosh
01fe74 6860              sbr     FLAGS1, (1<<fLIT)
01fe75 940f f703         call    DUP
01fe77 2f98              mov     tosh, tosl
01fe78 9592              swap    tosh
01fe79 709f              andi    tosh, 0xf
01fe7a 708f              andi    tosl, 0xf
01fe7b 6e90              ori     tosh, 0xe0
01fe7c 6880              ori     tosl, 0x80
01fe7d d113              rcall   ICOMMA
01fe7e 2f89              mov     tosl, tosh
01fe7f 9592              swap    tosh
01fe80 709f              andi    tosh, 0xf
01fe81 708f              andi    tosl, 0xf
01fe82 6e90              ori     tosh, 0xe0
01fe83 6980              ori     tosl, 0x90
01fe84 940d ff91         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
01fe86 de87              rcall   IUPDATEBUF
                 ISTORE1:
01fe87 9189
01fe88 9199              poptos
01fe89 e0a0              ldi     xl, low(ibuf)
01fe8a e0b2              ldi     xh, high(ibuf)
01fe8b 9100 03c4         lds     t0, iaddrl
01fe8d 7f0f              andi    t0, (PAGESIZEB-1)
01fe8e 0fa0              add     xl, t0
01fe8f 938d              st      x+, tosl
01fe90 939d              st      x+, tosh
01fe91 c077              rjmp    ICSTORE_POP
                 
01fe92 fcd2              fdw     LITERAL_L
                 TO_A_L:
01fe93 3e82
01fe94 0061              .db     NFA|2, ">a",0
                 TO_A:
01fe95 2f28              mov     al, tosl
01fe96 2f39              mov     ah, tosh
01fe97 9189
01fe98 9199              poptos
01fe99 9508              ret
                 
01fe9a fd26              fdw     TO_A_L
                 STORE_L:
01fe9b 2181              .db     NFA|1, "!"
                 STORE:
01fe9c 3292              cpi     tosh, high(PEEPROM)
01fe9d f440              brcc    STORE1
                 STORE_RAM:
01fe9e 01fc              movw    zl, tosl
01fe9f 9189
01fea0 9199              poptos
                 STORE_RAM_2:
01fea1 8391              std     Z+1, tosh
01fea2 8380              std     Z+0, tosl
01fea3 9189
01fea4 9199              poptos
01fea5 9508              ret
                 STORE1:
01fea6 d009              rcall   LOCKEDQ
01fea7 3392              cpi     tosh, high(OFLASH)
01fea8 f6e8              brcc    ISTORE
                 ESTORE:
01fea9 940f f0ed         call    TWODUP
01feab d06e              rcall   ECSTORE
01feac 9601              adiw    tosl, 1
01fead 8109              ldd     t0, Y+1
01feae 8308              std     y+0, t0
01feaf c06a              rjmp    ECSTORE
                 
                 LOCKEDQ:
01feb0 ff62              sbrs    FLAGS1, fLOCK
01feb1 9508              ret
01feb2 d9f5              rcall   DOTS
01feb3 940f f176         call    XSQUOTE
01feb5 4103
01feb6 3f44              .db     3,"AD?"
01feb7 940f f169         call    TYPE
01feb9 cf70              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
01feba 01fc              movw    z, tosl
                         sub_pflash_z
                 .ifdef RAMPZ
01febb 9100 03c7 	lds     t0, ibaseu
01febd 3003      	cpi     t0, RAMPZV
01febe f469      	brne    IIFETCH
                 .endif
01febf 11fb              cpse    zh, ibaseh
01fec0 c00b              rjmp    IIFETCH
01fec1 2f0e              mov     t0, zl
01fec2 7000              andi    t0, ~(PAGESIZEB-1)
01fec3 150a              cp      t0, ibasel
01fec4 f439              brne    IIFETCH
01fec5 e0a0              ldi     xl, low(ibuf)
01fec6 e0b2              ldi     xh, high(ibuf)
01fec7 7fef              andi    zl, (PAGESIZEB-1)
01fec8 0fae              add     xl, zl
01fec9 918d              ld      tosl, x+
01feca 919d              ld      tosh, x+
01fecb 9508              ret
                 IIFETCH:
01fecc 9187              lpm_    tosl, z+     ; Fetch from Flash directly
01fecd 9197              lpm_    tosh, z+
01fece 9508              ret
                                 
01fecf fd36              fdw     STORE_L
                 A_FROM_L:
01fed0 6182
01fed1 003e              .db     NFA|2, "a>",0
                 A_FROM:
01fed2 939a
01fed3 938a              pushtos
01fed4 2f82              mov     tosl, al
01fed5 2f93              mov     tosh, ah
01fed6 9508              ret
                 
                 .if FLASHEND > 0x3fff
01fed7 f524              fdw     XSTORE_L
                 .else
                 .endif
                 FETCH_L:
01fed8 4081              .db     NFA|1, "@"
                 FETCH:
01fed9 3292              cpi     tosh, high(PEEPROM)
01feda f420              brcc    FETCH1
                 FETCH_RAM:
01fedb 01fc              movw    zl, tosl
                 FETCH_RAM_2:
01fedc 9181              ld      tosl, z+
01fedd 9191              ld      tosh, z+
01fede 9508              ret
                 FETCH1:
01fedf 3392              cpi     tosh, high(OFLASH)
01fee0 f6c8              brcc    IFETCH
                 EFETCH:
01fee1 99f9              sbic    eecr, eewe
01fee2 cffe              rjmp    EFETCH
01fee3 5292              subi    tosh, high(PEEPROM)
01fee4 bd81              out     eearl, tosl
01fee5 bd92              out     eearh, tosh
01fee6 9af8              sbi     eecr, eere
01fee7 b500              in      t0, eedr
01fee8 9583              inc     tosl
01fee9 bd81              out     eearl, tosl
01feea 9af8              sbi     eecr, eere
01feeb b590              in      tosh, eedr
01feec 2f80              mov     tosl, t0
01feed 9508              ret
                 
                 ICFETCH:
01feee dfcb              rcall   IFETCH
01feef 2799              clr     tosh
01fef0 9508              ret
                 
01fef1 fdb0              fdw     FETCH_L
                 CFETCH_L:
01fef2 6382
01fef3 0040              .db     NFA|2, "c@",0
                 CFETCH:
01fef4 3292              cpi     tosh, high(PEEPROM)
01fef5 f420              brcc    CFETCH1
                 CFETCH_RAM:
01fef6 01fc              movw    zl, tosl
01fef7 9181              ld      tosl, z+
01fef8 2799              clr     tosh
01fef9 9508              ret
                 CFETCH1:
01fefa 3392              cpi     tosh, high(OFLASH)
01fefb f790              brcc    ICFETCH
                 ECFETCH:
01fefc dfe4              rcall   EFETCH
01fefd 2799              clr     tosh
01fefe 9508              ret
                 
                 ICSTORE:
01feff de0e              rcall   IUPDATEBUF
01ff00 9189
01ff01 9199              poptos
01ff02 e0a0              ldi     xl, low(ibuf)
01ff03 e0b2              ldi     xh, high(ibuf)
01ff04 9100 03c4         lds     t0, iaddrl
01ff06 7f0f              andi    t0, (PAGESIZEB-1)
01ff07 0fa0              add     xl, t0
01ff08 938d              st      x+, tosl
                 ICSTORE_POP:
01ff09 6061              sbr     FLAGS1, (1<<idirty)
01ff0a c009              rjmp    CSTORE_POP
                 
01ff0b fde4              fdw     CFETCH_L
                 CSTORE_L:
01ff0c 6382
01ff0d 0021              .db     NFA|2, "c!",0
                 CSTORE:
01ff0e 3292              cpi     tosh, high(PEEPROM)
01ff0f f438              brcc    CSTORE1
                 CSTORE_RAM:
01ff10 01fc              movw zl, tosl
01ff11 9189
01ff12 9199              poptos
01ff13 8380              st      Z, tosl
                 CSTORE_POP:
01ff14 9189
01ff15 9199              poptos
01ff16 9508              ret
                 CSTORE1:
01ff17 df98              rcall   LOCKEDQ
01ff18 3392              cpi     tosh, high(OFLASH)
01ff19 f728              brcc    ICSTORE
                 ECSTORE:
01ff1a 99f9              sbic    eecr, eewe
01ff1b cffe              rjmp    ECSTORE
01ff1c 5292              subi    tosh, high(PEEPROM)
01ff1d bd81              out     eearl, tosl
01ff1e bd92              out     eearh, tosh
01ff1f 9189
01ff20 9199              poptos
01ff21 bd80              out     eedr, tosl
01ff22 9afa              sbi     eecr, eemwe
01ff23 9af9              sbi     eecr, eewe
01ff24 cfef              rjmp    CSTORE_POP
                 
                 ;;; Disable writes to flash and eeprom
01ff25 fe18              fdw     CSTORE_L
                 
                 FLOCK_L:
01ff26 6683
01ff27 2d6c              .db     NFA|3,"fl-"
01ff28 6064              sbr     FLAGS1, (1<<fLOCK)
01ff29 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
01ff2a fe4c              fdw     FLOCK_L
                 FUNLOCK_L:
01ff2b 6683
01ff2c 2b6c              .db     NFA|3,"fl+"
01ff2d 7f6b              cbr     FLAGS1, (1<<fLOCK)
01ff2e 9508              ret
                 
                 
                 
01ff2f fe56              fdw     FUNLOCK_L
                 VALUE_L:
01ff30 7685
01ff31 6c61
01ff32 6575              .db     NFA|5,"value"
                 VALUE:
01ff33 d819              rcall   CREATE
01ff34 940f f06f         call    COMMA
01ff36 d868              rcall   XDOES
                 VALUE_DOES:
01ff37 940f effc         call    DODOES
01ff39 940d fed9         jmp     FETCH
                 
01ff3b fe60              fdw     VALUE_L
                 DEFER_L:
01ff3c 6485
01ff3d 6665
01ff3e 7265              .db     NFA|5,"defer"
                 DEFER:
01ff3f d80d              rcall   CREATE
01ff40 940f f6f9         call    DOLIT
01ff42 eda4              fdw     ABORT
01ff43 940f f06f         call    COMMA
01ff45 d859              rcall   XDOES
                 DEFER_DOES:
01ff46 940f effc         call    DODOES
01ff48 940d efbd         jmp     FEXECUTE
                 
01ff4a fe78              fdw     DEFER_L
                 IS_L:
01ff4b 69c2
01ff4c 0073              .db     NFA|IMMED|2,"is",0
                 IS:
01ff4d 940f f716         call    TICK
01ff4f 940f f276         call    TWOPLUS
01ff51 940f f276         call    TWOPLUS
01ff53 df85              rcall   FETCH
01ff54 d8c4              rcall   STATE_
01ff55 940f f319         call    ZEROSENSE
01ff57 f029              breq    IS1
01ff58 df14              rcall   LITERAL
01ff59 940f f00e         call    DOCOMMAXT
01ff5b fd38              fdw     STORE
01ff5c c001              rjmp    IS2
                 IS1:
01ff5d df3e              rcall   STORE
                 IS2:
01ff5e 9508              ret
                 
01ff5f fe96              fdw     IS_L
                 TO_L:
01ff60 74c2
01ff61 006f              .db     NFA|IMMED|2,"to",0
                 TO:
01ff62 940d ff4d         jmp     IS
                 
01ff64 fec0              fdw     TO_L
                 TURNKEY_L:
01ff65 7487
01ff66 7275
01ff67 6b6e
01ff68 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
01ff69 940f ff37         call    VALUE_DOES      ; Must be call for IS to work.
01ff6b 03ba              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
01ff6c feca              fdw     TURNKEY_L
                 PAUSE_L:
01ff6d 7085
01ff6e 7561
01ff6f 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
01ff70 dbec              rcall   IDLE_LOAD
                 .endif
01ff71 b71f              in_     t1, SREG
01ff72 94f8              cli
01ff73 95a8              wdr               ; watchdog reset
01ff74 93df              push    yh        ; SP
01ff75 93cf              push    yl
01ff76 939f              push    tosh      ; TOS
01ff77 938f              push    tosl
01ff78 935f              push    ph        ; P
01ff79 934f              push    pl
01ff7a 01f1              movw    zl, upl
01ff7b b70e              in      t0, sph
01ff7c 9302              st      -z, t0
01ff7d b70d              in      t0, spl
01ff7e 9302              st      -z, t0
01ff7f 91b2              ld      xh, -z     ; UP
01ff80 91a2              ld      xl, -z
01ff81 011d              movw    upl, xl
01ff82 910e              ld      t0, -x
01ff83 bf0e              out     sph, t0
01ff84 910e              ld      t0, -x
01ff85 bf0d              out     spl, t0
01ff86 914f              pop     pl
01ff87 915f              pop     ph
01ff88 918f              pop     tosl
01ff89 919f              pop     tosh
01ff8a 91cf              pop     yl
01ff8b 91df              pop     yh
01ff8c bf1f              out_    SREG, t1
01ff8d 9508              ret
                 
                 
01ff8e dd96              fdw     OPERATOR_L
                 ICOMMA_L:
01ff8f 6982
01ff90 002c              .db     NFA|2, "i,",0
                 ICOMMA:
01ff91 940f f730         call    IHERE
01ff93 df08              rcall   STORE
01ff94 940f f080         call    CELL
01ff96 940d f8e9         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
01ff98 ff1e              fdw     ICOMMA_L
                 ICCOMMA_L:
01ff99 6983
01ff9a 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
01ff9b 940f f730         call    IHERE
01ff9d df70              rcall   CSTORE
01ff9e 940f f120         call    ONE
01ffa0 940d f8e9         jmp     IALLOT
                 
                 L_DOTBASE:
01ffa2 2081              .db      NFA|1," "
                 DOTBASE:
01ffa3 940f f42c         call    BASE
01ffa5 df33              rcall   FETCH
01ffa6 3180              cpi     tosl, 0x10
01ffa7 f411              brne    DOTBASE1
01ffa8 e284              ldi     tosl,'$'
01ffa9 c009              rjmp    DOTBASEEND
                 DOTBASE1:
01ffaa 308a              cpi     tosl, 0xa
01ffab f411              brne    DOTBASE2
01ffac e283              ldi     tosl, '#'
01ffad c005              rjmp    DOTBASEEND
                 DOTBASE2:
01ffae 3082              cpi     tosl, 0x2
01ffaf f411              brne    DOTBASE3
01ffb0 e285              ldi     tosl, '%'
01ffb1 c001              rjmp    DOTBASEEND
                 DOTBASE3:
01ffb2 e38f              ldi     tosl, '?'
                 DOTBASEEND:
01ffb3 9508              ret
                 
                 MEMQADDR_N:
01ffb4 e084              fdw     ROM_N
01ffb5 e092              fdw     EROM_N
01ffb6 e0a2              fdw     FRAM_N
                 ;*******************************************************
                 umstar0:
01ffb7 920f              push t2
01ffb8 921f              push t3
01ffb9 9109              ld  t0, Y+
01ffba 9119              ld  t1, Y+
01ffbb 9f80              mul tosl,t0
01ffbc 01d0              movw t4, r0 ; r0=t2, r1=t3
01ffbd 27ee              clr t6
01ffbe 27ff              clr t7
01ffbf 9f90              mul tosh, t0
01ffc0 0db0              add t5, r0
01ffc1 1de1              adc t6, r1
01ffc2 1df5              adc t7, r_zero
01ffc3 9f81              mul tosl, t1
01ffc4 0db0              add t5, r0
01ffc5 1de1              adc t6, r1
01ffc6 1df5              adc t7, r_zero
01ffc7 9f91              mul tosh, t1
01ffc8 0de0              add t6, r0
01ffc9 1df1              adc t7, r1
01ffca 93ba              st -Y, t5
01ffcb 93aa              st -Y, t4
01ffcc 01cf              movw tosl, t6
01ffcd 901f              pop t3
01ffce 900f              pop t2
01ffcf 9508              ret
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
01ffd0 94e8              clt
01ffd1 2388              tst  tosl
01ffd2 f429              brne umslashmodstart
01ffd3 2399              tst  tosh
01ffd4 f419              brne umslashmodstart
01ffd5 9468              set  ; Set T flag
01ffd6 940d fda4         jmp  WARM_
                 umslashmodstart:
01ffd8 01dc              movw t4, tosl
                 
01ffd9 9019              ld t3, Y+
01ffda 91e9              ld t6, Y+
                 
01ffdb 9189              ld tosl, Y+
01ffdc 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
01ffdd e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
01ffde 27ff              clr t7
01ffdf 0f88              lsl tosl
01ffe0 1f99              rol tosh
01ffe1 1c11              rol t3
01ffe2 1fee              rol t6
01ffe3 1fff              rol t7
                 
                         ; try subtracting divisor
01ffe4 161a              cp  t3, t4
01ffe5 07eb              cpc t6, t5
01ffe6 05f5              cpc t7,r_zero
                 
01ffe7 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
01ffe8 9583              inc tosl
01ffe9 1a1a              sub t3, t4
01ffea 0beb              sbc t6, t5
                 
                 umslashmod2:
01ffeb 950a              dec  t0
01ffec f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
01ffed 93ea              st -Y,t6
01ffee 921a              st -Y,t3
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
01ffef 9508              ret
                 BASEQV:
01fff0 e7ee              fdw     DECIMAL
01fff1 e7fc              fdw     HEX
01fff2 e80c              fdw     BIN
                 
                 
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
01fff3 0000      STARTV: .dw      0
01fff4 3200      DPC:    .dw      OFLASH
01fff5 220c      DPE:    .dw      ehere
01fff6 04e2      DPD:    .dw      dpdata
01fff7 f55e      LW:     fdw      lastword
01fff8 ecbc      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega2560 register use summary:
r0 :  20 r1 :  23 r2 :   5 r3 :   1 r4 :   0 r5 :  28 r6 :   9 r7 :   5 
r8 :   4 r9 :   4 r10:   5 r11:   6 r12:   0 r13:   0 r14:   2 r15:   2 
r16: 171 r17:  57 r18:   7 r19:   2 r20:  14 r21:   7 r22:  35 r23:  17 
r24: 259 r25: 189 r26:  75 r27:  43 r28:   5 r29:   5 r30:  84 r31:  72 
x  :  16 y  : 181 z  :  37 
Registers used: 32 out of 35 (91.4%)

ATmega2560 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  20 add   :  20 adiw  :  14 and   :   4 
andi  :  26 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  21 brcs  :   1 break :   0 breq  :  57 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   2 brmi  :   6 
brne  :  34 brpl  :   3 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   5 bst   :   0 call  :  95 cbi   :   2 cbr   :  20 
clc   :   0 clh   :   0 cli   :   9 cln   :   0 clr   :  19 cls   :   0 
clt   :   1 clv   :   0 clz   :   1 com   :  11 cp    :   3 cpc   :   2 
cpi   :  39 cpse  :   7 dec   :   5 eicall:   0 eijmp :  15 elpm  :   9 
eor   :   2 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :  16 inc   :   8 jmp   : 162 ld    : 126 ldd   :   3 ldi   :  77 
lds   :  35 lpm   :   0 lsl   :  11 lsr   :   1 mov   :  25 movw  :  40 
mul   :   4 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :   7 
ori   :  19 out   :  34 pop   : 112 push  :  37 rcall : 986 ret   : 137 
reti  :   1 rjmp  : 121 rol   :  14 ror   :  21 sbc   :   8 sbci  :   3 
sbi   :   6 sbic  :   2 sbis  :   0 sbiw  :  14 sbr   :  17 sbrc  :  13 
sbrs  :  21 sec   :   0 seh   :   0 sei   :   5 sen   :   0 ser   :   5 
ses   :   0 set   :   1 sev   :   0 sez   :   1 sleep :   1 spm   :   2 
st    :  85 std   :   3 sts   :  41 sub   :   2 subi  :  10 swap  :   3 
tst   :   2 wdr   :   4 
Instructions used: 76 out of 116 (65.5%)

ATmega2560 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x02fd00 0x03fff2   6068   2516   8584  262144   3.3%
[.dseg] 0x000200 0x0004e4      0    740    740    8192   9.0%
[.eseg] 0x000000 0x000002      0      2      2    4096   0.0%

Assembly complete, 0 errors, 8 warnings
