
AVRASM ver. 2.1.30  avr/src/ff-atmega.asm Sun Sep 23 17:17:40 2018

avr/src/ff-atmega.asm(34): Including file 'avr/src/config.inc'
avr/src/config.inc(9): Including file 'avrasm2/inc\m328def.inc'
avr/src/ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
avr/src/ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
avr/src/ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
avr/src/ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
avr/src/ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
avr/src/ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
avr/src/ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          23.09.2018                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2017  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 ;.include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 ;.include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 .include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega328P.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328DEF_INC_
                 #define _M328DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328
                 #pragma AVRPART ADMIN PART_NAME ATmega328
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x14
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 .equ	BODSE	= 5	; BOD Sleep Enable
                 .equ	BODS	= 6	; BOD Sleep
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program. Or use the ff-shell.py which adds CR LF flow control.
                 .equ BAUDRATE0 = 38400               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 0
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 64  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 64          ; 32 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 90                   ; 80 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 ; Debug flash and eeprom writes
                 ; Prints F=Write to FLASH E=Write to EEPROM
                 .equ DEBUG_FLASH = 0
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #elif defined(__ATmega328__)
                 #define partstring "ATmega328"
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "23.09.2018"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def r_zero = r5      ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def al = r18
                   .def ah = r19
                   .def pl = r20         ; P Register and FOR..LOOP INDEX variable
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ; Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*255/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fIDLE=     6   ; 0 = busy, 1 = idle
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ fLIT=    7     ; Literal compiled
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001f7           litbuf0:    .byte 1
0001f8           litbuf1:    .byte 1
                 
0001f9           dpSTART:    .byte 2
0001fb           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001fd           dpEEPROM:   .byte 2
0001ff           dpRAM:      .byte 2
000201           dpLATEST:   .byte 2
                 
000203           iaddrl:     .byte 1
000204           iaddrh:     .byte 1
                 .ifdef RAMPZ
                 .endif
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1       
                 .endif
                 .endif
                 
000205           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
000206           state:      .byte 1 ; Compilation state
000207           uvars:      .byte   (-us0)
000223           up0:        .byte   2
000225           urbuf:      .byte   ursize
000265           usbuf:      .byte   ussize
0002a5           utibbuf:    .byte   utibsize
0002ff           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .if (FLASHEND == 0x1ffff)
                 .else
                 .org KERNEL_START
                 .endif
                 ;***********************************************************
                 CMP:
002f80 940e 32b9         call    TOR
002f82 c009              rjmp    CMP2
                 CMP1:
002f83 940e 3008         call    NEQUALSFETCH
002f85 940e 32eb         call    MINUS
002f87 940e 33fa         call    ZEROSENSE
002f89 f011              breq    CMP2
002f8a 940c 3964         jmp     TWODROPZ
                 CMP2:
002f8c 940e 3a95         call    XNEXT
002f8e f7a0              brcc    CMP1
002f8f 940c 3960         jmp     TWODROPNZ
                 
                 .if (FLASHEND == 0x1ffff)
                 .endif
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
002f91 0200              .dw      0x0200                ; cse, state
002f92 02a1              .dw      utibbuf-4             ; S0
002f93 0264              .dw      usbuf-1               ; R0
002f94 f8f0              fdw      OP_TX_
002f95 f93e              fdw      OP_RX_
002f96 f97e              fdw      OP_RXQ
002f97 000a              .dw      BASE_DEFAULT          ; BASE
002f98 02a5              .dw      utibbuf               ; TIB
002f99 df80              fdw      OPERATOR_AREA         ; TASK
002f9a 0000              .dw      0                     ; ustatus & uflg
002f9b 0000              .dw      0                     ; source
002f9c 0000              .dw      0                     ; source
002f9d 0000              .dw      0                     ; TOIN
002f9e 0223              .dw      up0                   ; Task link
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
002f9f 2081              .db     NFA|1," "
                 MEMQ:
002fa0 940e 3147         call    CSE_
002fa2 940e 37d8         call    DOLIT
002fa4 fecc              fdw     MEMQADDR_N
002fa5 940e 32de         call    PLUS
002fa7 940e 3719         call    FETCH_A
002fa9 940e 3581         call    CFETCHPP
002fab 940e 37d8         call    DOLIT
002fad 000f              .dw     NFAmask
002fae 940c 3326         jmp     AND_
                 
                 .if (FLASHEND == 0x1ffff)
                 .ifdef MCUSR
                 .else
                 .endif
                 .endif
                 ;*********************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fb0 0000              .dw     0
                 EXIT_L:
002fb1 6584
002fb2 6978
002fb3 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fb4 910f              pop     t0
002fb5 910f              pop     t0
002fb6 9508              ret
                 
002fb7 faa4              fdw     IFLUSH_L
                 OPERATOR_L:
002fb8 6f88
002fb9 6570
002fba 6172
002fbb 6f74
002fbc 0072              .db     NFA|8,"operator",0
                 OPERATOR:
002fbd 940e 30e0         call    DOCREATE
002fbf df80              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
002fc0 0223              .dw     up0
002fc1 0000
002fc2 0040              .dw     0, ursize
002fc3 0040
002fc4 005a              .dw     ussize, utibsize
                 
                 ; idle
002fc5 df62              fdw(EXIT_L)
                 IDLE_L:
002fc6 6984
002fc7 6c64
002fc8 0065              .db     NFA|4,"idle",0
                 IDLE:
002fc9 6470              sbr     FLAGS2, (1<<fIDLE)
002fca 9508              ret
                         
                 ; busy
002fcb df8c              fdw(IDLE_L)
                 BUSY_L:
002fcc 6284
002fcd 7375
002fce 0079              .db     NFA|4,"busy",0
                 BUSY:
002fcf 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fd0 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fd1 fe96              fdw     ICCOMMA_L
                 MSET_L:
002fd2 6d84
002fd3 6573
002fd4 0074              .db     NFA|4,"mset",0
                 MSET:
002fd5 01fc              movw    zl, tosl
002fd6 9189
002fd7 9199              poptos
002fd8 8100              ld      t0, z
002fd9 2b08              or      t0, tosl
002fda 8300              st      z, t0
002fdb 9189
002fdc 9199              poptos
002fdd 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002fde dfa4              fdw     MSET_L
                 MCLR_L:
002fdf 6d84
002fe0 6c63
002fe1 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002fe2 01fc              movw    zl, tosl
002fe3 9189
002fe4 9199              poptos
002fe5 8100              ld      t0, z
002fe6 9580              com     tosl
002fe7 2308              and     t0, tosl
002fe8 8300              st      z, t0
002fe9 9189
002fea 9199              poptos
002feb 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
002fec dfbe              fdw     MCLR_L
                 LSHIFT_L:
002fed 6c86
002fee 6873
002fef 6669
002ff0 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
002ff1 01fc              movw    zl, tosl
002ff2 9189
002ff3 9199              poptos
                 LSHIFT1:
002ff4 9731              sbiw    zl, 1
002ff5 f01a              brmi    LSHIFT2
002ff6 0f88              lsl     tosl
002ff7 1f99              rol     tosh
002ff8 cffb              rjmp    LSHIFT1
                 LSHIFT2:
002ff9 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
002ffa dfda              fdw     LSHIFT_L
                 RSHIFT_L:
002ffb 7286
002ffc 6873
002ffd 6669
002ffe 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
002fff 01fc              movw    zl, tosl
003000 9189
003001 9199              poptos
                 RSHIFT1:
003002 9731              sbiw    zl, 1
003003 f01a              brmi    RSHIFT2
003004 9596              lsr     tosh
003005 9587              ror     tosl
003006 cffb              rjmp    RSHIFT1
                 RSHIFT2:
003007 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
003008 d578              rcall   CFETCHPP
003009 d2a7              rcall   ROT
00300a d576              rcall   CFETCHPP
00300b c2a5              rjmp    ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
00300c dff6              fdw     RSHIFT_L
                 NEQUAL_L:
00300d 6e82
00300e 003d              .db     NFA|2,"n=",0
                 NEQUAL:
00300f dff8              rcall   NEQUALSFETCH
003010 708f              andi    tosl, 0xf
003011 d379              rcall   EQUAL
003012 d3e7              rcall   ZEROSENSE
003013 f0b1              breq    NEQUAL5
003014 d33f              rcall   ONEMINUS
003015 d56b              rcall   CFETCHPP
003016 d2a2              rcall   TOR
003017 c00c              rjmp    NEQUAL4
                 NEQUAL2:
003018 dfef              rcall   NEQUALSFETCH
003019 d36c              rcall   NOTEQUAL
00301a d3df              rcall   ZEROSENSE
00301b f021              breq    NEQUAL3
00301c d766              rcall   TRUE_
00301d 940e 3aa5         call    LEAVE
00301f c004              rjmp    NEQUAL4
                 NEQUAL3:
003020 d2ac              rcall   RFETCH
003021 d3d8              rcall   ZEROSENSE
003022 f409              brne    NEQUAL4
003023 d756              rcall   FALSE_
                 NEQUAL4:
003024 940e 3a95         call    XNEXT
003026 f788              brcc    NEQUAL2
003027 911f              pop     t1
003028 910f              pop     t0
003029 c001              rjmp    NEQUAL6
                 NEQUAL5:
00302a d758              rcall   TRUE_
                 NEQUAL6:
00302b d40f              rcall   NIP
00302c 940c 343b         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
00302e e01a              fdw     NEQUAL_L
                 SKIP_L:
00302f 7384
003030 696b
003031 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003032 d286              rcall   TOR
                 SKIP0:
003033 d3cc              rcall   DUPZEROSENSE
003034 f089              breq    SKIP2
                 
003035 d273              rcall   OVER
003036 d426              rcall   CFETCH_A
                 
003037 d7a9              rcall   DUP
003038 d79f              rcall   DOLIT
003039 0009              .dw     TAB_
00303a d350              rcall   EQUAL
00303b d3be              rcall   ZEROSENSE
00303c f429              brne    SKIP05    
00303d d28f              rcall   RFETCH
00303e d34c              rcall   EQUAL
00303f d3ba              rcall   ZEROSENSE
003040 f029              breq    SKIP2
003041 c001                      rjmp    SKIP1
                 SKIP05:
003042 d255              rcall   DROP
                 SKIP1:
003043 d1c4              rcall   ONE
003044 d4e7              rcall   SLASHSTRING
003045 cfed              rjmp    SKIP0
                 SKIP2:
003046 910f              pop     t0
003047 910f              pop     t0
003048 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
003049 e05e              fdw     SKIP_L
                 SCAN_L:
00304a 7384
00304b 6163
00304c 006e              .db     NFA|4,"scan",0
                 SCAN:
00304d d362              rcall   STORE_P_TO_R
00304e d26a              rcall   TOR
00304f c010              rjmp    SCAN3
                 SCAN1:
003050 d530              rcall   CFETCHPP
003051 d78f              rcall   DUP
003052 d785              rcall   DOLIT
003053 0009              .dw     TAB_
003054 d336              rcall   EQUAL
003055 d3a4              rcall   ZEROSENSE
003056 f011              breq    SCAN2
003057 d240              rcall   DROP
003058 c005              rjmp    SCAN25
                 SCAN2:
003059 940e 3b66         call    FETCH_P
00305b d32f              rcall   EQUAL
00305c d39d              rcall   ZEROSENSE
00305d f011              breq    SCAN3
                 SCAN25:
00305e d2f5              rcall   ONEMINUS
00305f c003              rjmp    SCAN4
                 SCAN3:
003060 940e 3a95         call    XNEXT
003062 f768              brcc    SCAN1
                 SCAN4:
003063 d25f              rcall   RFROM
003064 d2ea              rcall   ONEPLUS
003065 d355              rcall   R_TO_P
003066 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
003067 e094              fdw     SCAN_L
                 MTST_L:
003068 6d84
003069 7374
00306a 0074              .db     NFA|4,"mtst",0
                 MTST:
00306b 01fc              movw    zl, tosl
00306c 9181              ld      tosl, z+
00306d 9109              ld      t0, Y+
00306e 9119              ld      t1, Y+
00306f 2380              and     tosl, t0
003070 2799              clr     tosh
003071 9508              ret
                 
                 
003072 e0d0              fdw     MTST_L
                 FCY_L:
003073 4683
003074 7963              .db     NFA|3,"Fcy"
003075 d06a              rcall   DOCREATE
003076 3e80              .dw     FREQ_OSC / 1000
                 
                 ;;; Check parameter stack pointer
003077 7383
003078 3f70              .db     NFA|3,"sp?"
                 check_sp:
003079 d089              rcall   SPFETCH
00307a 940e 390e         call    R0_
00307c d69c              rcall   FETCH_A
00307d 940e 3909         call    S0
00307f d699              rcall   FETCH_A
003080 d2ce              rcall   ONEPLUS
003081 d2fa              rcall   WITHIN
003082 d1d9              rcall   XSQUOTE
003083 5303
003084 3f50              .db     3,"SP?"
003085 d73e              rcall   QABORT
003086 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
003087 e0e6              fdw     FCY_L
                 EMIT_L:
003088 6584
003089 696d
00308a 0074              .db     NFA|4,"emit",0
                 EMIT:
00308b d35e              rcall   UEMIT_
00308c 940c 30ab         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
00308e e110              fdw     EMIT_L
                 KEY_L:
00308f 6b83
003090 7965              .db     NFA|3,"key"
                 KEY:
003091 d35e              rcall   UKEY_
003092 940c 30ab         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003094 e11e              fdw     KEY_L
                 KEYQ_L:
003095 6b84
003096 7965
003097 003f              .db     NFA|4,"key?",0
                 KEYQ:
003098 d35d              rcall   UKEYQ_
003099 940c 30ab         jmp     FEXECUTE
                 
00309b e12a              fdw     KEYQ_L
                 EXECUTE_L:
00309c 6587
00309d 6578
00309e 7563
00309f 6574              .db     NFA|7,"execute"
                 EXECUTE:
0030a0 01fc              movw    zl, tosl
0030a1 58f0              sub_pflash_z
0030a2 9189
0030a3 9199              poptos
0030a4 9488              rampv_to_c
0030a5 95f7              ror     zh
0030a6 95e7              ror     zl
0030a7 9409              mijmp
                 
0030a8 e138              fdw     EXECUTE_L
                 FEXECUTE_L:
0030a9 4083
0030aa 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
0030ab d66d              rcall   FETCH_A
0030ac 940c 30a0         jmp     EXECUTE
                 
0030ae e152              fdw     FEXECUTE_L
                 VARIABLE_L:
0030af 7688
0030b0 7261
0030b1 6169
0030b2 6c62
0030b3 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
0030b4 d09c              rcall   HERE
0030b5 d0b1              rcall   CELL
0030b6 d1da              rcall   ALLOT
0030b7 940c 30cb         jmp     CONSTANT_
                 
0030b9 e15e              fdw     VARIABLE_L
                 TWOVARIABLE_L:
0030ba 3289
0030bb 6176
0030bc 6972
0030bd 6261
0030be 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
0030bf d091              rcall   HERE
0030c0 d717              rcall   DOLIT
0030c1 0004              .dw     0x4
0030c2 d1ce              rcall   ALLOT
0030c3 940c 30cb         jmp     CONSTANT_
                 
0030c5 e174              fdw     TWOVARIABLE_L
                 CONSTANT_L:
0030c6 6388
0030c7 6e6f
0030c8 7473
0030c9 6e61
0030ca 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
0030cb d7d6              rcall   COLON
0030cc 940e 3e22         call    LITERAL
0030ce 940c 38b0         jmp     SEMICOLON
                 
0030d0 e18c              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030d1 3289
0030d2 6f63
0030d3 736e
0030d4 6174
0030d5 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030d6 d1c8              rcall   SWOP
0030d7 d7ca              rcall   COLON
0030d8 940e 3e22         call    LITERAL
0030da 940e 3e22         call    LITERAL
0030dc 940c 38b0         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030de 2883
0030df 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030e0 91ff              pop     zh
0030e1 91ef              pop     zl
0030e2 d00c              rcall   FETCHLIT
                         m_pop_zh
0030e3 91ff              pop     zh
0030e4 91ef              pop     zl
0030e5 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030e6 2883
0030e7 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030e8 91bf              pop     xh
0030e9 91af              pop     xl
                         m_pop_zh
0030ea 91ff              pop     zh
0030eb 91ef              pop     zl
0030ec d002              rcall   FETCHLIT
0030ed 01fd              movw    z, x
0030ee 9409              mijmp    ; (z)
                 
                 FETCHLIT:
0030ef 939a
0030f0 938a              pushtos
0030f1 0fee              lsl     zl
0030f2 1fff              rol     zh
0030f3 9185              lpm_    tosl, z+
0030f4 9195              lpm_    tosh, z+
0030f5 9508              ret
                 
0030f6 2883
0030f7 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
0030f8 91ff              pop     zh
0030f9 91ef              pop     zl
0030fa dff4              rcall   FETCHLIT
0030fb 95f7              ror     zh
0030fc 95e7              ror     zl
0030fd 93ef              push    zl
0030fe 93ff              push    zh
                         m_push_t0
0030ff c098              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
003100 e1a2              fdw     TWOCONSTANT_L
                 SPFETCH_L:
003101 7383
003102 4070              .db     NFA|3,"sp@"
                 SPFETCH:
003103 01fe              movw    z, y
003104 939a
003105 938a              pushtos
003106 01cf              movw    tosl, z
003107 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
003108 7383
003109 2170              .db     NFA|3,"sp!"
                 SPSTORE:
00310a 01ec              movw    y, tosl
00310b 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
00310c 7283
00310d 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
00310e 91bf              pop     xh
00310f 91af              pop     xl
003110 940e 390e         call    R0_
003112 d606              rcall   FETCH_A
003113 bf8d              out     spl, tosl
003114 bf9e              out     sph, tosh
003115 9189
003116 9199              poptos
003117 01fd              movw    zl, xl
003118 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
003119 e202              fdw     SPFETCH_L
                 RPFETCH_L:
00311a 72b3
00311b 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
00311c 939a
00311d 938a              pushtos
00311e b78d              in      tosl, spl
00311f b79e              in      tosh, sph
003120 9508              ret
                 
                 ;   ><  Swap bytes        
003121 e234              fdw     RPFETCH_L
                 SWAPB_L:
003122 3ea2
003123 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
003124 2f08              mov     t0, tosl
003125 2f89              mov     tosl, tosh
003126 2f90              mov     tosh, t0
003127 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
003128 e244              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
003129 6685
00312a 616c
00312b 6873              .db     NFA|5,"flash"
                 ROM_:
00312c 9250 0205         sts     cse, r_zero
00312e 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
00312f e252              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003130 6586
003131 7065
003132 6f72
003133 006d              .db     NFA|6,"eeprom",0
                 EROM:
003134 9270 0205         sts     cse, r_two
003136 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
003137 e260              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
003138 7283
003139 6d61              .db     NFA|3,"ram"
                 FRAM:
00313a e004              ldi     t0, 4
00313b 9300 0205         sts     cse, t0
00313d 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
00313e e270              fdw     RAM_L
                 DP_L:
00313f 6482
003140 0070              .db     NFA|2,"dp",0
                 DP:
003141 d735              rcall   IDP
003142 d004              rcall   CSE_
003143 940c 32de         jmp     PLUS
                 
                 
                 ;;; 
003145 6383
003146 6573              .db     NFA|3,"cse"
                 CSE_:
003147 939a
003148 938a              pushtos
003149 9180 0205         lds     tosl, cse
00314b 2799              clr     tosh
00314c 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
00314d e27e              fdw     DP_L
                 HERE_L:
00314e 6884
00314f 7265
003150 0065              .db     NFA|4,"here",0
                 HERE:
003151 dfef              rcall   DP
003152 940c 3e8b         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003154 e29c              fdw     HERE_L
                 COMMA_L:
003155 2c81              .db     NFA|1,","
                 COMMA:
003156 dffa              rcall   HERE
003157 d437              rcall   STORE_A
003158 d00e              rcall   CELL
003159 940c 3291         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
00315b e2aa              fdw     COMMA_L 
                 CCOMMA_L:
00315c 6382
00315d 002c              .db     NFA|2,"c,",0
                 CCOMMA:
00315e dff2              rcall   HERE
00315f d301              rcall   CSTORE_A
003160 d0a7              rcall   ONE
003161 940c 3291         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003163 e2b8              fdw     CCOMMA_L
                 CELL_L:
003164 6384
003165 6c65
003166 006c              .db     NFA|4,"cell",0
                 CELL:
003167 939a
003168 938a              pushtos
003169 e082              ldi     tosl, 2
00316a e090              ldi     tosh, 0
00316b 9508              ret
                 
                 ; ALIGN    --                         align DP
00316c e2c8              fdw     CELL_L
                 ALIGN_L:
00316d 6185
00316e 696c
00316f 6e67              .db     NFA|5,"align"
                 ALIGN:
003170 dfe0              rcall   HERE
003171 d008              rcall   ALIGNED
003172 dfce              rcall   DP
003173 940c 3e51         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
003175 e2da              fdw     ALIGN_L
                 ALIGNED_L:
003176 6187
003177 696c
003178 6e67
003179 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00317a 9601              adiw    tosl, 1
00317b 7f8e              cbr     tosl, 1
00317c 9508              ret
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
00317d e2ec              fdw     ALIGNED_L
                 CELLPLUS_L:
00317e 63a5
00317f 6c65
003180 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003181 9602              adiw    tosl, 2
003182 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
003183 e2fc              fdw     CELLPLUS_L
                 CELLS_L:
003184 63a5
003185 6c65
003186 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
003187 0f88              lsl     tosl
003188 1f99              rol     tosh
003189 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
00318a e308              fdw     CELLS_L
                 CHARPLUS_L:
00318b 63a5
00318c 6168
00318d 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
00318e 9601              adiw    tosl, 1
00318f 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
003190 e316              fdw     CHARPLUS_L
                 CHARS_L:
003191 63a5
003192 6168
003193 7372              .db     NFA|INLINE|5,"chars"
003194 9508      CHARS:  ret
                 
003195 e322              fdw     CHARS_L
                 COMMAXT_L:
003196 6383
003197 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
003198 d648              rcall   DUP
003199 d674              rcall   IHERE
00319a d150              rcall   MINUS
00319b d13d              rcall   ABS_ 
00319c d63b              rcall   DOLIT
00319d 0ff0              .dw     0xff0
00319e d1f6              rcall   GREATER
00319f d25a              rcall   ZEROSENSE
0031a0 f049              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
0031a1 d636              rcall   DOLIT
                 .ifdef EIND
                 .else
0031a2 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
0031a3 940e 3f43         call    ICOMMA
0031a5 5890              sub_pflash_tos
0031a6 9488              rampv_to_c
0031a7 9597              ror     tosh
0031a8 9587              ror     tosl
0031a9 c006              rjmp    STORECF2
                 STORECF1:
0031aa d663              rcall   IHERE
0031ab d13f              rcall   MINUS
0031ac d73e              rcall   TWOMINUS
0031ad d1bc              rcall   TWOSLASH
                         ;rcall   RCALL_
0031ae 709f              andi    tosh, 0x0f
0031af 6d90              ori     tosh, 0xd0
                 STORECF2:
0031b0 940c 3f43         jmp    ICOMMA
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
0031b2 2182
0031b3 003a              .db     NFA|2,"!:",0
                 STORCOLON:
0031b4 d623              rcall   DOLIT
0031b5 fffa              .dw     0xfffa         ;  -6
0031b6 940c 39c7         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
0031b8 e32c              fdw     COMMAXT_L
                 TWOFETCH_L:
0031b9 3282
0031ba 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
0031bb d625              rcall   DUP
0031bc d55c              rcall   FETCH_A
0031bd d0e1              rcall   SWOP
0031be dfc2              rcall   CELLPLUS
0031bf 940c 3719         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
0031c1 e372              fdw     TWOFETCH_L
                 TWOSTORE_L:
0031c2 3282
0031c3 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
0031c4 d0da              rcall   SWOP
0031c5 d0e3              rcall   OVER
0031c6 dfba              rcall   CELLPLUS
0031c7 d3c7              rcall   STORE_A
0031c8 940c 3e51         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031ca e384              fdw     TWOSTORE_L
                 TWODROP_L:
0031cb 3285
0031cc 7264
0031cd 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031ce d0c9              rcall   DROP
0031cf 940c 3298         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031d1 e396              fdw     TWODROP_L
                 TWODUP_L:
0031d2 3284
0031d3 7564
0031d4 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031d5 d0d3              rcall   OVER
0031d6 940c 32a9         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031d8 e3a4              fdw     TWODUP_L
                 TWOSWAP_L:
0031d9 3285
0031da 7773
0031db 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031dc d0d4              rcall   ROT
0031dd d0db              rcall   TOR
0031de d0d2              rcall   ROT
0031df d0e3              rcall   RFROM
0031e0 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031e1 e3b2              fdw     TWOSWAP_L
                 SPACE_L:
0031e2 7385
0031e3 6170
0031e4 6563              .db     NFA|5,"space"
                 SPACE_:  
0031e5 d70a              rcall   BL
0031e6 940c 308b         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
0031e8 e3c4              fdw     SPACE_L
                 SPACES_L:
0031e9 7386
0031ea 6170
0031eb 6563
0031ec 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
0031ed d212              rcall   DUPZEROSENSE
0031ee f019              breq    SPCS2
0031ef dff5              rcall   SPACE_
0031f0 d163              rcall   ONEMINUS
0031f1 cffb              rjmp    SPCS1
0031f2 940c 3298 SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
0031f4 e3d2              fdw     SPACES_L
                 UMIN_L:
0031f5 7584
0031f6 696d
0031f7 006e              .db     NFA|4,"umin",0
                 UMIN:
0031f8 dfdc              rcall   TWODUP
0031f9 d1a8              rcall   UGREATER
0031fa c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
0031fb e3ea              fdw     UMIN_L
                 UMAX_L:
0031fc 7584
0031fd 616d
0031fe 0078              .db     NFA|4,"umax",0
                 UMAX:
0031ff dfd5              rcall   TWODUP
003200 d19a              rcall   ULESS
                 MINMAX:
003201 d1f8              rcall   ZEROSENSE
003202 f009              breq    UMAX1
003203 d09b              rcall   SWOP
003204 940c 3298 UMAX1:  jmp     DROP
                 
003206 e3f8              fdw     UMAX_L
                 ONE_L:
003207 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
003208 939a
003209 938a              pushtos
00320a e081              ldi     tosl, 1
00320b e090              ldi     tosh, 0
00320c 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
00320d e40e              fdw     ONE_L
                 ACCEPT_L:
00320e 6186
00320f 6363
003210 7065
003211 0074              .db     NFA|6,"accept",0
                 ACCEPT:
003212 d096              rcall   OVER
003213 d0ca              rcall   PLUS
003214 d094              rcall   OVER
                 ACC1:
003215 de7b              rcall   KEY
                 
003216 308d              cpi     tosl, CR_
003217 f429              brne    ACC_LF
                         
003218 d56a              rcall   TRUE_
003219 d02f              rcall   FCR
00321a d246              rcall   CSTORE_A
00321b d07c              rcall   DROP
00321c c026              rjmp    ACC6
                 ACC_LF:
00321d 308a              cpi     tosl, LF_
00321e f449              brne    ACC2
00321f d078              rcall   DROP
                 
003220 d028              rcall   FCR
003221 d23b              rcall   CFETCH_A
003222 d1d7              rcall   ZEROSENSE
003223 f0f9              breq    ACC6
003224 d555              rcall   FALSE_
003225 d023              rcall   FCR
003226 d23a              rcall   CSTORE_A
003227 cfed              rjmp    ACC1
                 ACC2:
003228 d551              rcall   FALSE_
003229 d01f              rcall   FCR
00322a d236              rcall   CSTORE_A
00322b d5b5              rcall   DUP
00322c de5e              rcall   EMIT
00322d d5b3              rcall   DUP
00322e d5a9              rcall   DOLIT
00322f 0008              .dw     BS_
003230 d15a              rcall   EQUAL
003231 d1c8              rcall   ZEROSENSE
003232 f039              breq    ACC3
003233 d064              rcall   DROP
003234 d11f              rcall   ONEMINUS
003235 d083              rcall   TOR
003236 d072              rcall   OVER
003237 d08b              rcall   RFROM
003238 dfc6              rcall   UMAX
003239 cfdb              rjmp    ACC1
                 ACC3:
00323a d06e              rcall   OVER
00323b d225              rcall   CSTORE_A
00323c d112              rcall   ONEPLUS
00323d d06b              rcall   OVER
00323e dfb9              rcall   UMIN
00323f df95              rcall   TWODUP
003240 d145              rcall   NOTEQUAL
003241 d1b8              rcall   ZEROSENSE
003242 f691              brne     ACC1
                 ACC6:
003243 d1f7              rcall   NIP
003244 d05a              rcall   SWOP
003245 940c 32eb         jmp     MINUS
                 
003247 6683
003248 7263              .db     NFA|3,"fcr"
                 FCR:
003249 d2cf              rcall   DOUSER
00324a fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
00324b e41c              fdw      ACCEPT_L
                 TYPE_L:
00324c 7484
00324d 7079
00324e 0065              .db     NFA|4,"type",0
                 TYPE:
00324f d069              rcall   TOR
003250 c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
003251 d32f              rcall   CFETCHPP
003252 de38              rcall   EMIT
                 TYPE2:
003253 940e 3a95         call    XNEXT
003255 f7d8              brcc    TYPE1
003256 911f              pop     t1
003257 910f              pop     t0
003258 940c 3298         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
00325a 2883
00325b 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
00325c 91ff              pop     zh
00325d 91ef              pop     zl
00325e 0fee              lsl     zl
00325f 1fff              rol     zh
003260 9105              lpm_    t0, z+
003261 939a
003262 938a              pushtos
003263 01cf              movw    tosl, zl
003264 5890              add_pflash_tos
003265 939a
003266 938a              pushtos
003267 2f80              mov     tosl, t0
003268 2799              clr     tosh
003269 0fe0              add     zl, t0
00326a 1ff9              adc     zh, tosh
00326b 9631              adiw    zl, 1
00326c 9488              rampv_to_c
00326d 95f7              ror     zh
00326e 95e7              ror     zl
00326f 9409              mijmp
                 
003270 e498              fdw     TYPE_L
                 SQUOTE_L:
003271 73d2
003272 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
003273 de84              rcall   DOCOMMAXT
003274 e4b8              fdw     XSQUOTE
003275 deb6              rcall   ROM_
003276 d005              rcall   CQUOTE
003277 940c 313a         jmp     FRAM
                 
003279 e4e2              fdw     SQUOTE_L
                 CQUOTE_L:
00327a 2c82
00327b 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
00327c d55b              rcall   DOLIT
00327d 0022              .dw     0x22
00327e d2c0              rcall   PARSE
00327f ded1              rcall   HERE
003280 d028              rcall   OVER
003281 d0cd              rcall   ONEPLUS
003282 def7              rcall   ALIGNED
003283 d00d              rcall   ALLOT
003284 940c 3578         jmp     PLACE
                 
                 
003286 e4f4              fdw     CQUOTE_L
                 DOTQUOTE_L:
003287 2ed2
003288 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
003289 dfe9              rcall   SQUOTE
00328a de6d              rcall   DOCOMMAXT
00328b e49e              fdw     TYPE
00328c 9508              ret
                 
00328d e50e              fdw     DOTQUOTE_L
                 ALLOT_L:
00328e 6185
00328f 6c6c
003290 746f              .db     NFA|5,"allot"
                 ALLOT:
003291 deaf              rcall   DP
003292 940c 3370         jmp     PLUSSTORE
                 
003294 e51c              fdw     ALLOT_L
                 DROP_L:
003295 64a4
003296 6f72
003297 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
003298 9189
003299 9199              poptos
00329a 9508              ret
                 
00329b e52a              fdw     DROP_L
                 SWOP_L:
00329c 7384
00329d 6177
00329e 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
00329f 9109              ld      t0, y+
0032a0 9119              ld      t1, y+
0032a1 939a
0032a2 938a              pushtos
0032a3 01c8              movw    tosl, t0
0032a4 9508              ret
                 
0032a5 e538              fdw     SWOP_L
                 OVER_L:
0032a6 6f84
0032a7 6576
0032a8 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
0032a9 939a
0032aa 938a              pushtos
0032ab 818a              ldd     tosl, y+2
0032ac 819b              ldd     tosh, y+3
0032ad 9508              ret
                 
0032ae e54c              fdw     OVER_L
                 ROT_L:
0032af 7283
0032b0 746f              .db     NFA|3, "rot"
                 ROT:
0032b1 d007              rcall   TOR
0032b2 dfec              rcall   SWOP
0032b3 d00f              rcall   RFROM
0032b4 940c 329f         jmp     SWOP
                 
0032b6 e55e              fdw     ROT_L
                 TOR_L:
0032b7 3e92
0032b8 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
0032b9 91ff              pop     zh
0032ba 91ef              pop     zl
0032bb 938f              push    tosl
0032bc 939f              push    tosh
0032bd 9189
0032be 9199              poptos
0032bf 9409              mijmp
                 
0032c0 e56e              fdw     TOR_L
                 RFROM_L:
0032c1 7292
0032c2 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
0032c3 91ff              pop     zh
0032c4 91ef              pop     zl
0032c5 939a
0032c6 938a              pushtos
0032c7 919f              pop     tosh
0032c8 918f              pop     tosl
0032c9 9409              mijmp
                 
0032ca e582              fdw     RFROM_L
                 RFETCH_L:
0032cb 7292
0032cc 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
0032cd 91ff              pop     zh
0032ce 91ef              pop     zl
0032cf 939a
0032d0 938a              pushtos
0032d1 919f              pop     tosh
0032d2 918f              pop     tosl
0032d3 938f              push    tosl
0032d4 939f              push    tosh
0032d5 9409              mijmp
                 
                 ;   ABS     n   --- n1      absolute value of n
0032d6 efbe              fdw     DUP_L
                 ABS_L:
0032d7 6183
0032d8 7362              .db     NFA|3,"abs"
                 ABS_:
0032d9 d507              rcall   DUP
0032da 940c 344a         jmp     QNEGATE
                 
0032dc e5ae              fdw     ABS_L
                 PLUS_L:
0032dd 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032de 9109              ld      t0, Y+        
0032df 9119              ld      t1, Y+
0032e0 0f80              add     tosl, t0
0032e1 1f91              adc     tosh, t1
0032e2 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032e3 e5ba              fdw     PLUS_L
                 MPLUS_L:
0032e4 6d82
0032e5 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032e6 d7d0              rcall   STOD
0032e7 940c 3ad9         jmp     DPLUS
                 
0032e9 e5c8              fdw     MPLUS_L
                 MINUS_L:
0032ea 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
0032eb 9109              ld      t0, Y+
0032ec 9119              ld      t1, Y+
0032ed 1b08              sub     t0, tosl
0032ee 0b19              sbc     t1, tosh
0032ef 01c8              movw    tosl, t0
0032f0 9508              ret
                 
                 FROM_LITBUF:
0032f1 9000 01f7         lds     r0, litbuf0
0032f3 9010 01f8         lds     r1, litbuf1
0032f5 9508              ret
                 PLUSC_:
0032f6 dffa              rcall   FROM_LITBUF
0032f7 9400              com     r0
0032f8 9410              com     r1
0032f9 0c06              add     r0, r_one
0032fa 1c15              adc     r1, r_zero
0032fb d00b              rcall   ANDIC1
0032fc c001              rjmp    MINUSC_1
                 MINUSC_:
0032fd d008              rcall   ANDIC0
                 MINUSC_1:
0032fe 6590              ori     tosh, 0x50
0032ff d021              rcall   ICOMMA_
003300 d4e0              rcall   DUP
003301 2d81              mov     tosl, r1
003302 d007              rcall   ANDIC2
003303 6980              ori     tosl, 0x90
003304 6490              ori     tosh, 0x40
003305 c01b              rjmp    ICOMMA_
                 ANDIC0:
003306 dfea              rcall   FROM_LITBUF
                 ANDIC1:
003307 d6f7              rcall   IDPMINUS
003308 d6f6              rcall   IDPMINUS
003309 2d80              mov     tosl, r0
                 ANDIC2:
00330a 2f98              mov     tosh, tosl
00330b 9592              swap    tosh
00330c 708f              andi    tosl, 0x0f
00330d 709f              andi    tosh, 0x0f
00330e 6880              ori     tosl, 0x80
00330f 9508              ret
                 ANDIC_:
003310 dff5              rcall   ANDIC0
003311 6790              ori     tosh, 0x70
003312 d00e              rcall   ICOMMA_
003313 d4cd              rcall   DUP
003314 2d81              mov     tosl, r1
003315 dff4              rcall   ANDIC2
003316 6980              ori     tosl, 0x90
003317 6790              ori     tosh, 0x70
003318 c008              rjmp    ICOMMA_
                 ORIC_:
003319 dfec              rcall   ANDIC0
00331a 6690              ori     tosh, 0x60
00331b d005              rcall   ICOMMA_
00331c d4c4              rcall   DUP
00331d 2d81              mov     tosl, r1
00331e dfeb              rcall   ANDIC2
00331f 6980              ori     tosl, 0x90
003320 6690              ori     tosh, 0x60
                 ICOMMA_:
003321 940c 3f43         jmp     ICOMMA
                 
003323 e5d4              fdw     MINUS_L
                 AND_L:
003324 6183
003325 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
003326 9109              ld      t0, Y+
003327 9119              ld      t1, Y+
003328 2380              and     tosl, t0
003329 2391              and     tosh, t1
00332a 9508              ret
                 
00332b e648              fdw     AND_L
                 OR_L:
00332c 6f82
00332d 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
00332e 9109              ld      t0, Y+
00332f 9119              ld      t1, Y+
003330 2b80              or      tosl, t0
003331 2b91              or      tosh, t1
003332 9508              ret
                 
003333 e658              fdw     OR_L
                 XOR_L:
003334 7883
003335 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
003336 9109              ld      t0, Y+
003337 9119              ld      t1, Y+
003338 2780              eor     tosl, t0
003339 2791              eor     tosh, t1
00333a 9508              ret
                 
00333b e668              fdw     XOR_L
                 INVERT_L:
00333c 69a6
00333d 766e
00333e 7265
00333f 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
003340 9580              com     tosl
003341 9590              com     tosh
003342 9508              ret
                 
003343 e678              fdw     INVERT_L
                 NEGATE_L:
003344 6e86
003345 6765
003346 7461
003347 0065              .db     NFA|6, "negate",0
                 NEGATE:
003348 9580              com     tosl
003349 9590              com     tosh
00334a 9601              adiw    tosl, 1
00334b 9508              ret
                 
00334c e688              fdw     NEGATE_L
                 ONEPLUS_L:
00334d 31a2
00334e 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
00334f 9601              adiw    tosl, 1
003350 9508              ret
                 
003351 e69a              fdw     ONEPLUS_L
                 ONEMINUS_L:
003352 31a2
003353 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
003354 9701              sbiw    tosl, 1
003355 9508              ret
                 
003356 e6a4              fdw     ONEMINUS_L
                 TWOPLUS_L:
003357 32a2
003358 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
003359 9602              adiw    tosl, 2
00335a 9508              ret
                 
00335b e6ae              fdw     TWOPLUS_L
                 TOBODY_L:
00335c 3ea5
00335d 6f62
00335e 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
00335f 9604              adiw    tosl, 4
003360 9508              ret
                 
003361 e6b8              fdw     TOBODY_L
                 TWOSTAR_L:
003362 32a2
003363 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003364 0f88              lsl     tosl
003365 1f99              rol     tosh
003366 9508              ret
                 
003367 e6c4              fdw     TWOSTAR_L
                 TWOSLASH_L:
003368 32a2
003369 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
00336a 9595              asr     tosh
00336b 9587              ror     tosl
00336c 9508              ret
                 
00336d e6d0              fdw     TWOSLASH_L
                 PLUSSTORE_L:
00336e 2b82
00336f 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
003370 df2e              rcall   SWOP
003371 df37              rcall   OVER
003372 d3a6              rcall   FETCH_A
003373 df6a              rcall   PLUS
003374 df2a              rcall   SWOP
003375 940c 3e51         jmp     STORE
                 
003377 e6dc              fdw     PLUSSTORE_L
                 WITHIN_L:
003378 7786
003379 7469
00337a 6968
00337b 006e              .db     NFA|6,"within",0
                 WITHIN:
00337c df2c              rcall   OVER
00337d df6d              rcall   MINUS
00337e df3a              rcall   TOR
00337f df6b              rcall   MINUS
003380 df42              rcall   RFROM
003381 940c 339b         jmp     ULESS
                 
003383 e6f0              fdw     WITHIN_L
                 NOTEQUAL_L:
003384 3c82
003385 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
003386 d004              rcall   EQUAL
003387 940c 37e7         jmp     ZEROEQUAL
                 
003389 efd8              fdw     ZEROLESS_L
                 EQUAL_L:
00338a 3d81              .db     NFA|1, "="
                 EQUAL:
00338b df5f              rcall   MINUS
00338c 940c 37e7         jmp     ZEROEQUAL
                 
                 
00338e e714              fdw     EQUAL_L
                 LESS_L:
00338f 3c81              .db     NFA|1,"<"
                 LESS:
003390 df5a              rcall   MINUS
003391 940c 37ee         jmp     ZEROLESS
                 
003393 e71e              fdw     LESS_L
                 GREATER_L:
003394 3e81              .db     NFA|1,">"
                 GREATER:
003395 df09              rcall   SWOP
003396 940c 3390         jmp     LESS
                 
003398 e728              fdw     GREATER_L
                 ULESS_L:
003399 7582
00339a 003c              .db     NFA|2,"u<",0
                 ULESS:
00339b df4f              rcall   MINUS       ; Carry is valid after MINUS
00339c 0b88              sbc     tosl, tosl
00339d 0b99              sbc     tosh, tosh
00339e 9508              ret
                 
00339f e732              fdw     ULESS_L
                 UGREATER_L:
0033a0 7582
0033a1 003e              .db     NFA|2, "u>",0
                 UGREATER:
0033a2 defc              rcall   SWOP
0033a3 940c 339b         jmp     ULESS
                 
0033a5 e740              fdw     UGREATER_L
                 STORE_P_L:
0033a6 2182
0033a7 0070              .db     NFA|2,"!p",0
                 STORE_P:
0033a8 01ac              movw    pl, tosl
0033a9 9189
0033aa 9199              poptos
0033ab 9508              ret
                 
0033ac e74c              fdw     STORE_P_L
                 STORE_P_TO_R_L:
0033ad 2194
0033ae 3e70
0033af 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
0033b0 91ff              pop     zh
0033b1 91ef              pop     zl
0033b2 934f              push    pl
0033b3 935f              push    ph
0033b4 01ac              movw    pl, tosl
0033b5 9189
0033b6 9199              poptos
0033b7 9409              mijmp
                 
0033b8 e75a              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
0033b9 7293
0033ba 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
0033bb 91ff              pop     zh
0033bc 91ef              pop     zl
0033bd 915f              pop     ph
0033be 914f              pop     pl
0033bf 9409              mijmp
                 
0033c0 e772              fdw     R_TO_P_L
                 PFETCH_L:
0033c1 7082
0033c2 0040              .db     NFA|2,"p@",0
                 PFETCH:
0033c3 939a
0033c4 938a              pushtos
0033c5 01ca              movw    tosl, pl
0033c6 940c 3e8b         jmp     FETCH
                 
0033c8 e782              fdw     PFETCH_L
                 PSTORE_L:
0033c9 7082
0033ca 0021              .db     NFA|2,"p!",0
                 PSTORE:
0033cb 939a
0033cc 938a              pushtos
0033cd 01ca              movw    tosl, pl
0033ce 940c 3e51         jmp     STORE
                 
0033d0 e792              fdw     PSTORE_L
                 PCSTORE_L:
0033d1 7083
0033d2 2163              .db     NFA|3,"pc!"
                 PCSTORE:
0033d3 939a
0033d4 938a              pushtos
0033d5 01ca              movw    tosl, pl
0033d6 940c 3ec0         jmp     CSTORE
                 
0033d8 e7a2              fdw     PCSTORE_L
                 PPLUS_L:
0033d9 70a2
0033da 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
0033db 0d46              add     pl, r_one
0033dc 1d55              adc     ph, r_zero
0033dd 9508              ret   
                 
0033de e7b2              fdw     PPLUS_L
                 PNPLUS_L:
0033df 7083
0033e0 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
0033e1 0f48              add     pl, tosl
0033e2 1f59              adc     ph, tosh
0033e3 9189
0033e4 9199              poptos
0033e5 9508              ret
                 
0033e6 e7be              fdw     PNPLUS_L
                 UEMIT_L:
0033e7 2785
0033e8 6d65
0033e9 7469              .db     NFA|5,"'emit"
                 UEMIT_:
0033ea d12e              rcall   DOUSER
0033eb ffe8              .dw     uemit
                         
0033ec e7ce              fdw     UEMIT_L
                 UKEY_L:
0033ed 2784
0033ee 656b
0033ef 0079              .db     NFA|4,"'key",0
                 UKEY_:
0033f0 d128              rcall   DOUSER
0033f1 ffea              .dw     ukey
                 
0033f2 e7da              fdw     UKEY_L
                 UKEYQ_L:
0033f3 2785
0033f4 656b
0033f5 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
0033f6 d122              rcall   DOUSER
0033f7 ffec              .dw     ukeyq
                 
0033f8 3f83
0033f9 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
0033fa 9700              sbiw    tosl, 0
0033fb 9189
0033fc 9199              poptos
0033fd 9508              ret
                 
0033fe 6483
0033ff 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
003400 9700              sbiw    tosl, 0
003401 9508              ret
                 
003402 e7e6              fdw     UKEYQ_L
                 UMSTAR_L:
003403 7583
003404 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
003405 940c 3f69         jmp     umstar0
                 
003407 e806              fdw     UMSTAR_L
                 UMSLASHMOD_L:
003408 7586
003409 2f6d
00340a 6f6d
00340b 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
00340c 940c 3f82         jmp     umslashmod0
                 
                 
00340e e810              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
00340f 7585
003410 6d2f
003411 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
003412 d367              rcall   FALSE_
003413 de8b              rcall   SWOP
003414 940c 3f82         jmp     umslashmod0
                 
003416 e81e              fdw     USLASHMOD_L
                 STAR_L:
003417 2a81              .db     NFA|1,"*"
                 STAR: 
003418 dfec              rcall   UMSTAR
003419 940c 3298         jmp     DROP
                 
00341b e82e              fdw     STAR_L
                 USLASH_L:
00341c 7582
00341d 002f              .db     NFA|2,"u/",0
                 USLASH:
00341e dff3              rcall   USLASHMOD
00341f 940c 343b         jmp     NIP
                 
003421 e838              fdw     USLASH_L
                 USSMOD_L:
003422 7586
003423 2f2a
003424 6f6d
003425 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
003426 de92              rcall   TOR
003427 dfdd              rcall   UMSTAR
003428 de9a              rcall   RFROM
003429 940c 340c         jmp     UMSLASHMOD
                 
                 
00342b e844              fdw     USSMOD_L
                 SLASH_L:
00342c 2f81              .db     NFA|1,"/"
                 SLASH: 
00342d dda7              rcall   TWODUP
00342e df07              rcall   XOR_
00342f de89              rcall   TOR
003430 dea8              rcall   ABS_
003431 de6d              rcall   SWOP
003432 dea6              rcall   ABS_
003433 de6b              rcall   SWOP
003434 dfe9              rcall   USLASH
003435 de8d              rcall   RFROM
003436 940c 344a         jmp     QNEGATE
                 
003438 e858              fdw     SLASH_L
                 NIP_L:
003439 6ea3
00343a 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
00343b 9109              ld      t0, y+
00343c 9109              ld      t0, y+
00343d 9508              ret
                     
00343e e872              fdw     NIP_L
                 TUCK_L:
00343f 7484
003440 6375
003441 006b              .db     NFA|4,"tuck",0
                 TUCK:
003442 de5c              rcall   SWOP
003443 940c 32a9         jmp     OVER
                 
003445 e87e              fdw     TUCK_L
                 QNEGATE_L:
003446 3f87
003447 656e
003448 6167
003449 6574              .db     NFA|7,"?negate"
                 QNEGATE:
00344a d3a3              rcall   ZEROLESS
00344b dfae              rcall   ZEROSENSE
00344c f009              breq    QNEGATE1
00344d defa              rcall   NEGATE
                 QNEGATE1:
00344e 9508              ret
                 
00344f e88c              fdw     QNEGATE_L
                 MAX_L:
003450 6d83
003451 7861              .db     NFA|3,"max"
003452 dd82      MAX:    rcall   TWODUP
003453 df3c              rcall   LESS
003454 cdac              rjmp    MINMAX
                 
003455 e8a0              fdw     MAX_L
                 MIN_L:
003456 6d83
003457 6e69              .db     NFA|3,"min"
003458 dd7c      MIN:    rcall   TWODUP
003459 df3b              rcall   GREATER
00345a cda6              rjmp    MINMAX
                 
00345b 6382
00345c 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
00345d 940c 3ea6         jmp     CFETCH
                 
00345f 6382
003460 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003461 940c 3ec0         jmp     CSTORE
                 
003463 e8ac              fdw     MIN_L
                 UPTR_L:
003464 7582
003465 0070              .db     NFA|2,"up",0
003466 dc79      UPTR:   rcall   DOCREATE
003467 0002              .dw     2 ; upl
                 
003468 e8c8              fdw     UPTR_L
                 HOLD_L:
003469 6884
00346a 6c6f
00346b 0064              .db     NFA|4,"hold",0
00346c d316      HOLD:   rcall   TRUE_
00346d d092              rcall   HP
00346e df01              rcall   PLUSSTORE
00346f d090              rcall   HP
003470 d2a8              rcall   FETCH_A
003471 940c 3ec0         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
003473 e8d2              fdw     HOLD_L
                 LESSNUM_L:
003474 3c82
003475 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
003476 d08e              rcall   PAD
003477 d088              rcall   HP
003478 940c 3e51         jmp     STORE
                 
                 ; digit   n -- c            convert to 0..9a..z
00347a e8e8              fdw     LESSNUM_L
                 TODIGIT_L:
00347b 6485
00347c 6769
00347d 7469              .db     NFA|5,"digit"
                 TODIGIT:
00347e 308a              cpi     tosl, 0xa
00347f f00c              brlt    TODIGIT1
003480 9687              adiw    tosl, 0x27
                 TODIGIT1:
003481 96c0              adiw    tosl, 0x30
003482 9508              ret
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
003483 e8f6              fdw     TODIGIT_L
                 NUM_L:
003484 2381              .db     NFA|1,"#"
                 NUM:
003485 d087              rcall   BASE
003486 d292              rcall   FETCH_A
003487 d182              rcall   UDSLASHMOD
003488 de28              rcall   ROT
003489 dff4              rcall   TODIGIT
00348a 940c 346c         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
00348c e908              fdw     NUM_L
                 NUMS_L:
00348d 2382
00348e 0073              .db     NFA|2,"#s",0
                 NUMS:
00348f dff5              rcall   NUM
003490 dd44              rcall   TWODUP
003491 de9c              rcall   OR_
003492 df67              rcall   ZEROSENSE
003493 f7d9              brne    NUMS
003494 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
003495 e91a              fdw     NUMS_L
                 NUMGREATER_L:
003496 2382
003497 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
003498 dd35              rcall   TWODROP
003499 d066              rcall   HP
00349a d27e              rcall   FETCH_A
00349b d069              rcall   PAD
00349c de0c              rcall   OVER
00349d 940c 32eb         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
00349f e92c              fdw     NUMGREATER_L
                 SIGN_L:
0034a0 7384
0034a1 6769
0034a2 006e              .db     NFA|4,"sign",0
                 SIGN:
0034a3 3090              cpi     tosh, 0
0034a4 f41a              brpl    SIGN1
0034a5 d332              rcall   DOLIT
0034a6 002d              .dw     0x2D
0034a7 dfc4              rcall   HOLD
                 SIGN1:
0034a8 940c 3298         jmp     DROP
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
0034aa e940              fdw     SIGN_L
                 UDOT_L:
0034ab 7582
0034ac 002e              .db     NFA|2,"u.",0
                 UDOT:
0034ad dfc8              rcall   LESSNUM
0034ae d2cb              rcall   FALSE_
0034af dfdf              rcall   NUMS
0034b0 dfe7              rcall   NUMGREATER
0034b1 dd9d              rcall   TYPE
0034b2 940c 31e5         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
0034b4 e956              fdw     UDOT_L
                 UDOTR_L:
0034b5 7583
0034b6 722e              .db     NFA|3,"u.r"
                 UDOTR:
0034b7 dfbe              rcall   LESSNUM
0034b8 de9b              rcall   ONEMINUS
0034b9 ddff              rcall   TOR
0034ba d2bf              rcall   FALSE_
0034bb c001              rjmp    UDOTR2
                 UDOTR1:
0034bc dfc8              rcall   NUM
                 UDOTR2: 
0034bd d5d7              rcall   XNEXT
0034be f7e8              brcc    UDOTR1
0034bf 911f              pop     t1
0034c0 910f              pop     t0
0034c1 dfcd              rcall   NUMS
0034c2 dfd5              rcall   NUMGREATER
0034c3 dd8b              rcall   TYPE
0034c4 940c 31e5         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
0034c6 e96a              fdw     UDOTR_L
                 DOT_L:
0034c7 2e81              .db     NFA|1,"."
0034c8 dfad      DOT:    rcall   LESSNUM
0034c9 d317              rcall   DUP
0034ca de0e              rcall   ABS_
0034cb d2ae              rcall   FALSE_
0034cc dfc2              rcall   NUMS
0034cd dde3              rcall   ROT
0034ce dfd4              rcall   SIGN
0034cf dfc8              rcall   NUMGREATER
0034d0 dd7e              rcall   TYPE
0034d1 940c 31e5         jmp     SPACE_
                 
0034d3 e98e              FDW     DOT_L
                 DECIMAL_L:
0034d4 6487
0034d5 6365
0034d6 6d69
0034d7 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
0034d8 d279              rcall   TEN
0034d9 d033              rcall   BASE
0034da 940c 3e51         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
0034dc e9a8              Fdw     DECIMAL_l
                 HEX_L:
0034dd 6883
0034de 7865              .db     NFA|3,"hex"
                 HEX:
0034df d2f8              rcall   DOLIT
0034e0 0010              .dw     16
0034e1 d02b              rcall   BASE
0034e2 940c 3e51         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
0034e4 e9ba              Fdw     HEX_L
                 BIN_L:
0034e5 6283
0034e6 6e69              .db     NFA|3,"bin"
0034e7 dc7f      BIN:    rcall   CELL
0034e8 d024              rcall   BASE
0034e9 940c 3e51         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
0034eb e9ca              fdw     BIN_L
                 RSAVE_L:
0034ec 7285
0034ed 6173
0034ee 6576              .db     NFA|5,"rsave"
0034ef d029      RSAVE_: rcall   DOUSER
0034f0 fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
0034f1 e9d8              fdw     RSAVE_L
                 ULINK_L:
0034f2 7585
0034f3 696c
0034f4 6b6e              .db     NFA|5,"ulink"
0034f5 d023      ULINK_: rcall   DOUSER
0034f6 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034f7 e9e4              fdw     ULINK_L
                 TASK_L:
0034f8 7484
0034f9 7361
0034fa 006b              .db     NFA|4,"task",0
0034fb d01d      TASK:   rcall   DOUSER
0034fc fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034fd e9f0              fdw     TASK_L
                 HP_L:
0034fe 6882
0034ff 0070              .db     NFA|2,"hp",0
003500 d018      HP:     rcall   DOUSER
003501 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
003502 e9fc              fdw     HP_L
                 PAD_L:
003503 7083
003504 6461              .db     NFA|3,"pad"
                 PAD:
003505 d17b              rcall   TIB
003506 d172              rcall   TIBSIZE
003507 940c 32de         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
003509 ea06              fdw     PAD_L
                 BASE_L:
00350a 6284
00350b 7361
00350c 0065              .db     NFA|4,"base",0
                 BASE:
00350d d00b              rcall   DOUSER
00350e ffee              .dw     ubase
                 
                 ; USER   n --
00350f ea14              fdw     BASE_L
                 USER_L:
003510 7584
003511 6573
003512 0072              .db     NFA|4,"user",0
                 USER:
003513 d317              rcall   CREATE
003514 dc52              rcall   CELL
003515 de32              rcall   NEGATE
003516 d4b0              rcall   IALLOT
003517 de09              rcall   ICOMMA_
003518 d364              rcall   XDOES
                 DOUSER:
                         m_pop_zh
003519 91ff              pop     zh
00351a 91ef              pop     zl
00351b dbd3              rcall   FETCHLIT
00351c 0d82              add     tosl, upl
00351d 1d93              adc     tosh, uph
00351e 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
00351f ea20              fdw     USER_L
                 SOURCE_L:
003520 7386
003521 756f
003522 6372
003523 0065              .db     NFA|6,"source",0
                 SOURCE:
003524 d16e              rcall   TICKSOURCE
003525 940c 31bb         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
003527 ea40              fdw      SOURCE_L
                 SLASHSTRING_L:
003528 2f87
003529 7473
00352a 6972
00352b 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
00352c dd72              rcall   SWOP
00352d dd7b              rcall   OVER
00352e ddbc              rcall   MINUS
00352f dd89              rcall   TOR
003530 ddad              rcall   PLUS
003531 dd91              rcall   RFROM
003532 9508              ret
                 
                 ; \     Skip the rest of the line
003533 ea50              fdw     SLASHSTRING_L
                 BSLASH_L:
003534 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
003535 dfee              rcall   SOURCE
003536 d155              rcall   TOIN
003537 d057              rcall   STORE_A
003538 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
003539 940c 3298         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
00353b ea68              fdw     BSLASH_L
                 PARSE_L:
00353c 7085
00353d 7261
00353e 6573              .db     NFA|5,"parse"
                 PARSE:
00353f d2a1              rcall   DUP             ; c c
003540 dfe3              rcall   SOURCE          ; c c a u
003541 d14a              rcall   TOIN            ; c c a u a
003542 d1d6              rcall   FETCH_A         ; c c a u n
003543 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
003544 938f              push    tosl
003545 939f              push    tosh            ; c c a u                  R: u (new tib len
003546 dd6a              rcall   ROT             ; c a u c
003547 daea              rcall   SKIP            ; c a u        
003548 dd60              rcall   OVER            ; c a u a
003549 dd6f              rcall   TOR             ; c a u                    R: u a (start of word
00354a dd66              rcall   ROT             ; a u c
00354b db01              rcall   SCAN            ; a u      end of word, tib left       
00354c deb3              rcall   DUPZEROSENSE
00354d f009              breq    PARSE1
00354e de05              rcall   ONEMINUS
00354f dd73      PARSE1: rcall   RFROM           ; a u a
003550 dd72              rcall   RFROM           ; a u a u
003551 dd5f              rcall   ROT             ; a a u u
003552 dd98              rcall   MINUS           ; a a n  ( addition to toin
003553 d138              rcall   TOIN
003554 de1b              rcall   PLUSSTORE       ; aend astart
003555 deec              rcall   TUCK            ; astart aend astart
003556 940c 32eb         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
003558 ea78              fdw     PARSE_L
                 WORD_L:
003559 7784
00355a 726f
00355b 0064              .db     NFA|4,"word",0
                 WORD:
00355c dfe2              rcall   PARSE           ; c-addr wlen
00355d dd41              rcall   SWOP
00355e ddf5              rcall   ONEMINUS
00355f dee2              rcall   TUCK
003560 940c 3ec0         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
003562 eab2              fdw     WORD_L
                 CMOVE_L:
003563 6385
003564 6f6d
003565 6576              .db     NFA|5,"cmove"
                 CMOVE:
003566 dd38              rcall   SWOP
003567 de48              rcall   STORE_P_TO_R
003568 dd50              rcall   TOR
003569 c003              rjmp    CMOVE2
                 CMOVE1:
00356a d016              rcall   CFETCHPP
00356b de67              rcall   PCSTORE
00356c de6e              rcall   PPLUS
                 CMOVE2:
00356d d527              rcall   XNEXT
00356e f7d8              brcc    CMOVE1
00356f 911f              pop     t1
003570 910f              pop     t0
003571 de49              rcall   R_TO_P
003572 940c 3298         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
003574 eac6              fdw     CMOVE_L
                 PLACE_L:
003575 7085
003576 616c
003577 6563              .db     NFA|5,"place"
                 PLACE: 
003578 dc5c              rcall   TWODUP
003579 dee7              rcall   CSTORE_A
00357a dc13              rcall   CHARPLUS
00357b dd23              rcall   SWOP
00357c 940c 3566         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
00357e eaea              fdw     PLACE_L
                 CFETCHPP_L:
00357f 6383
003580 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
003581 d25f              rcall   DUP
003582 ddcc              rcall   ONEPLUS
003583 dd1b              rcall   SWOP
003584 940c 3ea6         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
003586 eafe              fdw     CFETCHPP_L
                 FETCHPP_L:
003587 4082
003588 002b              .db     NFA|2,"@+",0
                 FETCHPP:
003589 d257              rcall   DUP
00358a ddce              rcall   TWOPLUS
00358b dd13              rcall   SWOP
00358c 940c 3e8b         jmp     FETCH
                 
00358e 2181              .db     NFA|1,"!"
                 STORE_A:        
00358f 940c 3e51         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
003591 eb0e              fdw    FETCHPP_L
                 NTOC_L:
003592 6e83
003593 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
003594 dfec              rcall   CFETCHPP
003595 708f              andi    tosl, 0x0f
003596 dd47              rcall   PLUS
003597 940c 317a         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
003599 eb24              fdw    NTOC_L
                 CTON_L:
00359a 6383
00359b 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
00359c d34e              rcall   TWOMINUS
00359d d243              rcall   DUP
00359e debe              rcall   CFETCH_A
00359f 940e 3e4a         call    TO_A
0035a1 ff27              sbrs    al, 7
0035a2 f3c9              breq    CFATONFA
0035a3 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
0035a4 eb34              fdw     CTON_L
                 BRACFIND_L:
0035a5 2883
0035a6 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
0035a7 dc2d              rcall   TWODUP
0035a8 da66              rcall   NEQUAL
0035a9 de56              rcall   DUPZEROSENSE
0035aa f021              breq    findi2
0035ab dcec              rcall   DROP
0035ac d33e              rcall   TWOMINUS ;;;      NFATOLFA
0035ad d16b              rcall   FETCH_A
0035ae d232              rcall   DUP
                 findi2:
0035af de4a              rcall   ZEROSENSE
0035b0 f7b1              brne    findi1
0035b1 de4e              rcall   DUPZEROSENSE
0035b2 f041              breq    findi3
0035b3 de87              rcall   NIP
0035b4 d22c              rcall   DUP
0035b5 dfde              rcall   NFATOCFA
0035b6 dce8              rcall   SWOP
0035b7 d009              rcall   IMMEDQ
0035b8 d22e              rcall   ZEROEQUAL
0035b9 dc4e              rcall   ONE
0035ba dd73              rcall   OR_
                 findi3: 
0035bb 9508              ret
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
0035bc eb4a              fdw     BRACFIND_L
                 IMMEDQ_L:
0035bd 6986
0035be 6d6d
0035bf 6465
0035c0 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
0035c1 de9b              rcall   CFETCH_A
0035c2 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
0035c3 7480              andi    tosl, IMMED
0035c4 9508              ret
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
0035c5 eb7a              fdw     IMMEDQ_L
                 FIND_L:
0035c6 6684
0035c7 6e69
0035c8 0064              .db     NFA|4,"find",0
                 FIND:   
0035c9 d20e              rcall   DOLIT
0035ca f6e6              fdw     kernellink
0035cb dfdb              rcall   findi
0035cc de33              rcall   DUPZEROSENSE
0035cd f421              brne    FIND1
0035ce dcc9              rcall   DROP
0035cf d333              rcall   LATEST_
0035d0 d148              rcall   FETCH_A
0035d1 dfd5              rcall   findi
                 FIND1:
0035d2 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
0035d3 eb8c              fdw     FIND_L
                 DIGITQ_L:
0035d4 6486
0035d5 6769
0035d6 7469
0035d7 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 0x31    a = 0x61
0035d8 3480              cpi     tosl, 0x40
0035d9 f00c              brlt    DIGITQ1
0035da 9787              sbiw    tosl, 0x27
                 DIGITQ1:        
0035db 97c0              sbiw    tosl, 0x30      ; 1
0035dc f40a              brpl    DIGITQ2
0035dd c19c              rjmp    FALSE_
                 DIGITQ2:
0035de d202              rcall   DUP             ; 1 1
0035df df2d              rcall   BASE            ; 1 1 base
0035e0 d138              rcall   FETCH_A         ; 1 1 10
0035e1 940c 3390         jmp     LESS            ; 1 ffff
                 
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035e3 eba8              fdw     DIGITQ_L
                 SIGNQ_L:
0035e4 7385
0035e5 6769
0035e6 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035e7 dcc1              rcall   OVER
0035e8 de74              rcall   CFETCH_A
0035e9 2f08              mov     t0, tosl
0035ea dcad              rcall   DROP
0035eb 320d              cpi     t0, '-'
0035ec f019              breq    SIGNQMINUS
0035ed 320b              cpi     t0, '+'
0035ee f019              breq    SIGNQPLUS
0035ef c003              rjmp    SIGNQEND
                 SIGNQMINUS:
0035f0 d004              rcall   SLASHONE
0035f1 c191              rjmp    TRUE_
                 SIGNQPLUS:
0035f2 d002              rcall   SLASHONE
                 SIGNQEND:
0035f3 940c 377a         jmp     FALSE_
                 SLASHONE:
0035f5 dc12              rcall   ONE
0035f6 940c 352c         jmp     SLASHSTRING
                 
                 ; UD*  ud u -- ud
0035f8 ebc8              fdw     SIGNQ_L
                 UDSTAR_L:
0035f9 7583
0035fa 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035fb 938f              push    tosl
0035fc 939f              push    tosh
0035fd de07              rcall   UMSTAR
0035fe dc99              rcall   DROP
0035ff dc9f              rcall   SWOP
003600 dcc2              rcall   RFROM
003601 de03              rcall   UMSTAR
003602 dcae              rcall   ROT
003603 940c 32de         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
003605 ebf2              fdw     UDSTAR_L
                 UDSLASHMOD_L:
003606 7586
003607 2f64
003608 6f6d
003609 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
00360a dcae              rcall   TOR             ; ud.l ud.h 
00360b d16e              rcall   FALSE_          ; ud.l ud.h 0
00360c dcc0              rcall   RFETCH          ; ud.l ud.h 0 u
00360d ddfe              rcall   UMSLASHMOD      ; ud.l r.h q.h
00360e dca2              rcall   ROT             ; r.h q.h ud.l
00360f dca1              rcall   ROT             ; q.h ud.l r.h
003610 dcb2              rcall   RFROM           ; q.h ud.l r.h u
003611 ddfa              rcall   UMSLASHMOD      ; q.h r.l q.l
003612 940c 32b1         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
003614 ec0c              fdw     UDSLASHMOD_L
                 TONUMBER_L:
003615 3e87
003616 756e
003617 626d
003618 7265              .db     NFA|7,">number"
                 TONUMBER:
003619 e021              ldi     al, 1
                 TONUM1:
00361a dde5              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
00361b f0d1              breq    TONUM3
00361c dc9c              rcall   TOR
00361d 938f              push    tosl             ; dup >r
00361e 939f              push    tosh             ; ud.l ud.h adr
00361f de3d              rcall   CFETCH_A
003620 328e              cpi     tosl, '.'
003621 f079              breq    TONUM_SKIP
003622 dfb5              rcall   DIGITQ          ; ud.l ud.h digit flag
003623 ddd6              rcall   ZEROSENSE
003624 f421              brne    TONUM2
003625 dc72              rcall   DROP
003626 dc9c              rcall   RFROM
003627 dc9b              rcall   RFROM
003628 c00d              rjmp    TONUM3
                 TONUM2: 
003629 dc8f              rcall   TOR             ; ud.l ud.h digit
00362a dee2              rcall   BASE
00362b d0ed              rcall   FETCH_A
00362c dfce              rcall   UDSTAR
00362d dc95              rcall   RFROM
00362e dcb7              rcall   MPLUS
00362f e020              ldi     al, 0
003630 c001              rjmp    TONUM_CONT
                 TONUM_SKIP:
003631 dc66              rcall   DROP
                 TONUM_CONT:
003632 dc90              rcall   RFROM
003633 dc8f              rcall   RFROM
003634 dfc0              rcall   SLASHONE
003635 cfe4              rjmp    TONUM1
                 TONUM3:
003636 0f82              add     tosl, al
003637 9508              ret
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
003638 ec2a              fdw     TONUMBER_L
                 NUMBERQ_L:
003639 6e87
00363a 6d75
00363b 6562
00363c 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
00363d d1a3              rcall   DUP             ; a a
00363e d13b              rcall   FALSE_          ; a a 0 0
00363f d13a              rcall   FALSE_          ; a a 0 0
003640 dc70              rcall   ROT             ; a 0 0 a
003641 df3f              rcall   CFETCHPP        ; a 0 0 a' u
003642 dfa4              rcall   SIGNQ           ; a 0 0 a' u f
003643 dc75              rcall   TOR             ; a 0 0 a' u
                 
003644 dec8              rcall   BASE
003645 d0d3              rcall   FETCH_A
003646 dc72              rcall   TOR             ; a 0 0 a' u
                         
003647 dc61              rcall   OVER
003648 de14              rcall   CFETCH_A
                         
003649 9783              sbiw    tosl, '#'
00364a 3083              cpi     tosl, 3
00364b f438              brsh    BASEQ1
                 
00364c db3a              rcall   CELLS
00364d d18a              rcall   DOLIT
00364e ff44              fdw     BASEQV
00364f dc8e              rcall   PLUS
003650 da5a              rcall   FEXECUTE
                 
003651 dfa3              rcall   SLASHONE
003652 c001              rjmp    BASEQ2
                 BASEQ1:
003653 dc44              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
003654 dfc4              rcall   TONUMBER        ; a ud.l ud.h  a' u
003655 dc6d              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
003656 deb6              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
003657 df37              rcall   STORE_A         ; a ud.l ud.h  a' u
003658 dda1              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
003659 f029              breq    QNUMD
                 QNUM_ERR:                       ; Not a number
00365a dc68              rcall   RFROM           ; a ud.l ud.h a' u sign
00365b db72              rcall   TWODROP
00365c db71              rcall   TWODROP
00365d d11c              rcall   FALSE_          ; a 0           Not a number
00365e c011              rjmp    QNUM3
                 QNUMD:                          ; Single or Double number
                                                 ; a ud.l ud.h a'
00365f 9701              sbiw    tosl, 1
003660 ddfc              rcall   CFETCH_A        ; a ud.l ud.h c
003661 940e 3e4a         call    TO_A
003663 dc5f              rcall   RFROM           ; a a' u ud.l ud.d sign
003664 dd95              rcall   ZEROSENSE
003665 f009              breq    QNUMD1
003666 d458              rcall   DNEGATE
                 QNUMD1:
003667 322e              cpi     al, '.'         ; a d.l d.h
003668 f421              brne    QNUM1
003669 dc47              rcall   ROT             ; d.l d.h a
00366a e082              ldi     tosl, 2
00366b e090              ldi     tosh, 0         ; d.l d.h 2    Double number
00366c c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a d.l d.h
00366d dc2a              rcall   DROP            ; a n
00366e ddcc              rcall   NIP             ; n
00366f db98              rcall   ONE             ; n 1           Single number
                 QNUM3:  
003670 9508              ret
                 
                 
003671 7384
003672 6177
003673 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003674 940c 329f         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003676 ec72              fdw     NUMBERQ_L
                 TIBSIZE_L:
003677 7483
003678 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
003679 de81              rcall   TASK
00367a d09e              rcall   FETCH_A
00367b 9608              adiw    tosl, 8
00367c 940c 3e8b         jmp     FETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00367e ecee              fdw     TIBSIZE_L
                 TIB_L:
00367f 7483
003680 6269              .db     NFA|3,"tib"
                 TIB:
003681 d005              rcall   TIU
003682 940c 3e8b         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003684 ecfe              fdw     TIB_L
                 TIU_L:
003685 7483
003686 7569              .db     NFA|3,"tiu"
                 TIU:
003687 de91              rcall   DOUSER
003688 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
003689 ed0a              fdw     TIU_L
                 TOIN_L:
00368a 3e83
00368b 6e69              .db     NFA|3,">in"
                 TOIN:
00368c de8c              rcall   DOUSER
00368d fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00368e ed14              fdw     TOIN_L
                 TICKSOURCE_L:
00368f 2787
003690 6f73
003691 7275
003692 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
003693 de85              rcall   DOUSER
003694 fff6              .dw     usource       ; two cells !!!!!!
                 
                 WORDQ:
003695 d14b              rcall   DUP
                         m_pop_t0
003696 91ff              pop     zh
003697 91ef              pop     zl
003698 da56              rcall   FETCHLIT
003699 95f7              ror     zh
00369a 95e7              ror     zl
00369b dcef              rcall   EQUAL
00369c dd5d              rcall   ZEROSENSE
00369d 9409              mijmp
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
00369e ed1e              fdw     TICKSOURCE_L
                 INTERPRET_L:
00369f 6989
0036a0 746e
0036a1 7265
0036a2 7270
0036a3 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
0036a4 dfee              rcall   TICKSOURCE
0036a5 db1e              rcall   TWOSTORE
0036a6 d0d3              rcall   FALSE_
0036a7 dfe4              rcall   TOIN
0036a8 dee6              rcall   STORE_A
                 IPARSEWORD:
0036a9 d6bd              rcall   INIT_012
0036aa d245              rcall   BL
0036ab deb0              rcall   WORD
                 
0036ac d134              rcall   DUP
0036ad ddaf              rcall   CFETCH_A
0036ae dd4b              rcall   ZEROSENSE
0036af f409              brne    IPARSEWORD1
0036b0 c064              rjmp    INOWORD
                 IPARSEWORD1:
0036b1 df17              rcall   FIND            ; sets also wflags
0036b2 dd4d              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
0036b3 f409              brne    IPARSEWORD2     ; NUMBER?
0036b4 c045              rjmp    INUMBER
                 IPARSEWORD2:
0036b5 dc99              rcall   ONEPLUS         ; 0 = normal 2 = immediate
0036b6 d240              rcall   STATE_
0036b7 d12f              rcall   ZEROEQUAL
0036b8 dc75              rcall   OR_
0036b9 dd40              rcall   ZEROSENSE
0036ba f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
0036bb fe94              sbrs    wflags, 4       ; Compile only check
0036bc c00a              rjmp    IEXECUTE        ; Not a compile only word
0036bd d239              rcall   STATE_          ; Compile only word check
0036be db9d              rcall   XSQUOTE
0036bf 430c
0036c0 4d4f
0036c1 4950
0036c2 454c
0036c3 4f20
0036c4 4c4e
0036c5 0059              .db     12,"COMPILE ONLY",0
0036c6 d0fd              rcall   QABORT
                 IEXECUTE:
0036c7 7b6f              cbr     FLAGS1, (1<<noclear)
0036c8 d9d7              rcall   EXECUTE
0036c9 fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
0036ca cfde              rjmp    IPARSEWORD
0036cb 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036cc 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036cd c02a              rjmp    ICLRFLIT
                 ICOMPILE_1:
0036ce 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036cf dfc5              rcall   WORDQ
0036d0 efce              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
0036d1 f011              breq    ICOMPILE_2
0036d2 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
0036d3 c020              rjmp    ICOMMAXT
                 ICOMPILE_2:
0036d4 ff67              sbrs    FLAGS1, fLIT
0036d5 c014              rjmp    ICOMPILE_6
0036d6 dfbe              rcall   WORDQ
0036d7 e64c              fdw     AND_    
0036d8 f011              breq    ICOMPILE_3
0036d9 dc36              rcall   ANDIC_
0036da c01d              rjmp    ICLRFLIT
                 ICOMPILE_3:
0036db dfb9              rcall   WORDQ
0036dc e65c              fdw     OR_
0036dd f011              breq    ICOMPILE_4
0036de dc3a              rcall   ORIC_
0036df c018              rjmp    ICLRFLIT
                 ICOMPILE_4:
0036e0 dfb4              rcall   WORDQ
0036e1 e5bc              fdw     PLUS
0036e2 f011              breq    ICOMPILE_5
0036e3 dc12              rcall   PLUSC_
0036e4 c013              rjmp    ICLRFLIT
                 ICOMPILE_5:
0036e5 dfaf              rcall   WORDQ
0036e6 e5d6              fdw     MINUS
0036e7 f011              breq    ICOMPILE_6
0036e8 dc14              rcall   MINUSC_
0036e9 c00e              rjmp    ICLRFLIT
                 ICOMPILE_6:
0036ea 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036eb dfa9              rcall   WORDQ
0036ec efc2              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
0036ed f009              breq    ICOMPILE
0036ee 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036ef fe95              sbrs    wflags, 5       ; Inline check
0036f0 c003              rjmp    ICOMMAXT
0036f1 940e 3a6c         call    INLINE0
0036f3 c004              rjmp    ICLRFLIT
                 ICOMMAXT:
0036f4 d125              rcall   COMMAXT_A
0036f5 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
0036f6 fc94              sbrc    wflags, 4            ; Compile only ?
0036f7 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
                 ICLRFLIT:
0036f8 776f              cbr     FLAGS1, (1<<fLIT)
0036f9 cfaf              rjmp    IPARSEWORD
                 INUMBER: 
0036fa 746f              cbr     FLAGS1, (1<<izeroeq) | (1<<idup) | (1<<fLIT)
0036fb db9c              rcall   DROP
0036fc df40              rcall   NUMBERQ
0036fd dd02              rcall   DUPZEROSENSE
0036fe f081              breq    IUNKNOWN
0036ff d1f7              rcall   STATE_
003700 dcf9              rcall   ZEROSENSE
003701 f059              breq    INUMBER1
003702 2f08              mov     t0, tosl
003703 9189
003704 9199              poptos
003705 ff01              sbrs    t0, 1
003706 c003              rjmp    ISINGLE
                 IDOUBLE:
003707 df6c              rcall   SWOP_A
003708 940e 3e22         call    LITERAL
                 ISINGLE:        
00370a 940e 3e22         call    LITERAL
00370c cf9c              rjmp    IPARSEWORD
                 
                 INUMBER1:
00370d db8a              rcall   DROP
00370e cfe9              rjmp    ICLRFLIT
                 
                 IUNKNOWN:
00370f db88              rcall   DROP 
003710 d045              rcall   DP_TO_RAM
003711 de6f              rcall   CFETCHPP
003712 db3c              rcall   TYPE
003713 d066              rcall   FALSE_
003714 d0a6              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
003715 d651              rcall   INIT_012
003716 940c 3298         jmp     DROP
                 
003718 4081              .db     NFA|1,"@"
                 FETCH_A:        
003719 940c 3e8b         jmp     FETCH
                 
                 ;;;    bitmask -- 
00371b ed3e              fdw     INTERPRET_L
                 SHB_L:
00371c 7383
00371d 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
00371e d1e4              rcall   LATEST_
00371f dff9              rcall   FETCH_A
003720 d0c0              rcall   DUP
003721 dd3b              rcall   CFETCH_A
003722 db8e              rcall   ROT
003723 dc0a              rcall   OR_
003724 df4f              rcall   SWOP_A
003725 940c 3ec0         jmp     CSTORE
                         
003727 ee38              fdw     SHB_L
                 IMMEDIATE_L:
003728 6989
003729 6d6d
00372a 6465
00372b 6169
00372c 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
00372d d0aa              rcall   DOLIT
00372e 0040              .dw     IMMED
00372f 940c 371e         jmp     SHB
                 
                 ;***************************************************************
003731 ee50              fdw     IMMEDIATE_L
                 INLINED_L:
003732 6987
003733 6c6e
003734 6e69
003735 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
003736 d0a1              rcall   DOLIT
003737 0020              .dw     INLINE
003738 940c 371e         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
00373a ee64              fdw     INLINED_L
                 DOTSTATUS_L:
00373b 2e83
00373c 7473              .db     NFA|3,".st"
                 DOTSTATUS:
00373d d09a              rcall   DOLIT
00373e 003c              .dw     '<'
00373f d94b              rcall   EMIT
003740 940e 3f55         call    DOTBASE
003742 d948              rcall   EMIT
003743 d094              rcall   DOLIT
003744 002c              .dw     ','
003745 d945              rcall   EMIT
003746 940e 2fa0         call    MEMQ
003748 db06              rcall   TYPE
003749 d08e              rcall   DOLIT
00374a 003e              .dw     '>'
00374b d93f              rcall   EMIT
00374c 940c 3986         jmp     DOTS
                 
00374e 3e82
00374f 0072              .db     NFA|2,">r",0
003750 940c 32b9 TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
                 ;        .db     NFA|1,"a"
                 TEN:
003752 d98d              rcall   DOCREATE
003753 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
003754 6483
003755 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
003756 d081              rcall   DOLIT
003757 0900              .dw     dp_start
003758 d1b9              rcall   INI
003759 dff8              rcall   TEN
00375a 940c 3566         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
00375c 3e83
00375d 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
00375e d079              rcall   DOLIT
00375f 0900              .dw     dp_start
003760 dc4f              rcall   STORE_P_TO_R
003761 d1b0              rcall   INI
003762 d075              rcall   DOLIT
003763 0004              .dw     4
003764 db54              rcall   TOR
                 DP_TO_EEPROM_0: 
003765 de23              rcall   FETCHPP
003766 d07a              rcall   DUP
003767 dc5b              rcall   PFETCH
003768 dc1d              rcall   NOTEQUAL
003769 dc90              rcall   ZEROSENSE
00376a f011              breq    DP_TO_EEPROM_1
                 .if DEBUG_FLASH == 1
                 .endif
00376b dc5f              rcall   PSTORE
00376c c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
00376d db2a              rcall   DROP
                 DP_TO_EEPROM_2:
00376e d406              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
00376f d325              rcall   XNEXT
003770 f7a0              brcc    DP_TO_EEPROM_0
003771 911f              pop     t1
003772 910f              pop     t0
003773 dc47              rcall   R_TO_P
003774 940c 3298         jmp     DROP
                 
003776 ee76              fdw     DOTSTATUS_L
                 FALSE_L:
003777 6685
003778 6c61
003779 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
00377a 939a
00377b 938a              pushtos
00377c 2788              clr     tosl
00377d 2799              clr     tosh
00377e 9508              ret
                 
00377f eeee              fdw     FALSE_L
                 TRUE_L:
003780 7484
003781 7572
003782 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
003783 939a
003784 938a              pushtos
003785 ef8f              ser     tosl
003786 ef9f              ser     tosh
003787 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
003788 ef00              fdw     TRUE_L
                 QUIT_L:
003789 7184
00378a 6975
00378b 0074              .db     NFA|4,"quit",0
                 QUIT:
00378c d981              rcall   RPEMPTY
00378d d10a              rcall   LEFTBRACKET
00378e d9ab              rcall   FRAM
                 QUIT0:  
                         ;; Copy INI and DP's from eeprom to ram
00378f dfc6              rcall   DP_TO_RAM
                 QUIT1: 
003790 d8e8              rcall   check_sp
003791 d08d              rcall   CR
003792 deee              rcall   TIB
003793 d04d              rcall   DUP
003794 dee4              rcall   TIBSIZE
003795 970a              sbiw    tosl, 10     ; Reserve 10 bytes for hold buffer
003796 da7b              rcall   ACCEPT
003797 da4d              rcall   SPACE_
003798 df0b              rcall   INTERPRET
003799 d15d              rcall   STATE_
00379a dc5f              rcall   ZEROSENSE
00379b f7a1              brne    QUIT1
00379c d5b9              rcall   IFLUSH
00379d dfc0              rcall   DP_TO_EEPROM
                          
00379e dabd              rcall    XSQUOTE
00379f 2003
0037a0 6b6f              .db     3," ok"
0037a1 daad              rcall    TYPE
0037a2 d007              rcall   PROMPT_
0037a3 940c 378f         jmp     QUIT0
                 
                 
0037a5 ef12              fdw     QUIT_L
                 PROMPT_L:
0037a6 7086
0037a7 6f72
0037a8 706d
0037a9 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
0037aa 940e 3ef8         call    DEFER_DOES
0037ac 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
0037ad ef4c              fdw     PROMPT_L
                 ABORT_L:
0037ae 6185
0037af 6f62
0037b0 7472              .db     NFA|5,"abort"
                 ABORT:
0037b1 d157              rcall   S0
0037b2 df66              rcall   FETCH_A
0037b3 d956              rcall   SPSTORE
0037b4 940c 378c         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
0037b6 ef5c              fdw     ABORT_L
                 QABORTQ_L:
0037b7 3f87
0037b8 6261
0037b9 726f
0037ba 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
0037bb daa0              rcall   XSQUOTE
0037bc 3f01              .db     1,"?"
0037bd 940c 37c4         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
0037bf ef6e              fdw     QABORTQ_L
                 QABORT_L:
0037c0 3f86
0037c1 6261
0037c2 726f
0037c3 0074              .db     NFA|6,"?abort",0
                 QABORT:
0037c4 daec              rcall   ROT
0037c5 dc34              rcall   ZEROSENSE
0037c6 f419              brne    QABO1
                 QABORT1:        
0037c7 da1d              rcall   SPACE_
0037c8 da86              rcall   TYPE
0037c9 dfe7              rcall   ABORT  ; ABORT never returns
0037ca 940c 31ce QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
0037cc ef80              fdw     QABORT_L
                 ABORTQUOTE_L:
0037cd 61d6
0037ce 6f62
0037cf 7472
0037d0 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
0037d1 daa1              rcall   SQUOTE
0037d2 d925              rcall   DOCOMMAXT
0037d3 ef88              fdw     QABORT
0037d4 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
0037d5 ef9a              fdw     ABORTQUOTE_L
                 DOLIT_L:
0037d6 6c83
0037d7 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
0037d8 91ff              pop     zh
0037d9 91ef              pop     zl
0037da d914              rcall   FETCHLIT
0037db 95f7              ror     zh
0037dc 95e7              ror     zl
0037dd 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
0037de e596              fdw     RFETCH_L
                 DUP_L:
0037df 64a3
0037e0 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
0037e1 939a
0037e2 938a              pushtos
0037e3 9508              ret
                 
0037e4 e708              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
0037e5 3082
0037e6 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:
0037e7 9701              sbiw    tosl, 1
0037e8 0b88              sbc     tosl, tosl
0037e9 0b99              sbc     tosh, tosh
0037ea 9508              ret
                 
0037eb efca              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
0037ec 3082
0037ed 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
0037ee 0f99              lsl     tosh
0037ef 0b88              sbc     tosl, tosl
0037f0 0b99              sbc     tosh, tosh
0037f1 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037f2 efac              fdw     DOLIT_L
                 TICK_L:
0037f3 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037f4 d0fb              rcall   BL
0037f5 dd66              rcall   WORD
0037f6 ddd2              rcall   FIND
0037f7 940c 37bb         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
0037f9 efe6              fdw     TICK_L
                 CHAR_L:
0037fa 6384
0037fb 6168
0037fc 0072              .db     NFA|4,"char",0
                 CHAR:
0037fd d0f2              rcall   BL
0037fe dd40              rcall   PARSE
0037ff da98              rcall   DROP
003800 940c 3ea6         jmp     CFETCH
                 
                 ; (    --                     skip input until )
003802 eff4              fdw     CHAR_L
                 PAREN_L:
003803 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
003804 dfd3              rcall   DOLIT
003805 0029              .dw     ')'
003806 dd38              rcall   PARSE
003807 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
003808 940c 31ce         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
00380a f006              fdw     PAREN_L
                 IHERE_L:
00380b 6985
00380c 6568
00380d 6572              .db     NFA|5,"ihere"
                 IHERE:
00380e d068              rcall   IDP
00380f cf09              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
003810 f016              fdw     IHERE_L
                 BRACCHAR_L:
003811 5bd6
003812 6863
003813 7261
003814 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
003815 dfe7              rcall   CHAR
003816 940c 3e22         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
003818 6383
003819 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
00381a 940c 3198         jmp     COMMAXT
                 
                 ; CR      --                      output newline
00381c f022              fdw     BRACCHAR_L
                 CR_L:
00381d 6382
00381e 0072              .db     NFA|2,"cr",0
                 CR:
00381f dfb8              rcall   DOLIT
003820 000d              .dw     0x0d       ; CR \r
003821 d869              rcall   EMIT
003822 dfb5              rcall   DOLIT
003823 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
003824 940c 308b         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
003826 f03a              fdw     CR_L
                 CREATE_L:
003827 6386
003828 6572
003829 7461
00382a 0065              .db     NFA|6,"create",0
                 CREATE:
00382b d0c4              rcall   BL
00382c dd2f              rcall   WORD            ; Parse a word
                 
00382d dfb3              rcall   DUP             ; Remember parsed word at rhere
00382e dd9a              rcall   FIND
00382f dc0b              rcall   NIP
003830 dfb6              rcall   ZEROEQUAL
003831 da2a              rcall   XSQUOTE
003832 410f
003833 524c
003834 4145
003835 5944
003836 4420
003837 4645
003838 4e49
003839 4445              .db     15,"ALREADY DEFINED"
00383a df89              rcall   QABORT         ; ABORT if word has already been defined
00383b dfa5              rcall   DUP             ; Check the word length 
00383c dc20              rcall   CFETCH_A
00383d d9ca              rcall   ONE
00383e df99              rcall   DOLIT
00383f 0010              .dw     16
003840 db3b              rcall   WITHIN
003841 df79              rcall   QABORTQ          ; Abort if there is no name for create
                 
003842 dfcb              rcall   IHERE
003843 d936              rcall   ALIGNED
003844 d032              rcall   IDP             ; Align the flash DP.
003845 dd49              rcall   STORE_A
                 
003846 d0bc              rcall   LATEST_
003847 ded1              rcall   FETCH_A
003848 dad8              rcall   ICOMMA_          ; Link field
003849 dd37              rcall   CFETCHPP        ; str len
00384a dfc3              rcall   IHERE
00384b df95              rcall   DUP             
00384c d0b6              rcall   LATEST_         ; new 'latest' link
00384d dd41              rcall   STORE_A         ; str len ihere
00384e dd29              rcall   PLACE           ; 
00384f dfbe              rcall   IHERE           ; ihere
003850 dc0c              rcall   CFETCH_A
003851 df86              rcall   DOLIT
003852 0080              .dw     NFA
003853 deca              rcall   SHB
003854 dafa              rcall   ONEPLUS
003855 d924              rcall   ALIGNED
003856 d170              rcall   IALLOT          ; The header has now been created
003857 df80              rcall   DOLIT             
003858 e1c0              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
003859 d947              rcall   STORECFF1       ; Append an exeution token, CALL !
00385a d915              rcall   ALIGN
00385b d8f5              rcall   HERE            ; compiles the current dataspace dp into the dictionary
00385c d8ea              rcall   CSE_
00385d db9c              rcall   ZEROSENSE
00385e f409              brne    CREATE2
00385f daf9              rcall   TWOPLUS
                 CREATE2:
003860 940c 3f43         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
003862 f04e              fdw    CREATE_L
                 POSTPONE_L:
003863 70d8
003864 736f
003865 7074
003866 6e6f
003867 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
003868 d087              rcall   BL
003869 dcf2              rcall   WORD
00386a dd5e              rcall   FIND
00386b df75              rcall   DUP
00386c df4e              rcall   QABORTQ
00386d df80              rcall   ZEROLESS
00386e db8b              rcall   ZEROSENSE
00386f f019              breq    POSTPONE1
003870 d887              rcall   DOCOMMAXT
003871 e1f0              fdw     DOCOMMAXT
003872 caae              rjmp    ICOMMA_
                 POSTPONE1:
003873 940c 3198         jmp     COMMAXT
                 
                 
                 IDP_L:
003875 6983
003876 7064              .db     NFA|3,"idp"
                 IDP:
003877 d868              rcall   DOCREATE
003878 01fb              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
003879 2887
00387a 6f64
00387b 7365
00387c 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
00387d da45              rcall   RFROM
00387e d084              rcall   LATEST_
00387f de99              rcall   FETCH_A
003880 dd13              rcall   NFATOCFA
003881 dff5              rcall   IDP
003882 de96              rcall   FETCH_A
003883 decc              rcall   TOR_A
003884 dff2              rcall   IDP
003885 dd09              rcall   STORE_A
003886 0f88              lsl     tosl
003887 1f99              rol     tosh
003888 d918              rcall   STORECFF1 ; Always stores a 4 byte call
003889 da39              rcall   RFROM
00388a dfec              rcall   IDP
00388b 940c 3e51         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
00388d f0c6              fdw     POSTPONE_L
                 DOES_L:
00388e 64d5
00388f 656f
003890 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
003891 d866      DOES:   rcall   DOCOMMAXT
003892 f0fa              fdw     XDOES
003893 d864              rcall   DOCOMMAXT
003894 e1d0              fdw     DODOES
003895 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
003896 f11c              fdw     DOES_L
                 LEFTBRACKET_L:
003897 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
003898 9250 0206         sts     state, r_zero
00389a 9508              ret
                 
                 
                 ; ]        --      enter compiling state
00389b f12e              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
00389c 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
00389d 9260 0206         sts     state, r_one
00389f 9508              ret
                 
                 ; :        --           begin a colon definition
0038a0 f138              fdw     RIGHTBRACKET_L
                 COLON_L:
0038a1 3a81              .db     NFA|1,":"
                 COLON:
0038a2 df88              rcall   CREATE
0038a3 dff9              rcall   RIGHTBRACKET
0038a4 940c 31b4         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
0038a6 f142              fdw     COLON_L
                 NONAME_L:
0038a7 3a87
0038a8 6f6e
0038a9 616e
0038aa 656d              .db     NFA|7,":noname"
                 NONAME:
0038ab df62              rcall   IHERE
0038ac 940c 389d         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
0038ae f14e              fdw     NONAME_L
                 SEMICOLON_L:
0038af 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
0038b0 dfe7              rcall   LEFTBRACKET
0038b1 fd61              sbrc    FLAGS1, fTAILC
0038b2 c024              rjmp    ADD_RETURN_1
0038b3 df5a              rcall   IHERE
0038b4 d029              rcall   MINUS_FETCH
0038b5 018c              movw    t0, tosl
0038b6 7f10              andi    t1, 0xf0
0038b7 5d10              subi    t1, 0xd0
0038b8 f059              breq    RCALL_TO_JMP
0038b9 9189
0038ba 9199              poptos
0038bb d022              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
0038bc 508e              subi    tosl, 0x0e
                 .endif
0038bd 4994              sbci    tosh, 0x94
0038be f4b9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
0038bf e08c              ldi     tosl, 0x0c
                 .endif
0038c0 e994              ldi     tosh, 0x94
0038c1 d9dd              rcall   SWOP
0038c2 940c 3e51         jmp     STORE
                 RCALL_TO_JMP:
0038c4 db76              rcall   NIP
0038c5 709f              andi    tosh, 0x0f
0038c6 fd93              sbrc    tosh, 3
0038c7 6f90              ori     tosh, 0xf0
0038c8 da9b              rcall   TWOSTAR
0038c9 df44              rcall   IHERE
0038ca da13              rcall   PLUS
0038cb df0c              rcall   DOLIT
0038cc fffe              .dw     -2
0038cd d0f9              rcall   IALLOT
0038ce df09              rcall   DOLIT
                 .ifdef EIND
                 .else
0038cf 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
0038d0 d008              rcall   ICOMMA__
0038d1 5890              sub_pflash_tos
0038d2 9488              rampv_to_c
0038d3 9597              ror     tosh
0038d4 9587              ror     tosl
0038d5 c003              rjmp    ICOMMA__
                 ADD_RETURN:
0038d6 d8f7              rcall   TWODROP
                 ADD_RETURN_1:
0038d7 df00              rcall   DOLIT   ; Compile a ret
0038d8 9508              .dw     0x9508
                 ICOMMA__:
0038d9 940c 3f43         jmp    ICOMMA
                 
                 
                 
0038db f15e              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
0038dc 2d82
0038dd 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
0038de d00c              rcall   TWOMINUS
0038df df01              rcall   DUP
0038e0 940c 3e8b         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
0038e2 f1b8              fdw     MINUS_FETCH_L
                 BRACTICK_L:
0038e3 5bd3
0038e4 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
0038e5 df0e              rcall   TICK       ; get xt of 'xxx'
0038e6 940c 3e22         jmp     LITERAL
                 
                 ; 2-    n -- n-2
0038e8 f1c6              fdw     BRACTICK_L
                 TWOMINUS_L:
0038e9 32a2
0038ea 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
0038eb 9702              sbiw    tosl, 2
0038ec 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038ed f1d2              fdw     TWOMINUS_L
                 BL_l:
0038ee 6282
0038ef 006c              .db     NFA|2,"bl",0
                 BL:
0038f0 940e 30e0         call    DOCREATE
0038f2 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038f3 f1dc              fdw     BL_L
                 STATE_L:
0038f4 7385
0038f5 6174
0038f6 6574              .db     NFA|5,"state"
                 STATE_:
0038f7 939a
0038f8 938a              pushtos
0038f9 9180 0206         lds     tosl, state
0038fb 9190 0206         lds     tosh, state
0038fd 9508              ret
                 
                 ; LATEST    -- a-addr           
0038fe f1e8              fdw     STATE_L
                 LATEST_L:
0038ff 6c86
003900 7461
003901 7365
003902 0074              .db     NFA|6,"latest",0
                 LATEST_:
003903 940e 30e0         call    DOCREATE
003905 0201              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
003906 f1fe              fdw     LATEST_L
                 S0_L:
003907 7382
003908 0030              .db     NFA|2,"s0",0
                 S0:
003909 dc0f              rcall   DOUSER
00390a ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
00390b f20e              fdw     S0_L
                 R0_L:
00390c 7282
00390d 0030              .db     NFA|2,"r0",0
                 R0_:
00390e dc0a              rcall   DOUSER
00390f ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
003910 6983
003911 696e              .db     NFA|3,"ini"
                 INI:
003912 940e 30e0          call   DOCREATE
003914 01f9              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
003915 f218              fdw     R0_L
                 TICKS_L:
003916 7485
003917 6369
003918 736b              .db     NFA|5,"ticks"
                 TICKS:  
003919 939a
00391a 938a              pushtos
00391b b70f              in_     t0, SREG
00391c 94f8              cli
00391d 2d8e              mov     tosl, ms_count
00391e 2d9f              mov     tosh, ms_count1
00391f bf0f              out_    SREG, t0
003920 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
003921 f22c              fdw     TICKS_L
                 MS_L:
003922 6d82
003923 0073              .db     NFA|2,"ms",0
                 MS:
003924 dff4              rcall   TICKS
003925 d9b8              rcall   PLUS
                 MS1:    
003926 d5fb              rcall   PAUSE
003927 deb9              rcall   DUP
003928 dff0              rcall   TICKS
003929 d9c1              rcall   MINUS
00392a dec3              rcall   ZEROLESS
00392b dace              rcall   ZEROSENSE
00392c f3c9              breq    MS1
00392d 940c 3298         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
00392f f244              fdw     MS_L
                 DOTID_L:
003930 2e83
003931 6469              .db     NFA|3,".id"
                 DOTID:
003932 dc4e              rcall   CFETCHPP
003933 708f              andi    tosl, 0x0f
003934 d984              rcall   TOR
003935 c003              rjmp    DOTID3
                 DOTID1:
003936 dc4a              rcall   CFETCHPP
003937 d00a              rcall   TO_PRINTABLE
003938 deeb              rcall   EMIT_A
                 DOTID3:
003939 d15b              rcall   XNEXT
00393a f7d8              brcc    DOTID1  
00393b 911f              pop     t1
00393c 910f              pop     t0
00393d 940c 3298         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
00393f f260              fdw     DOTID_L
                 TO_PRINTABLE_L:
003940 3e83
003941 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:
003942 2799              clr     tosh   
003943 3080              cpi     tosl, 0
003944 f012              brmi    TO_PRINTABLE1
003945 3280              cpi     tosl, 0x20
003946 f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
003947 e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
003948 9508              ret
                 
                 ;;;;;;;;;;;;;;
                 LIKEQ:
003949 dc37              rcall   CFETCHPP
00394a de8d              rcall   DOLIT
00394b 000f              .dw     0x0f
00394c d9d9              rcall   AND_
00394d d951              rcall   SWOP
00394e da59              rcall   STORE_P
00394f d94f              rcall   SWOP
003950 dc30              rcall   CFETCHPP
003951 d95f              rcall   ROT
003952 d956              rcall   OVER
003953 d997              rcall   MINUS
003954 d9fa              rcall   ONEPLUS
003955 de24              rcall   FALSE_
003956 dafb              rcall   MAX
003957 d961              rcall   TOR
003958 c009              rjmp    LIKEQ3
                 LIKEQ1:
003959 d87b              rcall   TWODUP
00395a d20b              rcall   FETCH_P
00395b da7f              rcall   PPLUS
00395c d942              rcall   SWOP
00395d 940e 2f80         call    CMP
00395f f011              breq    LIKEQ3
                 TWODROPNZ:
003960 9498              clz
003961 c003              rjmp    LIKEQ4
                 LIKEQ3:
003962 d132              rcall   XNEXT
003963 f7a8              brcc    LIKEQ1
                 TWODROPZ:
003964 9418              sez
                 LIKEQ4:
003965 911f              pop     t1
003966 910f              pop     t0
003967 c00a              rjmp    TWODROP__
                 
                 ;;;;;;;;;;;;;;;;;;;;
                 LIKES:
003968 d86c              rcall   TWODUP
003969 dfdf              rcall   LIKEQ
00396a f019              breq    LIKES1
00396b de75              rcall   DUP
00396c dfc5              rcall   DOTID
00396d d877              rcall   SPACE_
                 LIKES1:
00396e df7c              rcall   TWOMINUS
00396f dda9              rcall   FETCH_A
003970 da8f              rcall   DUPZEROSENSE
003971 f7b1              brne    LIKES
                 TWODROP__:
003972 940c 31ce         jmp     TWODROP
                 
                  ; WORDS    -- filter
003974 f280              fdw     TO_PRINTABLE_L
                 WORDS_L:
003975 7785
003976 726f
003977 7364              .db     NFA|5,"words"
003978 df77              rcall   BL
003979 dbe2              rcall   WORD
00397a de66              rcall   DUP
00397b de5c              rcall   DOLIT
00397c f6e6              fdw     kernellink
00397d d002              rcall   WDS1
00397e df84              rcall   LATEST_
00397f dd99              rcall   FETCH_A
003980 de9e      WDS1:   rcall   CR
003981 940c 3968         jmp     LIKES
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
003983 f2ea              fdw     WORDS_L
                 DOTS_L:
003984 2e82
003985 0073              .db     NFA|2,".s",0
                 DOTS:
003986 d85e              rcall   SPACE_
003987 de59              rcall   DUP
003988 940e 3103         call    SPFETCH
00398a df7e              rcall   S0
00398b dd8d              rcall   FETCH_A
00398c df5e              rcall   TWOMINUS
                 DOTS1:
00398d d847              rcall   TWODUP
00398e da01              rcall   LESS
00398f da6a              rcall   ZEROSENSE
003990 f019              breq    DOTS2
003991 df4c              rcall   MINUS_FETCH
003992 db1a              rcall   UDOT
003993 cff9              rjmp    DOTS1
                 DOTS2:  
003994 d903              rcall   DROP
003995 940c 31ce         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
003997 f308              fdw     DOTS_L
                 DUMP_L:
003998 6484
003999 6d75
00399a 0070              .db     NFA|4,"dump",0
                 DUMP:
00399b de3c              rcall   DOLIT
00399c 0010              .dw     16
00399d da80              rcall   USLASH
00399e d91a              rcall   TOR
00399f c020              rjmp    DUMP7
                 DUMP1:  
0039a0 de7e              rcall   CR
0039a1 de3f              rcall   DUP
0039a2 de35              rcall   DOLIT
0039a3 0004              .dw     4
0039a4 db12              rcall   UDOTR
0039a5 de32              rcall   DOLIT
0039a6 003a              .dw     ':'
0039a7 de7c              rcall   EMIT_A
0039a8 de2f              rcall   DOLIT
0039a9 000f              .dw     15
0039aa d90e              rcall   TOR
                 DUMP2:
0039ab dbd5              rcall   CFETCHPP
0039ac de2b              rcall   DOLIT
0039ad 0002              .dw     2
0039ae db08              rcall   UDOTR
0039af d0e5              rcall   XNEXT
0039b0 f7d0              brcc    DUMP2
0039b1 911f              pop     t1
0039b2 910f              pop     t0
                 
0039b3 de24              rcall   DOLIT
0039b4 0010              .dw     16
0039b5 d935              rcall   MINUS
0039b6 de21              rcall   DOLIT
0039b7 000f              .dw     15
0039b8 d900              rcall   TOR
                 DUMP4:  
0039b9 dbc7              rcall   CFETCHPP
0039ba df87              rcall   TO_PRINTABLE
0039bb de68              rcall   EMIT_A
0039bc d0d8              rcall   XNEXT
0039bd f7d8              brcc    DUMP4
0039be 911f              pop     t1
0039bf 910f              pop     t0
                 DUMP7:
0039c0 d0d4              rcall   XNEXT
0039c1 f6f0              brcc    DUMP1
0039c2 911f              pop     t1
0039c3 910f              pop     t0
0039c4 940c 3298         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
0039c6 2081              .db     NFA|1," "
                 IALLOT:
0039c7 deaf              rcall   IDP
0039c8 940c 3370         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
0039ca f330              fdw     DUMP_L
                 X_TO_R_L:
0039cb 7883
0039cc 723e              .db     NFA|3,"x>r"
                 X_TO_R:
0039cd 01fc              movw    zl, tosl
0039ce 9189
0039cf 9199              poptos
0039d0 d009              rcall   TO_XA
0039d1 9631              adiw    zl, 1
0039d2 9382              st      -z, tosl
0039d3 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
0039d4 9252              st      -z, r_zero
0039d5 01cf              movw    tosl, zl
0039d6 9508              ret
                 ;***************************************************************
0039d7 f396              fdw     X_TO_R_L
                 TO_XA_L:
0039d8 3e83
0039d9 6178              .db NFA|3,">xa"
                 TO_XA:
0039da 5890               sub_pflash_tos
0039db 9488               rampv_to_c
0039dc 9597               ror tosh
0039dd 9587               ror tosl
0039de 9508               ret
                 
0039df f3b0               fdw     TO_XA_L
                 XA_FROM_L:
0039e0 7883
0039e1 3e61              .db NFA|3,"xa>"
                 XA_FROM:
0039e2 0f88               lsl     tosl
0039e3 1f99               rol     tosh
0039e4 5890               add_pflash_tos
0039e5 9508               ret
                 ;***************************************************************
0039e6 f3c0               fdw    XA_FROM_L
                 PFL_L:
0039e7 7083
0039e8 6c66              .db     NFA|3,"pfl"
                 PFL:
0039e9 940e 30e0          call   DOCREATE
0039eb 8000              .dw     OFLASH
                 ;***************************************************************
0039ec f3ce              fdw    PFL_L
                 ZFL_L:
0039ed 7a83
0039ee 6c66              .db     NFA|3, "zfl"
                 ZFL:
0039ef 940e 30e0          call   DOCREATE
0039f1 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
0039f2 2c84
0039f3 303f
0039f4 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
0039f5 fd65              sbrc    FLAGS1, idup
0039f6 c003              rjmp    COMMAZEROSENSE1
0039f7 dde0              rcall   DOLIT
0039f8 e7f4              fdw     ZEROSENSE
0039f9 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
0039fa d004              rcall   IDPMINUS
0039fb dddc              rcall   DOLIT
0039fc e800              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
0039fd 7d6f              cbr     FLAGS1, (1<<idup)
0039fe c06d              rjmp    INLINE0
                 
                 IDPMINUS:
0039ff ddd8              rcall   DOLIT
003a00 fffc              .dw     -4
003a01 cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
003a02 d967              rcall   TWOSLASH
003a03 709f              andi    tosh, 0x0f
003a04 6c90              ori     tosh, 0xc0
003a05 ced3              rjmp    ICOMMA__
                 
                 
                 BRCCC:
003a06 ddd1              rcall   DOLIT
003a07 f008              .dw     0xf008      ; brcc pc+2
003a08 ced0              rjmp    ICOMMA__
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
003a09 ddce              rcall   DOLIT
003a0a f409              .dw     0xf409      ; brne pc+2
003a0b fd64              sbrc    FLAGS1, izeroeq
003a0c 7f9b              andi    tosh, ~4
003a0d cecb              rjmp    ICOMMA__
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
003a0e f3da              fdw     ZFL_L
                 IF_L:
003a0f 69d2
003a10 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
003a11 fd64              sbrc    FLAGS1, izeroeq
003a12 dfec              rcall   IDPMINUS
003a13 dfe1              rcall   COMMAZEROSENSE
003a14 dff4              rcall   BRNEC
003a15 7e6f              cbr     FLAGS1, (1<<izeroeq)
003a16 ddf7              rcall   IHERE
003a17 dd62              rcall   FALSE_
003a18 940c 3a02         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
003a1a f41e              fdw     IF_L
                 ELSE_L:
003a1b 65d4
003a1c 736c
003a1d 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
003a1e ddef              rcall   IHERE
003a1f dd5a              rcall   FALSE_
003a20 dfe1              rcall   RJMPC
003a21 dc52              rcall   SWOP_A      ; else-addr  if-addr 
003a22 940c 3a28         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
003a24 f436              fdw     ELSE_L
                 THEN_L:
003a25 74d4
003a26 6568
003a27 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
003a28 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a29 dde4              rcall   IHERE
003a2a d87e              rcall   OVER
003a2b d8bf              rcall   MINUS
003a2c debe              rcall   TWOMINUS
003a2d d93c              rcall   TWOSLASH
003a2e dda9              rcall   DOLIT
003a2f c000              .dw     0xc000      ;  back-addr mask 
003a30 d8fd              rcall   OR_
003a31 dc42              rcall   SWOP_A
003a32 940c 3e51         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
003a34 f44a              fdw     THEN_L
                 BEGIN_L:
003a35 62d5
003a36 6765
003a37 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
003a38 940c 380e         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
003a3a f46a              fdw     BEGIN_L
                 UNTIL_L:
003a3b 75d5
003a3c 746e
003a3d 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
003a3e 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a3f fd64              sbrc    FLAGS1, izeroeq
003a40 dfbe              rcall   IDPMINUS
003a41 dfb3              rcall   COMMAZEROSENSE
003a42 dfc6              rcall   BRNEC
003a43 7e6f              cbr     FLAGS1, (1<<izeroeq)
003a44 940c 3a4a         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
003a46 f476              fdw     UNTIL_L
                 AGAIN_L:
003a47 61d5
003a48 6167
003a49 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
003a4a 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a4b ddc2              rcall   IHERE
003a4c d89e              rcall   MINUS
003a4d de9d              rcall   TWOMINUS
003a4e 940c 3a02         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
003a50 f48e              fdw     AGAIN_L
                 WHILE_L:
003a51 77d5
003a52 6968
003a53 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
003a54 dfbc              rcall   IF_
003a55 940c 329f         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
003a57 f4a2              fdw     WHILE_L
                 REPEAT_L:
003a58 72d6
003a59 7065
003a5a 6165
003a5b 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
003a5c dfed              rcall   AGAIN_
003a5d 940c 3a28         jmp     THEN_
                 
003a5f f4b0              fdw     REPEAT_L
                 INLINE_L:
003a60 69d6
003a61 6c6e
003a62 6e69
003a63 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a64 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a65 7d6f              cbr      FLAGS1, (1<<idup)
003a66 dd8d              rcall    TICK
003a67 940c 3a6c         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a69 f4c0              fdw      INLINE_L
                 INLINEC_L:
003a6a 6983
003a6b 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a6c db1c              rcall   FETCHPP
003a6d dd73              rcall   DUP
003a6e dd69              rcall   DOLIT
003a6f 9508              .dw     0x9508
003a70 d915              rcall   NOTEQUAL
003a71 d988              rcall   ZEROSENSE
003a72 f011              breq    INLINE1
003a73 d4cf              rcall   ICOMMA
003a74 cff7              rjmp    INLINE0
                 INLINE1:
003a75 940c 31ce         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a77 f4d4              fdw     INLINEC_L
                 FOR_L:
003a78 66d3
003a79 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a7a 940e 30f8         call    DOCOMMAXT
003a7c e572              fdw     TOR
003a7d dd90              rcall   IHERE
003a7e dcfb              rcall   FALSE_
003a7f df82              rcall   RJMPC
003a80 dd8d              rcall   IHERE
003a81 940c 329f         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a83 f4f0              fdw     FOR_L
                 NEXT_L:
003a84 6ed4
003a85 7865
003a86 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a87 dfa0              rcall   THEN_
003a88 940e 30f8         call    DOCOMMAXT
003a8a f52a              fdw     XNEXT
003a8b df7a              rcall   BRCCC
                 
003a8c dfbd              rcall   AGAIN_
                 
003a8d dd4a              rcall   DOLIT
003a8e f53c              fdw     XNEXT1
003a8f 940c 3a6c         jmp     INLINE0
                 ; (next) decrement top of return stack
003a91 2887
003a92 656e
003a93 7478
003a94 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003a95 91ff              pop     zh
003a96 91ef              pop     zl
003a97 91bf              pop     xh
003a98 91af              pop     xl
003a99 9711              sbiw    xl, 1
003a9a 93af              push    xl
003a9b 93bf              push    xh
003a9c 9409              mijmp
003a9d 9508              ret
                 XNEXT1:
003a9e 911f              pop     t1
003a9f 910f              pop     t0
003aa0 9508              ret
                 
                 ; leave clear top of return stack
003aa1 f508              fdw     NEXT_L
                 LEAVE_L:
003aa2 6595
003aa3 646e
003aa4 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003aa5 91ff              pop     zh
003aa6 91ef              pop     zl
003aa7 911f              pop     t1
003aa8 910f              pop     t0
003aa9 925f              push    r_zero
003aaa 925f              push    r_zero
003aab 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003aac f544              fdw      LEAVE_L
                 RDROP_L:
003aad 72d5
003aae 7264
003aaf 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003ab0 dd27              rcall   DOLIT
003ab1 f53c              fdw     XNEXT1
003ab2 940c 3a6c         jmp     INLINE0
                 ;***************************************************
003ab4 f55a              fdw     RDROP_L
                 STOD_L:
003ab5 7383
003ab6 643e              .db     NFA|3,"s>d"
                 STOD:
003ab7 ff97              sbrs    tosh, 7
003ab8 ccc1              rjmp    FALSE_
003ab9 ccc9              rjmp    TRUE_
                 ;***************************************************
003aba f56a              fdw     STOD_L
                 DNEGATE_L:
003abb 6487
003abc 656e
003abd 6167
003abe 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003abf d049              rcall   DINVERT
003ac0 940e 3208         call    ONE
003ac2 940c 32e6         jmp     MPLUS
                 ;***************************************************
003ac4 f576              fdw     DNEGATE_L
                 QDNEGATE_L:
003ac5 3f88
003ac6 6e64
003ac7 6765
003ac8 7461
003ac9 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003aca dd23              rcall   ZEROLESS
003acb d92e              rcall   ZEROSENSE
003acc f009              breq    QDNEGATE1
003acd dff1              rcall   DNEGATE
                 QDNEGATE1:
003ace 9508              ret
                 
                 ;***************************************************
003acf f58a              fdw     QDNEGATE_L
                 DABS_L:
003ad0 6484
003ad1 6261
003ad2 0073              .db     NFA|4,"dabs",0
                 DABS:
003ad3 dd0d              rcall   DUP
003ad4 940c 3aca         jmp     QDNEGATE
                 ;***************************************************
003ad6 f5a0              fdw     DABS_L
                 DPLUS_L:
003ad7 6482
003ad8 002b              .db     NFA|2,"d+",0
                 DPLUS:
003ad9 91a9              ld      xl, Y+
003ada 91b9              ld      xh, Y+
003adb 91e9              ld      t6, Y+
003adc 91f9              ld      t7, Y+
003add 9109              ld      t0, Y+
003ade 9119              ld      t1, Y+
003adf 0fa0              add     xl, t0
003ae0 1fb1              adc     xh, t1
003ae1 1f8e              adc     tosl, t6
003ae2 1f9f              adc     tosh, t7
003ae3 93ba              st      -Y, xh
003ae4 93aa              st      -Y, xl
003ae5 9508              ret
                 
                 ;***************************************************
003ae6 f5ae              fdw     DPLUS_L
                 DMINUS_L:
003ae7 6482
003ae8 002d              .db     NFA|2,"d-",0
                 DMINUS:
003ae9 dfd5              rcall   DNEGATE
003aea 940c 3ad9         jmp     DPLUS
                 ;***************************************************
003aec f5ce              fdw     DMINUS_L
                 DTWOSLASH_L:
003aed 6483
003aee 2f32              .db     NFA|3,"d2/"
003aef 9109              ld      t0, y+
003af0 9119              ld      t1, y+
003af1 9595              asr     tosh
003af2 9587              ror     tosl
003af3 9517              ror     t1
003af4 9507              ror     t0
003af5 931a              st      -y, t1
003af6 930a              st      -y, t0
003af7 9508              ret
                 ;***************************************************
003af8 f5da              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003af9 6483
003afa 2a32              .db     NFA|3,"d2*"
003afb 9109              ld      t0, y+
003afc 9119              ld      t1, y+
003afd 0f00              lsl     t0
003afe 1f11              rol     t1
003aff 1f88              rol     tosl
003b00 1f99              rol     tosh
003b01 931a              st      -y, t1
003b02 930a              st      -y, t0
003b03 9508              ret
                 ;***************************************************
003b04 f5f2              fdw     DTWOSTAR_L
                 DINVERT_L:
003b05 6487
003b06 6e69
003b07 6576
003b08 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003b09 9109              ld      t0, y+
003b0a 9119              ld      t1, y+
003b0b 9500              com     t0
003b0c 9510              com     t1
003b0d 9580              com     tosl
003b0e 9590              com     tosh
003b0f 931a              st      -y, t1
003b10 930a              st      -y, t0
003b11 9508              ret
                 ;***************************************************
003b12 f60a              fdw     DINVERT_L
                 DZEROEQUAL_L:
003b13 6483
003b14 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003b15 91a9              ld      xl, y+
003b16 91b9              ld      xh, y+
003b17 2b89              or      tosl, tosh
003b18 2b8a              or      tosl, xl
003b19 2b8b              or      tosl, xh
003b1a f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003b1b ef8f              ser     tosl
003b1c ef9f              ser     tosh
003b1d 9508              ret
                 
                 ;***************************************************
003b1e f626              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003b1f 6483
003b20 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003b21 91a9              ld      xl, y+
003b22 91b9              ld      xh, y+
003b23 3090              cpi     tosh, 0
003b24 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003b25 2788              clr     tosl
003b26 2799              clr     tosh
003b27 9508              ret
                 ;***************************************************
003b28 f63e              fdw     DZEROLESS_L
                 DEQUAL_L:
003b29 6482
003b2a 003d              .db     NFA|2,"d=",0
003b2b dfbd              rcall   DMINUS
003b2c 940c 3b15         jmp     DZEROEQUAL
                 ;***************************************************
003b2e f652              fdw     DEQUAL_L
                 DLESS_L:
003b2f 6482
003b30 003c              .db     NFA|2,"d<",0
                 DLESS:
003b31 dfb7              rcall   DMINUS
003b32 940c 3b21         jmp     DZEROLESS
                 ;***************************************************
003b34 f65e              fdw     DLESS_L
                 DGREATER_L:
003b35 6482
003b36 003e              .db     NFA|2,"d>",0
                 DGREATER:
003b37 940e 31dc         call    TWOSWAP
003b39 940c 3b31         jmp     DLESS
                 ;***************************************************
003b3b f66a              fdw     DGREATER_L
                 UDDOT_L:
003b3c 7583
003b3d 2e64              .db     NFA|3,"ud."
003b3e d937              rcall   LESSNUM
003b3f d94f              rcall   NUMS
003b40 d957              rcall   NUMGREATER
003b41 940e 324f         call    TYPE
003b43 940c 31e5         jmp     SPACE_
                 ;***************************************************
003b45 f678              fdw     UDDOT_L
                 DDOT_L:
003b46 6482
003b47 002e              .db     NFA|2,"d.",0
003b48 d92d              rcall   LESSNUM
003b49 938f              push    tosl     ; dup >r
003b4a 939f              push    tosh
003b4b df87              rcall   DABS
003b4c d942              rcall   NUMS
003b4d 940e 32c3         call    RFROM
003b4f d953              rcall   SIGN
003b50 d947              rcall   NUMGREATER
003b51 940e 324f         call    TYPE
003b53 940c 31e5         jmp     SPACE_
                 ;****************************************************
003b55 f68c              fdw      DDOT_L
                 MEMHI_L:
003b56 6882
003b57 0069              .db     NFA|2,"hi",0
                 MEMHI:
003b58 dc7f              rcall   DOLIT
003b59 f6c0              fdw     FLASHHI
003b5a 940e 3147         call    CSE_
003b5c 940e 32de         call    PLUS
003b5e 940c 3e8b         jmp     FETCH
                 FLASHHI:
003b60 deff              .dw      FLASH_HI
003b61 0cff              .dw      EEPROM_HI
003b62 08ff              .dw      RAM_HI
                 
                 .if FLASHEND > 0x3fff
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
                 .endif
                 
                 ;***************************************************
                 
003b63 f6ac              fdw      MEMHI_L
                 L_FETCH_P:
003b64 40a2
003b65 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b66 939a
003b67 938a              pushtos
003b68 01ca              movw    tosl, pl
003b69 9508              ret
                 ;***************************************************
003b6a f6c8              fdw     L_FETCH_P
                 L_PCFETCH:
003b6b 7083
003b6c 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b6d 939a
003b6e 938a              pushtos
003b6f 01ca              movw    tosl, pl
003b70 940c 3ea6         jmp     CFETCH
                 ;***************************************************
003b72 f6d6              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b73 70a3
003b74 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b75 0d47              add     pl, r_two
003b76 1d55              adc     ph, r_zero
003b77 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b78 0000              .dw     0
                 L_MARKER:
                 lastword:
003b79 6d86
003b7a 7261
003b7b 656b
003b7c 0072              .db     NFA|6,"marker",0
                 MARKER:
003b7d 940e 312c         call    ROM_
003b7f dcab              rcall   CREATE
003b80 dc57              rcall   DOLIT
003b81 0900              .dw     dp_start
003b82 940e 3151         call    HERE
003b84 dbcd              rcall   TEN
003b85 d9e0              rcall   CMOVE
003b86 dbcb              rcall   TEN
003b87 940e 3291         call    ALLOT
003b89 940e 313a         call    FRAM
003b8b dcf1              rcall   XDOES
003b8c 940e 30e8         call    DODOES
003b8e dd83              rcall   INI
003b8f dbc2              rcall   TEN
003b90 940c 3566         jmp     CMOVE
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD_LED == 1
                 ;;; Enable load led
003b92 df98              fdw     BUSY_L
                 LOADON_L:
003b93 6c85
003b94 616f
003b95 2b64              .db     NFA|5,"load+"
003b96 6170              sbr     FLAGS2, (1<<fLOADled)
003b97 9508              ret
                 
                 ;;; Disable load led
003b98 f726              fdw     LOADON_L
                 LOADOFF_L:
003b99 6c85
003b9a 616f
003b9b 2d64              .db     NFA|5,"load-"
003b9c 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
                 .if CPU_LOAD_LED_POLARITY == 1
003b9d 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003b9e 9508              ret
                 .endif
                 ;;; 
                 .if CPU_LOAD == 1
                 .if CPU_LOAD_LED == 1
                 .else
                 .endif
                 .endif
                 .endif
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003b9f fe00              sbrs    t2, PORF
003ba0 c003              rjmp    RQ_EXTR
003ba1 dc36              rcall   DOLIT
003ba2 0050              .dw     'P'
003ba3 dc80              rcall   EMIT_A
                 RQ_EXTR:
003ba4 fe01              sbrs    t2, EXTRF
003ba5 c003              rjmp    RQ_BORF
003ba6 dc31              rcall   DOLIT
003ba7 0045              .dw     'E'
003ba8 dc7b              rcall   EMIT_A
                 RQ_BORF:
003ba9 fe02              sbrs    t2, BORF
003baa c003              rjmp    RQ_WDRF
003bab dc2c              rcall   DOLIT
003bac 0042              .dw     'B'
003bad dc76              rcall   EMIT_A
                 RQ_WDRF:
003bae fe03              sbrs    t2, WDRF
003baf c003              rjmp    RQ_DIVZERO
003bb0 dc27              rcall   DOLIT
003bb1 0057              .dw     'W'
003bb2 dc71              rcall   EMIT_A
                 RQ_DIVZERO:
003bb3 fe16              sbrs    t3, 6 ; T bit MATH error
003bb4 c003              rjmp    RQ_END
003bb5 dc22              rcall   DOLIT
003bb6 004d              .dw     'M'
003bb7 dc6c              rcall   EMIT_A
                 RQ_END: 
003bb8 940c 31e5         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
                 .endif
                 .if CPU_LOAD_LED == 1
003bba ff74              sbrs    FLAGS2, fLOADled
003bbb c001              rjmp    LOAD_LED_END
                 .if CPU_LOAD_LED_POLARITY == 1
003bbc 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003bbd ff76              sbrs    FLAGS2, fIDLE
003bbe c00a              rjmp    IDLE_LOAD1
003bbf e203              ldi     t0, low(up0)
003bc0 1620              cp      upl, t0
003bc1 f439              brne    IDLE_LOAD1
                 .ifdef SMCR
003bc2 91e0 01b6         lds     zl, rbuf0_lv
                 .ifdef rbuf1_lv
                 .else
003bc4 30e0              cpi     zl, 0
                 .endif
003bc5 f419              brne    IDLE_LOAD1
003bc6 be63              out_    SMCR, r_one
                 .else
                 .endif
                 .if CPU_LOAD == 1
                 .endif
003bc7 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003bc8 be53              out_    SMCR, r_zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003bc9 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003bca 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003bcb 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d70 RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d03b                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d039                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d037                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
003c08 d035                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
003c0a d033                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d031                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
003c0e d02f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
003c10 d02d                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
003c12 d02b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
003c14 d029                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
003c16 d027                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
003c18 d025                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
003c1a d023                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
003c1c c033                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
003c1e d01f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
003c20 d01d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
003c22 d01b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
003c24 d019                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d017                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d015                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
                 .else
003c2a d013                  rcall FF_ISR
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d011                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d00f                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d00d                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d00b                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
003c33 919f              pop     tosh
003c34 918f              pop     tosl
003c35 911f              pop     t1
003c36 910f              pop     t0
003c37 91ff              pop     zh
003c38 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
003c39 91a9              ld      xl, y+
003c3a 91b9              ld      xh, y+
003c3b bfbf              out_    SREG, xh
003c3c 91b9              ld      xh, y+
003c3d 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
003c3e 93ba              st      -y, xh
003c3f b7bf              in_     xh, SREG
003c40 93ba              st      -y, xh
003c41 93aa              st      -y, xl
                         m_pop_xh
003c42 91bf              pop     xh
003c43 91af              pop     xl
003c44 93ef              push    zl
003c45 93ff              push    zh
003c46 930f              push    t0
003c47 931f              push    t1
003c48 938f              push    tosl
003c49 939f              push    tosh
                 .if low(ivec) == 0x80
003c4a e7bf              ldi     xh, low(ivec-1)
003c4b 0fab              add     xl, xh
                 .else
                 .endif
003c4c e0b1              ldi     xh, high(ivec)
003c4d 91ed              ld      zl, x+
003c4e 91fd              ld      zh, x+
003c4f 9409              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
003c50 93ba              st      -y, xh
003c51 b7bf              in_     xh, SREG
003c52 93ba              st      -y, xh
003c53 93aa              st      -y, xl
003c54 0ce6              add     ms_count,  r_one
003c55 1cf5              adc     ms_count1, r_zero
                 .if CPU_LOAD == 1
                 .endif
003c56 cfe2              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
003c57 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
003c59 30bf              cpi     xh, 0xf
003c5a f409              brne    pc+2
003c5b cfa4              rjmp    RESET_
                 .endif
                 .endif
003c5c 91a0 01b6         lds     xl, rbuf0_lv
003c5e 33ae              cpi     xl, RX0_BUF_SIZE-2
003c5f f091              breq    RX0_OVF
003c60 95a3              inc     xl
003c61 93a0 01b6         sts     rbuf0_lv, xl
                 
003c63 30a4              cpi     xl, RX0_OFF_FILL
003c64 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c65 d02d              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
                 
003c66 ebe7              ldi     zl, low(rbuf0)
003c67 e0f1              ldi     zh, high(rbuf0)
                 
003c68 91a0 01b4         lds     xl, rbuf0_wr
003c6a 0fea              add     zl, xl
003c6b 1df5              adc     zh, r_zero
003c6c 83b0              st      z, xh
003c6d 95a3              inc     xl
003c6e 73af              andi    xl, (RX0_BUF_SIZE-1)
003c6f 93a0 01b4         sts     rbuf0_wr, xl
003c71 cfc1              rjmp    FF_ISR_EXIT
                 RX0_OVF:
003c72 e7fc              ldi     zh, '|'
003c73 d021              rcall   TX0_SEND
003c74 cfbe              rjmp    FF_ISR_EXIT
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .else
                 .if CPU_LOAD_LED == 1
003c75 f732              fdw(LOADOFF_L)
                 .else
                 .endif
                 .endif
                 .else
                 .endif
                 TX0_L:
003c76 7483
003c77 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c78 3181              cpi     tosl, XON
003c79 f061              breq    XXON_TX0_TOS
003c7a 3183              cpi     tosl, XOFF
003c7b f091              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c7c d2a5              rcall   PAUSE
003c7d 9100 00c0         in_     t0, UCSR0A
003c7f ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003c80 cffb              rjmp    TX0_LOOP
003c81 9380 00c6         out_    UDR0_, tosl
003c83 9189
003c84 9199              poptos
003c85 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003c86 9189
003c87 9199              poptos
003c88 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003c89 ff70              sbrs    FLAGS2, ixoff_tx0
003c8a 9508              ret
                 XXON_TX0_1:
003c8b 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003c8c e1f1              ldi     zh, XON
003c8d c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003c8e 9189
003c8f 9199              poptos
003c90 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003c91 fd70              sbrc    FLAGS2, ixoff_tx0
003c92 9508              ret     
                 XXOFF_TX0_1:
003c93 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003c94 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003c95 91e0 00c0         in_     zl, UCSR0A
003c97 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003c98 cffc              rjmp    TX0_SEND
003c99 93f0 00c6         out_    UDR0_, zh
003c9b 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003c9c f8ec              fdw(TX0_L)
                 RX0_L:
003c9d 7283
003c9e 3078              .db     NFA|3,"rx0"
                 RX0_:
003c9f d282              rcall   PAUSE
003ca0 d01e              rcall   RX0Q
003ca1 940e 33fa         call    ZEROSENSE
003ca3 f3d9              breq    RX0_
003ca4 939a
003ca5 938a              pushtos
003ca6 ebe7              ldi     zl, low(rbuf0)
003ca7 e0f1              ldi     zh, high(rbuf0)
003ca8 91a0 01b5         lds     xl, rbuf0_rd
003caa 0fea              add     zl, xl
003cab 1df5              adc     zh, r_zero
003cac 8180              ld      tosl, z
003cad 2799              clr     tosh
003cae b70f              in_     t0, SREG
003caf 94f8              cli
003cb0 95a3              inc     xl
003cb1 73af              andi    xl, (RX0_BUF_SIZE-1)
003cb2 93a0 01b5         sts     rbuf0_rd, xl
003cb4 91a0 01b6         lds     xl, rbuf0_lv
003cb6 95aa              dec     xl
003cb7 93a0 01b6         sts     rbuf0_lv, xl
003cb9 bf0f              out_    SREG, t0
003cba 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003cbb f93a              fdw     RX0_L
                 RX0Q_L:
003cbc 7284
003cbd 3078
003cbe 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003cbf 91a0 01b6         lds     xl, rbuf0_lv
003cc1 11a5              cpse    xl, r_zero
003cc2 940c 3783         jmp     TRUE_
                 .if U0FC_TYPE == 1
003cc4 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003cc5 940c 377a         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003cc7 dcbe              rcall   DOTS
003cc8 940e 325c         call    XSQUOTE
003cca 4103
003ccb 3f44              .db     3,"AD?"
003ccc 940e 324f         call    TYPE
003cce cae2              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003ccf 5890      	sub_pflash_tos
                 .ifdef  RAMPZ
                 .endif
                 XUPDATEBUF:
003cd0 9380 0203         sts     iaddrl, tosl
003cd2 9390 0204         sts     iaddrh, tosh
                 .ifdef RAMPZ
                 .endif
003cd4 359f              cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
003cd5 f788              brcc    ISTORERR
                 XUPDATEBUF2:	
003cd6 9100 0203         lds     t0, iaddrl
003cd8 7800              andi    t0, ~(PAGESIZEB-1)
003cd9 110a              cpse    t0, ibasel
003cda c005              rjmp    IFILL_BUFFER
003cdb 9100 0204         lds     t0, iaddrh
003cdd 110b              cpse    t0, ibaseh
003cde c001              rjmp    IFILL_BUFFER
                 .ifdef RAMPZ
                 .endif
003cdf 9508              ret
                 
                 IFILL_BUFFER:
003ce0 d075              rcall   IFLUSH
003ce1 9100 0203         lds     t0, iaddrl
003ce3 7800              andi    t0, ~(PAGESIZEB-1)
003ce4 2ea0              mov     ibasel, t0
003ce5 90b0 0204         lds     ibaseh, iaddrh
                 .ifdef RAMPZ
                 .endif
                 IFILL_BUFFER_1:
003ce7 e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003ce8 01f5              movw    zl, ibasel
003ce9 e0a0              ldi     xl, low(ibuf)
003cea e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003ceb 9115              lpm_    t1, z+
003cec 931d              st      x+, t1
003ced 950a              dec     t0
003cee f7e1              brne    IFILL_BUFFER_2
                 .ifdef RAMPZ
                 .endif
003cef 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003cf0 dae7              rcall   DOLIT
003cf1 0013              .dw     XOFF
003cf2 940e 308b         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003cf4 dae3              rcall   DOLIT
003cf5 000a              .dw     10
003cf6 dc2d              rcall   MS
                         ; Disable interrupts
003cf7 94f8              cli
003cf8 01f5              movw    zl, ibasel
                 .ifdef RAMPZ
                 .endif
003cf9 e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003cfa d02d              rcall   DO_SPM
003cfb e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003cfc d02b              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003cfd e800              ldi     t0, low(PAGESIZEB);init loop variable
003cfe e0a0              ldi     xl, low(ibuf)
003cff e0b1              ldi     xh, high(ibuf)
003d00 920f              push    r0
003d01 921f              push    r1
                 IWRITE_BUFFER1:
003d02 900d              ld      r0, x+
003d03 901d              ld      r1, x+
003d04 e011              ldi     t1, (1<<SPMEN)
003d05 d022              rcall   DO_SPM
003d06 9632              adiw    zl, 2
003d07 5002              subi    t0, 2
003d08 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d09 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d0a 40f0              sbci    zh, high(PAGESIZEB)
003d0b e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d0c d01b              rcall   DO_SPM
                         ; re-enable the RWW section
003d0d d014              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d0e e800              ldi     t0, low(PAGESIZEB);init loop variable
003d0f 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d10 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d11 9005              lpm_    r0, z+
003d12 901d              ld      r1, x+
003d13 1001              cpse    r0, r1
003d14 c05b              rjmp    WARM_     ; reset
003d15 5001              subi    t0, 1
003d16 f7d1              brne    IWRITE_BUFFER2
003d17 901f              pop     r1
003d18 900f              pop     r0
003d19 ef0f      	ser     t0
003d1a 2eb0      	mov     ibaseh, t0
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
003d1b 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d1c 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d1d daba              rcall   DOLIT
003d1e 0011              .dw     XON
003d1f 940e 308b         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 .if DEBUG_FLASH == 1
                 .endif
003d21 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d22 b687              in_     t8, SPMCSR
003d23 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d24 9508              ret
                         ; re-enable the RWW section
003d25 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d26 d001              rcall   DO_SPM
003d27 cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d28 b687              in_     t8, SPMCSR
003d29 fc80              sbrc    t8, SPMEN
003d2a cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d2b bf17              out_    SPMCSR, t1
003d2c 95e8              spm
003d2d 9508              ret
                 ; WD+ ( n -- )  n < 8 start watchdog timer
                 .if (FLASHEND < 0x1ffff)
003d2e fe3e              fdw     PAUSE_L
                 WDON_L:
003d2f 7783
003d30 2b64              .db     NFA|3,"wd+"
                 WDON:
003d31 94f8              cli
003d32 95a8              wdr
003d33 9190 0060         lds     tosh, WDTCSR
003d35 6198              ori     tosh, (1<<WDCE)|(1<<WDE)
003d36 9390 0060         sts     WDTCSR, tosh
003d38 7087              andi    tosl, 7
003d39 6088              ori     tosl, (1<<WDE)
003d3a 9380 0060         sts     WDTCSR, tosl
003d3c 9478              sei
003d3d 940c 3298         jmp     DROP
                 
                 ; WD- ( -- )    stop the watchdog 
003d3f fa5e              fdw     WDON_L
                 WDOFF_L:
003d40 7783
003d41 2d64              .db     NFA|3,"wd-"
                 WDOFF:
003d42 94f8              cli
003d43 95a8              wdr
                 .ifdef MCUSR
003d44 be54              out     MCUSR, r_zero
                 .else
                 .endif
003d45 e108              ldi     t0, (1<<WDCE)|(1<<WDE)
003d46 9300 0060         sts     WDTCSR, t0
003d48 9250 0060         sts     WDTCSR, r_zero
003d4a 9478              sei
003d4b 9508              ret
                 
                 ; WDR ( -- )    kick the dog
003d4c fa80              fdw     WDOFF_L
                 CWD_L:
003d4d 63a3
003d4e 6477              .db     NFA|INLINE|3,"cwd"
                 CWD:
003d4f 95a8              wdr
003d50 9508              ret
                 
                 .endif
003d51 fa9a              fdw     CWD_L
                 IFLUSH_L:
003d52 6986
003d53 6c66
003d54 7375
003d55 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d56 fd60              sbrc    FLAGS1, idirty
003d57 cf98              rjmp    IWRITE_BUFFER
003d58 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d59 f978              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d5a 6585
003d5b 706d
003d5c 7974              .db     NFA|5,"empty"
                 EMPTY:
003d5d da7a              rcall   DOLIT
003d5e ff4a              fdw     COLDLIT
003d5f da78              rcall   DOLIT
003d60 0900              .dw     dp_start
003d61 da76              rcall   DOLIT
003d62 000c              .dw     coldlitsize
003d63 940e 3566         call    CMOVE
003d65 940c 3756         jmp     DP_TO_RAM
                 
                 ; Init constant registers
                 INIT_012:
003d67 2455              clr     r_zero
003d68 e0e1              ldi     zl, 1
003d69 e0f2              ldi     zh, 2
003d6a 013f              movw    r_one, zl
003d6b 9508              ret
                 ;*******************************************************
003d6c fab4              fdw     EMPTY_L
                 WARM_L:
003d6d 7784
003d6e 7261
003d6f 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d70 94f8              cli           ; Disable interrupts
003d71 27aa              clr     xl
003d72 27bb              clr     xh
003d73 e1c9              ldi     yl, 25
003d74 e0d0              ldi     yh, 0
                 WARM_1:
003d75 93dd              st      x+, yh
003d76 50c1              subi    yl, 1
003d77 f7e9              brne    WARM_1
                 
003d78 b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d79 b604              in_     t2, MCUSR
003d7a 9250 0034         sts     MCUSR, r_zero
                 .endif
003d7c e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d7d 925d              st      x+, r_zero
003d7e 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d7f f7e9              brne    WARM_2
                 
                 ; Init empty flash buffer
003d80 94ba      	    dec     ibaseh
                 .ifdef RAMPZ
                 .endif
                 
                 ; Init Stack pointer
003d81 eac1              ldi     yl, low(utibbuf-4)
003d82 e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d83 e604              ldi     t0, low(usbuf-1)
003d84 e012              ldi     t1, high(usbuf-1)
003d85 bf0d              out     spl, t0
003d86 bf1e              out     sph, t1
                 
003d87 dfdf              rcall   INIT_012
003d88 940e 3d42         call    WDOFF
                 
                 ; Init user pointer
003d8a e203              ldi     t0, low(up0)
003d8b e012              ldi     t1, high(up0)
003d8c 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d8d da4a              rcall   DOLIT
003d8e df22              fdw     WARMLIT
003d8f da48              rcall   DOLIT
003d90 0205              .dw     cse
003d91 da46              rcall   DOLIT
003d92 001c              .dw     warmlitsize
003d93 940e 3566         call    CMOVE
                 ; init cold data to eeprom
003d95 da42              rcall   DOLIT
003d96 0900              .dw     dp_start
003d97 d0f3              rcall   FETCH
003d98 d9ea              rcall   TRUE_
003d99 940e 338b         call    EQUAL
003d9b 940e 33fa         call    ZEROSENSE
003d9d f009              breq    WARM_3  
003d9e dfbe              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d9f be65              out_    MCUCR, r_one   ; (1<<IVCE)
003da0 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 ; Start watchdog timer
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
003da1 bc74              out_    TCCR0A, r_two  ; CTC
003da2 e003              ldi     t0, ms_pre_tmr0
003da3 bd05              out_    TCCR0B, t0
003da4 ef09              ldi     t0, ms_value_tmr0
003da5 bd07              out_    OCR0A, t0
003da6 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
003da8 da2f              rcall   DOLIT
003da9 3c57              .dw     RX0_ISR
003daa da2d              rcall   DOLIT
                 .ifdef URXC0addr
                 .else
003dab 01a4              .dw     URXCaddr+ivec
                 .endif
003dac d0a4              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, r_zero
003dad e109              ldi     t0, ubrr0val
003dae 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003db0 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003db1 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003db3 e006              ldi     t0, (3<<UCSZ00)|URSEL_
003db4 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003db6 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003db7 d99e              rcall   DP_TO_RAM
003db8 9478              sei
                 
003db9 dde5              rcall   RQ_EMIT
003dba d028              rcall   VER
003dbb 9250 01b6         sts     rbuf0_lv, r_zero
003dbd 9250 01b4         sts     rbuf0_wr, r_zero
                 .ifdef rbuf1_lv
                 .endif
                 .if CPU_LOAD_LED == 1
003dbf 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .endif
                 ; Turnkey ?
003dc0 d15a              rcall   TURNKEY
003dc1 940e 33fa         call    ZEROSENSE
003dc3 f0d1              breq    STARTQ2
003dc4 940e 325c         call    XSQUOTE
003dc6 4503
003dc7 4353              .db     3,"ESC"
003dc8 940e 324f         call    TYPE
003dca da0d              rcall   DOLIT
003dcb 07d0              .dw     TURNKEY_DELAY
003dcc db57              rcall   MS
003dcd 940e 3098         call    KEYQ
003dcf 940e 33fa         call    ZEROSENSE
003dd1 f049              breq    STARTQ1
003dd2 940e 3091         call    KEY
003dd4 da03              rcall   DOLIT
003dd5 001b              .dw     0x1b
003dd6 940e 338b         call    EQUAL
003dd8 940e 33fa         call    ZEROSENSE
003dda f419              brne    STARTQ2
                 STARTQ1:
003ddb d13f              rcall   TURNKEY
003ddc 940e 30a0         call    EXECUTE
                 STARTQ2:
003dde 940c 37b1         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
003de0 fada              fdw     WARM_L
                 VER_L:
003de1 7683
003de2 7265              .db     NFA|3,"ver"
                 VER:
003de3 940e 325c         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
003de5 4623
003de6 616c
003de7 6873
003de8 6f46
003de9 7472
003dea 2068
003deb 2035
003dec 5441
003ded 656d
003dee 6167
003def 3233
003df0 2038
003df1 3332
003df2 302e
003df3 2e39
003df4 3032
003df5 3831
003df6 0a0d              .db     partlen+datelen+16,"FlashForth 5 ",partstring," ", DATE,0xd,0xa
003df7 940c 324f         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003df9 fbc2              fdw     VER_L
                 EI_L:
003dfa 65a2
003dfb 0069              .db     NFA|INLINE|2,"ei",0
003dfc 9478              sei
003dfd 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003dfe fbf4              fdw     EI_L
                 DI_L:
003dff 64a2
003e00 0069              .db     NFA|INLINE|2,"di",0
003e01 94f8              cli
003e02 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003e03 fbfe              fdw     DI_L
                 IRQ_SEMI_L:
003e04 3bc2
003e05 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003e06 d9d1              rcall   DOLIT
                 .ifdef EIND
                 .else
003e07 940c              .dw     0x940C     ; jmp
                 .endif
003e08 d13a              rcall   ICOMMA
003e09 d9ce              rcall   DOLIT
003e0a 3c33              .dw     FF_ISR_EXIT
003e0b d137              rcall   ICOMMA
003e0c 940c 3898         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003e0e fc08              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003e0f 6984
003e10 746e
003e11 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003e12 01fc              movw    zl, tosl
003e13 9731              sbiw    zl, 1
003e14 0fee              lsl     zl
                 .if low(ivec) == 0x80
003e15 e8f0              ldi     zh, low(ivec)
003e16 0fef              add     zl,  zh
                 .endif
003e17 e0f1              ldi     zh, high(ivec)
003e18 9189
003e19 9199              poptos
003e1a dbbf              rcall   TO_XA
003e1b 940c 3e56         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003e1d fc1e              fdw     IRQ_V_L
                 LITERAL_L:
003e1e 6cc7
003e1f 7469
003e20 7265
003e21 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003e22 d9b5              rcall   DOLIT
003e23 efc2              fdw     DUP
003e24 dc47              rcall   INLINE0
003e25 9380 01f7         sts     litbuf0, tosl
003e27 9390 01f8         sts     litbuf1, tosh
003e29 6860              sbr     FLAGS1, (1<<fLIT)
003e2a 940e 37e1         call    DUP
003e2c 2f98              mov     tosh, tosl
003e2d 9592              swap    tosh
003e2e 709f              andi    tosh, 0xf
003e2f 708f              andi    tosl, 0xf
003e30 6e90              ori     tosh, 0xe0
003e31 6880              ori     tosl, 0x80
003e32 d110              rcall   ICOMMA
003e33 2f89              mov     tosl, tosh
003e34 9592              swap    tosh
003e35 709f              andi    tosh, 0xf
003e36 708f              andi    tosl, 0xf
003e37 6e90              ori     tosh, 0xe0
003e38 6980              ori     tosl, 0x90
003e39 940c 3f43         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e3b de93              rcall   IUPDATEBUF
                 ISTORE1:
003e3c 9189
003e3d 9199              poptos
003e3e e0a0              ldi     xl, low(ibuf)
003e3f e0b1              ldi     xh, high(ibuf)
003e40 9100 0203         lds     t0, iaddrl
003e42 770f              andi    t0, (PAGESIZEB-1)
003e43 0fa0              add     xl, t0
003e44 938d              st      x+, tosl
003e45 939d              st      x+, tosh
003e46 c074              rjmp    ICSTORE_POP
                 
003e47 fc3c              fdw     LITERAL_L
                 TO_A_L:
003e48 3e82
003e49 0061              .db     NFA|2, ">a",0
                 TO_A:
003e4a 2f28              mov     al, tosl
003e4b 2f39              mov     ah, tosh
003e4c 9189
003e4d 9199              poptos
003e4e 9508              ret
                 
003e4f fc90              fdw     TO_A_L
                 STORE_L:
003e50 2181              .db     NFA|1, "!"
                 STORE:
003e51 3099              cpi     tosh, high(PEEPROM)
003e52 f440              brcc    STORE1
                 STORE_RAM:
003e53 01fc              movw    zl, tosl
003e54 9189
003e55 9199              poptos
                 STORE_RAM_2:
003e56 8391              std     Z+1, tosh
003e57 8380              std     Z+0, tosl
003e58 9189
003e59 9199              poptos
003e5a 9508              ret
                 STORE1:
003e5b d009              rcall   LOCKEDQ
003e5c 3890              cpi     tosh, high(OFLASH)
003e5d f6e8              brcc    ISTORE
                 ESTORE:
003e5e 940e 31d5         call    TWODUP
003e60 d06b              rcall   ECSTORE
003e61 9601              adiw    tosl, 1
003e62 8109              ldd     t0, Y+1
003e63 8308              std     y+0, t0
003e64 c067              rjmp    ECSTORE
                 
                 LOCKEDQ:
003e65 ff62              sbrs    FLAGS1, fLOCK
003e66 9508              ret
003e67 db1e              rcall   DOTS
003e68 940e 325c         call    XSQUOTE
003e6a 4103
003e6b 3f44              .db     3,"AD?"
003e6c 940e 324f         call    TYPE
003e6e cf6f              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e6f 01fc              movw    z, tosl
003e70 58f0              sub_pflash_z
                 .ifdef RAMPZ
                 .endif
003e71 11fb              cpse    zh, ibaseh
003e72 c00b              rjmp    IIFETCH
003e73 2f0e              mov     t0, zl
003e74 7800              andi    t0, ~(PAGESIZEB-1)
003e75 150a              cp      t0, ibasel
003e76 f439              brne    IIFETCH
003e77 e0a0              ldi     xl, low(ibuf)
003e78 e0b1              ldi     xh, high(ibuf)
003e79 77ef              andi    zl, (PAGESIZEB-1)
003e7a 0fae              add     xl, zl
003e7b 918d              ld      tosl, x+
003e7c 919d              ld      tosh, x+
003e7d 9508              ret
                 IIFETCH:
003e7e 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e7f 9195              lpm_    tosh, z+
003e80 9508              ret
                                 
003e81 fca0              fdw     STORE_L
                 A_FROM_L:
003e82 6182
003e83 003e              .db     NFA|2, "a>",0
                 A_FROM:
003e84 939a
003e85 938a              pushtos
003e86 2f82              mov     tosl, al
003e87 2f93              mov     tosh, ah
003e88 9508              ret
                 
                 .if FLASHEND > 0x3fff
                 .else
003e89 fd04              fdw     A_FROM_L
                 .endif
                 FETCH_L:
003e8a 4081              .db     NFA|1, "@"
                 FETCH:
003e8b 3099              cpi     tosh, high(PEEPROM)
003e8c f420              brcc    FETCH1
                 FETCH_RAM:
003e8d 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e8e 9181              ld      tosl, z+
003e8f 9191              ld      tosh, z+
003e90 9508              ret
                 FETCH1:
003e91 3890              cpi     tosh, high(OFLASH)
003e92 f6e0              brcc    IFETCH
                 EFETCH:
003e93 99f9              sbic    eecr, eewe
003e94 cffe              rjmp    EFETCH
003e95 5099              subi    tosh, high(PEEPROM)
003e96 bd81              out     eearl, tosl
003e97 bd92              out     eearh, tosh
003e98 9af8              sbi     eecr, eere
003e99 b500              in      t0, eedr
003e9a 9583              inc     tosl
003e9b bd81              out     eearl, tosl
003e9c 9af8              sbi     eecr, eere
003e9d b590              in      tosh, eedr
003e9e 2f80              mov     tosl, t0
003e9f 9508              ret
                 
                 ICFETCH:
003ea0 dfce              rcall   IFETCH
003ea1 2799              clr     tosh
003ea2 9508              ret
                 
003ea3 fd14              fdw     FETCH_L
                 CFETCH_L:
003ea4 6382
003ea5 0040              .db     NFA|2, "c@",0
                 CFETCH:
003ea6 3099              cpi     tosh, high(PEEPROM)
003ea7 f420              brcc    CFETCH1
                 CFETCH_RAM:
003ea8 01fc              movw    zl, tosl
003ea9 9181              ld      tosl, z+
003eaa 2799              clr     tosh
003eab 9508              ret
                 CFETCH1:
003eac 3890              cpi     tosh, high(OFLASH)
003ead f790              brcc    ICFETCH
                 ECFETCH:
003eae dfe4              rcall   EFETCH
003eaf 2799              clr     tosh
003eb0 9508              ret
                 
                 ICSTORE:
003eb1 de1d              rcall   IUPDATEBUF
003eb2 9189
003eb3 9199              poptos
003eb4 e0a0              ldi     xl, low(ibuf)
003eb5 e0b1              ldi     xh, high(ibuf)
003eb6 9100 0203         lds     t0, iaddrl
003eb8 770f              andi    t0, (PAGESIZEB-1)
003eb9 0fa0              add     xl, t0
003eba 938d              st      x+, tosl
                 ICSTORE_POP:
003ebb 6061              sbr     FLAGS1, (1<<idirty)
003ebc c009              rjmp    CSTORE_POP
                 
003ebd fd48              fdw     CFETCH_L
                 CSTORE_L:
003ebe 6382
003ebf 0021              .db     NFA|2, "c!",0
                 CSTORE:
003ec0 3099              cpi     tosh, high(PEEPROM)
003ec1 f438              brcc    CSTORE1
                 CSTORE_RAM:
003ec2 01fc              movw zl, tosl
003ec3 9189
003ec4 9199              poptos
003ec5 8380              st      Z, tosl
                 CSTORE_POP:
003ec6 9189
003ec7 9199              poptos
003ec8 9508              ret
                 CSTORE1:
003ec9 df9b              rcall   LOCKEDQ
003eca 3890              cpi     tosh, high(OFLASH)
003ecb f728              brcc    ICSTORE
                 ECSTORE:
003ecc 99f9              sbic    eecr, eewe
003ecd cffe              rjmp    ECSTORE
003ece 5099              subi    tosh, high(PEEPROM)
003ecf bd81              out     eearl, tosl
003ed0 bd92              out     eearh, tosh
003ed1 9189
003ed2 9199              poptos
003ed3 bd80              out     eedr, tosl
003ed4 9afa              sbi     eecr, eemwe
003ed5 9af9              sbi     eecr, eewe
003ed6 cfef              rjmp    CSTORE_POP
                 
                 ;;; Disable writes to flash and eeprom
003ed7 fd7c              fdw     CSTORE_L
                 
                 FLOCK_L:
003ed8 6683
003ed9 2d6c              .db     NFA|3,"fl-"
003eda 6064              sbr     FLAGS1, (1<<fLOCK)
003edb 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003edc fdb0              fdw     FLOCK_L
                 FUNLOCK_L:
003edd 6683
003ede 2b6c              .db     NFA|3,"fl+"
003edf 7f6b              cbr     FLAGS1, (1<<fLOCK)
003ee0 9508              ret
                 
                 
                 
003ee1 fdba              fdw     FUNLOCK_L
                 VALUE_L:
003ee2 7685
003ee3 6c61
003ee4 6575              .db     NFA|5,"value"
                 VALUE:
003ee5 d945              rcall   CREATE
003ee6 940e 3156         call    COMMA
003ee8 d994              rcall   XDOES
                 VALUE_DOES:
003ee9 940e 30e8         call    DODOES
003eeb 940c 3e8b         jmp     FETCH
                 
003eed fdc4              fdw     VALUE_L
                 DEFER_L:
003eee 6485
003eef 6665
003ef0 7265              .db     NFA|5,"defer"
                 DEFER:
003ef1 d939              rcall   CREATE
003ef2 940e 37d8         call    DOLIT
003ef4 ef62              fdw     ABORT
003ef5 940e 3156         call    COMMA
003ef7 d985              rcall   XDOES
                 DEFER_DOES:
003ef8 940e 30e8         call    DODOES
003efa 940c 30ab         jmp     FEXECUTE
                 
003efc fddc              fdw     DEFER_L
                 IS_L:
003efd 69c2
003efe 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003eff 940e 37f4         call    TICK
003f01 940e 3359         call    TWOPLUS
003f03 940e 3359         call    TWOPLUS
003f05 df85              rcall   FETCH
003f06 d9f0              rcall   STATE_
003f07 940e 33fa         call    ZEROSENSE
003f09 f029              breq    IS1
003f0a df17              rcall   LITERAL
003f0b 940e 30f8         call    DOCOMMAXT
003f0d fca2              fdw     STORE
003f0e c001              rjmp    IS2
                 IS1:
003f0f df41              rcall   STORE
                 IS2:
003f10 9508              ret
                 
003f11 fdfa              fdw     IS_L
                 TO_L:
003f12 74c2
003f13 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003f14 940c 3eff         jmp     IS
                 
003f16 fe24              fdw     TO_L
                 TURNKEY_L:
003f17 7487
003f18 7275
003f19 6b6e
003f1a 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003f1b 940e 3ee9         call    VALUE_DOES      ; Must be call for IS to work.
003f1d 01f9              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003f1e fe2e              fdw     TURNKEY_L
                 PAUSE_L:
003f1f 7085
003f20 7561
003f21 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003f22 dc97              rcall   IDLE_LOAD
                 .endif
003f23 b71f              in_     t1, SREG
003f24 94f8              cli
003f25 95a8              wdr               ; watchdog reset
003f26 93df              push    yh        ; SP
003f27 93cf              push    yl
003f28 939f              push    tosh      ; TOS
003f29 938f              push    tosl
003f2a 935f              push    ph        ; P
003f2b 934f              push    pl
003f2c 01f1              movw    zl, upl
003f2d b70e              in      t0, sph
003f2e 9302              st      -z, t0
003f2f b70d              in      t0, spl
003f30 9302              st      -z, t0
003f31 91b2              ld      xh, -z     ; UP
003f32 91a2              ld      xl, -z
003f33 011d              movw    upl, xl
003f34 910e              ld      t0, -x
003f35 bf0e              out     sph, t0
003f36 910e              ld      t0, -x
003f37 bf0d              out     spl, t0
003f38 914f              pop     pl
003f39 915f              pop     ph
003f3a 918f              pop     tosl
003f3b 919f              pop     tosh
003f3c 91cf              pop     yl
003f3d 91df              pop     yh
003f3e bf1f              out_    SREG, t1
003f3f 9508              ret
                 
                 
003f40 df70              fdw     OPERATOR_L
                 ICOMMA_L:
003f41 6982
003f42 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f43 940e 380e         call    IHERE
003f45 df0b              rcall   STORE
003f46 940e 3167         call    CELL
003f48 940c 39c7         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f4a fe82              fdw     ICOMMA_L
                 ICCOMMA_L:
003f4b 6983
003f4c 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f4d 940e 380e         call    IHERE
003f4f df70              rcall   CSTORE
003f50 940e 3208         call    ONE
003f52 940c 39c7         jmp     IALLOT
                 
                 L_DOTBASE:
003f54 2081              .db      NFA|1," "
                 DOTBASE:
003f55 940e 350d         call    BASE
003f57 df33              rcall   FETCH
003f58 3180              cpi     tosl, 0x10
003f59 f411              brne    DOTBASE1
003f5a e284              ldi     tosl,'$'
003f5b c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f5c 308a              cpi     tosl, 0xa
003f5d f411              brne    DOTBASE2
003f5e e283              ldi     tosl, '#'
003f5f c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f60 3082              cpi     tosl, 0x2
003f61 f411              brne    DOTBASE3
003f62 e285              ldi     tosl, '%'
003f63 c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f64 e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f65 9508              ret
                 
                 MEMQADDR_N:
003f66 e252              fdw     ROM_N
003f67 e260              fdw     EROM_N
003f68 e270              fdw     FRAM_N
                 ;*******************************************************
                 umstar0:
003f69 920f              push t2
003f6a 921f              push t3
003f6b 9109              ld  t0, Y+
003f6c 9119              ld  t1, Y+
003f6d 9f80              mul tosl,t0
003f6e 01d0              movw t4, r0 ; r0=t2, r1=t3
003f6f 27ee              clr t6
003f70 27ff              clr t7
003f71 9f90              mul tosh, t0
003f72 0db0              add t5, r0
003f73 1de1              adc t6, r1
003f74 1df5              adc t7, r_zero
003f75 9f81              mul tosl, t1
003f76 0db0              add t5, r0
003f77 1de1              adc t6, r1
003f78 1df5              adc t7, r_zero
003f79 9f91              mul tosh, t1
003f7a 0de0              add t6, r0
003f7b 1df1              adc t7, r1
003f7c 93ba              st -Y, t5
003f7d 93aa              st -Y, t4
003f7e 01cf              movw tosl, t6
003f7f 901f              pop t3
003f80 900f              pop t2
003f81 9508              ret
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
003f82 94e8              clt
003f83 2388              tst  tosl
003f84 f429              brne umslashmodstart
003f85 2399              tst  tosh
003f86 f419              brne umslashmodstart
003f87 9468              set  ; Set T flag
003f88 940c 3d70         jmp  WARM_
                 umslashmodstart:
003f8a 01dc              movw t4, tosl
                 
003f8b 9019              ld t3, Y+
003f8c 91e9              ld t6, Y+
                 
003f8d 9189              ld tosl, Y+
003f8e 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
003f8f e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
003f90 27ff              clr t7
003f91 0f88              lsl tosl
003f92 1f99              rol tosh
003f93 1c11              rol t3
003f94 1fee              rol t6
003f95 1fff              rol t7
                 
                         ; try subtracting divisor
003f96 161a              cp  t3, t4
003f97 07eb              cpc t6, t5
003f98 05f5              cpc t7,r_zero
                 
003f99 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
003f9a 9583              inc tosl
003f9b 1a1a              sub t3, t4
003f9c 0beb              sbc t6, t5
                 
                 umslashmod2:
003f9d 950a              dec  t0
003f9e f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
003f9f 93ea              st -Y,t6
003fa0 921a              st -Y,t3
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
003fa1 9508              ret
                 BASEQV:
003fa2 e9b0              fdw     DECIMAL
003fa3 e9be              fdw     HEX
003fa4 e9ce              fdw     BIN
                 
                 
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
003fa5 0000      STARTV: .dw      0
003fa6 8000      DPC:    .dw      OFLASH
003fa7 090c      DPE:    .dw      ehere
003fa8 02ff      DPD:    .dw      dpdata
003fa9 f6f2      LW:     fdw      lastword
003faa ee7a      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328 register use summary:
r0 :  20 r1 :  23 r2 :   5 r3 :   1 r4 :   0 r5 :  23 r6 :   7 r7 :   5 
r8 :   4 r9 :   4 r10:   5 r11:   5 r12:   0 r13:   0 r14:   2 r15:   2 
r16: 131 r17:  55 r18:   7 r19:   2 r20:  14 r21:   7 r22:  35 r23:  12 
r24: 244 r25: 188 r26:  55 r27:  40 r28:   5 r29:   5 r30:  79 r31:  52 
x  :  16 y  : 171 z  :  31 
Registers used: 32 out of 35 (91.4%)

ATmega328 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  18 add   :  20 adiw  :  14 and   :   4 
andi  :  24 asr   :   2 bclr  :   5 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  21 brcs  :   1 break :   0 breq  :  49 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   2 brmi  :   5 
brne  :  34 brpl  :   3 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  93 cbi   :   2 cbr   :  19 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :  18 cls   :   0 
clt   :   1 clv   :   0 clz   :   1 com   :  11 cp    :   3 cpc   :   2 
cpi   :  32 cpse  :   5 dec   :   4 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  15 in    :  15 inc   :   5 jmp   : 161 
ld    : 117 ldd   :   3 ldi   :  64 lds   :  21 lpm   :   7 lsl   :  11 
lsr   :   1 mov   :  24 movw  :  39 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   6 ori   :  19 out   :  25 pop   :  88 
push  :  36 rcall : 952 ret   : 130 reti  :   1 rjmp  : 110 rol   :  14 
ror   :  21 sbc   :   8 sbci  :   3 sbi   :   6 sbic  :   2 sbis  :   0 
sbiw  :  14 sbr   :  15 sbrc  :  12 sbrs  :  18 sec   :   0 seh   :   0 
sei   :   5 sen   :   0 ser   :   5 ses   :   0 set   :   1 sev   :   0 
sez   :   1 sleep :   1 spm   :   2 st    :  81 std   :   3 sts   :  26 
sub   :   2 subi  :  17 swap  :   3 tst   :   2 wdr   :   4 
Instructions used: 76 out of 113 (67.3%)

ATmega328 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007f56   5648   2478   8126   32768  24.8%
[.dseg] 0x000100 0x000301      0    513    513    2048  25.0%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 7 warnings
