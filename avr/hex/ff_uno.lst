
AVRASM ver. 2.1.42  E:\avr\src\ff-atmega.asm Wed Apr 02 20:57:41 2014

E:\avr\src\ff-atmega.asm(34): Including file 'E:\avr\src\config.inc'
E:\avr\src\config.inc(8): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m328def.inc'
E:\avr\src\ff-atmega.asm(72): warning: Register r26 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(73): warning: Register r27 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(74): warning: Register r30 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(75): warning: Register r31 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(238): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
E:\avr\src\ff-atmega.asm(239): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
E:\avr\src\ff-atmega.asm(240): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          02.04.2014                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2013  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 ;.include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 .include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 
                 ;***** Created: 2011-08-25 20:59 ******* Source: ATmega328.xml ***********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328
                 ;* Date              : 2011-08-25
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328DEF_INC_
                 #define _M328DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328
                 #pragma AVRPART ADMIN PART_NAME ATmega328
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x14
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturbs the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program.
                 .equ BAUDRATE0 = 38400              ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 84                   ; 74 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 1
                 
                 
                 
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def iaddrl=r12       ; Not in interrupt
                   .def iaddrh=r13       ; Not in interrupt
                   .def ms_count  = r14       ; Not in interrupt
                   .def ms_count1 = r15       ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def il = r18         ; FOR..LOOP INDEX variable
                   .def ih = r19
                   .def pl = r20         ; P Register
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*256/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fBUSY=     7   ; 1 = busy
                 .equ fIDLE=     6   ; 1 = busy
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)              ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                 	
                 ;;; USER AREA for the OPERATOR task
                 ;.equ uaddsize=     0          ; No additional user variables 
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001d7           dpSTART:    .byte 2
0001d9           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001db           dpEEPROM:   .byte 2
0001dd           dpRAM:      .byte 2
0001df           dpLATEST:   .byte 2
                 
0001e1           areg:       .byte 2 ; A register data
0001e3           load_acc:   .byte 3 ; Load measurement accumulator
0001e6           load:       .byte 1 ; Cpu load in percent
0001e7           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0001e8           state:      .byte 1 ; Compilation state
0001e9           uvars:      .byte   (-us0)
000205           up0:        .byte   2
000207           urbuf:      .byte   ursize
000267           usbuf:      .byte   ussize
0002a7           utibbuf:    .byte   utibsize
0002fb           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
002f80 94e8              clt
002f81 2388              tst  tosl
002f82 f429              brne umslashmodstart
002f83 2399              tst  tosh
002f84 f419              brne umslashmodstart
002f85 9468              set  ; Set T flag
002f86 940c 3d5d         jmp  WARM_
                 umslashmodstart:
002f88 01dc              movw t4, tosl
                 
002f89 9019              ld t3, Y+
002f8a 91e9              ld t6, Y+
                   
002f8b 9189              ld tosl, Y+
002f8c 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
002f8d e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
002f8e 27ff              clr t7
002f8f 0f88              lsl tosl
002f90 1f99              rol tosh
002f91 1c11              rol t3
002f92 1fee              rol t6
002f93 1fff              rol t7
                 
                         ; try subtracting divisor
002f94 161a              cp  t3, t4
002f95 07eb              cpc t6, t5
002f96 05f5              cpc t7,zero
                 
002f97 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
002f98 9583              inc tosl
002f99 1a1a              sub t3, t4
002f9a 0beb              sbc t6, t5
                 
                 umslashmod2:
002f9b 950a              dec  t0
002f9c f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
002f9d 93ea              st -Y,t6
002f9e 921a              st -Y,t3
                 
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
002f9f 9508              ret
                 ; *******************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fa0 0000              .dw     0
                 EXIT_L:
002fa1 6584
002fa2 6978
002fa3 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fa4 910f              pop     t0
002fa5 910f              pop     t0
002fa6 9508              ret
                 
                 ; idle
002fa7 df42              fdw(EXIT_L)
                 IDLE_L:
002fa8 6984
002fa9 6c64
002faa 0065              .db     NFA|4,"idle",0
                 IDLE:
002fab 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fac 9508              ret
                         
                 ; busy
002fad df50              fdw(IDLE_L)
                 BUSY_L:
002fae 6284
002faf 7375
002fb0 0079              .db     NFA|4,"busy",0
                 BUSY:
002fb1 6470              sbr     FLAGS2, (1<<fIDLE)
002fb2 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fb3 feac              fdw     ICCOMMA_L
                 MSET_L:
002fb4 6d84
002fb5 6573
002fb6 0074              .db     NFA|4,"mset",0
                 MSET:
002fb7 01fc              movw    zl, tosl
002fb8 9189
002fb9 9199              poptos
002fba 8100              ld      t0, z
002fbb 2b08              or      t0, tosl
002fbc 8300              st      z, t0
002fbd 9189
002fbe 9199              poptos
002fbf 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002fc0 df68              fdw     MSET_L
                 MCLR_L:
002fc1 6d84
002fc2 6c63
002fc3 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002fc4 01fc              movw    zl, tosl
002fc5 9189
002fc6 9199              poptos
002fc7 8100              ld      t0, z
002fc8 9580              com     tosl
002fc9 2308              and     t0, tosl
002fca 8300              st      z, t0
002fcb 9189
002fcc 9199              poptos
002fcd 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
002fce df82              fdw     MCLR_L
                 LSHIFT_L:
002fcf 6c86
002fd0 6873
002fd1 6669
002fd2 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
002fd3 01fc              movw    zl, tosl
002fd4 9189
002fd5 9199              poptos
                 LSHIFT1:
002fd6 9731              sbiw    zl, 1
002fd7 f01a              brmi    LSHIFT2
002fd8 0f88              lsl     tosl
002fd9 1f99              rol     tosh
002fda cffb              rjmp    LSHIFT1
                 LSHIFT2:
002fdb 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
002fdc df9e              fdw     LSHIFT_L
                 RSHIFT_L:
002fdd 7286
002fde 6873
002fdf 6669
002fe0 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
002fe1 01fc              movw    zl, tosl
002fe2 9189
002fe3 9199              poptos
                 RSHIFT1:
002fe4 9731              sbiw    zl, 1
002fe5 f01a              brmi    RSHIFT2
002fe6 9596              lsr     tosh
002fe7 9587              ror     tosl
002fe8 cffb              rjmp    RSHIFT1
                 RSHIFT2:
002fe9 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
002fea d546              rcall   CFETCHPP
002feb d298              rcall   ROT
002fec d544              rcall   CFETCHPP
002fed 940c 3284         jmp     ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
002fef dfba              fdw     RSHIFT_L
                 NEQUAL_L:
002ff0 6e82
002ff1 003d              .db     NFA|2,"n=",0
                 NEQUAL:
002ff2 dff7              rcall   NEQUALSFETCH
002ff3 708f              andi    tosl, 0xf
002ff4 d337              rcall   EQUAL
002ff5 d3a6              rcall   ZEROSENSE
002ff6 f0b1              breq    NEQUAL5
002ff7 d2fb              rcall   ONEMINUS
002ff8 d538              rcall   CFETCHPP
002ff9 d291              rcall   TOR
002ffa c00c              rjmp    NEQUAL4
                 NEQUAL2:
002ffb dfee              rcall   NEQUALSFETCH
002ffc d328              rcall   NOTEQUAL
002ffd d39e              rcall   ZEROSENSE
002ffe f021              breq    NEQUAL3
002fff d736              rcall   TRUE_
003000 940e 3a48         call    LEAVE
003002 c004              rjmp    NEQUAL4
                 NEQUAL3:
003003 d29b              rcall   RFETCH
003004 d397              rcall   ZEROSENSE
003005 f409              brne    NEQUAL4
003006 d726              rcall   FALSE_
                 NEQUAL4:
003007 940e 3a38         call    XNEXT
003009 f788              brcc    NEQUAL2
00300a 911f              pop     t1
00300b 910f              pop     t0
00300c c001              rjmp    NEQUAL6
                 NEQUAL5:
00300d d728              rcall   TRUE_
                 NEQUAL6:
00300e d3ce              rcall   NIP
00300f 940c 33dd         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
003011 dfe0              fdw     NEQUAL_L
                 SKIP_L:
003012 7384
003013 696b
003014 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003015 d275              rcall   TOR
                 SKIP1:
003016 d77d              rcall   DUP
003017 d384              rcall   ZEROSENSE
003018 f049              breq    SKIP2
003019 d262              rcall   OVER
00301a d3e4              rcall   CFETCH_A
00301b d283              rcall   RFETCH
00301c d30f              rcall   EQUAL
00301d d37e              rcall   ZEROSENSE
00301e f019              breq    SKIP2
00301f d1bf              rcall   ONE
003020 d4bb              rcall   SLASHSTRING
003021 cff4              rjmp    SKIP1
                 SKIP2:
003022 910f              pop     t0
003023 910f              pop     t0
003024 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
003025 e024              fdw     SKIP_L
                 SCAN_L:
003026 7384
003027 6163
003028 006e              .db     NFA|4,"scan",0
                 SCAN:
003029 d328              rcall   STORE_P_TO_R
00302a d260              rcall   TOR
00302b c008              rjmp    SCAN3
                 SCAN1:
00302c d504              rcall   CFETCHPP
00302d 940e 3b0d         call    FETCH_P
00302f d2fc              rcall   EQUAL
003030 d36b              rcall   ZEROSENSE
003031 f011              breq    SCAN3
003032 d2c0              rcall   ONEMINUS
003033 c003              rjmp    SCAN4
                 SCAN3:
003034 940e 3a38         call    XNEXT
003036 f7a8              brcc    SCAN1
                 SCAN4:
003037 d25d              rcall   RFROM
003038 d2b5              rcall   ONEPLUS
003039 d323              rcall   R_TO_P
00303a 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
00303b e04c              fdw     SCAN_L
                 MTST_L:
00303c 6d84
00303d 7374
00303e 0074              .db     NFA|4,"mtst",0
                 MTST:
00303f 940e 3e9b         call    CFETCH
003041 940c 32c6         jmp     AND_
                 
003043 e078              fdw     MTST_L
                 FCY_L:
003044 4683
003045 7963              .db     NFA|3,"Fcy"
003046 d06a              rcall   DOCREATE
003047 3e80              .dw     FREQ_OSC / 1000
                 
                 ;*******************************************************
                 ; Assembler
                 ;*******************************************************
                 ; FIXME
                 ;*******************************************************
                         
                 
                 ;;; Check parameter stack pointer
003048 7383
003049 3f70              .db     NFA|3,"sp?"
                 check_sp:
00304a d089              rcall   SPFETCH
00304b 940e 38c4         call    R0_
00304d d67d              rcall   FETCH_A
00304e 940e 38bf         call    S0
003050 d67a              rcall   FETCH_A
003051 d29c              rcall   ONEPLUS
003052 d2c8              rcall   WITHIN
003053 d1df              rcall   XSQUOTE
003054 5303
003055 3f50              .db     3,"SP?"
003056 d721              rcall   QABORT
003057 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
003058 e088              fdw     FCY_L
                 EMIT_L:
003059 6584
00305a 696d
00305b 0074              .db     NFA|4,"emit",0
                 EMIT:
00305c d32f              rcall   UEMIT_
00305d 940c 307c         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
00305f e0b2              fdw     EMIT_L
                 KEY_L:
003060 6b83
003061 7965              .db     NFA|3,"key"
                 KEY:
003062 d32f              rcall   UKEY_
003063 940c 307c         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003065 e0c0              fdw     KEY_L
                 KEYQ_L:
003066 6b84
003067 7965
003068 003f              .db     NFA|4,"key?",0
                 KEYQ:
003069 d32e              rcall   UKEYQ_
00306a 940c 307c         jmp     FEXECUTE
                 
00306c e0cc              fdw     KEYQ_L
                 EXECUTE_L:
00306d 6587
00306e 6578
00306f 7563
003070 6574              .db     NFA|7,"execute"
                 EXECUTE:
003071 01fc              movw    zl, tosl
003072 58f0              sub_pflash_z
003073 9189
003074 9199              poptos
003075 9488              rampv_to_c
003076 95f7              ror     zh
003077 95e7              ror     zl
003078 9409              mijmp
                 
003079 e0da              fdw     EXECUTE_L
                 FEXECUTE_L:
00307a 4083
00307b 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
00307c d64e              rcall   FETCH_A
00307d 940c 3071         jmp     EXECUTE
                 
00307f e0f4              fdw     FEXECUTE_L
                 VARIABLE_L:
003080 7688
003081 7261
003082 6169
003083 6c62
003084 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
003085 d09b              rcall   HERE
003086 d0b0              rcall   CELL
003087 d1dc              rcall   ALLOT
003088 940c 309c 	jmp	CONSTANT_
                 
00308a e100              fdw     VARIABLE_L
                 TWOVARIABLE_L:
00308b 3289
00308c 6176
00308d 6972
00308e 6261
00308f 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
003090 d090              rcall   HERE
003091 d6f9              rcall   DOLIT
003092 0004              .dw     0x4
003093 d1d0              rcall   ALLOT
003094 940c 309c 	jmp	CONSTANT_
                 
003096 e116              fdw     TWOVARIABLE_L
                 CONSTANT_L:
003097 6388
003098 6e6f
003099 7473
00309a 6e61
00309b 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
00309c d7b9              rcall   COLON
00309d 940e 3dfd         call    LITERAL
00309f 940c 3864         jmp     SEMICOLON
                 
0030a1 e12e              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030a2 3289
0030a3 6f63
0030a4 736e
0030a5 6174
0030a6 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030a7 d1ca              rcall   SWOP
0030a8 d7ad              rcall   COLON
0030a9 940e 3dfd         call    LITERAL
0030ab 940e 3dfd         call    LITERAL
0030ad 940c 3864         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030af 2883
0030b0 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030b1 91ff              pop     zh
0030b2 91ef              pop     zl
0030b3 d00c              rcall   FETCHLIT
                         m_pop_zh
0030b4 91ff              pop     zh
0030b5 91ef              pop     zl
0030b6 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030b7 2883
0030b8 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030b9 91bf              pop     xh
0030ba 91af              pop     xl
                         m_pop_zh
0030bb 91ff              pop     zh
0030bc 91ef              pop     zl
0030bd d002              rcall   FETCHLIT
0030be 01fd              movw    z, x
0030bf 9409              mijmp    ; (z)
                 FETCHLIT:
0030c0 939a
0030c1 938a              pushtos
0030c2 0fee              lsl     zl
0030c3 1fff              rol     zh
0030c4 9185              lpm_    tosl, z+
0030c5 9195              lpm_    tosh, z+
0030c6 9508              ret
                 
0030c7 2883
0030c8 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
0030c9 91ff              pop     zh
0030ca 91ef              pop     zl
0030cb dff4              rcall   FETCHLIT
0030cc 95f7      	ror     zh
0030cd 95e7              ror     zl
0030ce 93ef              push    zl
0030cf 93ff              push    zh
                         m_push_t0
0030d0 c099              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
0030d1 e144              fdw     TWOCONSTANT_L
                 SPFETCH_L:
0030d2 7383
0030d3 4070              .db     NFA|3,"sp@"
                 SPFETCH:
0030d4 01fe              movw    z, y
0030d5 939a
0030d6 938a              pushtos
0030d7 01cf              movw    tosl, z
0030d8 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
0030d9 7383
0030da 2170              .db     NFA|3,"sp!"
                 SPSTORE:
0030db 01ec              movw    y, tosl
0030dc 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
0030dd 7283
0030de 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
0030df 91bf              pop     xh
0030e0 91af              pop     xl
0030e1 d7e2              rcall   R0_
0030e2 d5e8              rcall   FETCH_A
0030e3 bf8d              out     spl, tosl
0030e4 bf9e              out     sph, tosh
0030e5 9189
0030e6 9199              poptos
0030e7 01fd              movw    zl, xl
0030e8 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
0030e9 e1a4              fdw     SPFETCH_L
                 RPFETCH_L:
0030ea 72b3
0030eb 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
0030ec 939a
0030ed 938a              pushtos
0030ee b78d              in      tosl, spl
0030ef b79e              in      tosh, sph
0030f0 9508              ret
                 
                 ;   ><  Swap bytes        
0030f1 e1d4              fdw     RPFETCH_L
                 SWAPB_L:
0030f2 3ea2
0030f3 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
0030f4 2f08              mov     t0, tosl
0030f5 2f89              mov     tosl, tosh
0030f6 2f90              mov     tosh, t0
0030f7 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
0030f8 e1e4              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
0030f9 6685
0030fa 616c
0030fb 6873              .db     NFA|5,"flash"
                 ROM_:
0030fc 9250 01e7         sts     cse, zero
0030fe 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
0030ff e1f2              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003100 6586
003101 7065
003102 6f72
003103 006d              .db     NFA|6,"eeprom",0
                 EROM:
003104 9270 01e7         sts     cse, r_two
003106 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
003107 e200              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
003108 7283
003109 6d61              .db     NFA|3,"ram"
                 FRAM:
00310a e004              ldi     t0, 4
00310b 9300 01e7         sts     cse, t0
00310d 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
00310e e210              fdw     RAM_L
                 DP_L:
00310f 6482
003110 0070              .db     NFA|2,"dp",0
                 DP:
003111 d717              rcall   IDP
003112 d004              rcall   CSE_
003113 940c 32b0         jmp     PLUS
                 
                 
                 ;;; 
003115 6383
003116 6573              .db     NFA|3,"cse"
                 CSE_:
003117 939a
003118 938a              pushtos
003119 9180 01e7         lds     tosl, cse
00311b 2799              clr     tosh
00311c 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
00311d e21e              fdw     DP_L
                 HERE_L:
00311e 6884
00311f 7265
003120 0065              .db     NFA|4,"here",0
                 HERE:
003121 dfef              rcall   DP
003122 940c 3e71         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003124 e23c              fdw     HERE_L
                 COMMA_L:
003125 2c81              .db     NFA|1,","
                 COMMA:
003126 dffa              rcall   HERE
003127 d417              rcall   STORE_A
003128 d00e              rcall   CELL
003129 940c 3264         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
00312b e24a              fdw     COMMA_L 
                 CCOMMA_L:
00312c 6382
00312d 002c              .db     NFA|2,"c,",0
                 CCOMMA:
00312e dff2              rcall   HERE
00312f d2d3              rcall   CSTORE_A
003130 d0ae              rcall   ONE
003131 940c 3264         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003133 e258              fdw     CCOMMA_L
                 CELL_L:
003134 6384
003135 6c65
003136 006c              .db     NFA|4,"cell",0
                 CELL:
003137 939a
003138 938a              pushtos
003139 e082              ldi     tosl, 2
00313a e090              ldi     tosh, 0
00313b 9508              ret
                 
                 ; ALIGN    --                         align DP
00313c e268              fdw     CELL_L
                 ALIGN_L:
00313d 6185
00313e 696c
00313f 6e67              .db     NFA|5,"align"
                 ALIGN:
003140 dfe0              rcall   HERE
003141 d008              rcall   ALIGNED
003142 dfce              rcall   DP
003143 940c 3e29         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
003145 e27a              fdw     ALIGN_L
                 ALIGNED_L:
003146 6187
003147 696c
003148 6e67
003149 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00314a 9601              adiw    tosl, 1
00314b d63f              rcall   DOLIT
00314c fffe              .dw     0xfffe
00314d 940c 32c6         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
00314f e28c              fdw     ALIGNED_L
                 CELLPLUS_L:
003150 63a5
003151 6c65
003152 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003153 9602              adiw    tosl, 2
003154 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
003155 e2a0              fdw     CELLPLUS_L
                 CELLS_L:
003156 63a5
003157 6c65
003158 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
003159 0f88              lsl     tosl
00315a 1f99              rol     tosh
00315b 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
00315c e2ac              fdw     CELLS_L
                 CHARPLUS_L:
00315d 63a5
00315e 6168
00315f 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
003160 9601              adiw    tosl, 1
003161 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
003162 e2ba              fdw     CHARPLUS_L
                 CHARS_L:
003163 63a5
003164 6168
003165 7372              .db     NFA|INLINE|5,"chars"
003166 9508      CHARS:  ret
                 
003167 e2c6              fdw     CHARS_L
                 COMMAXT_L:
003168 6383
003169 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
00316a d629              rcall   DUP
00316b d656              rcall   IHERE
00316c d150              rcall   MINUS
00316d d13d              rcall   ABS_ 
00316e d61c              rcall   DOLIT
00316f 0ff0              .dw     0xff0
003170 d1c5              rcall   GREATER
003171 d22a              rcall   ZEROSENSE
003172 f059              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
003173 d617              rcall   DOLIT
                 .ifdef EIND
                 .else
003174 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
003175 940e 3f4e         call    ICOMMA
003177 5890              sub_pflash_tos
003178 9488              rampv_to_c
003179 9597              ror     tosh
00317a 9587              ror     tosl
00317b 940e 3f4e         call    ICOMMA
00317d c008              rjmp    STORECF2
                 STORECF1:
00317e d643              rcall   IHERE
00317f d13d              rcall   MINUS
003180 d720              rcall   TWOMINUS
003181 d187              rcall   TWOSLASH
                         ;rcall   RCALL_
003182 709f              andi    tosh, 0x0f
003183 6d90              ori     tosh, 0xd0
003184 940e 3f4e         call    ICOMMA
                 STORECF2:
003186 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
003187 2186
003188 6f63
003189 6f6c
00318a 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
00318b d5ff              rcall   DOLIT
00318c fffa              .dw     0xfffa         ;  -6
00318d 940c 3967         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
00318f e2d0              fdw     COMMAXT_L
                 TWOFETCH_L:
003190 3282
003191 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
003192 d601              rcall   DUP
003193 d537              rcall   FETCH_A
003194 d0dd              rcall   SWOP
003195 dfbd              rcall   CELLPLUS
003196 940c 36cb         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
003198 e320              fdw     TWOFETCH_L
                 TWOSTORE_L:
003199 3282
00319a 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
00319b d0d6              rcall   SWOP
00319c d0df              rcall   OVER
00319d dfb5              rcall   CELLPLUS
00319e d3a0              rcall   STORE_A
00319f 940c 3e29         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031a1 e332              fdw     TWOSTORE_L
                 TWODROP_L:
0031a2 3285
0031a3 7264
0031a4 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031a5 d0c5              rcall   DROP
0031a6 940c 326b         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031a8 e344              fdw     TWODROP_L
                 TWODUP_L:
0031a9 3284
0031aa 7564
0031ab 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031ac d0cf              rcall   OVER
0031ad 940c 327c         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031af e352              fdw     TWODUP_L
                 TWOSWAP_L:
0031b0 3285
0031b1 7773
0031b2 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031b3 d0d0              rcall   ROT
0031b4 d0d6              rcall   TOR
0031b5 d0ce              rcall   ROT
0031b6 d0de              rcall   RFROM
0031b7 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031b8 e360              fdw     TWOSWAP_L
                 SPACE_L:
0031b9 7385
0031ba 6170
0031bb 6563              .db     NFA|5,"space"
                 SPACE_:  
0031bc d6e9              rcall   BL
0031bd 940c 305c         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
0031bf e372              fdw     SPACE_L
                 SPACES_L:
0031c0 7386
0031c1 6170
0031c2 6563
0031c3 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
0031c4 d1dd              rcall   DUPZEROSENSE
0031c5 f019              breq    SPCS2
0031c6 dff5              rcall   SPACE_
0031c7 d12b              rcall   ONEMINUS
0031c8 cffb              rjmp    SPCS1
0031c9 940c 326b SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
0031cb e380              fdw     SPACES_L
                 UMIN_L:
0031cc 7584
0031cd 696d
0031ce 006e              .db     NFA|4,"umin",0
                 UMIN:
0031cf dfdc              rcall   TWODUP
0031d0 d173              rcall   UGREATER
0031d1 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
0031d2 e398              fdw     UMIN_L
                 UMAX_L:
0031d3 7584
0031d4 616d
0031d5 0078              .db     NFA|4,"umax",0
                 UMAX:
0031d6 dfd5              rcall   TWODUP
0031d7 d164              rcall   ULESS
                 MINMAX:
0031d8 d1c3              rcall   ZEROSENSE
0031d9 f009              breq    UMAX1
0031da d097              rcall   SWOP
0031db 940c 326b UMAX1:  jmp     DROP
                 
0031dd e3a6              fdw     UMAX_L
                 ONE_L:
0031de 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
0031df 939a
0031e0 938a              pushtos
0031e1 e081              ldi     tosl, 1
0031e2 e090              ldi     tosh, 0
0031e3 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
0031e4 e3bc              fdw     ONE_L
                 ACCEPT_L:
0031e5 6186
0031e6 6363
0031e7 7065
0031e8 0074              .db     NFA|6,"accept",0
                 ACCEPT:
0031e9 d092              rcall   OVER
0031ea d0c5              rcall   PLUS
0031eb d090              rcall   OVER
                 ACC1:
0031ec de75              rcall   KEY
                 
0031ed 308d              cpi     tosl, CR_
0031ee f429              brne    ACC_LF
                         
0031ef d546              rcall   TRUE_
0031f0 d02f              rcall   FCR
0031f1 d211              rcall   CSTORE_A
0031f2 d078              rcall   DROP
0031f3 c026              rjmp    ACC6
                 ACC_LF:
0031f4 308a              cpi     tosl, LF_
0031f5 f449              brne    ACC2
0031f6 d074              rcall   DROP
                 
0031f7 d028              rcall   FCR
0031f8 d206              rcall   CFETCH_A
0031f9 d1a2              rcall   ZEROSENSE
0031fa f0f9              breq    ACC6
0031fb d531              rcall   FALSE_
0031fc d023              rcall   FCR
0031fd d205              rcall   CSTORE_A
0031fe cfed              rjmp    ACC1
                 ACC2:
0031ff d52d              rcall   FALSE_
003200 d01f              rcall   FCR
003201 d201              rcall   CSTORE_A
003202 d591              rcall   DUP
003203 de58              rcall   EMIT
003204 d58f              rcall   DUP
003205 d585              rcall   DOLIT
003206 0008              .dw     BS_
003207 d124              rcall   EQUAL
003208 d193              rcall   ZEROSENSE
003209 f039              breq    ACC3
00320a d060              rcall   DROP
00320b d0e7              rcall   ONEMINUS
00320c d07e              rcall   TOR
00320d d06e              rcall   OVER
00320e d086              rcall   RFROM
00320f dfc6              rcall   UMAX
003210 cfdb              rjmp    ACC1
                 ACC3:
003211 d06a              rcall   OVER
003212 d1f0              rcall   CSTORE_A
003213 d0da              rcall   ONEPLUS
003214 d067              rcall   OVER
003215 dfb9              rcall   UMIN
003216 df95              rcall   TWODUP
003217 d10d              rcall   NOTEQUAL
003218 d183              rcall   ZEROSENSE
003219 f691              brne     ACC1
                 ACC6:
00321a d1c2              rcall   NIP
00321b d056              rcall   SWOP
00321c 940c 32bd         jmp     MINUS
                 
00321e 6683
00321f 7263              .db     NFA|3,"fcr"
                 FCR:
003220 d2a3              rcall   DOUSER
003221 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
003222 e3ca              fdw      ACCEPT_L
                 TYPE_L:
003223 7484
003224 7079
003225 0065              .db     NFA|4,"type",0
                 TYPE:
003226 d064              rcall   TOR
003227 c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
003228 d308              rcall   CFETCHPP
003229 de32              rcall   EMIT
                 TYPE2:
00322a 940e 3a38         call    XNEXT
00322c f7d8              brcc    TYPE1
00322d 911f              pop     t1
00322e 910f              pop     t0
00322f 940c 326b         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
003231 2883
003232 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
003233 d06b              rcall   RFETCH
003234 0f88              lsl     tosl
003235 1f99              rol     tosh
003236 5890              add_pflash_tos
003237 d2f9              rcall   CFETCHPP
003238 d55b              rcall   DUP
003239 d0b4              rcall   ONEPLUS
00323a df0f              rcall   ALIGNED
00323b 9596              lsr     tosh
00323c 9587              ror     tosl
00323d d057              rcall   RFROM
00323e d071              rcall   PLUS
00323f 01fc              movw    zl, tosl
003240 9189
003241 9199              poptos
003242 9409              mijmp
                 
003243 e446              fdw     TYPE_L
                 SQUOTE_L:
003244 73d2
003245 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
003246 de82              rcall   DOCOMMAXT
003247 e466              fdw     XSQUOTE
003248 deb3              rcall   ROM_
003249 d005              rcall   CQUOTE
00324a 940c 310a         jmp     FRAM
                 
00324c e488              fdw     SQUOTE_L
                 CQUOTE_L:
00324d 2c82
00324e 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
00324f d53b              rcall   DOLIT
003250 0022              .dw     0x22
003251 d29d              rcall   PARSE
003252 dece              rcall   HERE
003253 d028              rcall   OVER
003254 d099              rcall   ONEPLUS
003255 def4              rcall   ALIGNED
003256 d00d              rcall   ALLOT
003257 940c 3528         jmp     PLACE
                 
                 
003259 e49a              fdw     CQUOTE_L
                 DOTQUOTE_L:
00325a 2ed2
00325b 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
00325c dfe9              rcall   SQUOTE
00325d de6b              rcall   DOCOMMAXT
00325e e44c              fdw     TYPE
00325f 9508              ret
                 
003260 e4b4              fdw     DOTQUOTE_L
                 ALLOT_L:
003261 6185
003262 6c6c
003263 746f              .db     NFA|5,"allot"
                 ALLOT:
003264 deac              rcall   DP
003265 940c 330f         jmp     PLUSSTORE
                 
003267 e4c2              fdw     ALLOT_L
                 DROP_L:
003268 64a4
003269 6f72
00326a 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
00326b 9189
00326c 9199              poptos
00326d 9508              ret
                 
00326e e4d0              fdw     DROP_L
                 SWOP_L:
00326f 7384
003270 6177
003271 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
003272 9109              ld      t0, y+
003273 9119              ld      t1, y+
003274 939a
003275 938a              pushtos
003276 01c8              movw    tosl, t0
003277 9508              ret
                 
003278 e4de              fdw     SWOP_L
                 OVER_L:
003279 6f84
00327a 6576
00327b 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
00327c 939a
00327d 938a              pushtos
00327e 818a              ldd     tosl, y+2
00327f 819b              ldd     tosh, y+3
003280 9508              ret
                 
003281 e4f2              fdw     OVER_L
                 ROT_L:
003282 7283
003283 746f              .db     NFA|3, "rot"
                 ROT:
003284 d006              rcall   TOR
003285 dfec              rcall   SWOP
003286 d00e              rcall   RFROM
003287 cfea              rjmp    SWOP
                 
003288 e504              fdw     ROT_L
                 TOR_L:
003289 3e92
00328a 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
00328b 91ff              pop     zh
00328c 91ef              pop     zl
00328d 938f              push    tosl
00328e 939f              push    tosh
00328f 9189
003290 9199              poptos
003291 9409              mijmp
                 
003292 e512              fdw     TOR_L
                 RFROM_L:
003293 7292
003294 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
003295 91ff              pop     zh
003296 91ef              pop     zl
003297 939a
003298 938a              pushtos
003299 919f              pop     tosh
00329a 918f              pop     tosl
00329b 9409              mijmp
                 
00329c e526              fdw     RFROM_L
                 RFETCH_L:
00329d 7292
00329e 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
00329f 91ff              pop     zh
0032a0 91ef              pop     zl
0032a1 939a
0032a2 938a              pushtos
0032a3 919f              pop     tosh
0032a4 918f              pop     tosl
0032a5 938f              push    tosl
0032a6 939f              push    tosh
0032a7 9409              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
0032a8 ef24              fdw     DUP_L
                 ABS_L:
0032a9 6183
0032aa 7362              .db     NFA|3,"abs"
                 ABS_:
0032ab d4e8              rcall   DUP
0032ac 940c 33ec         jmp     QNEGATE
                 
0032ae e552              fdw     ABS_L
                 PLUS_L:
0032af 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032b0 9109              ld      t0, Y+        
0032b1 9119              ld      t1, Y+
0032b2 0f80              add     tosl, t0
0032b3 1f91              adc     tosh, t1
0032b4 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032b5 e55e              fdw     PLUS_L
                 MPLUS_L:
0032b6 6d82
0032b7 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032b8 d7a3              rcall   STOD
0032b9 940c 3a7e         jmp     DPLUS
                 
0032bb e56c              fdw     MPLUS_L
                 MINUS_L:
0032bc 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
0032bd 9109              ld      t0, Y+
0032be 9119              ld      t1, Y+
0032bf 1b08              sub     t0, tosl
0032c0 0b19              sbc     t1, tosh
0032c1 01c8              movw    tosl, t0
0032c2 9508              ret
                 
0032c3 e578              fdw     MINUS_L
                 AND_L:
0032c4 6183
0032c5 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
0032c6 9109              ld      t0, Y+
0032c7 9119              ld      t1, Y+
0032c8 2380              and     tosl, t0
0032c9 2391              and     tosh, t1
0032ca 9508              ret
                 
0032cb e588              fdw     AND_L
                 OR_L:
0032cc 6f82
0032cd 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
0032ce 9109              ld      t0, Y+
0032cf 9119              ld      t1, Y+
0032d0 2b80              or      tosl, t0
0032d1 2b91              or      tosh, t1
0032d2 9508              ret
                 
0032d3 e598              fdw     OR_L
                 XOR_L:
0032d4 7883
0032d5 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
0032d6 9109              ld      t0, Y+
0032d7 9119              ld      t1, Y+
0032d8 2780              eor     tosl, t0
0032d9 2791              eor     tosh, t1
0032da 9508              ret
                 
0032db e5a8              fdw     XOR_L
                 INVERT_L:
0032dc 69a6
0032dd 766e
0032de 7265
0032df 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
0032e0 9580              com     tosl
0032e1 9590              com     tosh
0032e2 9508              ret
                 
0032e3 e5b8              fdw     INVERT_L
                 NEGATE_L:
0032e4 6e86
0032e5 6765
0032e6 7461
0032e7 0065              .db     NFA|6, "negate",0
                 NEGATE:
0032e8 dff7              rcall   INVERT
0032e9 940c 32ee         jmp     ONEPLUS
                 
0032eb e5c8              fdw     NEGATE_L
                 ONEPLUS_L:
0032ec 31a2
0032ed 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
0032ee 9601              adiw    tosl, 1
0032ef 9508              ret
                 
0032f0 e5d8              fdw     ONEPLUS_L
                 ONEMINUS_L:
0032f1 31a2
0032f2 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
0032f3 9701              sbiw    tosl, 1
0032f4 9508              ret
                 
0032f5 e5e2              fdw     ONEMINUS_L
                 TWOPLUS_L:
0032f6 32a2
0032f7 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
0032f8 9602              adiw    tosl, 2
0032f9 9508              ret
                 
0032fa e5ec              fdw     TWOPLUS_L
                 TOBODY_L:
0032fb 3ea5
0032fc 6f62
0032fd 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
0032fe 9604              adiw    tosl, 4
0032ff 9508              ret
                 
003300 e5f6              fdw     TOBODY_L
                 TWOSTAR_L:
003301 32a2
003302 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003303 0f88              lsl     tosl
003304 1f99              rol     tosh
003305 9508              ret
                 
003306 e602              fdw     TWOSTAR_L
                 TWOSLASH_L:
003307 32a2
003308 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
003309 9595              asr     tosh
00330a 9587              ror     tosl
00330b 9508              ret
                 
00330c e60e              fdw     TWOSLASH_L
                 PLUSSTORE_L:
00330d 2b82
00330e 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
00330f df62              rcall   SWOP
003310 df6b              rcall   OVER
003311 d3b9              rcall   FETCH_A
003312 df9d              rcall   PLUS
003313 df5e              rcall   SWOP
003314 940c 3e29         jmp     STORE
                 
003316 e61a              fdw     PLUSSTORE_L
                 WITHIN_L:
003317 7786
003318 7469
003319 6968
00331a 006e              .db     NFA|6,"within",0
                 WITHIN:
00331b df60              rcall   OVER
00331c dfa0              rcall   MINUS
00331d df6d              rcall   TOR
00331e df9e              rcall   MINUS
00331f df75              rcall   RFROM
003320 940c 333c         jmp     ULESS
                 
003322 e62e              fdw     WITHIN_L
                 NOTEQUAL_L:
003323 3c82
003324 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
003325 df97              rcall	MINUS        	; MINUS leaves a valid zero flag
003326 f409              brne	NOTEQUAL1
003327 c47c              rjmp	FALSE_F
                 NOTEQUAL1:
003328 940c 379c         jmp	TRUE_F
                 
00332a ef40              fdw     ZEROLESS_L
                 EQUAL_L:
00332b 3d81              .db     NFA|1, "="
                 EQUAL:
00332c df90              rcall   MINUS
00332d 940c 379a         jmp     ZEROEQUAL
                 
                 
00332f e656              fdw     EQUAL_L
                 LESS_L:
003330 3c81              .db     NFA|1,"<"
                 LESS:
003331 df8b              rcall   MINUS
003332 940c 37a2         jmp     ZEROLESS
                 
003334 e660              fdw     LESS_L
                 GREATER_L:
003335 3e81              .db     NFA|1,">"
                 GREATER:
003336 df3b              rcall   SWOP
003337 940c 3331         jmp     LESS
                 
003339 e66a              fdw     GREATER_L
                 ULESS_L:
00333a 7582
00333b 003c              .db     NFA|2,"u<",0
                 ULESS:
00333c df80              rcall   MINUS
00333d f408              brcc    ULESS1        ; Carry test  
00333e c45d              rjmp    TRUE_F
                 ULESS1:
00333f 940c 37a4         jmp     FALSE_F
                 
                 
003341 e674              fdw     ULESS_L
                 UGREATER_L:
003342 7582
003343 003e              .db     NFA|2, "u>",0
                 UGREATER:
003344 df2d              rcall   SWOP
003345 940c 333c         jmp     ULESS
                 
003347 e684              fdw     UGREATER_L
                 STORE_P_L:
003348 2182
003349 0070              .db     NFA|2,"!p",0
                 STORE_P:
00334a 01ac              movw    pl, tosl
00334b 9189
00334c 9199              poptos
00334d 9508              ret
                 
00334e e690              fdw     STORE_P_L
                 STORE_P_TO_R_L:
00334f 2194
003350 3e70
003351 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
003352 91ff              pop     zh
003353 91ef              pop     zl
003354 934f              push    pl
003355 935f              push    ph
003356 01ac              movw    pl, tosl
003357 9189
003358 9199              poptos
003359 9409              mijmp
                 
00335a e69e              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
00335b 7293
00335c 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
00335d 91ff              pop     zh
00335e 91ef              pop     zl
00335f 915f              pop     ph
003360 914f              pop     pl
003361 9409              mijmp
                 
003362 e6b6              fdw     R_TO_P_L
                 PFETCH_L:
003363 7082
003364 0040              .db     NFA|2,"p@",0
                 PFETCH:
003365 939a
003366 938a              pushtos
003367 01ca              movw    tosl, pl
003368 940c 3e71         jmp     FETCH
                 
00336a e6c6              fdw     PFETCH_L
                 PSTORE_L:
00336b 7082
00336c 0021              .db     NFA|2,"p!",0
                 PSTORE:
00336d 939a
00336e 938a              pushtos
00336f 01ca              movw    tosl, pl
003370 940c 3e29         jmp     STORE
                 
003372 e6d6              fdw     PSTORE_L
                 PCSTORE_L:
003373 7083
003374 2163              .db     NFA|3,"pc!"
                 PCSTORE:
003375 939a
003376 938a              pushtos
003377 01ca              movw    tosl, pl
003378 940c 3ebe         jmp     CSTORE
                 
00337a e6e6              fdw     PCSTORE_L
                 PPLUS_L:
00337b 70a2
00337c 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
00337d 0d46              add     pl, r_one
00337e 1d55              adc     ph, zero
00337f 9508              ret   
                 
003380 e6f6              fdw     PPLUS_L
                 PNPLUS_L:
003381 7083
003382 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
003383 0f48              add     pl, tosl
003384 1f59              adc     ph, tosh
003385 9189
003386 9199              poptos
003387 9508              ret
                 
003388 e702              fdw     PNPLUS_L
                 UEMIT_L:
003389 2785
00338a 6d65
00338b 7469              .db     NFA|5,"'emit"
                 UEMIT_:
00338c d137              rcall   DOUSER
00338d ffe8              .dw     uemit
                         
00338e e712              fdw     UEMIT_L
                 UKEY_L:
00338f 2784
003390 656b
003391 0079              .db     NFA|4,"'key",0
                 UKEY_:
003392 d131              rcall   DOUSER
003393 ffea              .dw     ukey
                 
003394 e71e              fdw     UKEY_L
                 UKEYQ_L:
003395 2785
003396 656b
003397 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
003398 d12b              rcall   DOUSER
003399 ffec              .dw     ukeyq
                 
00339a 3f83
00339b 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
00339c 9700              sbiw    tosl, 0
00339d 9189
00339e 9199              poptos
00339f 9508              ret
                 
0033a0 6483
0033a1 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
0033a2 9700              sbiw    tosl, 0
0033a3 9508              ret
                 
0033a4 e72a              fdw     UKEYQ_L
                 UMSTAR_L:
0033a5 7583
0033a6 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
0033a7 940c 3f85         jmp     umstar0
                 
0033a9 e74a              fdw     UMSTAR_L
                 UMSLASHMOD_L:
0033aa 7586
0033ab 2f6d
0033ac 6f6d
0033ad 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
0033ae 940c 2f80         jmp     umslashmod0
                 
                 
0033b0 e754              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
0033b1 7585
0033b2 6d2f
0033b3 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
0033b4 d378              rcall   FALSE_
0033b5 debc              rcall   SWOP
0033b6 940c 2f80         jmp     umslashmod0
                 
0033b8 e762              fdw     USLASHMOD_L
                 STAR_L:
0033b9 2a81              .db     NFA|1,"*"
                 STAR: 
0033ba dfec              rcall   UMSTAR
0033bb 940c 326b         jmp     DROP
                 
0033bd e772              fdw     STAR_L
                 USLASH_L:
0033be 7582
0033bf 002f              .db     NFA|2,"u/",0
                 USLASH:
0033c0 dff3              rcall   USLASHMOD
0033c1 940c 33dd         jmp     NIP
                 
0033c3 e77c              fdw     USLASH_L
                 USSMOD_L:
0033c4 7586
0033c5 2f2a
0033c6 6f6d
0033c7 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
0033c8 dec2              rcall   TOR
0033c9 dfdd              rcall   UMSTAR
0033ca deca              rcall   RFROM
0033cb 940c 33ae         jmp     UMSLASHMOD
                 
                 
0033cd e788              fdw     USSMOD_L
                 SLASH_L:
0033ce 2f81              .db     NFA|1,"/"
                 SLASH: 
0033cf dddc              rcall   TWODUP
0033d0 df05              rcall   XOR_
0033d1 deb9              rcall   TOR
0033d2 ded8              rcall   ABS_
0033d3 de9e              rcall   SWOP
0033d4 ded6              rcall   ABS_
0033d5 de9c              rcall   SWOP
0033d6 dfe9              rcall   USLASH
0033d7 debd              rcall   RFROM
0033d8 940c 33ec         jmp     QNEGATE
                 
0033da e79c              fdw     SLASH_L
                 NIP_L:
0033db 6e83
0033dc 7069              .db     NFA|3,"nip"
                 NIP:
0033dd de94              rcall   SWOP
0033de 940c 326b         jmp     DROP
                     
0033e0 e7b6              fdw     NIP_L
                 TUCK_L:
0033e1 7484
0033e2 6375
0033e3 006b              .db     NFA|4,"tuck",0
                 TUCK:
0033e4 de8d              rcall   SWOP
0033e5 940c 327c         jmp     OVER
                 
0033e7 e7c2              fdw     TUCK_L
                 QNEGATE_L:
0033e8 3f87
0033e9 656e
0033ea 6167
0033eb 6574              .db     NFA|7,"?negate"
                 QNEGATE:
0033ec d3b5              rcall   ZEROLESS
0033ed dfae              rcall   ZEROSENSE
0033ee f009              breq    QNEGATE1
0033ef def8              rcall   NEGATE
                 QNEGATE1:
0033f0 9508              ret
                 
0033f1 e7d0              fdw     QNEGATE_L
                 MAX_L:
0033f2 6d83
0033f3 7861              .db     NFA|3,"max"
0033f4 ddb7      MAX:    rcall   TWODUP
0033f5 df3b              rcall   LESS
0033f6 cde1              rjmp    MINMAX
                 
0033f7 e7e4              fdw     MAX_L
                 MIN_L:
0033f8 6d83
0033f9 6e69              .db     NFA|3,"min"
0033fa ddb1      MIN:    rcall   TWODUP
0033fb df3a              rcall   GREATER
0033fc cddb              rjmp    MINMAX
                 
0033fd 6382
0033fe 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
0033ff 940c 3e9b         jmp     CFETCH
                 
003401 6382
003402 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003403 940c 3ebe         jmp     CSTORE
                 
003405 e7f0              fdw     MIN_L
                 UPTR_L:
003406 7582
003407 0070              .db     NFA|2,"up",0
003408 dca8      UPTR:   rcall   DOCREATE
003409 0002              .dw     2 ; upl
                 
00340a e80c              fdw     UPTR_L
                 HOLD_L:
00340b 6884
00340c 6c6f
00340d 0064              .db     NFA|4,"hold",0
00340e d327      HOLD:   rcall   TRUE_
00340f d09a              rcall   HP
003410 defe              rcall   PLUSSTORE
003411 d098              rcall   HP
003412 d2b8              rcall   FETCH_A
003413 940c 3ebe         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
003415 e816              fdw     HOLD_L
                 LESSNUM_L:
003416 3c82
003417 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
003418 d096              rcall   PAD
003419 d090              rcall   HP
00341a 940c 3e29         jmp     STORE
                 
                 ; >digit   n -- c            convert to 0..9a..z
00341c e82c              fdw     LESSNUM_L
                 TODIGIT_L:
00341d 3e86
00341e 6964
00341f 6967
003420 0074              .db     NFA|6,">digit",0
                 TODIGIT: 
003421 d372              rcall   DUP
003422 d368              rcall   DOLIT
003423 0009              .dw     9
003424 df11              rcall   GREATER
003425 d365              rcall   DOLIT
003426 0027              .dw     0x27
003427 de9e              rcall   AND_
003428 de87              rcall   PLUS
003429 d361              rcall   DOLIT
00342a 0030              .dw     0x30
00342b 940c 32b0         jmp     PLUS
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
00342d e83a              fdw     TODIGIT_L
                 NUM_L:
00342e 2381              .db     NFA|1,"#"
                 NUM:
00342f d087              rcall   BASE
003430 d29a              rcall   FETCH_A
003431 d198              rcall   UDSLASHMOD
003432 de51              rcall   ROT
003433 dfed              rcall   TODIGIT
003434 940c 340e         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
003436 e85c              fdw     NUM_L
                 NUMS_L:
003437 2382
003438 0073              .db     NFA|2,"#s",0
                 NUMS:
003439 dff5              rcall   NUM
00343a dd71              rcall   TWODUP
00343b de92              rcall   OR_
00343c df5f              rcall   ZEROSENSE
00343d f7d9              brne    NUMS
00343e 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
00343f e86e              fdw     NUMS_L
                 NUMGREATER_L:
003440 2382
003441 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
003442 dd62              rcall   TWODROP
003443 d066              rcall   HP
003444 d286              rcall   FETCH_A
003445 d069              rcall   PAD
003446 de35              rcall   OVER
003447 940c 32bd         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
003449 e880              fdw     NUMGREATER_L
                 SIGN_L:
00344a 7384
00344b 6769
00344c 006e              .db     NFA|4,"sign",0
                 SIGN:   
00344d d354              rcall   ZEROLESS
00344e df4d              rcall   ZEROSENSE
00344f f019              breq    SIGN1
003450 d33a              rcall   DOLIT
003451 002d              .dw     0x2D
003452 dfbb              rcall   HOLD
                 SIGN1:
003453 9508              ret
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
003454 e894              fdw     SIGN_L
                 UDOT_L:
003455 7582
003456 002e              .db     NFA|2,"u.",0
                 UDOT:
003457 dfc0              rcall   LESSNUM
003458 d2d4              rcall   FALSE_
003459 dfdf              rcall   NUMS
00345a dfe7              rcall   NUMGREATER
00345b ddca              rcall   TYPE
00345c 940c 31bc         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
00345e e8aa              fdw     UDOT_L
                 UDOTR_L:
00345f 7583
003460 722e              .db     NFA|3,"u.r"
                 UDOTR:
003461 dfb6              rcall   LESSNUM
003462 de90              rcall   ONEMINUS
003463 de27              rcall   TOR
003464 d2c8              rcall   FALSE_
003465 c001              rjmp    UDOTR2
                 UDOTR1:
003466 dfc8              rcall   NUM
                 UDOTR2: 
003467 d5d0              rcall   XNEXT
003468 f7e8              brcc    UDOTR1
003469 911f              pop     t1
00346a 910f              pop     t0
00346b dfcd              rcall   NUMS
00346c dfd5              rcall   NUMGREATER
00346d ddb8              rcall   TYPE
00346e 940c 31bc         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
003470 e8be              fdw     UDOTR_L
                 DOT_L:
003471 2e81              .db     NFA|1,"."
003472 dfa5      DOT:    rcall   LESSNUM
003473 d320              rcall   DUP
003474 de36              rcall   ABS_
003475 d2b7              rcall   FALSE_
003476 dfc2              rcall   NUMS
003477 de0c              rcall   ROT
003478 dfd4              rcall   SIGN
003479 dfc8              rcall   NUMGREATER
00347a ddab              rcall   TYPE
00347b 940c 31bc         jmp     SPACE_
                 
00347d e8e2              FDW     DOT_L
                 DECIMAL_L:
00347e 6487
00347f 6365
003480 6d69
003481 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
003482 d282              rcall   TEN
003483 d033              rcall   BASE
003484 940c 3e29         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
003486 e8fc              Fdw     DECIMAL_l
                 HEX_L:
003487 6883
003488 7865              .db     NFA|3,"hex"
                 HEX:
003489 d301              rcall   DOLIT
00348a 0010              .dw     16
00348b d02b              rcall   BASE
00348c 940c 3e29         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
00348e e90e              Fdw     HEX_L
                 BIN_L:
00348f 6283
003490 6e69              .db     NFA|3,"bin"
003491 dca5      BIN:    rcall   CELL
003492 d024              rcall   BASE
003493 940c 3e29         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
003495 e91e              fdw     BIN_L
                 RSAVE_L:
003496 7285
003497 6173
003498 6576              .db     NFA|5,"rsave"
003499 d02a      RSAVE_: rcall   DOUSER
00349a fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
00349b e92c              fdw     RSAVE_L
                 ULINK_L:
00349c 7585
00349d 696c
00349e 6b6e              .db     NFA|5,"ulink"
00349f d024      ULINK_: rcall   DOUSER
0034a0 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034a1 e938              fdw     ULINK_L
                 TASK_L:
0034a2 7484
0034a3 7361
0034a4 006b              .db     NFA|4,"task",0
0034a5 d01e      TASK:   rcall   DOUSER
0034a6 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034a7 e944              fdw     TASK_L
                 HP_L:
0034a8 6882
0034a9 0070              .db     NFA|2,"hp",0
0034aa d019      HP:     rcall   DOUSER
0034ab 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
0034ac e950              fdw     HP_L
                 PAD_L:
0034ad 7083
0034ae 6461              .db     NFA|3,"pad"
                 PAD:
0034af d19f              rcall   TIB
0034b0 d196              rcall   TIBSIZE
0034b1 940c 32b0         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
0034b3 e95a              fdw     PAD_L
                 BASE_L:
0034b4 6284
0034b5 7361
0034b6 0065              .db     NFA|4,"base",0
                 BASE:
0034b7 d00c              rcall   DOUSER
0034b8 ffee              .dw     ubase
                 
                 ; USER   n --
0034b9 e968              fdw     BASE_L
                 USER_L:
0034ba 7584
0034bb 6573
0034bc 0072              .db     NFA|4,"user",0
                 USER:
0034bd d321              rcall   CREATE
0034be dc78              rcall   CELL
0034bf de28              rcall	NEGATE
0034c0 d4a6              rcall   IALLOT
0034c1 940e 3f4e         call    ICOMMA
0034c3 d36b              rcall   XDOES
                 DOUSER:
0034c4 939a
0034c5 938a              pushtos
                         m_pop_zh
0034c6 91ff              pop     zh
0034c7 91ef              pop     zl
0034c8 0fee              lsl     zl
0034c9 1fff              rol     zh
0034ca 9185              lpm_    tosl, z+
0034cb 9195              lpm_    tosh, z+
0034cc 0d82              add     tosl, upl
0034cd 1d93              adc     tosh, uph
0034ce 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
0034cf e974              fdw     USER_L
                 SOURCE_L:
0034d0 7386
0034d1 756f
0034d2 6372
0034d3 0065              .db     NFA|6,"source",0
                 SOURCE:
0034d4 d18c              rcall   TICKSOURCE
0034d5 940c 3192         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
0034d7 e9a0              fdw      SOURCE_L
                 SLASHSTRING_L:
0034d8 2f87
0034d9 7473
0034da 6972
0034db 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
0034dc dd95              rcall   SWOP
0034dd dd9e              rcall   OVER
0034de ddde              rcall   MINUS
0034df ddab              rcall   TOR
0034e0 ddcf              rcall   PLUS
0034e1 ddb3              rcall   RFROM
0034e2 9508              ret
                 
                 ; \     Skip the rest of the line
0034e3 e9b0              fdw     SLASHSTRING_L
                 BSLASH_L:
0034e4 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
0034e5 dfee              rcall   SOURCE
0034e6 d173              rcall   TOIN
0034e7 d057              rcall   STORE_A
0034e8 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
0034e9 940c 326b         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
0034eb e9c8              fdw     BSLASH_L
                 PARSE_L:
0034ec 7085
0034ed 7261
0034ee 6573              .db     NFA|5,"parse"
                 PARSE:
0034ef d2a4              rcall   DUP             ; c c
0034f0 dfe3              rcall   SOURCE          ; c c a u
0034f1 d168              rcall   TOIN            ; c c a u a
0034f2 d1d8              rcall   FETCH_A         ; c c a u n
0034f3 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
0034f4 d29f              rcall   DUP             ; c c a u u
0034f5 dd95              rcall   TOR             ; c c a u                  R: u (new tib len
0034f6 dd8d              rcall   ROT             ; c a u c
0034f7 db1d              rcall   SKIP            ; c a u        
0034f8 dd83              rcall   OVER            ; c a u a
0034f9 dd91              rcall   TOR             ; c a u                    R: u a (start of word
0034fa dd89              rcall   ROT             ; a u c
0034fb db2d              rcall   SCAN            ; a u      end of word, tib left       
0034fc dea5              rcall   DUPZEROSENSE
0034fd f009              breq    PARSE1
0034fe ddf4              rcall   ONEMINUS
0034ff dd95      PARSE1: rcall   RFROM           ; a u a
003500 dd94              rcall   RFROM           ; a u a u
003501 dd82              rcall   ROT             ; a a u u
003502 ddba              rcall   MINUS           ; a a n  ( addition to toin
003503 d156              rcall   TOIN
003504 de0a              rcall   PLUSSTORE       ; aend astart
003505 dede              rcall   TUCK            ; astart aend astart
003506 940c 32bd         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
003508 e9d8              fdw     PARSE_L
                 WORD_L:
003509 7784
00350a 726f
00350b 0064              .db     NFA|4,"word",0
                 WORD:
00350c dfe2              rcall   PARSE           ; c-addr wlen
00350d dd64              rcall   SWOP
00350e dde4              rcall   ONEMINUS
00350f ded4              rcall   TUCK
003510 940c 3ebe         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
003512 ea12              fdw     WORD_L
                 CMOVE_L:
003513 6385
003514 6f6d
003515 6576              .db     NFA|5,"cmove"
                 CMOVE:
003516 dd5b              rcall   SWOP
003517 de3a              rcall   STORE_P_TO_R
003518 dd72              rcall   TOR
003519 c003              rjmp    CMOVE2
                 CMOVE1:
00351a d016              rcall   CFETCHPP
00351b de59              rcall   PCSTORE
00351c de60              rcall   PPLUS
                 CMOVE2:
00351d d51a              rcall   XNEXT
00351e f7d8              brcc    CMOVE1
00351f 911f              pop     t1
003520 910f              pop     t0
003521 de3b              rcall   R_TO_P
003522 940c 326b         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
003524 ea26              fdw     CMOVE_L
                 PLACE_L:
003525 7085
003526 616c
003527 6563              .db     NFA|5,"place"
                 PLACE: 
003528 dc83              rcall   TWODUP
003529 ded9              rcall   CSTORE_A
00352a dc35              rcall   CHARPLUS
00352b dd46              rcall   SWOP
00352c 940c 3516         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
00352e ea4a              fdw     PLACE_L
                 CFETCHPP_L:
00352f 6383
003530 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
003531 d262              rcall   DUP
003532 ddbb              rcall   ONEPLUS
003533 dd3e              rcall   SWOP
003534 940c 3e9b         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
003536 ea5e              fdw     CFETCHPP_L
                 FETCHPP_L:
003537 4082
003538 002b              .db     NFA|2,"@+",0
                 FETCHPP:
003539 d25a              rcall   DUP
00353a ddbd              rcall   TWOPLUS
00353b dd36              rcall   SWOP
00353c 940c 3e71         jmp     FETCH
                 
00353e 2181              .db     NFA|1,"!"
                 STORE_A:        
00353f 940c 3e29         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
003541 ea6e              fdw    FETCHPP_L
                 NTOC_L:
003542 6e83
003543 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
003544 dfec              rcall   CFETCHPP
003545 d245              rcall   DOLIT
003546 000f              .dw     0x0f
003547 dd7e              rcall   AND_
003548 dd67              rcall   PLUS
003549 940c 314a         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
00354b ea84              fdw    NTOC_L
                 CTON_L:
00354c 6383
00354d 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
00354e d352              rcall   TWOMINUS
00354f d244              rcall   DUP
003550 deae              rcall   CFETCH_A
003551 d239              rcall   DOLIT
003552 007f              .dw     0x007F
003553 dde2              rcall   GREATER
003554 de47              rcall   ZEROSENSE
003555 f3c1              breq    CFATONFA
003556 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
003557 ea98              fdw     CTON_L
                 BRACFIND_L:
003558 2883
003559 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
00355a dc51              rcall   TWODUP
                 ;        rcall   OVER
                 ;        rcall   CFETCH_A
00355b da96              rcall   NEQUAL
00355c de45              rcall   DUPZEROSENSE
00355d f021              breq    findi2
00355e dd0c              rcall   DROP
00355f d341              rcall   TWOMINUS ;;;      NFATOLFA
003560 d16a              rcall   FETCH_A
003561 d232              rcall   DUP
                 findi2:
003562 de39              rcall   ZEROSENSE
003563 f7b1              brne    findi1
003564 de3d              rcall   DUPZEROSENSE
003565 f041              breq    findi3
003566 de76              rcall   NIP
003567 d22c              rcall   DUP
003568 dfdb              rcall   NFATOCFA
003569 dd08              rcall   SWOP
00356a d009              rcall   IMMEDQ
00356b d22e              rcall   ZEROEQUAL
00356c dc72              rcall   ONE
00356d dd60              rcall   OR_
                 findi3: 
00356e 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
00356f eab0              fdw     BRACFIND_L
                 IMMEDQ_L:
003570 6986
003571 6d6d
003572 6465
003573 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
003574 de8a              rcall   CFETCH_A
003575 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
003576 d214              rcall   DOLIT
003577 0040              .dw     IMMED
003578 940c 32c6         jmp     AND_
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
00357a eae0              fdw     IMMEDQ_L
                 FIND_L:
00357b 6684
00357c 6e69
00357d 0064              .db     NFA|4,"find",0
                 FIND:   
00357e d20c              rcall   DOLIT
00357f f634              fdw     kernellink
003580 dfd9              rcall   findi
003581 de20              rcall   DUPZEROSENSE
003582 f421              brne    FIND1
003583 dce7              rcall   DROP
003584 d334              rcall   LATEST_
003585 d145              rcall   FETCH_A
003586 dfd3              rcall   findi
                 FIND1:
003587 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
003588 eaf6              fdw     FIND_L
                 DIGITQ_L:
003589 6486
00358a 6769
00358b 7469
00358c 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
00358d d206              rcall   DUP             ; c c       c c
00358e d1fc              rcall   DOLIT
00358f 0039              .dw     0x39            ; c c 39    c c 39
003590 dda5              rcall   GREATER         ; c 0       c ffff
003591 de0a              rcall   ZEROSENSE
003592 f019              breq    DIGITQ1
003593 d1f7              rcall   DOLIT
003594 0027              .dw     0x27
003595 dd27              rcall   MINUS
                 DIGITQ1:        
003596 d1f4              rcall   DOLIT
003597 0030              .dw     0x30            ; c 30
003598 dd24              rcall   MINUS           ; 1
003599 d1fa              rcall   DUP             ; 1 1
00359a df1c              rcall   BASE            ; 1 1 base
00359b d12f              rcall   FETCH_A         ; 1 1 10
00359c dd94              rcall   LESS            ; 1 ffff
00359d dcde              rcall   OVER            ; 1 ffff 1
00359e d203              rcall   ZEROLESS        ; 1 ffff 0
00359f dd40              rcall   INVERT
0035a0 940c 32c6         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035a2 eb12              fdw     DIGITQ_L
                 SIGNQ_L:
0035a3 7385
0035a4 6769
0035a5 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035a6 dcd5              rcall   OVER
0035a7 de57              rcall   CFETCH_A
0035a8 d1e2              rcall   DOLIT
0035a9 002c              .dw     ','
0035aa dd12              rcall   MINUS
0035ab d1e8              rcall   DUP
0035ac dcfe              rcall   ABS_
0035ad dc31              rcall   ONE
0035ae dd7d              rcall   EQUAL
0035af dd16              rcall   AND_
0035b0 ddf1              rcall   DUPZEROSENSE
0035b1 f029              breq    QSIGN1
0035b2 dd3b              rcall   ONEPLUS
0035b3 dcd7              rcall   TOR
0035b4 dc2a              rcall   ONE
0035b5 df26              rcall   SLASHSTRING
0035b6 dcde              rcall   RFROM
0035b7 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
0035b8 eb46              fdw     SIGNQ_L
                 UDSTAR_L:
0035b9 7583
0035ba 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035bb d1d8              rcall   DUP
0035bc dcce              rcall   TOR
0035bd dde9              rcall   UMSTAR
0035be dcac              rcall   DROP
0035bf dcb2              rcall   SWOP
0035c0 dcd4              rcall   RFROM
0035c1 dde5              rcall   UMSTAR
0035c2 dcc1              rcall   ROT
0035c3 940c 32b0         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
0035c5 eb72              fdw     UDSTAR_L
                 UDSLASHMOD_L:
0035c6 7586
0035c7 2f64
0035c8 6f6d
0035c9 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
0035ca dcc0              rcall   TOR             ; ud.l ud.h 
0035cb d161              rcall   FALSE_          ; ud.l ud.h 0
0035cc dcd2              rcall   RFETCH          ; ud.l ud.h 0 u
0035cd dde0              rcall   UMSLASHMOD      ; ud.l r.h q.h
0035ce dcb5              rcall   ROT             ; r.h q.h ud.l
0035cf dcb4              rcall   ROT             ; q.h ud.l r.h
0035d0 dcc4              rcall   RFROM           ; q.h ud.l r.h u
0035d1 dddc              rcall   UMSLASHMOD      ; q.h r.l q.l
0035d2 940c 3284         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
0035d4 eb8c              fdw     UDSLASHMOD_L
                 TONUMBER_L:
0035d5 3e87
0035d6 756e
0035d7 626d
0035d8 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
0035d9 ddc8              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
0035da f0b1              breq    TONUM3
0035db dcaf              rcall   TOR
0035dc d1b7              rcall   DUP
0035dd dcad              rcall   TOR             ; ud.l ud.h adr
0035de de20              rcall   CFETCH_A
0035df dfad              rcall   DIGITQ          ; ud.l ud.h digit flag
0035e0 ddbb              rcall   ZEROSENSE
0035e1 f421              brne    TONUM2
0035e2 dc88              rcall   DROP
0035e3 dcb1              rcall   RFROM
0035e4 dcb0              rcall   RFROM
0035e5 c00b              rjmp    TONUM3
                 TONUM2: 
0035e6 dca4              rcall   TOR             ; ud.l ud.h digit
0035e7 decf              rcall   BASE
0035e8 d0e2              rcall   FETCH_A
0035e9 dfd1              rcall   UDSTAR
0035ea dcaa              rcall   RFROM
0035eb dccc              rcall   MPLUS
0035ec dca8              rcall   RFROM
0035ed dca7              rcall   RFROM
                         
0035ee dbf0              rcall   ONE
0035ef deec              rcall   SLASHSTRING
0035f0 cfe8              rjmp    TONUM1
                 TONUM3: 
0035f1 9508              ret
                 
                 BASEQV:   
0035f2 e904              fdw     DECIMAL
0035f3 e912              fdw     HEX
0035f4 e922              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
0035f5 ebaa              fdw     TONUMBER_L
                 NUMBERQ_L:
0035f6 6e87
0035f7 6d75
0035f8 6562
0035f9 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
0035fa d199              rcall   DUP             ; a a
0035fb d131              rcall   FALSE_          ; a a 0 0
0035fc d130              rcall   FALSE_          ; a a 0 0
0035fd dc86              rcall   ROT             ; a 0 0 a
0035fe df32              rcall   CFETCHPP        ; a 0 0 a' u
0035ff dfa6              rcall   SIGNQ           ; a 0 0 a' u f
003600 dc8a              rcall   TOR             ; a 0 0 a' u
                 
003601 deb5              rcall   BASE
003602 d0c8              rcall   FETCH_A
003603 dc87              rcall   TOR             ; a 0 0 a' u
                         
003604 dc77              rcall   OVER
003605 ddf9              rcall   CFETCH_A
                         
003606 d184              rcall   DOLIT
003607 0023              .dw     '#'
003608 dcb4              rcall   MINUS
003609 d18a              rcall   DUP
00360a d180              rcall   DOLIT
00360b 0003              .dw     3
00360c dd2f              rcall   ULESS
00360d dd8e              rcall   ZEROSENSE
00360e f041              breq    BASEQ1
00360f db49              rcall   CELLS
                         
003610 d17a              rcall   DOLIT
003611 ebe4              fdw     BASEQV
003612 dc9d              rcall   PLUS
003613 da68              rcall   FEXECUTE
                 
003614 dbca              rcall   ONE
003615 dec6              rcall   SLASHSTRING
003616 c001              rjmp    BASEQ2
                 BASEQ1:
003617 dc53              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
003618 dfc0              rcall   TONUMBER        ; a ud.l ud.h  a' u
003619 dc7b              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
00361a de9c              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
00361b df23              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
00361c d177              rcall   DUP
00361d d283              rcall   TWOMINUS
00361e d183              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
00361f dd7c              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
003620 f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
003621 dc73              rcall   RFROM           ; a ud.l ud.h a' u sign
003622 dc48              rcall   DROP
003623 db81              rcall   TWODROP
                 QNUM_ERR1:      
003624 db80              rcall   TWODROP
003625 d107              rcall   FALSE_          ; a 0           Not a number
003626 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
003627 db8b              rcall   TWOSWAP         ; a a' u ud.l ud.h 
003628 dc6c              rcall   RFROM           ; a a' u ud.l ud.d sign
003629 dd72              rcall   ZEROSENSE
00362a f009              breq    QNUMD1
00362b d438              rcall   DNEGATE
                 QNUMD1: 
00362c db86              rcall   TWOSWAP         ; a d.l d.h a' u
00362d dd6e              rcall   ZEROSENSE       ; a d.l d.h a'
00362e f061              breq    QNUM1
00362f 940e 3e9b         call    CFETCH
003631 d159              rcall   DOLIT
003632 002e              .dw     '.'
003633 dc89              rcall   MINUS
003634 dd67              rcall   ZEROSENSE       ; a d.l d.h
003635 f771              brne    QNUM_ERR1
003636 dc4d              rcall   ROT             ; d.l d.h a
003637 dc33              rcall   DROP            ; d.l d.h
003638 d152              rcall   DOLIT         ; 
003639 0002              .dw     2               ; d.l ud.h 2    Double number
00363a c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
00363b db69              rcall   TWODROP         ; a n
00363c dda0              rcall   NIP             ; n
00363d dba1              rcall   ONE             ; n 1           Single number
                 QNUM3:  
00363e 9508              ret
                 
                 
00363f 7384
003640 6177
003641 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003642 940c 3272         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003644 ebec              fdw     NUMBERQ_L
                 TIBSIZE_L:
003645 7483
003646 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
003647 de5d              rcall   TASK
003648 d082              rcall   FETCH_A
003649 9605              adiw    tosl, 5
00364a 940c 3e9b         jmp     CFETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00364c ec8a              fdw     TIBSIZE_L
                 TIB_L:
00364d 7483
00364e 6269              .db     NFA|3,"tib"
                 TIB:
00364f d005              rcall   TIU
003650 940c 3e71         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003652 ec9a              fdw     TIB_L
                 TIU_L:
003653 7483
003654 7569              .db     NFA|3,"tiu"
                 TIU:
003655 de6e              rcall   DOUSER
003656 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
003657 eca6              fdw     TIU_L
                 TOIN_L:
003658 3e83
003659 6e69              .db     NFA|3,">in"
                 TOIN:
00365a de69              rcall   DOUSER
00365b fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00365c ecb0              fdw     TOIN_L
                 TICKSOURCE_L:
00365d 2787
00365e 6f73
00365f 7275
003660 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
003661 de62              rcall   DOUSER
003662 fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
003663 ecba              fdw     TICKSOURCE_L
                 INTERPRET_L:
003664 6989
003665 746e
003666 7265
003667 7270
003668 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
003669 dff7              rcall   TICKSOURCE
00366a db30              rcall   TWOSTORE
00366b d0c1              rcall   FALSE_
00366c dfed              rcall   TOIN
00366d ded1              rcall   STORE_A
                 IPARSEWORD:
00366e d237              rcall   BL
00366f de9c              rcall   WORD
                 
003670 d123              rcall   DUP
003671 dd8d              rcall   CFETCH_A
003672 dd29              rcall   ZEROSENSE
003673 f409              brne    IPARSEWORD1
003674 c053              rjmp    INOWORD
                 IPARSEWORD1:
003675 df08              rcall   FIND            ; sets also wflags
003676 dd2b              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
003677 f1a1              breq    INUMBER         ; NUMBER?
003678 dc75              rcall   ONEPLUS         ; 0 = normal 2 = immediate
003679 d233              rcall   STATE_
00367a d11f              rcall   ZEROEQUAL
00367b dc52              rcall   OR_
00367c dd1f              rcall   ZEROSENSE
00367d f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
00367e fe94              sbrs    wflags, 4       ; Compile only check
00367f c00a              rjmp    IEXECUTE        ; Not a compile only word
003680 d22c              rcall   STATE_          ; Compile only word check
003681 dbb1              rcall   XSQUOTE
003682 430c
003683 4d4f
003684 4950
003685 454c
003686 4f20
003687 4c4e
003688 0059              .db     12,"COMPILE ONLY",0
003689 d0ee              rcall   QABORT
                 IEXECUTE:
00368a 7b6f              cbr     FLAGS1, (1<<noclear)
00368b d9e5              rcall   EXECUTE
00368c fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
00368d cfe0              rjmp    IPARSEWORD
00368e 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
00368f 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
003690 cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
003691 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
003692 d101              rcall   DUP
003693 d0f7              rcall   DOLIT
003694 ef34              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
003695 dc96              rcall   EQUAL
003696 dd05              rcall   ZEROSENSE
003697 f011              breq    ICOMPILE_2
003698 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
003699 c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
00369a 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
00369b d0f8              rcall   DUP
00369c d0ee              rcall   DOLIT
00369d ef28              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
00369e dc8d              rcall   EQUAL
00369f dcfc              rcall   ZEROSENSE
0036a0 f009              breq    ICOMPILE
0036a1 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036a2 fe95              sbrs    wflags, 5       ; Inline check
0036a3 c003              rjmp    ICOMMAXT
0036a4 940e 3a0f         call    INLINE0
0036a6 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
0036a7 d126              rcall   COMMAXT_A
0036a8 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
0036a9 fc94              sbrc    wflags, 4            ; Compile only ?
0036aa 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0036ab cfc2              rjmp    IPARSEWORD
                 INUMBER: 
0036ac 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036ad 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036ae dbbc              rcall   DROP
0036af df4a              rcall   NUMBERQ
0036b0 dcf1              rcall   DUPZEROSENSE
0036b1 f081              breq    IUNKNOWN
0036b2 d1fa              rcall   STATE_
0036b3 dce8              rcall   ZEROSENSE
0036b4 f059              breq    INUMBER1
0036b5 2f08              mov     t0, tosl
0036b6 9189
0036b7 9199              poptos
0036b8 ff01              sbrs    t0, 1
0036b9 c003              rjmp    ISINGLE
                 IDOUBLE:
0036ba df87              rcall   SWOP_A
0036bb 940e 3dfd         call    LITERAL
                 ISINGLE:        
0036bd 940e 3dfd         call    LITERAL
0036bf cfae              rjmp    IPARSEWORD
                 
                 INUMBER1:
0036c0 dbaa              rcall   DROP
0036c1 cfac              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
0036c2 dba8              rcall   DROP 
0036c3 d045              rcall   DP_TO_RAM
0036c4 de6c              rcall   CFETCHPP
0036c5 db60              rcall   TYPE
0036c6 d066              rcall   FALSE_
0036c7 d0a7              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
0036c8 940c 326b         jmp     DROP
                 
0036ca 4081              .db     NFA|1,"@"
                 FETCH_A:        
0036cb 940c 3e71         jmp     FETCH
                 
                 ;;;    bitmask -- 
0036cd ecc8              fdw     INTERPRET_L
                 SHB_L:
0036ce 7383
0036cf 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
0036d0 d1e8              rcall   LATEST_
0036d1 dff9              rcall   FETCH_A
0036d2 d0c1              rcall   DUP
0036d3 dd2b              rcall   CFETCH_A
0036d4 dbaf              rcall   ROT
0036d5 dbf8              rcall   OR_
0036d6 df6b              rcall   SWOP_A
0036d7 940c 3ebe         jmp     CSTORE
                         
0036d9 ed9c              fdw     SHB_L
                 IMMEDIATE_L:
0036da 6989
0036db 6d6d
0036dc 6465
0036dd 6169
0036de 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
0036df d0ab              rcall   DOLIT
0036e0 0040              .dw     IMMED
0036e1 940c 36d0         jmp     SHB
                 
                 ;***************************************************************
0036e3 edb4              fdw     IMMEDIATE_L
                 INLINED_L:
0036e4 6987
0036e5 6c6e
0036e6 6e69
0036e7 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
0036e8 d0a2              rcall   DOLIT
0036e9 0020              .dw     INLINE
0036ea 940c 36d0         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
0036ec edc8              fdw     INLINED_L
                 DOTSTATUS_L:
0036ed 2e83
0036ee 7473              .db     NFA|3,".st"
                 DOTSTATUS:
0036ef d09b              rcall   DOLIT
0036f0 003c              .dw     '<'
0036f1 d96a              rcall   EMIT
0036f2 940e 3f60         call    DOTBASE
0036f4 d967              rcall   EMIT
0036f5 d095              rcall   DOLIT
0036f6 002c              .dw     ','
0036f7 d964              rcall   EMIT
0036f8 940e 3f75         call    MEMQ
0036fa db2b              rcall   TYPE
0036fb d08f              rcall   DOLIT
0036fc 003e              .dw     '>'
0036fd d95e              rcall   EMIT
0036fe 940c 3926         jmp     DOTS
                 
003700 3e82
003701 0072              .db     NFA|2,">r",0
003702 940c 328b TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
003704 6181              .db     NFA|1,"a"
                 TEN:
003705 d9ab              rcall   DOCREATE
003706 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
003707 6483
003708 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
003709 d081              rcall   DOLIT
00370a 0900              .dw     dp_start
00370b d1bc              rcall   INI
00370c dff8              rcall   TEN
00370d 940c 3516         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
00370f 3e83
003710 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
003711 d079              rcall   DOLIT
003712 0900              .dw     dp_start
003713 dc3e              rcall   STORE_P_TO_R
003714 d1b3              rcall   INI
003715 d075              rcall   DOLIT
003716 0004              .dw     4
003717 db73              rcall   TOR
                 DP_TO_EEPROM_0: 
003718 de20              rcall   FETCHPP
003719 d07a              rcall   DUP
00371a dc4a              rcall   PFETCH
00371b dc09              rcall   NOTEQUAL
00371c dc7f              rcall   ZEROSENSE
00371d f011              breq    DP_TO_EEPROM_1
00371e dc4e              rcall   PSTORE
00371f c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
003720 db4a              rcall   DROP
                 DP_TO_EEPROM_2:
003721 d3fa              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
003722 d315              rcall   XNEXT
003723 f7a0              brcc    DP_TO_EEPROM_0
003724 911f              pop     t1
003725 910f              pop     t0
003726 dc36              rcall   R_TO_P
003727 940c 326b         jmp     DROP
                 
003729 edda              fdw     DOTSTATUS_L
                 FALSE_L:
00372a 6685
00372b 6c61
00372c 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
00372d 939a
00372e 938a              pushtos
00372f 2788              clr     tosl
003730 2799              clr     tosh
003731 9508              ret
                 
003732 ee54              fdw     FALSE_L
                 TRUE_L:
003733 7484
003734 7572
003735 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
003736 939a
003737 938a              pushtos
003738 ef8f              ser     tosl
003739 ef9f              ser     tosh
00373a 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
00373b ee66              fdw     TRUE_L
                 QUIT_L:
00373c 7184
00373d 6975
00373e 0074              .db     NFA|4,"quit",0
                 QUIT:
00373f d99f              rcall   RPEMPTY
003740 d109              rcall   LEFTBRACKET
003741 d9c8              rcall   FRAM
                 QUIT0:  
003742 d605              rcall   IFLUSH
                         ;; Copy INI and DP's from eeprom to ram
003743 dfc5              rcall   DP_TO_RAM
                 QUIT1: 
003744 d905              rcall   check_sp
003745 d08d              rcall   CR
003746 df08              rcall   TIB
003747 d04c              rcall   DUP
003748 defe              rcall   TIBSIZE
003749 dfbb              rcall   TEN                 ; Reserve 10 bytes for hold buffer
00374a db72              rcall   MINUS
00374b da9d              rcall   ACCEPT
00374c da6f              rcall   SPACE_
00374d df1b              rcall   INTERPRET
00374e d15e              rcall   STATE_
00374f dc4c              rcall   ZEROSENSE
003750 f799              brne    QUIT1
003751 dfbf              rcall   DP_TO_EEPROM
                          
003752 dae0              rcall    XSQUOTE
003753 2003
003754 6b6f              .db     3," ok"
003755 dad0              rcall    TYPE
003756 d007              rcall   PROMPT_
003757 cfea              rjmp    QUIT0
003758 9508              ret
                 
003759 ee78              fdw     QUIT_L
                 PROMPT_L:
00375a 7086
00375b 6f72
00375c 706d
00375d 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
00375e 940e 3ef8         call    DEFER_DOES
003760 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
003761 eeb4              fdw     PROMPT_L
                 ABORT_L:
003762 6185
003763 6f62
003764 7472              .db     NFA|5,"abort"
                 ABORT:
003765 d159              rcall   S0
003766 df64              rcall   FETCH_A
003767 d973              rcall   SPSTORE
003768 940c 373f         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
00376a eec4              fdw     ABORT_L
                 QABORTQ_L:
00376b 3f87
00376c 6261
00376d 726f
00376e 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
00376f dac3              rcall   XSQUOTE
003770 3f01              .db     1,"?"
003771 940c 3778         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
003773 eed6              fdw     QABORTQ_L
                 QABORT_L:
003774 3f86
003775 6261
003776 726f
003777 0074              .db     NFA|6,"?abort",0
                 QABORT:
003778 db0b              rcall   ROT
003779 dc22              rcall   ZEROSENSE
00377a f419              brne    QABO1
                 QABORT1:        
00377b da40              rcall   SPACE_
00377c daa9              rcall   TYPE
00377d dfe7              rcall   ABORT  ; ABORT never returns
00377e 940c 31a5 QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
003780 eee8              fdw     QABORT_L
                 ABORTQUOTE_L:
003781 61d6
003782 6f62
003783 7472
003784 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
003785 dac0              rcall   SQUOTE
003786 d942              rcall   DOCOMMAXT
003787 eef0              fdw     QABORT
003788 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
003789 6c83
00378a 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
00378b 91ff              pop     zh
00378c 91ef              pop     zl
00378d d932              rcall   FETCHLIT
00378e 95f7              ror     zh
00378f 95e7              ror     zl
003790 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
003791 e53a              fdw     RFETCH_L
                 DUP_L:
003792 64a3
003793 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
003794 939a
003795 938a              pushtos
003796 9508              ret
                 
003797 e646              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
003798 3082
003799 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:      
00379a 2b98              or      tosh, tosl
00379b f441              brne    FALSE_F
                 TRUE_F:
00379c ef9f              ser     tosh
00379d ef8f              ser     tosl
                 ZEROEQUAL_1:
00379e 9508              ret
                 
00379f ef30              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
0037a0 3082
0037a1 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
0037a2 2399              tst     tosh
0037a3 f3c2              brmi    TRUE_F
                 FALSE_F:
0037a4 2799              clr     tosh
0037a5 2788              clr     tosl
0037a6 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037a7 ef02              fdw     ABORTQUOTE_L
                 TICK_L:
0037a8 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037a9 d0fc              rcall   BL
0037aa dd61              rcall   WORD
0037ab ddd2              rcall   FIND
0037ac 940c 376f         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
0037ae ef50              fdw     TICK_L
                 CHAR_L:
0037af 6384
0037b0 6168
0037b1 0072              .db     NFA|4,"char",0
                 CHAR:
0037b2 d0f3              rcall   BL
0037b3 dd3b              rcall   PARSE
0037b4 dab6              rcall   DROP
0037b5 940c 3e9b         jmp     CFETCH
                 
                 ; (    --                     skip input until )
0037b7 ef5e              fdw     CHAR_L
                 PAREN_L:
0037b8 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
0037b9 dfd1              rcall   DOLIT
0037ba 0029              .dw     ')'
0037bb dd33              rcall   PARSE
0037bc 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
0037bd 940c 31a5         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
0037bf 6985
0037c0 6568
0037c1 6572              .db     NFA|5,"ihere"
                 IHERE:
0037c2 d066              rcall   IDP
0037c3 cf07              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
0037c4 ef70              fdw     PAREN_L
                 BRACCHAR_L:
0037c5 5bd6
0037c6 6863
0037c7 7261
0037c8 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
0037c9 dfe8              rcall   CHAR
0037ca 940c 3dfd         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
0037cc 6383
0037cd 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
0037ce 940c 316a         jmp     COMMAXT
                 
                 ; CR      --                      output newline
0037d0 ef8a              fdw     BRACCHAR_L
                 CR_L:
0037d1 6382
0037d2 0072              .db     NFA|2,"cr",0
                 CR:
0037d3 dfb7              rcall   DOLIT
0037d4 000d              .dw     0x0d       ; CR \r
0037d5 d886              rcall   EMIT
0037d6 dfb4              rcall   DOLIT
0037d7 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
0037d8 940c 305c         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
0037da efa2              fdw     CR_L
                 CREATE_L:
0037db 6386
0037dc 6572
0037dd 7461
0037de 0065              .db     NFA|6,"create",0
                 CREATE:
0037df d0c6              rcall   BL
0037e0 dd2b              rcall   WORD            ; Parse a word
                 
0037e1 dfb2              rcall   DUP             ; Remember parsed word at rhere
0037e2 dd9b              rcall   FIND
0037e3 dbf9              rcall   NIP
0037e4 dfb5              rcall   ZEROEQUAL
0037e5 da4d              rcall   XSQUOTE
0037e6 410f
0037e7 524c
0037e8 4145
0037e9 5944
0037ea 4420
0037eb 4645
0037ec 4e49
0037ed 4445              .db     15,"ALREADY DEFINED"
0037ee df89              rcall   QABORT         ; ABORT if word has already been defined
0037ef dfa4              rcall   DUP             ; Check the word length 
0037f0 dc0e              rcall   CFETCH_A
0037f1 d9ed              rcall   ONE
0037f2 df98              rcall   DOLIT
0037f3 0010              .dw     16
0037f4 db26              rcall   WITHIN
0037f5 df79              rcall   QABORTQ          ; Abort if there is no name for create
                 
0037f6 d0c2              rcall   LATEST_
0037f7 ded3              rcall   FETCH_A
0037f8 940e 3f4e         call    ICOMMA          ; Link field
0037fa dd36              rcall   CFETCHPP        ; str len
0037fb dfc6              rcall   IHERE
0037fc df97              rcall   DUP             
0037fd d0bb              rcall   LATEST_         ; new 'latest' link
0037fe dd40              rcall   STORE_A         ; str len ihere
0037ff dd28              rcall   PLACE           ; 
003800 dfc1              rcall   IHERE           ; ihere
003801 dbfd              rcall   CFETCH_A
003802 df88              rcall   DOLIT
003803 0080              .dw     NFA
003804 decb              rcall   SHB
003805 dae8              rcall   ONEPLUS
003806 d943              rcall   ALIGNED
003807 d15f              rcall   IALLOT          ; The header has now been created
003808 df82              rcall   DOLIT             
003809 e162              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
00380a d968              rcall   STORECFF1       ; Append an exeution token, CALL !
00380b d934              rcall   ALIGN
00380c d914              rcall   HERE            ; compiles the current dataspace dp into the dictionary
00380d d909              rcall   CSE_
00380e db8d              rcall   ZEROSENSE
00380f f409              brne    CREATE2
003810 dae7              rcall   TWOPLUS
                 CREATE2:
003811 940c 3f4e         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
003813 efb6              fdw    CREATE_L
                 POSTPONE_L:
003814 70d8
003815 736f
003816 7074
003817 6e6f
003818 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
003819 d08c              rcall   BL
00381a dcf1              rcall   WORD
00381b dd62              rcall   FIND
00381c df77              rcall   DUP
00381d df51              rcall   QABORTQ
00381e df83              rcall   ZEROLESS
00381f db7c              rcall   ZEROSENSE
003820 f021              breq    POSTPONE1
003821 d8a7              rcall   DOCOMMAXT
003822 e192              fdw     DOCOMMAXT
003823 940c 3f4e         jmp     ICOMMA
                 POSTPONE1:
003825 940c 316a         jmp     COMMAXT
                 
                 
                 IDP_L:
003827 6983
003828 7064              .db     NFA|3,"idp"
                 IDP:
003829 d887              rcall   DOCREATE
00382a 01d9              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
00382b 2887
00382c 6f64
00382d 7365
00382e 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
00382f da65              rcall   RFROM
003830 d088              rcall   LATEST_
003831 de99              rcall   FETCH_A
003832 dd11              rcall   NFATOCFA
003833 dff5              rcall   IDP
003834 de96              rcall   FETCH_A
003835 decc              rcall   TOR_A
003836 dff2              rcall   IDP
003837 dd07              rcall   STORE_A
003838 0f88              lsl     tosl
003839 1f99              rol     tosh
00383a d938              rcall   STORECFF1 ; Always stores a 4 byte call
00383b da59              rcall   RFROM
00383c dfec              rcall   IDP
00383d 940c 3e29         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
00383f f028              fdw     POSTPONE_L
                 DOES_L:
003840 64d5
003841 656f
003842 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
003843 d885      DOES:   rcall   DOCOMMAXT
003844 f05e              fdw     XDOES
003845 d883              rcall   DOCOMMAXT
003846 e172              fdw     DODOES
003847 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
003848 f080              fdw     DOES_L
                 LEFTBRACKET_L:
003849 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
00384a 7000              cbr     t0, 0xff
00384b 9300 01e8         sts     state, t0
00384d 9508              ret
                 
                 
                 ; ]        --      enter compiling state
00384e f092              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
00384f 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
003850 6f0f              sbr     t0, 0xff
003851 9300 01e8         sts     state, t0
003853 9508              ret
                 
                 ; :        --           begin a colon definition
003854 f09e              fdw     RIGHTBRACKET_L
                 COLON_L:
003855 3a81              .db     NFA|1,":"
                 COLON:
003856 df88              rcall   CREATE
003857 dff8              rcall   RIGHTBRACKET
003858 940c 318b         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
00385a f0aa              fdw     COLON_L
                 NONAME_L:
00385b 3a87
00385c 6f6e
00385d 616e
00385e 656d              .db     NFA|7,":noname"
                 NONAME:
00385f df62              rcall   IHERE
003860 940c 3850         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
003862 f0b6              fdw     NONAME_L
                 SEMICOLON_L:
003863 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
003864 dfe5              rcall   LEFTBRACKET
003865 fd61              sbrc    FLAGS1, fTAILC
003866 c026              rjmp    ADD_RETURN_1
003867 df5a              rcall   IHERE
003868 d02b              rcall   MINUS_FETCH
003869 018c              movw    t0, tosl
00386a 7f10              andi    t1, 0xf0
00386b 5d10              subi    t1, 0xd0
00386c f059              breq    RCALL_TO_JMP
00386d 9189
00386e 9199              poptos
00386f d024              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
003870 508e              subi    tosl, 0x0e
                 .endif
003871 4994              sbci    tosh, 0x94
003872 f4c9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
003873 e08c              ldi     tosl, 0x0c
                 .endif
003874 e994              ldi     tosh, 0x94
003875 d9fc              rcall   SWOP
003876 940c 3e29         jmp     STORE
                 RCALL_TO_JMP:
003878 db64              rcall   NIP
003879 709f              andi    tosh, 0x0f
00387a fd93              sbrc    tosh, 3
00387b 6f90              ori     tosh, 0xf0
00387c da86              rcall   TWOSTAR
00387d df44              rcall   IHERE
00387e da31              rcall   PLUS
00387f df0b              rcall   DOLIT
003880 fffe              .dw     -2
003881 d0e5              rcall   IALLOT
003882 df08              rcall   DOLIT
                 .ifdef EIND
                 .else
003883 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
003884 940e 3f4e         call    ICOMMA
003886 5890              sub_pflash_tos
003887 9488              rampv_to_c
003888 9597              ror     tosh
003889 9587              ror     tosl
00388a 940c 3f4e         jmp     ICOMMA
                 ADD_RETURN:
00388c d918              rcall   TWODROP
                 ADD_RETURN_1:
00388d defd              rcall   DOLIT   ; Compile a ret
00388e 9508              .dw     0x9508
00388f 940c 3f4e         jmp    ICOMMA
                 
                 
                 
003891 f0c6              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
003892 2d82
003893 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
003894 d00c              rcall   TWOMINUS
003895 defe              rcall   DUP
003896 940c 3e71         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
003898 f124              fdw     MINUS_FETCH_L
                 BRACTICK_L:
003899 5bd3
00389a 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
00389b df0d              rcall   TICK       ; get xt of 'xxx'
00389c 940c 3dfd         jmp     LITERAL
                 
                 ; 2-    n -- n-2
00389e f132              fdw     BRACTICK_L
                 TWOMINUS_L:
00389f 32a2
0038a0 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
0038a1 9702              sbiw    tosl, 2
0038a2 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038a3 f13e              fdw     TWOMINUS_L
                 BL_l:
0038a4 6282
0038a5 006c              .db     NFA|2,"bl",0
                 BL:
0038a6 940e 30b1         call    DOCREATE
0038a8 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038a9 f148              fdw     BL_L
                 STATE_L:
0038aa 7385
0038ab 6174
0038ac 6574              .db     NFA|5,"state"
                 STATE_:
0038ad 939a
0038ae 938a              pushtos
0038af 9180 01e8         lds     tosl, state
0038b1 9190 01e8         lds     tosh, state
0038b3 9508              ret
                 
                 ; LATEST    -- a-addr           
0038b4 f154              fdw     STATE_L
                 LATEST_L:
0038b5 6c86
0038b6 7461
0038b7 7365
0038b8 0074              .db     NFA|6,"latest",0
                 LATEST_:
0038b9 940e 30b1         call    DOCREATE
0038bb 01df              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
0038bc f16a              fdw     LATEST_L
                 S0_L:
0038bd 7382
0038be 0030              .db     NFA|2,"s0",0
                 S0:
0038bf dc04              rcall   DOUSER
0038c0 ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
0038c1 f17a              fdw     S0_L
                 R0_L:
0038c2 7282
0038c3 0030              .db     NFA|2,"r0",0
                 R0_:
0038c4 dbff              rcall   DOUSER
0038c5 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
0038c6 6983
0038c7 696e              .db     NFA|3,"ini"
                 INI:
0038c8 940e 30b1          call   DOCREATE
0038ca 01d7              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
0038cb f184              fdw     R0_L
                 TICKS_L:
0038cc 7485
0038cd 6369
0038ce 736b              .db     NFA|5,"ticks"
                 TICKS:
0038cf 939a
0038d0 938a              pushtos
0038d1 b60f              in_     t2, SREG
0038d2 94f8              cli
0038d3 2d8e              mov     tosl, ms_count
0038d4 2d9f              mov     tosh, ms_count1
0038d5 be0f              out_    SREG, t2
0038d6 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
0038d7 f198              fdw     TICKS_L
                 MS_L:
0038d8 6d82
0038d9 0073              .db     NFA|2,"ms",0
                 MS:
0038da dff4              rcall   TICKS
0038db d9d4              rcall   PLUS
                 MS1:    
0038dc d645              rcall   PAUSE
0038dd deb6              rcall   DUP
0038de dff0              rcall   TICKS
0038df d9dd              rcall   MINUS
0038e0 dec1              rcall   ZEROLESS
0038e1 daba              rcall   ZEROSENSE
0038e2 f3c9              breq    MS1
0038e3 940c 326b         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
0038e5 f1b0              fdw     MS_L
                 DOTID_L:
0038e6 2e83
0038e7 6469              .db     NFA|3,".id"
                 DOTID:
0038e8 dc48              rcall   CFETCHPP
0038e9 dea1              rcall   DOLIT
0038ea 000f              .dw     0x0f
0038eb d9da              rcall   AND_
0038ec d99e              rcall   TOR
0038ed c003              rjmp    DOTID3
                 DOTID1:
0038ee dc42              rcall   CFETCHPP
0038ef d00a              rcall   TO_PRINTABLE
0038f0 dee7              rcall   EMIT_A
                 DOTID3:
0038f1 d146              rcall   XNEXT
0038f2 f7d8              brcc    DOTID1  
0038f3 911f              pop     t1
0038f4 910f              pop     t0
0038f5 940c 326b         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
0038f7 f1cc              fdw     DOTID_L
                 TO_PRINTABLE_L:
0038f8 3e83
0038f9 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:   
0038fa 3080              cpi     tosl, 0
0038fb f012              brmi    TO_PRINTABLE1
0038fc 3280              cpi     tosl, 0x20
0038fd f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
0038fe e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
0038ff 9508              ret
                 
                  ; WORDS    --          list all words in dict.
003900 f1f0              fdw     TO_PRINTABLE_L
                 WORDS_L:
003901 7785
003902 726f
003903 7364              .db     NFA|5,"words"
003904 de28              rcall   FALSE_
003905 decd              rcall   CR
003906 de84              rcall   DOLIT
003907 f634              fdw     kernellink
003908 d004              rcall   WDS1
003909 de23              rcall   FALSE_
00390a dec8              rcall   CR
00390b dfad              rcall   LATEST_
00390c ddbe              rcall   FETCH_A
00390d de86      WDS1:   rcall   DUP
00390e dfd9              rcall   DOTID
00390f dd32              rcall   SWOP_A
003910 d9dd              rcall   ONEPLUS
003911 de82              rcall   DUP
003912 de78              rcall   DOLIT
003913 0007              .dw     7
003914 d9b1              rcall   AND_
003915 da86              rcall   ZEROSENSE
003916 f021              breq    WDS2
003917 de73              rcall   DOLIT
003918 0009              .dw     9
003919 debe              rcall   EMIT_A
00391a c001              rjmp    WDS3
                 WDS2:   
00391b deb7              rcall   CR
                 WDS3:
00391c dd25              rcall   SWOP_A
                 
00391d df83              rcall   TWOMINUS
00391e ddac              rcall   FETCH_A
00391f da82              rcall   DUPZEROSENSE
003920 f761              brne    WDS1
003921 940c 31a5         jmp     TWODROP
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
003923 f202              fdw     WORDS_L
                 DOTS_L:
003924 2e82
003925 0073              .db     NFA|2,".s",0
                 DOTS:
003926 d895              rcall   SPACE_
003927 de6c              rcall   DUP          ; push tosl:tosh to memory
003928 940e 30d4         call    SPFETCH
00392a df94              rcall   S0
00392b dd9f              rcall   FETCH_A
00392c df74              rcall   TWOMINUS
                 DOTS1:
00392d d87e              rcall   TWODUP
00392e da02              rcall   LESS
00392f da6c              rcall   ZEROSENSE
003930 f019              breq    DOTS2
003931 df62              rcall   MINUS_FETCH
003932 db24              rcall   UDOT
003933 cff9              rjmp    DOTS1
                 DOTS2:  
003934 d936              rcall   DROP
003935 940c 31a5         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
003937 f248              fdw     DOTS_L
                 DUMP_L:
003938 6484
003939 6d75
00393a 0070              .db     NFA|4,"dump",0
                 DUMP:
00393b de4f              rcall   DOLIT
00393c 0010              .dw     16
00393d da82              rcall   USLASH
00393e d94c              rcall   TOR
00393f c020              rjmp    DUMP7
                 DUMP1:  
003940 de92              rcall   CR
003941 de52              rcall   DUP
003942 de48              rcall   DOLIT
003943 0004              .dw     4
003944 db1c              rcall   UDOTR
003945 de45              rcall   DOLIT
003946 003a              .dw     ':'
003947 de90              rcall   EMIT_A
003948 de42              rcall   DOLIT
003949 000f              .dw     15
00394a d940              rcall   TOR
                 DUMP2:
00394b dbe5              rcall   CFETCHPP
00394c de3e              rcall   DOLIT
00394d 0002              .dw     2
00394e db12              rcall   UDOTR
00394f d0e8              rcall   XNEXT
003950 f7d0              brcc    DUMP2
003951 911f              pop     t1
003952 910f              pop     t0
                 
003953 de37              rcall   DOLIT
003954 0010              .dw     16
003955 d967              rcall   MINUS
003956 de34              rcall   DOLIT
003957 000f              .dw     15
003958 d932              rcall   TOR
                 DUMP4:  
003959 dbd7              rcall   CFETCHPP
00395a df9f              rcall   TO_PRINTABLE
00395b de7c              rcall   EMIT_A
00395c d0db              rcall   XNEXT
00395d f7d8              brcc    DUMP4
00395e 911f              pop     t1
00395f 910f              pop     t0
                 DUMP7:
003960 d0d7              rcall   XNEXT
003961 f6f0              brcc    DUMP1
003962 911f              pop     t1
003963 910f              pop     t0
003964 940c 326b         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
003966 2081              .db     NFA|1," "
                 IALLOT:
003967 dec1              rcall   IDP
003968 940c 330f         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
00396a f270              fdw     DUMP_L
                 X_TO_R_L:
00396b 7883
00396c 723e              .db     NFA|3,"x>r"
                 X_TO_R:
00396d 01fc              movw    zl, tosl
00396e 9189
00396f 9199              poptos
003970 d009              rcall   TO_XA
003971 9631              adiw    zl, 1
003972 9382              st      -z, tosl
003973 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
003974 9252              st      -z, zero
003975 01cf              movw    tosl, zl
003976 9508              ret
                 ;***************************************************************
003977 f2d6              fdw     X_TO_R_L
                 TO_XA_L:
003978 3e83
003979 6178              .db NFA|3,">xa"
                 TO_XA:
00397a 5890               sub_pflash_tos
00397b 9488               rampv_to_c
00397c 9597               ror tosh
00397d 9587               ror tosl
00397e 9508               ret
                 
00397f f2f0               fdw     TO_XA_L
                 XA_FROM_L:
003980 7883
003981 3e61              .db NFA|3,"xa>"
                 XA_FROM:
003982 0f88               lsl     tosl
003983 1f99               rol     tosh
003984 5890               add_pflash_tos
003985 9508               ret
                 ;***************************************************************
003986 f300               fdw    XA_FROM_L
                 PFL_L:
003987 7083
003988 6c66              .db     NFA|3,"pfl"
                 PFL:
003989 940e 30b1          call   DOCREATE
00398b 8000              .dw     PFLASH
                 ;***************************************************************
00398c f30e              fdw    PFL_L
                 ZFL_L:
00398d 7a83
00398e 6c66              .db     NFA|3, "zfl"
                 ZFL:
00398f 940e 30b1          call   DOCREATE
003991 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
003992 2c84
003993 303f
003994 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
003995 fd65              sbrc    FLAGS1, idup
003996 c003              rjmp    COMMAZEROSENSE1
003997 ddf3              rcall   DOLIT
003998 e738              fdw     ZEROSENSE
003999 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
00399a d004              rcall   IDPMINUS
00399b ddef              rcall   DOLIT
00399c e744              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
00399d 7d6f              cbr     FLAGS1, (1<<idup)
00399e c070              rjmp    INLINE0
                 
                 IDPMINUS:
00399f ddeb              rcall   DOLIT
0039a0 fffc              .dw     -4
0039a1 cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
0039a2 d966              rcall   TWOSLASH
0039a3 709f              andi    tosh, 0x0f
0039a4 6c90              ori     tosh, 0xc0
0039a5 940c 3f4e         jmp     ICOMMA
                 
                 
                 BRCCC:
0039a7 dde3              rcall   DOLIT
0039a8 f008              .dw     0xf008      ; brcc pc+2
0039a9 940c 3f4e         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
0039ab dddf              rcall   DOLIT
0039ac f409              .dw     0xf409      ; brne pc+2
0039ad fd64              sbrc    FLAGS1, izeroeq
0039ae 7f9b              andi    tosh, ~4
0039af 940c 3f4e         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
0039b1 f31a              fdw     ZFL_L
                 IF_L:
0039b2 69d2
0039b3 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
0039b4 fd64              sbrc    FLAGS1, izeroeq
0039b5 dfe9              rcall   IDPMINUS
0039b6 dfde              rcall   COMMAZEROSENSE
0039b7 dff3              rcall   BRNEC
0039b8 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039b9 de08              rcall   IHERE
0039ba dd72              rcall   FALSE_
0039bb 940c 39a2         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
0039bd f364              fdw     IF_L
                 ELSE_L:
0039be 65d4
0039bf 736c
0039c0 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
0039c1 de00              rcall   IHERE
0039c2 dd6a              rcall   FALSE_
0039c3 dfde              rcall   RJMPC
0039c4 dc7d              rcall   SWOP_A      ; else-addr  if-addr 
0039c5 940c 39cb         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
0039c7 f37c              fdw     ELSE_L
                 THEN_L:
0039c8 74d4
0039c9 6568
0039ca 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
0039cb 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039cc ddf5              rcall   IHERE
0039cd d8ae              rcall   OVER
0039ce d8ee              rcall   MINUS
0039cf ded1              rcall   TWOMINUS
0039d0 d938              rcall   TWOSLASH
0039d1 ddb9              rcall   DOLIT
0039d2 c000              .dw     0xc000      ;  back-addr mask 
0039d3 d8fa              rcall   OR_
0039d4 dc6d              rcall   SWOP_A
0039d5 940c 3e29         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
0039d7 f390              fdw     THEN_L
                 BEGIN_L:
0039d8 62d5
0039d9 6765
0039da 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
0039db 940c 37c2         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
0039dd f3b0              fdw     BEGIN_L
                 UNTIL_L:
0039de 75d5
0039df 746e
0039e0 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
0039e1 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039e2 fd64              sbrc    FLAGS1, izeroeq
0039e3 dfbb              rcall   IDPMINUS
0039e4 dfb0              rcall   COMMAZEROSENSE
0039e5 dfc5              rcall   BRNEC
0039e6 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039e7 940c 39ed 	    jmp     AGAIN_
                 
                 				; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
0039e9 f3bc              fdw     UNTIL_L
                 AGAIN_L:
0039ea 61d5
0039eb 6167
0039ec 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
0039ed 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039ee ddd3              rcall   IHERE
0039ef d8cd              rcall   MINUS
0039f0 deb0              rcall   TWOMINUS
0039f1 940c 39a2         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
0039f3 f3d4              fdw     AGAIN_L
                 WHILE_L:
0039f4 77d5
0039f5 6968
0039f6 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
0039f7 dfbc              rcall   IF_
0039f8 940c 3272         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
0039fa f3e8              fdw     WHILE_L
                 REPEAT_L:
0039fb 72d6
0039fc 7065
0039fd 6165
0039fe 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
0039ff dfed              rcall   AGAIN_
003a00 940c 39cb         jmp     THEN_
                 
003a02 f3f6              fdw     REPEAT_L
                 INLINE_L:
003a03 69d6
003a04 6c6e
003a05 6e69
003a06 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a07 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a08 7d6f              cbr      FLAGS1, (1<<idup)
003a09 dd9f              rcall    TICK
003a0a 940c 3a0f         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a0c f406              fdw      INLINE_L
                 INLINEC_L:
003a0d 6983
003a0e 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a0f db29              rcall   FETCHPP
003a10 dd83              rcall   DUP
003a11 dd79              rcall   DOLIT
003a12 9508              .dw     0x9508
003a13 d911              rcall   NOTEQUAL
003a14 d987              rcall   ZEROSENSE
003a15 f011              breq    INLINE1
003a16 d537              rcall   ICOMMA
003a17 cff7              rjmp    INLINE0
                 INLINE1:
003a18 940c 31a5         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a1a f41a              fdw     INLINEC_L
                 FOR_L:
003a1b 66d3
003a1c 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a1d 940e 30c9         call    DOCOMMAXT
003a1f e516              fdw     TOR
003a20 dda1              rcall   IHERE
003a21 dd0b              rcall   FALSE_
003a22 df7f              rcall   RJMPC
003a23 dd9e              rcall   IHERE
003a24 940c 3272         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a26 f436              fdw     FOR_L
                 NEXT_L:
003a27 6ed4
003a28 7865
003a29 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a2a dfa0              rcall   THEN_
003a2b 940e 30c9         call    DOCOMMAXT
003a2d f470              fdw     XNEXT
003a2e df78              rcall   BRCCC
                 
003a2f dfbd              rcall   AGAIN_
                 
003a30 dd5a              rcall   DOLIT
003a31 f482              fdw     XNEXT1
003a32 940c 3a0f         jmp     INLINE0
                 ; (next) decrement top of return stack
003a34 2887
003a35 656e
003a36 7478
003a37 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003a38 91ff              pop     zh
003a39 91ef              pop     zl
003a3a 91bf              pop     xh
003a3b 91af              pop     xl
003a3c 9711              sbiw    xl, 1
003a3d 93af              push    xl
003a3e 93bf              push    xh
003a3f 9409              mijmp
003a40 9508              ret
                 XNEXT1:
003a41 911f              pop     t1
003a42 910f              pop     t0
003a43 9508              ret
                 
                 ; leave clear top of return stack
003a44 f44e              fdw     NEXT_L
                 LEAVE_L:
003a45 6595
003a46 646e
003a47 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003a48 91ff              pop     zh
003a49 91ef              pop     zl
003a4a 911f              pop     t1
003a4b 910f              pop     t0
003a4c 2700              clr     t0
003a4d 2711              clr     t1
003a4e 930f              push    t0
003a4f 931f              push    t1
003a50 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003a51 f48a              fdw      LEAVE_L
                 RDROP_L:
003a52 72d5
003a53 7264
003a54 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003a55 dd35              rcall   DOLIT
003a56 f482              fdw     XNEXT1
003a57 940c 3a0f         jmp     INLINE0
                 ;***************************************************
003a59 f4a4              fdw     RDROP_L
                 STOD_L:
003a5a 7383
003a5b 643e              .db     NFA|3,"s>d"
                 STOD:
003a5c ff97              sbrs    tosh, 7
003a5d cccf              rjmp    FALSE_
003a5e ccd7              rjmp    TRUE_
                 ;***************************************************
003a5f f4b4              fdw     STOD_L
                 DNEGATE_L:
003a60 6487
003a61 656e
003a62 6167
003a63 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003a64 d049              rcall   DINVERT
003a65 940e 31df         call    ONE
003a67 940c 32b8         jmp     MPLUS
                 ;***************************************************
003a69 f4c0              fdw     DNEGATE_L
                 QDNEGATE_L:
003a6a 3f88
003a6b 6e64
003a6c 6765
003a6d 7461
003a6e 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003a6f dd32              rcall   ZEROLESS
003a70 d92b              rcall   ZEROSENSE
003a71 f009              breq    QDNEGATE1
003a72 dff1              rcall   DNEGATE
                 QDNEGATE1:
003a73 9508              ret
                 
                 ;***************************************************
003a74 f4d4              fdw     QDNEGATE_L
                 DABS_L:
003a75 6484
003a76 6261
003a77 0073              .db     NFA|4,"dabs",0
                 DABS:
003a78 dd1b              rcall   DUP
003a79 940c 3a6f         jmp     QDNEGATE
                 ;***************************************************
003a7b f4ea              fdw     DABS_L
                 DPLUS_L:
003a7c 6482
003a7d 002b              .db     NFA|2,"d+",0
                 DPLUS:
003a7e 91a9              ld      xl, Y+
003a7f 91b9              ld      xh, Y+
003a80 9009              ld      t2, Y+
003a81 9019              ld      t3, Y+
003a82 9109              ld      t0, Y+
003a83 9119              ld      t1, Y+
003a84 0fa0              add     xl, t0
003a85 1fb1              adc     xh, t1
003a86 1d80              adc     tosl, t2
003a87 1d91              adc     tosh, t3
003a88 93ba              st      -Y, xh
003a89 93aa              st      -Y, xl
003a8a 9508              ret
                 
                 ;***************************************************
003a8b f4f8              fdw     DPLUS_L
                 DMINUS_L:
003a8c 6482
003a8d 002d              .db     NFA|2,"d-",0
                 DMINUS:
003a8e dfd5              rcall   DNEGATE
003a8f 940c 3a7e         jmp     DPLUS
                 ;***************************************************
003a91 f518              fdw     DMINUS_L
                 DTWOSLASH_L:
003a92 6483
003a93 2f32              .db     NFA|3,"d2/"
003a94 9109              ld      t0, y+
003a95 9119              ld      t1, y+
003a96 9595              asr     tosh
003a97 9587              ror     tosl
003a98 9517              ror     t1
003a99 9507              ror     t0
003a9a 931a              st      -y, t1
003a9b 930a              st      -y, t0
003a9c 9508              ret
                 ;***************************************************
003a9d f524              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003a9e 6483
003a9f 2a32              .db     NFA|3,"d2*"
003aa0 9109              ld      t0, y+
003aa1 9119              ld      t1, y+
003aa2 0f00              lsl     t0
003aa3 1f11              rol     t1
003aa4 1f88              rol     tosl
003aa5 1f99              rol     tosh
003aa6 931a              st      -y, t1
003aa7 930a              st      -y, t0
003aa8 9508              ret
                 ;***************************************************
003aa9 f53c              fdw     DTWOSTAR_L
                 DINVERT_L:
003aaa 6487
003aab 6e69
003aac 6576
003aad 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003aae 91a9              ld      xl, y+
003aaf 91b9              ld      xh, y+
003ab0 95a0              com     xl
003ab1 95b0              com     xh
003ab2 9580              com     tosl
003ab3 9590              com     tosh
003ab4 93ba              st      -y, xh
003ab5 93aa              st      -y, xl
003ab6 9508              ret
                 ;***************************************************
003ab7 f554              fdw     DINVERT_L
                 DZEROEQUAL_L:
003ab8 6483
003ab9 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003aba 91a9              ld      xl, y+
003abb 91b9              ld      xh, y+
003abc 2b89              or      tosl, tosh
003abd 2b8a              or      tosl, xl
003abe 2b8b              or      tosl, xh
003abf f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003ac0 ef8f              ser     tosl
003ac1 ef9f              ser     tosh
003ac2 9508              ret
                 
                 ;***************************************************
003ac3 f570              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003ac4 6483
003ac5 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003ac6 91a9              ld      xl, y+
003ac7 91b9              ld      xh, y+
003ac8 3090              cpi     tosh, 0
003ac9 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003aca 2788              clr     tosl
003acb 2799              clr     tosh
003acc 9508              ret
                 ;***************************************************
003acd f588              fdw     DZEROLESS_L
                 DEQUAL_L:
003ace 6482
003acf 003d              .db     NFA|2,"d=",0
003ad0 dfbd              rcall   DMINUS
003ad1 940c 3aba         jmp     DZEROEQUAL
                 ;***************************************************
003ad3 f59c              fdw     DEQUAL_L
                 DLESS_L:
003ad4 6482
003ad5 003c              .db     NFA|2,"d<",0
                 DLESS:
003ad6 dfb7              rcall   DMINUS
003ad7 940c 3ac6         jmp     DZEROLESS
                 ;***************************************************
003ad9 f5a8              fdw     DLESS_L
                 DGREATER_L:
003ada 6482
003adb 003e              .db     NFA|2,"d>",0
                 DGREATER:
003adc 940e 31b3         call    TWOSWAP
003ade 940c 3ad6         jmp     DLESS
                 ;***************************************************
003ae0 f5b4              fdw     DGREATER_L
                 UDDOT_L:
003ae1 7583
003ae2 2e64              .db     NFA|3,"ud."
003ae3 d934              rcall   LESSNUM
003ae4 d954              rcall   NUMS
003ae5 d95c              rcall   NUMGREATER
003ae6 940e 3226         call    TYPE
003ae8 940c 31bc         jmp     SPACE_
                 ;***************************************************
003aea f5c2              fdw     UDDOT_L
                 DDOT_L:
003aeb 6482
003aec 002e              .db     NFA|2,"d.",0
003aed d92a              rcall   LESSNUM
003aee 940e 3794         call    DUP
003af0 940e 328b         call    TOR
003af2 df85              rcall   DABS
003af3 d945              rcall   NUMS
003af4 940e 3295         call    RFROM
003af6 d956              rcall   SIGN
003af7 d94a              rcall   NUMGREATER
003af8 940e 3226         call    TYPE
003afa 940c 31bc         jmp     SPACE_
                 ;****************************************************
003afc f5d6              fdw      DDOT_L
                 MEMHI_L:
003afd 6882
003afe 0069              .db     NFA|2,"hi",0
                 MEMHI:
003aff dc8b              rcall   DOLIT
003b00 f60e              fdw     FLASHHI
003b01 940e 3117         call    CSE_
003b03 940e 32b0         call    PLUS
003b05 940c 3e71         jmp     FETCH
                 FLASHHI:
003b07 deff              .dw      FLASH_HI
003b08 0cff              .dw      EEPROM_HI
003b09 08ff              .dw      RAM_HI
                 ;***************************************************
                 
003b0a f5fa              fdw      MEMHI_L
                 L_FETCH_P:
003b0b 40a2
003b0c 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b0d 939a
003b0e 938a              pushtos
003b0f 01ca              movw    tosl, pl
003b10 9508              ret
                 ;***************************************************
003b11 f616              fdw     L_FETCH_P
                 L_PCFETCH:
003b12 7083
003b13 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b14 939a
003b15 938a              pushtos
003b16 01ca              movw    tosl, pl
003b17 940c 3e9b         jmp     CFETCH
                 ;***************************************************
003b19 f624              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b1a 70a3
003b1b 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b1c 0d47              add     pl, r_two
003b1d 1d55              adc     ph, zero
003b1e 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b1f 0000              .dw     0
                 L_MARKER:
                 lastword:
003b20 6d86
003b21 7261
003b22 656b
003b23 0072              .db     NFA|6,"marker",0
                 MARKER:
003b24 940e 30fc         call    ROM_
003b26 dcb8              rcall   CREATE
003b27 dc63              rcall   DOLIT
003b28 0900              .dw     dp_start
003b29 940e 3121         call    HERE
003b2b dbd9              rcall   TEN
003b2c d9e9              rcall   CMOVE
003b2d dbd7              rcall   TEN
003b2e 940e 3264         call    ALLOT
003b30 940e 310a         call    FRAM
003b32 dcfc              rcall   XDOES
003b33 940e 30b9         call    DODOES
003b35 dd92              rcall   INI
003b36 dbce              rcall   TEN
003b37 940c 3516         jmp     CMOVE
                 
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003b39 fe00              sbrs    t2, PORF
003b3a c003              rjmp    RQ_EXTR
003b3b dc4f              rcall   DOLIT
003b3c 0050              .dw     'P'
003b3d dc9a              rcall   EMIT_A
                 RQ_EXTR:
003b3e fe01              sbrs    t2, EXTRF
003b3f c003              rjmp    RQ_BORF
003b40 dc4a              rcall   DOLIT
003b41 0045              .dw     'E'
003b42 dc95              rcall   EMIT_A
                 RQ_BORF:
003b43 fe02              sbrs    t2, BORF
003b44 c003              rjmp    RQ_WDRF
003b45 dc45              rcall   DOLIT
003b46 0042              .dw     'B'
003b47 dc90              rcall   EMIT_A
                 RQ_WDRF:
003b48 fe03              sbrs    t2, WDRF
003b49 c003              rjmp    RQ_DIVZERO
003b4a dc40              rcall   DOLIT
003b4b 0057              .dw     'W'
003b4c dc8b              rcall   EMIT_A
                 RQ_DIVZERO:
003b4d fe16              sbrs    t3, 6 ; T bit MATH error
003b4e c003              rjmp    RQ_END
003b4f dc3b              rcall   DOLIT
003b50 004d              .dw     'M'
003b51 dc86              rcall   EMIT_A
                 RQ_END: 
003b52 940c 31bc         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1	
003b54 ff75              sbrs    FLAGS2, fLOAD
003b55 c01f              rjmp    CPU_LOAD_END
003b56 939a
003b57 938a              pushtos
003b58 b60f              in_     t2, SREG
003b59 94f8              cli
003b5a 7d7f              cbr     FLAGS2, (1<<fLOAD)
003b5b 9180 01e3         lds     tosl, load_acc
003b5d 9190 01e4         lds     tosh, load_acc+1
003b5f 939a
003b60 938a              pushtos
003b61 9180 01e5         lds     tosl, load_acc+2
003b63 9250 01e3         sts     load_acc, zero
003b65 9250 01e4         sts     load_acc+1, zero
003b67 9250 01e5         sts     load_acc+2, zero
003b69 be0f              out_    SREG, t2
003b6a 2799              clr     tosh
003b6b 939a
003b6c 938a              pushtos
003b6d e080              ldi     tosl, low(CPU_LOAD_VAL)
003b6e ea90              ldi     tosh, high(CPU_LOAD_VAL)
003b6f 940e 33ae         call    UMSLASHMOD
003b71 9380 01e6         sts     load, tosl
003b73 940e 31a5         call    TWODROP 
                 CPU_LOAD_END:
                 .endif
                 .if CPU_LOAD_LED == 1
003b75 ff74              sbrs    FLAGS2, fLOADled
003b76 c002              rjmp    LOAD_LED_END
003b77 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003b78 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003b79 fd76              sbrc    FLAGS2, fIDLE
003b7a c00b              rjmp    IDLE_LOAD1
003b7b fd77              sbrc    FLAGS2, fBUSY
003b7c c009              rjmp    IDLE_LOAD1
003b7d e005              ldi	    t0, low(up0)
003b7e 1620              cp      upl, t0
003b7f f431              brne    IDLE_LOAD1
                 .ifdef SMCR
003b80 e001              ldi     t0, (1<<SE)
003b81 bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
003b82 9250 0081         out_    TCCR1B, zero	; Stop load counter
                 .endif
003b84 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003b85 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003b86 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003b87 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003b88 9508              ret
                 .endif
                 
                 .if CPU_LOAD == 1	
                 LOAD_ADD:
003b89 91e0 01e3         lds     zl, load_acc
003b8b 91f0 01e4         lds     zh, load_acc+1
003b8d 9100 01e5         lds     t0, load_acc+2
003b8f 91b0 0084         in_     xh, TCNT1L
003b91 0feb              add     zl, xh
003b92 91b0 0085         in_     xh, TCNT1H
003b94 1ffb              adc     zh, xh
003b95 1d05              adc     t0, zero
003b96 9250 0085         out_    TCNT1H, zero
003b98 9250 0084         out_    TCNT1L, zero
003b9a 93e0 01e3         sts     load_acc, zl
003b9c 93f0 01e4         sts     load_acc+1, zh
003b9e 9300 01e5         sts     load_acc+2, t0
003ba0 20ee              tst     ms_count
003ba1 f409              brne    LOAD_ADD_END
003ba2 6270              sbr     FLAGS2, (1<<fLOAD)
                 LOAD_ADD_END:
003ba3 c099              rjmp    FF_ISR_EXIT2
                 .endif
                 
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d5d RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d042                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d040                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d03e                  rcall FF_ISR
                 .org BOOT_START + 0x08
003c08 d03c                  rcall FF_ISR
                 .org BOOT_START + 0x0a
003c0a d03a                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d038                  rcall FF_ISR
                 .org BOOT_START + 0x0e
003c0e d036                  rcall FF_ISR
                 .org BOOT_START + 0x10
003c10 d034                  rcall FF_ISR
                 .org BOOT_START + 0x12
003c12 d032                  rcall FF_ISR
                 .org BOOT_START + 0x14
003c14 d030                  rcall FF_ISR
                 .org BOOT_START + 0x16
003c16 d02e                  rcall FF_ISR
                 .org BOOT_START + 0x18
003c18 d02c                  rcall FF_ISR
                 .org BOOT_START + 0x1a
003c1a d02a                  rcall FF_ISR
                 .org BOOT_START + 0x1c
003c1c d028                  rcall FF_ISR
                 .org BOOT_START + 0x1e
003c1e d026                  rcall FF_ISR
                 .org BOOT_START + 0x20
003c20 d024                  rcall FF_ISR
                 .org BOOT_START + 0x22
003c22 d022                  rcall FF_ISR
                 .org BOOT_START + 0x24
003c24 d020                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d01e                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d01c                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
003c2a d01a                  rcall FF_ISR
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d018                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d016                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d014                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d012                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE
                 FF_ISR_EXIT:
003c34 919f              pop     tosh
003c35 918f              pop     tosl
003c36 901f              pop     t3
003c37 900f              pop     t2
                 
003c38 911f              pop     t1
003c39 c003              rjmp    FF_ISR_EXIT2
                 MS_TIMER_ISR:
003c3a 0ce6              add     ms_count,  r_one
003c3b 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
003c3c cf4c              rjmp    LOAD_ADD	
                 .endif
                 FF_ISR_EXIT2:
003c3d 910f              pop     t0
003c3e 91ff              pop     zh
003c3f 91ef              pop     zl
                 FF_ISR_EXIT3:
003c40 91a9              ld      xl, y+
003c41 91b9              ld      xh, y+
003c42 bfbf              out_    SREG, xh
003c43 91b9              ld      xh, y+
003c44 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
003c45 9260 0081         out_    TCCR1B, r_one	; Start load counter
                 .endif
                 .endif
003c47 93ba              st      -y, xh
003c48 b7bf              in_     xh, SREG
003c49 93ba              st      -y, xh
003c4a 93aa              st      -y, xl
                         m_pop_xh
003c4b 91bf              pop     xh
003c4c 91af              pop     xl
003c4d 93ef              push    zl
003c4e 93ff              push    zh
003c4f 930f              push    t0
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
003c50 31ad              cpi     xl, low(OC0Aaddr+1)
                 .endif
                 .ifdef OC0addr
                 .endif
003c51 f341              breq    MS_TIMER_ISR
                 .endif
                 .if MS_TIMER == 1
                 .endif
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .endif
                 .ifdef OC2addr
                 .endif
                 .endif
                 
                 
                 .ifdef URXC0addr
                 .else
003c52 32a5              cpi     xl, low(URXCaddr+1)
                 .endif
003c53 f051              breq    RX0_ISR
                 .ifdef URXC1addr
                 .endif
                 
003c54 931f              push    t1
003c55 920f              push    t2
003c56 921f              push    t3
003c57 938f              push    tosl
003c58 939f              push    tosh
                 
003c59 50a1              subi    xl, 1
003c5a e0b1              ldi     xh, high(ivec)
003c5b 91ed              ld      zl, x+
003c5c 91fd              ld      zh, x+
003c5d 9409              mijmp    ;(z)
                 
                 ;;; *************************************************
                 RX0_ISR:
003c5e ebe7              ldi     zl, low(rbuf0)
003c5f e0f1              ldi     zh, high(rbuf0)
003c60 91a0 01b4         lds     xl, rbuf0_wr
003c62 0fea              add     zl, xl
003c63 1df5              adc     zh, zero
003c64 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
003c66 30bf              cpi     xh, 0xf
003c67 f409              brne    pc+2
003c68 cf97              rjmp    RESET_
                 .endif
003c69 83b0              st      z, xh
003c6a 95a3              inc     xl
003c6b 71af              andi    xl, (RX0_BUF_SIZE-1)
003c6c 93a0 01b4         sts     rbuf0_wr, xl
003c6e 91a0 01b6         lds     xl, rbuf0_lv
003c70 95a3              inc     xl
003c71 93a0 01b6         sts     rbuf0_lv, xl
003c73 31ae              cpi     xl, RX0_BUF_SIZE-2
003c74 f409              brne    PC+2
003c75 d004              rcall   RX0_OVF
003c76 30a4              cpi     xl, RX0_OFF_FILL
003c77 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c78 d03b              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
003c79 cfc3              rjmp    FF_ISR_EXIT2
                 RX0_OVF:
003c7a e7fc              ldi     zh, '|'
003c7b c03a              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;;; Enable load led
003c7c df5c              fdw     BUSY_L
                 LOADON_L:
003c7d 6c85
003c7e 616f
003c7f 2b64              .db     NFA|5,"load+"
003c80 6170              sbr     FLAGS2, (1<<fLOADled)
003c81 9508              ret
                 
                 ;;; Disable load led
003c82 f8fa              fdw     LOADON_L
                 LOADOFF_L:
003c83 6c85
003c84 616f
003c85 2d64              .db     NFA|5,"load-"
003c86 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
003c87 9825              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003c88 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003c89 9508              ret
                 ;;; Enable load led
003c8a f906              fdw     LOADOFF_L
                 LOAD_L:
003c8b 6c84
003c8c 616f
003c8d 0064              .db     NFA|4,"load",0
003c8e 939a
003c8f 938a              pushtos
003c90 2799              clr     tosh
003c91 9180 01e6         lds     tosl, load
003c93 9508              ret
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
003c94 f916              fdw(LOAD_L)
                 TX0_L:
003c95 7483
003c96 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c97 3181              cpi     tosl, XON
003c98 f071              breq    XXON_TX0_TOS
003c99 3183              cpi     tosl, XOFF
003c9a f0a1              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c9b 6870              sbr     FLAGS2, (1<<fBUSY)
003c9c d285              rcall   PAUSE
003c9d 9100 00c0         in_     t0, UCSR0A
003c9f ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003ca0 cffa              rjmp    TX0_LOOP
003ca1 9380 00c6         out_    UDR0_, tosl
003ca3 9189
003ca4 9199              poptos
003ca5 777f              cbr     FLAGS2, (1<<fBUSY)
003ca6 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003ca7 9189
003ca8 9199              poptos
003ca9 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003caa ff70              sbrs    FLAGS2, ixoff_tx0
003cab 9508              ret
                 XXON_TX0_1:
003cac 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003cad e1f1              ldi     zh, XON
003cae c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003caf 9189
003cb0 9199              poptos
003cb1 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003cb2 fd70              sbrc    FLAGS2, ixoff_tx0
003cb3 9508              ret     
                 XXOFF_TX0_1:
003cb4 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003cb5 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003cb6 91e0 00c0         in_     zl, UCSR0A
003cb8 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003cb9 cffc              rjmp    TX0_SEND
003cba 93f0 00c6         out_    UDR0_, zh
003cbc 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003cbd f92a              fdw(TX0_L)
                 RX0_L:
003cbe 7283
003cbf 3078              .db     NFA|3,"rx0"
                 RX0_:
003cc0 d261              rcall   PAUSE
003cc1 d01e              rcall   RX0Q
003cc2 940e 339c         call    ZEROSENSE
003cc4 f3d9              breq    RX0_
003cc5 939a
003cc6 938a              pushtos
003cc7 ebe7              ldi     zl, low(rbuf0)
003cc8 e0f1              ldi     zh, high(rbuf0)
003cc9 91a0 01b5         lds     xl, rbuf0_rd
003ccb 0fea              add     zl, xl
003ccc 1df5              adc     zh, zero
003ccd 8180              ld      tosl, z
003cce 2799              clr     tosh
003ccf b60f              in_     t2, SREG
003cd0 94f8              cli
003cd1 95a3              inc     xl
003cd2 71af              andi    xl, (RX0_BUF_SIZE-1)
003cd3 93a0 01b5         sts     rbuf0_rd, xl
003cd5 91a0 01b6         lds     xl, rbuf0_lv
003cd7 95aa              dec     xl
003cd8 93a0 01b6         sts     rbuf0_lv, xl
003cda be0f              out_    SREG, t2
003cdb 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003cdc f97c              fdw     RX0_L
                 RX0Q_L:
003cdd 7284
003cde 3078
003cdf 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003ce0 91a0 01b6         lds     xl, rbuf0_lv
003ce2 11a5              cpse    xl, zero
003ce3 940c 3736         jmp     TRUE_
                 .if U0FC_TYPE == 1
003ce5 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003ce6 940c 372d         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003ce8 dc3d              rcall   DOTS
003ce9 940e 3233         call    XSQUOTE
003ceb 4103
003cec 3f44              .db     3,"AD?"
003ced 940e 3226         call    TYPE
003cef ca75              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibasehi != iaddrhi)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003cf0 2d0d              mov     t0, iaddrh
003cf1 3d0f              cpi     t0, high(FLASH_HI+1)       ; Dont allow kernel writes
003cf2 f7a8              brcc    ISTORERR
003cf3 2d0c              mov     t0, iaddrl
003cf4 7800              andi    t0, ~(PAGESIZEB-1)
003cf5 110a              cpse    t0, ibasel
003cf6 c003              rjmp    IFILL_BUFFER
003cf7 10db              cpse    iaddrh, ibaseh
003cf8 c001              rjmp    IFILL_BUFFER
003cf9 9508              ret
                 
                 IFILL_BUFFER:
003cfa d04d              rcall   IFLUSH
003cfb 2d0c              mov     t0, iaddrl
003cfc 7800              andi    t0, ~(PAGESIZEB-1)
003cfd 2ea0              mov     ibasel, t0
003cfe 2cbd              mov     ibaseh, iaddrh
                 IFILL_BUFFER_1:
003cff e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003d00 01f5              movw    zl, ibasel
003d01 58f0              sub_pflash_z
003d02 e0a0              ldi     xl, low(ibuf)
003d03 e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003d04 9115              lpm_    t1, z+
003d05 931d              st      x+, t1
003d06 950a              dec     t0
003d07 f7e1              brne    IFILL_BUFFER_2
003d08 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d09 da81              rcall   DOLIT
003d0a 0013              .dw     XOFF
003d0b 940e 305c         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d0d da7d              rcall   DOLIT
003d0e 000a              .dw     10
003d0f dbca              rcall   MS
                         ; Disable interrupts
003d10 94f8              cli
003d11 01f5              movw    zl, ibasel
003d12 58f0              sub_pflash_z
003d13 e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003d14 d028              rcall   DO_SPM
003d15 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003d16 d026              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003d17 e800              ldi     t0, low(PAGESIZEB);init loop variable
003d18 e0a0              ldi     xl, low(ibuf)
003d19 e0b1              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
003d1a 900d              ld      r0, x+
003d1b 901d              ld      r1, x+
003d1c e011              ldi     t1, (1<<SPMEN)
003d1d d01f              rcall   DO_SPM
003d1e 9632              adiw    zl, 2
003d1f 5002              subi    t0, 2
003d20 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d21 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d22 40f0              sbci    zh, high(PAGESIZEB)
003d23 e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d24 d018              rcall   DO_SPM
                         ; re-enable the RWW section
003d25 d011              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d26 e800              ldi     t0, low(PAGESIZEB);init loop variable
003d27 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d28 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d29 9005              lpm_    r0, z+
003d2a 901d              ld      r1, x+
003d2b 1001              cpse    r0, r1
003d2c c030              rjmp    WARM_     ; reset
003d2d 5001              subi    t0, 1
003d2e f7d1              brne    IWRITE_BUFFER2
                 
003d2f 24bb              clr     ibaseh
003d30 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d31 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d32 da58              rcall   DOLIT
003d33 0011              .dw     XON
003d34 940e 305c         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d36 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d37 b687              in_     t8, SPMCSR
003d38 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d39 9508              ret
                         ; re-enable the RWW section
003d3a e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d3b d001              rcall   DO_SPM
003d3c cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d3d b687              in_     t8, SPMCSR
003d3e fc80              sbrc    t8, SPMEN
003d3f cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d40 bf17              out_    SPMCSR, t1
003d41 95e8              spm
003d42 9508              ret
                 
                                 
003d43 fe3e              fdw     PAUSE_L
                 IFLUSH_L:
003d44 6986
003d45 6c66
003d46 7375
003d47 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d48 fd60              sbrc    FLAGS1, idirty
003d49 cfbf              rjmp    IWRITE_BUFFER
003d4a 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d4b f9ba              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d4c 6585
003d4d 706d
003d4e 7974              .db     NFA|5,"empty"
                 EMPTY:
003d4f da3b              rcall   DOLIT
003d50 ff50              fdw     COLDLIT
003d51 da39              rcall   DOLIT
003d52 0900              .dw     dp_start
003d53 da37              rcall   DOLIT
003d54 000c              .dw     coldlitsize
003d55 940e 3516         call    CMOVE
003d57 940c 3709         jmp     DP_TO_RAM
                         
                 ;*******************************************************
003d59 fa98              fdw     EMPTY_L
                 WARM_L:
003d5a 7784
003d5b 7261
003d5c 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d5d 94f8              cli           ; Disable interrupts
003d5e 27aa              clr     xl
003d5f 27bb              clr     xh
003d60 e1c9              ldi     yl, 25
003d61 e0d0              ldi     yh, 0
                 WARM_1:
003d62 93dd              st      x+, yh
003d63 50c1              subi    yl, 1
003d64 f7e9              brne    WARM_1
                 
003d65 b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d66 b604              in_     t2, MCUSR
003d67 9250 0034         sts     MCUSR, zero
                 .endif
003d69 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d6a 925d              st      x+, zero
003d6b 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d6c f7e9              brne    WARM_2
003d6d e0c1              ldi     yl, 1
003d6e 2e6c              mov     r_one, yl
003d6f e0c2              ldi     yl, 2
003d70 2e7c              mov     r_two, yl
                 ; Init Stack pointer
003d71 eac3              ldi     yl, low(utibbuf-4)
003d72 e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d73 e606              ldi     t0, low(usbuf-1)
003d74 e012              ldi     t1, high(usbuf-1)
003d75 bf0d              out     spl, t0
003d76 bf1e              out     sph, t1
                 ; Init user pointer
003d77 e005              ldi     t0, low(up0)
003d78 e012              ldi     t1, high(up0)
003d79 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d7a da10              rcall   DOLIT
003d7b ff34              fdw     WARMLIT
003d7c da0e              rcall   DOLIT
003d7d 01e7              .dw     cse
003d7e da0c              rcall   DOLIT
003d7f 001c              .dw     warmlitsize
003d80 940e 3516         call    CMOVE
                 ; init cold data to eeprom
003d82 da08              rcall   DOLIT
003d83 0900              .dw     dp_start
003d84 d0ec              rcall   FETCH
003d85 d9b0              rcall   TRUE_
003d86 940e 332c         call    EQUAL
003d88 940e 339c         call    ZEROSENSE
003d8a f009              breq    WARM_3  
003d8b dfc3              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d8c be65              out_    MCUCR, r_one   ; (1<<IVCE)
003d8d be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 ; Init ms timer
                 .ifdef TIMSK0
003d8e bc74              out_    TCCR0A, r_two  ; CTC
003d8f e003              ldi     t0, ms_pre_tmr0
003d90 bd05              out_    TCCR0B, t0
003d91 ef09              ldi     t0, ms_value_tmr0
003d92 bd07              out_    OCR0A, t0
003d93 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
                         ; Set baud rate
                 ;        out_    UBRR0H, zero
003d95 e109              ldi     t0, ubrr0val
003d96 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003d98 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003d99 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003d9b e006              ldi     t0, (3<<UCSZ00)|URSEL_
003d9c 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003d9e 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d9f d969              rcall   DP_TO_RAM
003da0 9478              sei
                 
003da1 dd97              rcall   RQ_EMIT
003da2 d023              rcall   VER
                 ; Turnkey ?
003da3 d177              rcall   TURNKEY
003da4 940e 339c         call    ZEROSENSE
003da6 f0d1              breq    STARTQ2
003da7 940e 3233         call    XSQUOTE
003da9 4503
003daa 4353              .db     3,"ESC"
003dab 940e 3226         call    TYPE
003dad d9dd              rcall   DOLIT
003dae 07d0              .dw     TURNKEY_DELAY
003daf db2a              rcall   MS
003db0 940e 3069         call    KEYQ
003db2 940e 339c         call    ZEROSENSE
003db4 f049              breq    STARTQ1
003db5 940e 3062         call    KEY
003db7 d9d3              rcall   DOLIT
003db8 001b              .dw     0x1b
003db9 940e 332c         call    EQUAL
003dbb 940e 339c         call    ZEROSENSE
003dbd f419              brne    STARTQ2
                 STARTQ1:
003dbe d15c              rcall   TURNKEY
003dbf 940e 3071         call    EXECUTE
                 STARTQ2:
003dc1 940c 3765         jmp     ABORT
                 
003dc3 fab4              fdw     WARM_L
                 VER_L:
003dc4 7683
003dc5 7265              .db     NFA|3,"ver"
                 VER:
003dc6 940e 3233         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
003dc8 4617
003dc9 616c
003dca 6873
003dcb 6f46
003dcc 7472
003dcd 2068
003dce 7441
003dcf 656d
003dd0 6167
003dd1 3520
003dd2 302e
003dd3 0a0d              .db 23,"FlashForth Atmega 5.0",0xd,0xa
003dd4 940c 3226         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003dd6 fb88              fdw     VER_L
                 EI_L:
003dd7 65a2
003dd8 0069              .db     NFA|INLINE|2,"ei",0
003dd9 9478              sei
003dda 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003ddb fbae              fdw     EI_L
                 DI_L:
003ddc 64a2
003ddd 0069              .db     NFA|INLINE|2,"di",0
003dde 94f8              cli
003ddf 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003de0 fbb8              fdw     DI_L
                 IRQ_SEMI_L:
003de1 3bc2
003de2 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003de3 d9a7              rcall   DOLIT
                 .ifdef EIND
                 .else
003de4 940c              .dw     0x940C     ; jmp
                 .endif
003de5 d168              rcall   ICOMMA
003de6 d9a4              rcall   DOLIT
003de7 3c34              .dw     FF_ISR_EXIT
003de8 d165              rcall   ICOMMA
003de9 940c 384a         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003deb fbc2              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003dec 6984
003ded 746e
003dee 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003def 01fc              movw    zl, tosl
003df0 9731              sbiw    zl, 1
003df1 0fee              lsl     zl
003df2 e0f1              ldi     zh, high(ivec)
003df3 9189
003df4 9199              poptos
003df5 db84              rcall   TO_XA
003df6 940c 3e2e         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003df8 fbd8              fdw     IRQ_V_L
                 LITERAL_L:
003df9 6cc7
003dfa 7469
003dfb 7265
003dfc 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003dfd d98d              rcall   DOLIT
003dfe ef28              fdw     DUP
003dff dc0f              rcall   INLINE0
003e00 940e 3794         call    DUP
003e02 2f98              mov     tosh, tosl
003e03 9592              swap    tosh
003e04 709f              andi    tosh, 0xf
003e05 708f              andi    tosl, 0xf
003e06 6e90              ori     tosh, 0xe0
003e07 6880              ori     tosl, 0x80
003e08 d145              rcall   ICOMMA
003e09 2f89              mov     tosl, tosh
003e0a 9592              swap    tosh
003e0b 709f              andi    tosh, 0xf
003e0c 708f              andi    tosl, 0xf
003e0d 6e90              ori     tosh, 0xe0
003e0e 6980              ori     tosl, 0x90
003e0f 940c 3f4e         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e11 d039              rcall   LOCKEDQ
003e12 016c              movw    iaddrl, tosl
003e13 dedc              rcall   IUPDATEBUF
003e14 9189
003e15 9199              poptos
003e16 e0a0              ldi     xl, low(ibuf)
003e17 e0b1              ldi     xh, high(ibuf)
003e18 2d0c              mov     t0, iaddrl
003e19 770f              andi    t0, (PAGESIZEB-1)
003e1a 0fa0              add     xl, t0
003e1b 938d              st      x+, tosl
003e1c 939d              st      x+, tosh
003e1d 9189
003e1e 9199              poptos
003e1f 6061              sbr     FLAGS1, (1<<idirty)
003e20 9508              ret
                 
003e21 fbf2              fdw     LITERAL_L
                 TO_A_L:
003e22 3e82
003e23 0061              .db     NFA|2, ">a",0
003e24 eee1              ldi     zl, low(areg)
003e25 e0f1              ldi     zh, high(areg)
003e26 c007              rjmp    STORE_RAM_2
                 
003e27 fc44              fdw     TO_A_L
                 STORE_L:
003e28 2181              .db     NFA|1, "!"
                 STORE:
003e29 3099              cpi     tosh, high(PEEPROM)
003e2a f440              brcc    STORE1
                 STORE_RAM:
003e2b 01fc              movw    zl, tosl
003e2c 9189
003e2d 9199              poptos
                 STORE_RAM_2:
003e2e 8391              std     Z+1, tosh
003e2f 8380              std     Z+0, tosl
003e30 9189
003e31 9199              poptos
003e32 9508              ret
                 STORE1:
003e33 3890              cpi     tosh, high(OFLASH)
003e34 f6e0              brcc    ISTORE
                 ESTORE:
003e35 d015              rcall   LOCKEDQ
003e36 99f9              sbic    eecr, eewe
003e37 cffd              rjmp    ESTORE
003e38 5099              subi    tosh, high(PEEPROM)
003e39 bd81              out     eearl, tosl
003e3a bd92              out     eearh, tosh
003e3b 9189
003e3c 9199              poptos
003e3d bd80              out     eedr, tosl
003e3e 9afa              sbi     eecr, eemwe
003e3f 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
003e40 99f9              sbic    eecr, eewe
003e41 cffe              rjmp    ESTORE1
                 
003e42 b581              in      tosl, eearl
003e43 9583              inc     tosl
003e44 bd81              out     eearl, tosl
                 
003e45 bd90              out     eedr, tosh
003e46 9afa              sbi     eecr, eemwe
003e47 9af9              sbi     eecr, eewe
                 
003e48 9189
003e49 9199              poptos
003e4a 9508              ret
                 LOCKEDQ:
003e4b ff62              sbrs    FLAGS1, fLOCK
003e4c 9508              ret
003e4d dad8              rcall   DOTS
003e4e 940e 3233         call    XSQUOTE
003e50 4103
003e51 3f44              .db     3,"AD?"
003e52 940e 3226         call    TYPE
003e54 cf6c              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e55 01fc              movw    z, tosl
003e56 11fb              cpse    zh, ibaseh
003e57 c00b              rjmp    IIFETCH
003e58 2f0e              mov     t0, zl
003e59 7800              andi    t0, ~(PAGESIZEB-1)
003e5a 150a              cp      t0, ibasel
003e5b f439              brne    IIFETCH
003e5c e0a0              ldi     xl, low(ibuf)
003e5d e0b1              ldi     xh, high(ibuf)
003e5e 77ef              andi    zl, (PAGESIZEB-1)
003e5f 0fae              add     xl, zl
003e60 918d              ld      tosl, x+
003e61 919d              ld      tosh, x+
003e62 9508              ret
                 IIFETCH:
003e63 58f0              sub_pflash_z
003e64 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e65 9195              lpm_    tosh, z+
                 .ifdef RAMPZ
                 .endif
003e66 9508              ret
                                 
003e67 fc50              fdw     STORE_L
                 A_FROM_L:
003e68 6182
003e69 003e              .db     NFA|2, "a>",0
003e6a 939a
003e6b 938a              pushtos
003e6c eee1              ldi     zl, low(areg)
003e6d e0f1              ldi     zh, high(areg)
003e6e c005              rjmp    FETCH_RAM_2
                 
003e6f fcd0              fdw     A_FROM_L
                 FETCH_L:
003e70 4081              .db     NFA|1, "@"
                 FETCH:
003e71 3099              cpi     tosh, high(PEEPROM)
003e72 f420              brcc    FETCH1
                 FETCH_RAM:
003e73 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e74 9181              ld      tosl, z+
003e75 9191              ld      tosh, z+
003e76 9508              ret
                 FETCH1:
003e77 3890              cpi     tosh, high(OFLASH)
003e78 f6e0              brcc    IFETCH
                 EFETCH:
003e79 99f9              sbic    eecr, eewe
003e7a cffe              rjmp    EFETCH
003e7b 5099              subi    tosh, high(PEEPROM)
003e7c bd81              out     eearl, tosl
003e7d bd92              out     eearh, tosh
003e7e 9af8              sbi     eecr, eere
003e7f b580              in      tosl, eedr
003e80 b591              in      tosh, eearl
003e81 9593              inc     tosh
003e82 bd91              out     eearl, tosh
003e83 9af8              sbi     eecr, eere
003e84 b590              in      tosh, eedr
003e85 9508              ret
                 
                 ICFETCH:
003e86 01fc              movw    z, tosl
003e87 11fb              cpse    zh, ibaseh
003e88 c00b              rjmp    IICFETCH
003e89 2f0e              mov     t0, zl
003e8a 7800              andi    t0, ~(PAGESIZEB-1)
003e8b 150a              cp      t0, ibasel
003e8c f439              brne    IICFETCH
003e8d e0a0              ldi     xl, low(ibuf)
003e8e e0b1              ldi     xh, high(ibuf)
003e8f 77ef              andi    zl, (PAGESIZEB-1)
003e90 0fae              add     xl, zl
003e91 918d              ld      tosl, x+
003e92 2799              clr     tosh
003e93 9508              ret
                 IICFETCH:
003e94 58f0              sub_pflash_z
003e95 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e96 2799              clr     tosh
                 .ifdef RAMPZ
                 .endif
003e97 9508              ret
                 
003e98 fce0              fdw     FETCH_L
                 CFETCH_L:
003e99 6382
003e9a 0040              .db     NFA|2, "c@",0
                 CFETCH:
003e9b 3099              cpi     tosh, high(PEEPROM)
003e9c f420              brcc    CFETCH1
                 CFETCH_RAM:
003e9d 01fc              movw    zl, tosl
003e9e 9181              ld      tosl, z+
003e9f 2799              clr     tosh
003ea0 9508              ret
                 CFETCH1:
003ea1 3890              cpi     tosh, high(OFLASH)
003ea2 f718              brcc    ICFETCH
                 ECFETCH:
003ea3 99f9              sbic    eecr, eewe
003ea4 cffe              rjmp    ECFETCH
003ea5 5099              subi    tosh, high(PEEPROM)
003ea6 bd81              out     eearl, tosl
003ea7 bd92              out     eearh, tosh
003ea8 9af8              sbi     eecr, eere
003ea9 b580              in      tosl, eedr
003eaa 2799              clr     tosh
003eab 9508              ret
                 
                 ICSTORE:
003eac df9e              rcall   LOCKEDQ
003ead 016c              movw    iaddrl, tosl
003eae de41              rcall   IUPDATEBUF
003eaf 9189
003eb0 9199              poptos
003eb1 e0a0              ldi     xl, low(ibuf)
003eb2 e0b1              ldi     xh, high(ibuf)
003eb3 2d0c              mov     t0, iaddrl
003eb4 770f              andi    t0, (PAGESIZEB-1)
003eb5 0fa0              add     xl, t0
003eb6 938d              st      x+, tosl
003eb7 9189
003eb8 9199              poptos
003eb9 6061              sbr     FLAGS1, (1<<idirty)
003eba 9508              ret
                 
003ebb fd32              fdw     CFETCH_L
                 CSTORE_L:
003ebc 6382
003ebd 0021              .db     NFA|2, "c!",0
                 CSTORE:
003ebe 3099              cpi     tosh, high(PEEPROM)
003ebf f438              brcc    CSTORE1
                 CSTORE_RAM:
003ec0 01fc              movw zl, tosl
003ec1 9189
003ec2 9199              poptos
003ec3 8380              std Z+0, tosl
003ec4 9189
003ec5 9199              poptos
003ec6 9508              ret
                 CSTORE1:
003ec7 3890              cpi     tosh, high(OFLASH)
003ec8 f718              brcc    ICSTORE
                 ECSTORE:
003ec9 df81              rcall   LOCKEDQ
003eca 99f9              sbic    eecr, eewe
003ecb cffd              rjmp    ECSTORE
003ecc 5099              subi    tosh, high(PEEPROM)
003ecd bd81              out     eearl, tosl
003ece bd92              out     eearh, tosh
003ecf 9189
003ed0 9199              poptos
003ed1 bd80              out     eedr, tosl
003ed2 9afa              sbi     eecr, eemwe
003ed3 9af9              sbi     eecr, eewe
003ed4 9189
003ed5 9199              poptos
003ed6 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
003ed7 fd78              fdw     CSTORE_L
                 
                 FLOCK_L:
003ed8 6683
003ed9 2d6c              .db     NFA|3,"fl-"
003eda 6064              sbr     FLAGS1, (1<<fLOCK)
003edb 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003edc fdb0              fdw     FLOCK_L
                 FUNLOCK_L:
003edd 6683
003ede 2b6c              .db     NFA|3,"fl+"
003edf 7f6b              cbr     FLAGS1, (1<<fLOCK)
003ee0 9508              ret
                 
                 
                 
003ee1 fdba              fdw     FUNLOCK_L
                 VALUE_L:
003ee2 7685
003ee3 6c61
003ee4 6575              .db     NFA|5,"value"
                 VALUE:
003ee5 d8f9              rcall   CREATE
003ee6 940e 3126         call    COMMA
003ee8 d946              rcall   XDOES
                 VALUE_DOES:
003ee9 940e 30b9         call    DODOES
003eeb 940c 3e71         jmp     FETCH
                 
003eed fdc4              fdw     VALUE_L
                 DEFER_L:
003eee 6485
003eef 6665
003ef0 7265              .db     NFA|5,"defer"
                 DEFER:
003ef1 d8ed              rcall   CREATE
003ef2 940e 378b         call    DOLIT
003ef4 eeca              fdw     ABORT
003ef5 940e 3126         call    COMMA
003ef7 d937              rcall   XDOES
                 DEFER_DOES:
003ef8 940e 30b9         call    DODOES
003efa 940c 307c         jmp     FEXECUTE
                 
003efc fddc              fdw     DEFER_L
                 IS_L:
003efd 69c2
003efe 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003eff 940e 37a9         call    TICK
003f01 940e 32f8         call    TWOPLUS
003f03 940e 32f8         call    TWOPLUS
003f05 df6b              rcall   FETCH
003f06 d9a6              rcall   STATE_
003f07 940e 339c         call    ZEROSENSE
003f09 f029              breq    IS1
003f0a def2              rcall   LITERAL
003f0b 940e 30c9         call    DOCOMMAXT
003f0d fc52              fdw     STORE
003f0e c001              rjmp    IS2
                 IS1:
003f0f df19              rcall   STORE
                 IS2:
003f10 9508              ret
                 
003f11 fdfa              fdw     IS_L
                 TO_L:
003f12 74c2
003f13 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003f14 940c 3eff         jmp     IS
                 
003f16 fe24              fdw     TO_L
                 TURNKEY_L:
003f17 7487
003f18 7275
003f19 6b6e
003f1a 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003f1b 940e 3ee9         call    VALUE_DOES      ; Must be call for IS to work.
003f1d 01d7              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003f1e fe2e              fdw     TURNKEY_L
                 PAUSE_L:
003f1f 7085
003f20 7561
003f21 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003f22 dc31              rcall   IDLE_LOAD
                 .endif
003f23 b60f              in_     t2, SREG
003f24 94f8              cli
003f25 93df              push    yh        ; SP
003f26 93cf              push    yl
003f27 939f              push    tosh      ; TOS
003f28 938f              push    tosl
003f29 935f              push    ph        ; P
003f2a 934f              push    pl
003f2b 01f1              movw    zl, upl
003f2c b70e              in      t0, sph
003f2d 9302              st      -z, t0
003f2e b70d              in      t0, spl
003f2f 9302              st      -z, t0
003f30 91b2              ld      xh, -z     ; UP
003f31 91a2              ld      xl, -z
003f32 011d              movw    upl, xl
003f33 910e              ld      t0, -x
003f34 bf0e              out     sph, t0
003f35 910e              ld      t0, -x
003f36 bf0d              out     spl, t0
003f37 914f              pop     pl
003f38 915f              pop     ph
003f39 918f              pop     tosl
003f3a 919f              pop     tosh
003f3b 91cf              pop     yl
003f3c 91df              pop     yh
003f3d be0f              out_    SREG, t2
003f3e 9508              ret
                 
                 
003f3f fa88              fdw     IFLUSH_L
                 OPERATOR_L:
003f40 6f88
003f41 6570
003f42 6172
003f43 6f74
003f44 0072              .db     NFA|8,"operator",0
                 OPERATOR:
003f45 940e 30b1         call    DOCREATE
003f47 fe90              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
003f48 0205              .dw     up0
003f49 6000              .db     0, ursize
003f4a 5440              .db     ussize, utibsize
                 
003f4b fe80              fdw     OPERATOR_L
                 ICOMMA_L:
003f4c 6982
003f4d 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f4e 940e 37c2         call    IHERE
003f50 ded8              rcall   STORE
003f51 940e 3137         call    CELL
003f53 940c 3967         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f55 fe98              fdw     ICOMMA_L
                 ICCOMMA_L:
003f56 6983
003f57 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f58 940e 37c2         call    IHERE
003f5a df63              rcall   CSTORE
003f5b 940e 31df         call    ONE
003f5d 940c 3967         jmp     IALLOT
                 
                 L_DOTBASE:
003f5f 2081              .db      NFA|1," "
                 DOTBASE:
003f60 940e 34b7         call    BASE
003f62 df0e              rcall   FETCH
003f63 3180              cpi     tosl, 0x10
003f64 f411              brne    DOTBASE1
003f65 e284              ldi     tosl,'$'
003f66 c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f67 308a              cpi     tosl, 0xa
003f68 f411              brne    DOTBASE2
003f69 e283              ldi     tosl, '#'
003f6a c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f6b 3082              cpi     tosl, 0x2
003f6c f411              brne    DOTBASE3
003f6d e285              ldi     tosl, '%'
003f6e c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f6f e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f70 9508              ret
                 
                 MEMQADDR_N:
003f71 e1f2              fdw     ROM_N
003f72 e200              fdw     EROM_N
003f73 e210              fdw     FRAM_N
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
003f74 2081              .db     NFA|1," "
                 MEMQ:
003f75 940e 3117         call    CSE_
003f77 940e 378b         call    DOLIT
003f79 fee2              fdw     MEMQADDR_N
003f7a 940e 32b0         call    PLUS
003f7c 940e 36cb         call    FETCH_A
003f7e 940e 3531         call    CFETCHPP
003f80 940e 378b         call    DOLIT
003f82 000f              .dw     NFAmask
003f83 940c 32c6         jmp     AND_
                 
                 ;*******************************************************
                 umstar0:
003f85 9109              ld  t0, Y+
003f86 9119              ld  t1, Y+
003f87 9f80              mul tosl,t0
003f88 01d0              movw t4, r0 ; r0=t2, r1=t3
003f89 27ee              clr t6
003f8a 27ff              clr t7
003f8b 9f90              mul tosh, t0
003f8c 0db0              add t5, r0
003f8d 1de1              adc t6, r1
003f8e 1df5              adc t7, zero
003f8f 9f81              mul tosl, t1
003f90 0db0              add t5, r0
003f91 1de1              adc t6, r1
003f92 1df5              adc t7, zero
003f93 9f91              mul tosh, t1
003f94 0de0              add t6, r0
003f95 1df1              adc t7, r1
003f96 93ba              st -Y, t5
003f97 93aa              st -Y, t4
003f98 01cf              movw tosl, t6
003f99 9508              ret
                 
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
003f9a 0200              .dw      0x0200                ; cse, state
003f9b 02a3              .dw      utibbuf-4             ; S0
003f9c 0266              .dw      usbuf-1               ; R0
003f9d f92e              fdw      OP_TX_
003f9e f980              fdw      OP_RX_
003f9f f9c0              fdw      OP_RXQ
003fa0 000a              .dw      BASE_DEFAULT          ; BASE
003fa1 02a7              .dw      utibbuf               ; TIB
003fa2 fe90              fdw      OPERATOR_AREA         ; TASK
003fa3 0000              .dw      0                     ; ustatus & uflg
003fa4 0000              .dw      0                     ; source
003fa5 0000              .dw      0                     ; source
003fa6 0000              .dw      0                     ; TOIN
003fa7 0205              .dw      up0                   ; Task link
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 .equ coldlitsize=12
                 ;.section user_eedata
                 COLDLIT:
003fa8 0000      STARTV: .dw      0
003fa9 8000      DPC:    .dw      OFLASH
003faa 090c      DPE:    .dw      ehere
003fab 02fb      DPD:    .dw      dpdata
003fac f640      LW:     fdw      lastword
003fad edde      STAT:   fdw      DOTSTATUS
                 
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328 register use summary:
r0 :  24 r1 :  17 r2 :   5 r3 :   1 r4 :   0 r5 :  21 r6 :   5 r7 :   6 
r8 :   4 r9 :   4 r10:   6 r11:   5 r12:   6 r13:   3 r14:   3 r15:   2 
r16: 119 r17:  50 r18:   0 r19:   0 r20:  14 r21:   7 r22:  34 r23:  18 
r24: 220 r25: 180 r26:  61 r27:  43 r28:   9 r29:   5 r30:  73 r31:  51 
x  :  17 y  : 178 z  :  33 
Registers used: 32 out of 35 (91.4%)

ATmega328 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  18 add   :  17 adiw  :   9 and   :   3 
andi  :  20 asr   :   2 bclr  :   4 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  20 brcs  :   1 break :   0 breq  :  45 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   6 
brne  :  37 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  93 cbi   :   3 cbr   :  21 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :  22 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   7 cp    :   4 cpc   :   2 
cpi   :  25 cpse  :   6 dec   :   3 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  14 in    :  18 inc   :   6 jmp   : 163 
ld    : 123 ldd   :   2 ldi   :  66 lds   :  20 lpm   :   9 lsl   :  11 
lsr   :   2 mov   :  20 movw  :  40 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   7 ori   :   7 out   :  32 pop   :  80 
push  :  26 rcall : 969 ret   : 126 reti  :   1 rjmp  :  95 rol   :  15 
ror   :  18 sbc   :   2 sbci  :   3 sbi   :  11 sbic  :   5 sbis  :   0 
sbiw  :   8 sbr   :  18 sbrc  :  14 sbrs  :  16 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   6 ses   :   0 set   :   1 sev   :   0 
sez   :   0 sleep :   1 spm   :   2 st    :  83 std   :   3 sts   :  27 
sub   :   2 subi  :  22 swap  :   2 tst   :   4 wdr   :   0 
Instructions used: 71 out of 113 (62.8%)

ATmega328 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007f5c   5576   2474   8050   32768  24.6%
[.dseg] 0x000100 0x0002fd      0    509    509    2048  24.9%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 7 warnings
