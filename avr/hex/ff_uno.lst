
AVRASM ver. 2.1.30  avr/src/ff-atmega.asm Sat Jul 02 17:02:51 2016

avr/src/ff-atmega.asm(34): Including file 'avr/src/config.inc'
avr/src/config.inc(8): Including file 'avrasm2/inc\m328pdef.inc'
avr/src/ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
avr/src/ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
avr/src/ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
avr/src/ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
avr/src/ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
avr/src/ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
avr/src/ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          02.07.2016                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2016  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 ;.include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 .include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega328P.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328Pdef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328P
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328P
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328PDEF_INC_
                 #define _M328PDEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328P
                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x0f
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 .equ	BODSE	= 5	; BOD Sleep Enable
                 .equ	BODS	= 6	; BOD Sleep
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328PDEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program. Or use the ff-shell.py which adds CR LF flow control.
                 .equ BAUDRATE0 = 9600               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 1
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 96                   ; 86 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #define partstring "ATmega328P"
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "02.07.2016"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def il = r18         ; FOR..LOOP INDEX variable
                   .def ih = r19
                   .def pl = r20         ; P Register
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*255/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fIDLE=     6   ; 0 = busy, 1 = idle
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 ;.equ uaddsize=     0          ; No additional user variables 
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001d7           dpSTART:    .byte 2
0001d9           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001db           dpEEPROM:   .byte 2
0001dd           dpRAM:      .byte 2
0001df           dpLATEST:   .byte 2
                 
0001e1           areg:       .byte 2 ; A register data
0001e3           iaddrl:     .byte 1
0001e4           iaddrh:     .byte 1
                 .ifdef RAMPZ
                 .endif
                 
0001e5           load_acc:   .byte 3 ; Load measurement accumulator
0001e8           load_res:   .byte 3 ; Load result
                 
0001eb           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0001ec           state:      .byte 1 ; Compilation state
0001ed           uvars:      .byte   (-us0)
000209           up0:        .byte   2
00020b           urbuf:      .byte   ursize
00026b           usbuf:      .byte   ussize
0002ab           utibbuf:    .byte   utibsize
00030b           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
002f80 2081              .db     NFA|1," "
                 MEMQ:
002f81 940e 3149         call    CSE_
002f83 940e 37b9         call    DOLIT
002f85 feda              fdw     MEMQADDR_N
002f86 940e 32e3         call    PLUS
002f88 940e 36f9         call    FETCH_A
002f8a 940e 355f         call    CFETCHPP
002f8c 940e 37b9         call    DOLIT
002f8e 000f              .dw     NFAmask
002f8f 940c 32f9         jmp     AND_
                 
                 
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
002f91 94e8              clt
002f92 2388              tst  tosl
002f93 f429              brne umslashmodstart
002f94 2399              tst  tosh
002f95 f419              brne umslashmodstart
002f96 9468              set  ; Set T flag
002f97 940c 3d56         jmp  WARM_
                 umslashmodstart:
002f99 920f              push t2
002f9a 921f              push t3
002f9b 01dc              movw t4, tosl
                 
002f9c 9019              ld t3, Y+
002f9d 91e9              ld t6, Y+
                   
002f9e 9189              ld tosl, Y+
002f9f 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
002fa0 e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
002fa1 27ff              clr t7
002fa2 0f88              lsl tosl
002fa3 1f99              rol tosh
002fa4 1c11              rol t3
002fa5 1fee              rol t6
002fa6 1fff              rol t7
                 
                         ; try subtracting divisor
002fa7 161a              cp  t3, t4
002fa8 07eb              cpc t6, t5
002fa9 05f5              cpc t7,zero
                 
002faa f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
002fab 9583              inc tosl
002fac 1a1a              sub t3, t4
002fad 0beb              sbc t6, t5
                 
                 umslashmod2:
002fae 950a              dec  t0
002faf f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
002fb0 93ea              st -Y,t6
002fb1 921a              st -Y,t3
002fb2 901f              pop t3
002fb3 900f              pop t2
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
002fb4 9508              ret
                 ;*********************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fb5 0000              .dw     0
                 EXIT_L:
002fb6 6584
002fb7 6978
002fb8 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fb9 910f              pop     t0
002fba 910f              pop     t0
002fbb 9508              ret
                 
002fbc fa7a              fdw     IFLUSH_L
                 OPERATOR_L:
002fbd 6f88
002fbe 6570
002fbf 6172
002fc0 6f74
002fc1 0072              .db     NFA|8,"operator",0
                 OPERATOR:
002fc2 940e 30e3         call    DOCREATE
002fc4 df8a              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
002fc5 0209              .dw     up0
002fc6 0000
002fc7 0060              .dw     0, ursize
002fc8 0040
002fc9 0060              .dw     ussize, utibsize
                 
                 ; idle
002fca df6c              fdw(EXIT_L)
                 IDLE_L:
002fcb 6984
002fcc 6c64
002fcd 0065              .db     NFA|4,"idle",0
                 IDLE:
002fce 6470              sbr     FLAGS2, (1<<fIDLE)
002fcf 9508              ret
                         
                 ; busy
002fd0 df96              fdw(IDLE_L)
                 BUSY_L:
002fd1 6284
002fd2 7375
002fd3 0079              .db     NFA|4,"busy",0
                 BUSY:
002fd4 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fd5 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fd6 fea4              fdw     ICCOMMA_L
                 MSET_L:
002fd7 6d84
002fd8 6573
002fd9 0074              .db     NFA|4,"mset",0
                 MSET:
002fda 01fc              movw    zl, tosl
002fdb 9189
002fdc 9199              poptos
002fdd 8100              ld      t0, z
002fde 2b08              or      t0, tosl
002fdf 8300              st      z, t0
002fe0 9189
002fe1 9199              poptos
002fe2 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002fe3 dfae              fdw     MSET_L
                 MCLR_L:
002fe4 6d84
002fe5 6c63
002fe6 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002fe7 01fc              movw    zl, tosl
002fe8 9189
002fe9 9199              poptos
002fea 8100              ld      t0, z
002feb 9580              com     tosl
002fec 2308              and     t0, tosl
002fed 8300              st      z, t0
002fee 9189
002fef 9199              poptos
002ff0 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
002ff1 dfc8              fdw     MCLR_L
                 LSHIFT_L:
002ff2 6c86
002ff3 6873
002ff4 6669
002ff5 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
002ff6 01fc              movw    zl, tosl
002ff7 9189
002ff8 9199              poptos
                 LSHIFT1:
002ff9 9731              sbiw    zl, 1
002ffa f01a              brmi    LSHIFT2
002ffb 0f88              lsl     tosl
002ffc 1f99              rol     tosh
002ffd cffb              rjmp    LSHIFT1
                 LSHIFT2:
002ffe 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
002fff dfe4              fdw     LSHIFT_L
                 RSHIFT_L:
003000 7286
003001 6873
003002 6669
003003 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
003004 01fc              movw    zl, tosl
003005 9189
003006 9199              poptos
                 RSHIFT1:
003007 9731              sbiw    zl, 1
003008 f01a              brmi    RSHIFT2
003009 9596              lsr     tosh
00300a 9587              ror     tosl
00300b cffb              rjmp    RSHIFT1
                 RSHIFT2:
00300c 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
00300d d551              rcall   CFETCHPP
00300e d2a7              rcall   ROT
00300f d54f              rcall   CFETCHPP
003010 940c 32b6         jmp     ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
003012 e000              fdw     RSHIFT_L
                 NEQUAL_L:
003013 6e82
003014 003d              .db     NFA|2,"n=",0
                 NEQUAL:
003015 dff7              rcall   NEQUALSFETCH
003016 708f              andi    tosl, 0xf
003017 d348              rcall   EQUAL
003018 d3b6              rcall   ZEROSENSE
003019 f0b1              breq    NEQUAL5
00301a d30b              rcall   ONEMINUS
00301b d543              rcall   CFETCHPP
00301c d2a1              rcall   TOR
00301d c00c              rjmp    NEQUAL4
                 NEQUAL2:
00301e dfee              rcall   NEQUALSFETCH
00301f d338              rcall   NOTEQUAL
003020 d3ae              rcall   ZEROSENSE
003021 f021              breq    NEQUAL3
003022 d741              rcall   TRUE_
003023 940e 3a76         call    LEAVE
003025 c004              rjmp    NEQUAL4
                 NEQUAL3:
003026 d2ab              rcall   RFETCH
003027 d3a7              rcall   ZEROSENSE
003028 f409              brne    NEQUAL4
003029 d731              rcall   FALSE_
                 NEQUAL4:
00302a 940e 3a66         call    XNEXT
00302c f788              brcc    NEQUAL2
00302d 911f              pop     t1
00302e 910f              pop     t0
00302f c001              rjmp    NEQUAL6
                 NEQUAL5:
003030 d733              rcall   TRUE_
                 NEQUAL6:
003031 d3de              rcall   NIP
003032 940c 3410         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
003034 e026              fdw     NEQUAL_L
                 SKIP_L:
003035 7384
003036 696b
003037 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003038 d285              rcall   TOR
                 SKIP0:
003039 d39b              rcall   DUPZEROSENSE
00303a f089              breq    SKIP2
                 
00303b d272              rcall   OVER
00303c d3f5              rcall   CFETCH_A
                 
00303d d784              rcall   DUP
00303e d77a              rcall   DOLIT
00303f 0009              .dw     TAB_
003040 d31f              rcall   EQUAL
003041 d38d              rcall   ZEROSENSE
003042 f429              brne    SKIP05    
003043 d28e              rcall   RFETCH
003044 d31b              rcall   EQUAL
003045 d389              rcall   ZEROSENSE
003046 f029              breq    SKIP2
003047 c001                      rjmp    SKIP1
                 SKIP05:
003048 d254              rcall   DROP
                 SKIP1:
003049 d1c7              rcall   ONE
00304a d4bf              rcall   SLASHSTRING
00304b cfed              rjmp    SKIP0
                 SKIP2:
00304c 910f              pop     t0
00304d 910f              pop     t0
00304e 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
00304f e06a              fdw     SKIP_L
                 SCAN_L:
003050 7384
003051 6163
003052 006e              .db     NFA|4,"scan",0
                 SCAN:
003053 d331              rcall   STORE_P_TO_R
003054 d269              rcall   TOR
003055 c010              rjmp    SCAN3
                 SCAN1:
003056 d508              rcall   CFETCHPP
003057 d76a              rcall   DUP
003058 d760              rcall   DOLIT
003059 0009              .dw     TAB_
00305a d305              rcall   EQUAL
00305b d373              rcall   ZEROSENSE
00305c f011              breq    SCAN2
00305d d23f              rcall   DROP
00305e c005              rjmp    SCAN25
                 SCAN2:
00305f 940e 3b3b         call    FETCH_P
003061 d2fe              rcall   EQUAL
003062 d36c              rcall   ZEROSENSE
003063 f011              breq    SCAN3
                 SCAN25:
003064 d2c1              rcall   ONEMINUS
003065 c003              rjmp    SCAN4
                 SCAN3:
003066 940e 3a66         call    XNEXT
003068 f768              brcc    SCAN1
                 SCAN4:
003069 d25e              rcall   RFROM
00306a d2b6              rcall   ONEPLUS
00306b d324              rcall   R_TO_P
00306c 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
00306d e0a0              fdw     SCAN_L
                 MTST_L:
00306e 6d84
00306f 7374
003070 0074              .db     NFA|4,"mtst",0
                 MTST:
003071 940e 3ea3         call    CFETCH
003073 940c 32f9         jmp     AND_
                 
003075 e0dc              fdw     MTST_L
                 FCY_L:
003076 4683
003077 7963              .db     NFA|3,"Fcy"
003078 d06a              rcall   DOCREATE
003079 3e80              .dw     FREQ_OSC / 1000
                 
                 ;*******************************************************
                 ; Assembler
                 ;*******************************************************
                 ; FIXME
                 ;*******************************************************
                         
                 
                 ;;; Check parameter stack pointer
00307a 7383
00307b 3f70              .db     NFA|3,"sp?"
                 check_sp:
00307c d089              rcall   SPFETCH
00307d 940e 38f0         call    R0_
00307f d679              rcall   FETCH_A
003080 940e 38eb         call    S0
003082 d676              rcall   FETCH_A
003083 d29d              rcall   ONEPLUS
003084 d2c9              rcall   WITHIN
003085 d1df              rcall   XSQUOTE
003086 5303
003087 3f50              .db     3,"SP?"
003088 d71d              rcall   QABORT
003089 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
00308a e0ec              fdw     FCY_L
                 EMIT_L:
00308b 6584
00308c 696d
00308d 0074              .db     NFA|4,"emit",0
                 EMIT:
00308e d330              rcall   UEMIT_
00308f 940c 30ae         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003091 e116              fdw     EMIT_L
                 KEY_L:
003092 6b83
003093 7965              .db     NFA|3,"key"
                 KEY:
003094 d330              rcall   UKEY_
003095 940c 30ae         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003097 e124              fdw     KEY_L
                 KEYQ_L:
003098 6b84
003099 7965
00309a 003f              .db     NFA|4,"key?",0
                 KEYQ:
00309b d32f              rcall   UKEYQ_
00309c 940c 30ae         jmp     FEXECUTE
                 
00309e e130              fdw     KEYQ_L
                 EXECUTE_L:
00309f 6587
0030a0 6578
0030a1 7563
0030a2 6574              .db     NFA|7,"execute"
                 EXECUTE:
0030a3 01fc              movw    zl, tosl
0030a4 58f0              sub_pflash_z
0030a5 9189
0030a6 9199              poptos
0030a7 9488              rampv_to_c
0030a8 95f7              ror     zh
0030a9 95e7              ror     zl
0030aa 9409              mijmp
                 
0030ab e13e              fdw     EXECUTE_L
                 FEXECUTE_L:
0030ac 4083
0030ad 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
0030ae d64a              rcall   FETCH_A
0030af 940c 30a3         jmp     EXECUTE
                 
0030b1 e158              fdw     FEXECUTE_L
                 VARIABLE_L:
0030b2 7688
0030b3 7261
0030b4 6169
0030b5 6c62
0030b6 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
0030b7 d09b              rcall   HERE
0030b8 d0b0              rcall   CELL
0030b9 d1dc              rcall   ALLOT
0030ba 940c 30ce         jmp     CONSTANT_
                 
0030bc e164              fdw     VARIABLE_L
                 TWOVARIABLE_L:
0030bd 3289
0030be 6176
0030bf 6972
0030c0 6261
0030c1 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
0030c2 d090              rcall   HERE
0030c3 d6f5              rcall   DOLIT
0030c4 0004              .dw     0x4
0030c5 d1d0              rcall   ALLOT
0030c6 940c 30ce         jmp     CONSTANT_
                 
0030c8 e17a              fdw     TWOVARIABLE_L
                 CONSTANT_L:
0030c9 6388
0030ca 6e6f
0030cb 7473
0030cc 6e61
0030cd 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
0030ce d7b3              rcall   COLON
0030cf 940e 3e05         call    LITERAL
0030d1 940c 3890         jmp     SEMICOLON
                 
0030d3 e192              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030d4 3289
0030d5 6f63
0030d6 736e
0030d7 6174
0030d8 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030d9 d1ca              rcall   SWOP
0030da d7a7              rcall   COLON
0030db 940e 3e05         call    LITERAL
0030dd 940e 3e05         call    LITERAL
0030df 940c 3890         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030e1 2883
0030e2 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030e3 91ff              pop     zh
0030e4 91ef              pop     zl
0030e5 d00c              rcall   FETCHLIT
                         m_pop_zh
0030e6 91ff              pop     zh
0030e7 91ef              pop     zl
0030e8 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030e9 2883
0030ea 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030eb 91bf              pop     xh
0030ec 91af              pop     xl
                         m_pop_zh
0030ed 91ff              pop     zh
0030ee 91ef              pop     zl
0030ef d002              rcall   FETCHLIT
0030f0 01fd              movw    z, x
0030f1 9409              mijmp    ; (z)
                 FETCHLIT:
0030f2 939a
0030f3 938a              pushtos
0030f4 0fee              lsl     zl
0030f5 1fff              rol     zh
0030f6 9185              lpm_    tosl, z+
0030f7 9195              lpm_    tosh, z+
0030f8 9508              ret
                 
0030f9 2883
0030fa 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
0030fb 91ff              pop     zh
0030fc 91ef              pop     zl
0030fd dff4              rcall   FETCHLIT
0030fe 95f7              ror     zh
0030ff 95e7              ror     zl
003100 93ef              push    zl
003101 93ff              push    zh
                         m_push_t0
003102 c099              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
003103 e1a8              fdw     TWOCONSTANT_L
                 SPFETCH_L:
003104 7383
003105 4070              .db     NFA|3,"sp@"
                 SPFETCH:
003106 01fe              movw    z, y
003107 939a
003108 938a              pushtos
003109 01cf              movw    tosl, z
00310a 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
00310b 7383
00310c 2170              .db     NFA|3,"sp!"
                 SPSTORE:
00310d 01ec              movw    y, tosl
00310e 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
00310f 7283
003110 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
003111 91bf              pop     xh
003112 91af              pop     xl
003113 d7dc              rcall   R0_
003114 d5e4              rcall   FETCH_A
003115 bf8d              out     spl, tosl
003116 bf9e              out     sph, tosh
003117 9189
003118 9199              poptos
003119 01fd              movw    zl, xl
00311a 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
00311b e208              fdw     SPFETCH_L
                 RPFETCH_L:
00311c 72b3
00311d 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
00311e 939a
00311f 938a              pushtos
003120 b78d              in      tosl, spl
003121 b79e              in      tosh, sph
003122 9508              ret
                 
                 ;   ><  Swap bytes        
003123 e238              fdw     RPFETCH_L
                 SWAPB_L:
003124 3ea2
003125 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
003126 2f08              mov     t0, tosl
003127 2f89              mov     tosl, tosh
003128 2f90              mov     tosh, t0
003129 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
00312a e248              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
00312b 6685
00312c 616c
00312d 6873              .db     NFA|5,"flash"
                 ROM_:
00312e 9250 01eb         sts     cse, zero
003130 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
003131 e256              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003132 6586
003133 7065
003134 6f72
003135 006d              .db     NFA|6,"eeprom",0
                 EROM:
003136 9270 01eb         sts     cse, r_two
003138 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
003139 e264              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
00313a 7283
00313b 6d61              .db     NFA|3,"ram"
                 FRAM:
00313c e004              ldi     t0, 4
00313d 9300 01eb         sts     cse, t0
00313f 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
003140 e274              fdw     RAM_L
                 DP_L:
003141 6482
003142 0070              .db     NFA|2,"dp",0
                 DP:
003143 d711              rcall   IDP
003144 d004              rcall   CSE_
003145 940c 32e3         jmp     PLUS
                 
                 
                 ;;; 
003147 6383
003148 6573              .db     NFA|3,"cse"
                 CSE_:
003149 939a
00314a 938a              pushtos
00314b 9180 01eb         lds     tosl, cse
00314d 2799              clr     tosh
00314e 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
00314f e282              fdw     DP_L
                 HERE_L:
003150 6884
003151 7265
003152 0065              .db     NFA|4,"here",0
                 HERE:
003153 dfef              rcall   DP
003154 940c 3e79         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003156 e2a0              fdw     HERE_L
                 COMMA_L:
003157 2c81              .db     NFA|1,","
                 COMMA:
003158 dffa              rcall   HERE
003159 d413              rcall   STORE_A
00315a d00e              rcall   CELL
00315b 940c 3296         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
00315d e2ae              fdw     COMMA_L 
                 CCOMMA_L:
00315e 6382
00315f 002c              .db     NFA|2,"c,",0
                 CCOMMA:
003160 dff2              rcall   HERE
003161 d2d4              rcall   CSTORE_A
003162 d0ae              rcall   ONE
003163 940c 3296         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003165 e2bc              fdw     CCOMMA_L
                 CELL_L:
003166 6384
003167 6c65
003168 006c              .db     NFA|4,"cell",0
                 CELL:
003169 939a
00316a 938a              pushtos
00316b e082              ldi     tosl, 2
00316c e090              ldi     tosh, 0
00316d 9508              ret
                 
                 ; ALIGN    --                         align DP
00316e e2cc              fdw     CELL_L
                 ALIGN_L:
00316f 6185
003170 696c
003171 6e67              .db     NFA|5,"align"
                 ALIGN:
003172 dfe0              rcall   HERE
003173 d008              rcall   ALIGNED
003174 dfce              rcall   DP
003175 940c 3e31         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
003177 e2de              fdw     ALIGN_L
                 ALIGNED_L:
003178 6187
003179 696c
00317a 6e67
00317b 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00317c 9601              adiw    tosl, 1
00317d d63b              rcall   DOLIT
00317e fffe              .dw     0xfffe
00317f 940c 32f9         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
003181 e2f0              fdw     ALIGNED_L
                 CELLPLUS_L:
003182 63a5
003183 6c65
003184 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003185 9602              adiw    tosl, 2
003186 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
003187 e304              fdw     CELLPLUS_L
                 CELLS_L:
003188 63a5
003189 6c65
00318a 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
00318b 0f88              lsl     tosl
00318c 1f99              rol     tosh
00318d 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
00318e e310              fdw     CELLS_L
                 CHARPLUS_L:
00318f 63a5
003190 6168
003191 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
003192 9601              adiw    tosl, 1
003193 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
003194 e31e              fdw     CHARPLUS_L
                 CHARS_L:
003195 63a5
003196 6168
003197 7372              .db     NFA|INLINE|5,"chars"
003198 9508      CHARS:  ret
                 
003199 e32a              fdw     CHARS_L
                 COMMAXT_L:
00319a 6383
00319b 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
00319c d625              rcall   DUP
00319d d650              rcall   IHERE
00319e d151              rcall   MINUS
00319f d13e              rcall   ABS_ 
0031a0 d618              rcall   DOLIT
0031a1 0ff0              .dw     0xff0
0031a2 d1c7              rcall   GREATER
0031a3 d22b              rcall   ZEROSENSE
0031a4 f059              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
0031a5 d613              rcall   DOLIT
                 .ifdef EIND
                 .else
0031a6 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
0031a7 940e 3f4a         call    ICOMMA
0031a9 5890              sub_pflash_tos
0031aa 9488              rampv_to_c
0031ab 9597              ror     tosh
0031ac 9587              ror     tosl
0031ad 940e 3f4a         call    ICOMMA
0031af c008              rjmp    STORECF2
                 STORECF1:
0031b0 d63d              rcall   IHERE
0031b1 d13e              rcall   MINUS
0031b2 d71a              rcall   TWOMINUS
0031b3 d188              rcall   TWOSLASH
                         ;rcall   RCALL_
0031b4 709f              andi    tosh, 0x0f
0031b5 6d90              ori     tosh, 0xd0
0031b6 940e 3f4a         call    ICOMMA
                 STORECF2:
0031b8 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
0031b9 2186
0031ba 6f63
0031bb 6f6c
0031bc 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
0031bd d5fb              rcall   DOLIT
0031be fffa              .dw     0xfffa         ;  -6
0031bf 940c 3995         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
0031c1 e334              fdw     COMMAXT_L
                 TWOFETCH_L:
0031c2 3282
0031c3 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
0031c4 d5fd              rcall   DUP
0031c5 d533              rcall   FETCH_A
0031c6 d0dd              rcall   SWOP
0031c7 dfbd              rcall   CELLPLUS
0031c8 940c 36f9         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
0031ca e384              fdw     TWOFETCH_L
                 TWOSTORE_L:
0031cb 3282
0031cc 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
0031cd d0d6              rcall   SWOP
0031ce d0df              rcall   OVER
0031cf dfb5              rcall   CELLPLUS
0031d0 d39c              rcall   STORE_A
0031d1 940c 3e31         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031d3 e396              fdw     TWOSTORE_L
                 TWODROP_L:
0031d4 3285
0031d5 7264
0031d6 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031d7 d0c5              rcall   DROP
0031d8 940c 329d         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031da e3a8              fdw     TWODROP_L
                 TWODUP_L:
0031db 3284
0031dc 7564
0031dd 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031de d0cf              rcall   OVER
0031df 940c 32ae         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031e1 e3b6              fdw     TWODUP_L
                 TWOSWAP_L:
0031e2 3285
0031e3 7773
0031e4 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031e5 d0d0              rcall   ROT
0031e6 d0d7              rcall   TOR
0031e7 d0ce              rcall   ROT
0031e8 d0df              rcall   RFROM
0031e9 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031ea e3c4              fdw     TWOSWAP_L
                 SPACE_L:
0031eb 7385
0031ec 6170
0031ed 6563              .db     NFA|5,"space"
                 SPACE_:  
0031ee d6e3              rcall   BL
0031ef 940c 308e         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
0031f1 e3d6              fdw     SPACE_L
                 SPACES_L:
0031f2 7386
0031f3 6170
0031f4 6563
0031f5 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
0031f6 d1de              rcall   DUPZEROSENSE
0031f7 f019              breq    SPCS2
0031f8 dff5              rcall   SPACE_
0031f9 d12c              rcall   ONEMINUS
0031fa cffb              rjmp    SPCS1
0031fb 940c 329d SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
0031fd e3e4              fdw     SPACES_L
                 UMIN_L:
0031fe 7584
0031ff 696d
003200 006e              .db     NFA|4,"umin",0
                 UMIN:
003201 dfdc              rcall   TWODUP
003202 d174              rcall   UGREATER
003203 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
003204 e3fc              fdw     UMIN_L
                 UMAX_L:
003205 7584
003206 616d
003207 0078              .db     NFA|4,"umax",0
                 UMAX:
003208 dfd5              rcall   TWODUP
003209 d166              rcall   ULESS
                 MINMAX:
00320a d1c4              rcall   ZEROSENSE
00320b f009              breq    UMAX1
00320c d097              rcall   SWOP
00320d 940c 329d UMAX1:  jmp     DROP
                 
00320f e40a              fdw     UMAX_L
                 ONE_L:
003210 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
003211 939a
003212 938a              pushtos
003213 e081              ldi     tosl, 1
003214 e090              ldi     tosh, 0
003215 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
003216 e420              fdw     ONE_L
                 ACCEPT_L:
003217 6186
003218 6363
003219 7065
00321a 0074              .db     NFA|6,"accept",0
                 ACCEPT:
00321b d092              rcall   OVER
00321c d0c6              rcall   PLUS
00321d d090              rcall   OVER
                 ACC1:
00321e de75              rcall   KEY
                 
00321f 308d              cpi     tosl, CR_
003220 f429              brne    ACC_LF
                         
003221 d542              rcall   TRUE_
003222 d02f              rcall   FCR
003223 d212              rcall   CSTORE_A
003224 d078              rcall   DROP
003225 c026              rjmp    ACC6
                 ACC_LF:
003226 308a              cpi     tosl, LF_
003227 f449              brne    ACC2
003228 d074              rcall   DROP
                 
003229 d028              rcall   FCR
00322a d207              rcall   CFETCH_A
00322b d1a3              rcall   ZEROSENSE
00322c f0f9              breq    ACC6
00322d d52d              rcall   FALSE_
00322e d023              rcall   FCR
00322f d206              rcall   CSTORE_A
003230 cfed              rjmp    ACC1
                 ACC2:
003231 d529              rcall   FALSE_
003232 d01f              rcall   FCR
003233 d202              rcall   CSTORE_A
003234 d58d              rcall   DUP
003235 de58              rcall   EMIT
003236 d58b              rcall   DUP
003237 d581              rcall   DOLIT
003238 0008              .dw     BS_
003239 d126              rcall   EQUAL
00323a d194              rcall   ZEROSENSE
00323b f039              breq    ACC3
00323c d060              rcall   DROP
00323d d0e8              rcall   ONEMINUS
00323e d07f              rcall   TOR
00323f d06e              rcall   OVER
003240 d087              rcall   RFROM
003241 dfc6              rcall   UMAX
003242 cfdb              rjmp    ACC1
                 ACC3:
003243 d06a              rcall   OVER
003244 d1f1              rcall   CSTORE_A
003245 d0db              rcall   ONEPLUS
003246 d067              rcall   OVER
003247 dfb9              rcall   UMIN
003248 df95              rcall   TWODUP
003249 d10e              rcall   NOTEQUAL
00324a d184              rcall   ZEROSENSE
00324b f691              brne     ACC1
                 ACC6:
00324c d1c3              rcall   NIP
00324d d056              rcall   SWOP
00324e 940c 32f0         jmp     MINUS
                 
003250 6683
003251 7263              .db     NFA|3,"fcr"
                 FCR:
003252 d2a4              rcall   DOUSER
003253 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
003254 e42e              fdw      ACCEPT_L
                 TYPE_L:
003255 7484
003256 7079
003257 0065              .db     NFA|4,"type",0
                 TYPE:
003258 d065              rcall   TOR
003259 c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
00325a d304              rcall   CFETCHPP
00325b de32              rcall   EMIT
                 TYPE2:
00325c 940e 3a66         call    XNEXT
00325e f7d8              brcc    TYPE1
00325f 911f              pop     t1
003260 910f              pop     t0
003261 940c 329d         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
003263 2883
003264 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
003265 d06c              rcall   RFETCH
003266 0f88              lsl     tosl
003267 1f99              rol     tosh
003268 5890              add_pflash_tos
003269 d2f5              rcall   CFETCHPP
00326a d557              rcall   DUP
00326b d0b5              rcall   ONEPLUS
00326c df0f              rcall   ALIGNED
00326d 9596              lsr     tosh
00326e 9587              ror     tosl
00326f d058              rcall   RFROM
003270 d072              rcall   PLUS
003271 01fc              movw    zl, tosl
003272 9189
003273 9199              poptos
003274 9409              mijmp
                 
003275 e4aa              fdw     TYPE_L
                 SQUOTE_L:
003276 73d2
003277 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
003278 de82              rcall   DOCOMMAXT
003279 e4ca              fdw     XSQUOTE
00327a deb3              rcall   ROM_
00327b d005              rcall   CQUOTE
00327c 940c 313c         jmp     FRAM
                 
00327e e4ec              fdw     SQUOTE_L
                 CQUOTE_L:
00327f 2c82
003280 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
003281 d537              rcall   DOLIT
003282 0022              .dw     0x22
003283 d299              rcall   PARSE
003284 dece              rcall   HERE
003285 d028              rcall   OVER
003286 d09a              rcall   ONEPLUS
003287 def4              rcall   ALIGNED
003288 d00d              rcall   ALLOT
003289 940c 3556         jmp     PLACE
                 
                 
00328b e4fe              fdw     CQUOTE_L
                 DOTQUOTE_L:
00328c 2ed2
00328d 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
00328e dfe9              rcall   SQUOTE
00328f de6b              rcall   DOCOMMAXT
003290 e4b0              fdw     TYPE
003291 9508              ret
                 
003292 e518              fdw     DOTQUOTE_L
                 ALLOT_L:
003293 6185
003294 6c6c
003295 746f              .db     NFA|5,"allot"
                 ALLOT:
003296 deac              rcall   DP
003297 940c 3342         jmp     PLUSSTORE
                 
003299 e526              fdw     ALLOT_L
                 DROP_L:
00329a 64a4
00329b 6f72
00329c 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
00329d 9189
00329e 9199              poptos
00329f 9508              ret
                 
0032a0 e534              fdw     DROP_L
                 SWOP_L:
0032a1 7384
0032a2 6177
0032a3 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
0032a4 9109              ld      t0, y+
0032a5 9119              ld      t1, y+
0032a6 939a
0032a7 938a              pushtos
0032a8 01c8              movw    tosl, t0
0032a9 9508              ret
                 
0032aa e542              fdw     SWOP_L
                 OVER_L:
0032ab 6f84
0032ac 6576
0032ad 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
0032ae 939a
0032af 938a              pushtos
0032b0 818a              ldd     tosl, y+2
0032b1 819b              ldd     tosh, y+3
0032b2 9508              ret
                 
0032b3 e556              fdw     OVER_L
                 ROT_L:
0032b4 7283
0032b5 746f              .db     NFA|3, "rot"
                 ROT:
0032b6 d007              rcall   TOR
0032b7 dfec              rcall   SWOP
0032b8 d00f              rcall   RFROM
0032b9 940c 32a4         jmp     SWOP
                 
0032bb e568              fdw     ROT_L
                 TOR_L:
0032bc 3e92
0032bd 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
0032be 91ff              pop     zh
0032bf 91ef              pop     zl
0032c0 938f              push    tosl
0032c1 939f              push    tosh
0032c2 9189
0032c3 9199              poptos
0032c4 9409              mijmp
                 
0032c5 e578              fdw     TOR_L
                 RFROM_L:
0032c6 7292
0032c7 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
0032c8 91ff              pop     zh
0032c9 91ef              pop     zl
0032ca 939a
0032cb 938a              pushtos
0032cc 919f              pop     tosh
0032cd 918f              pop     tosl
0032ce 9409              mijmp
                 
0032cf e58c              fdw     RFROM_L
                 RFETCH_L:
0032d0 7292
0032d1 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
0032d2 91ff              pop     zh
0032d3 91ef              pop     zl
0032d4 939a
0032d5 938a              pushtos
0032d6 919f              pop     tosh
0032d7 918f              pop     tosl
0032d8 938f              push    tosl
0032d9 939f              push    tosh
0032da 9409              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
0032db ef80              fdw     DUP_L
                 ABS_L:
0032dc 6183
0032dd 7362              .db     NFA|3,"abs"
                 ABS_:
0032de d4e3              rcall   DUP
0032df 940c 341f         jmp     QNEGATE
                 
0032e1 e5b8              fdw     ABS_L
                 PLUS_L:
0032e2 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032e3 9109              ld      t0, Y+        
0032e4 9119              ld      t1, Y+
0032e5 0f80              add     tosl, t0
0032e6 1f91              adc     tosh, t1
0032e7 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032e8 e5c4              fdw     PLUS_L
                 MPLUS_L:
0032e9 6d82
0032ea 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032eb d79e              rcall   STOD
0032ec 940c 3aac         jmp     DPLUS
                 
0032ee e5d2              fdw     MPLUS_L
                 MINUS_L:
0032ef 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
0032f0 9109              ld      t0, Y+
0032f1 9119              ld      t1, Y+
0032f2 1b08              sub     t0, tosl
0032f3 0b19              sbc     t1, tosh
0032f4 01c8              movw    tosl, t0
0032f5 9508              ret
                 
0032f6 e5de              fdw     MINUS_L
                 AND_L:
0032f7 6183
0032f8 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
0032f9 9109              ld      t0, Y+
0032fa 9119              ld      t1, Y+
0032fb 2380              and     tosl, t0
0032fc 2391              and     tosh, t1
0032fd 9508              ret
                 
0032fe e5ee              fdw     AND_L
                 OR_L:
0032ff 6f82
003300 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
003301 9109              ld      t0, Y+
003302 9119              ld      t1, Y+
003303 2b80              or      tosl, t0
003304 2b91              or      tosh, t1
003305 9508              ret
                 
003306 e5fe              fdw     OR_L
                 XOR_L:
003307 7883
003308 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
003309 9109              ld      t0, Y+
00330a 9119              ld      t1, Y+
00330b 2780              eor     tosl, t0
00330c 2791              eor     tosh, t1
00330d 9508              ret
                 
00330e e60e              fdw     XOR_L
                 INVERT_L:
00330f 69a6
003310 766e
003311 7265
003312 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
003313 9580              com     tosl
003314 9590              com     tosh
003315 9508              ret
                 
003316 e61e              fdw     INVERT_L
                 NEGATE_L:
003317 6e86
003318 6765
003319 7461
00331a 0065              .db     NFA|6, "negate",0
                 NEGATE:
00331b dff7              rcall   INVERT
00331c 940c 3321         jmp     ONEPLUS
                 
00331e e62e              fdw     NEGATE_L
                 ONEPLUS_L:
00331f 31a2
003320 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
003321 9601              adiw    tosl, 1
003322 9508              ret
                 
003323 e63e              fdw     ONEPLUS_L
                 ONEMINUS_L:
003324 31a2
003325 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
003326 9701              sbiw    tosl, 1
003327 9508              ret
                 
003328 e648              fdw     ONEMINUS_L
                 TWOPLUS_L:
003329 32a2
00332a 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
00332b 9602              adiw    tosl, 2
00332c 9508              ret
                 
00332d e652              fdw     TWOPLUS_L
                 TOBODY_L:
00332e 3ea5
00332f 6f62
003330 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
003331 9604              adiw    tosl, 4
003332 9508              ret
                 
003333 e65c              fdw     TOBODY_L
                 TWOSTAR_L:
003334 32a2
003335 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003336 0f88              lsl     tosl
003337 1f99              rol     tosh
003338 9508              ret
                 
003339 e668              fdw     TWOSTAR_L
                 TWOSLASH_L:
00333a 32a2
00333b 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
00333c 9595              asr     tosh
00333d 9587              ror     tosl
00333e 9508              ret
                 
00333f e674              fdw     TWOSLASH_L
                 PLUSSTORE_L:
003340 2b82
003341 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
003342 df61              rcall   SWOP
003343 df6a              rcall   OVER
003344 d3b4              rcall   FETCH_A
003345 df9d              rcall   PLUS
003346 df5d              rcall   SWOP
003347 940c 3e31         jmp     STORE
                 
003349 e680              fdw     PLUSSTORE_L
                 WITHIN_L:
00334a 7786
00334b 7469
00334c 6968
00334d 006e              .db     NFA|6,"within",0
                 WITHIN:
00334e df5f              rcall   OVER
00334f dfa0              rcall   MINUS
003350 df6d              rcall   TOR
003351 df9e              rcall   MINUS
003352 df75              rcall   RFROM
003353 940c 3370         jmp     ULESS
                 
003355 e694              fdw     WITHIN_L
                 NOTEQUAL_L:
003356 3c82
003357 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
003358 df97              rcall   MINUS           ; MINUS leaves a valid zero flag
003359 ef9f              ser     tosh
00335a ef8f              ser     tosl
00335b f409              brne    NOTEQUAL1
00335c 9601              adiw    tosl,1
                 NOTEQUAL1:
00335d 9508              ret
                 
00335e ef9a              fdw     ZEROLESS_L
                 EQUAL_L:
00335f 3d81              .db     NFA|1, "="
                 EQUAL:
003360 df8f              rcall   MINUS
003361 940c 37c8         jmp     ZEROEQUAL
                 
                 
003363 e6be              fdw     EQUAL_L
                 LESS_L:
003364 3c81              .db     NFA|1,"<"
                 LESS:
003365 df8a              rcall   MINUS
003366 940c 37cf         jmp     ZEROLESS
                 
003368 e6c8              fdw     LESS_L
                 GREATER_L:
003369 3e81              .db     NFA|1,">"
                 GREATER:
00336a df39              rcall   SWOP
00336b 940c 3365         jmp     LESS
                 
00336d e6d2              fdw     GREATER_L
                 ULESS_L:
00336e 7582
00336f 003c              .db     NFA|2,"u<",0
                 ULESS:
003370 df7f              rcall   MINUS       ; Carry is valid after MINUS
003371 0b88              sbc     tosl, tosl
003372 0b99              sbc     tosh, tosh
003373 9508              ret
                 
003374 e6dc              fdw     ULESS_L
                 UGREATER_L:
003375 7582
003376 003e              .db     NFA|2, "u>",0
                 UGREATER:
003377 df2c              rcall   SWOP
003378 940c 3370         jmp     ULESS
                 
00337a e6ea              fdw     UGREATER_L
                 STORE_P_L:
00337b 2182
00337c 0070              .db     NFA|2,"!p",0
                 STORE_P:
00337d 01ac              movw    pl, tosl
00337e 9189
00337f 9199              poptos
003380 9508              ret
                 
003381 e6f6              fdw     STORE_P_L
                 STORE_P_TO_R_L:
003382 2194
003383 3e70
003384 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
003385 91ff              pop     zh
003386 91ef              pop     zl
003387 934f              push    pl
003388 935f              push    ph
003389 01ac              movw    pl, tosl
00338a 9189
00338b 9199              poptos
00338c 9409              mijmp
                 
00338d e704              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
00338e 7293
00338f 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
003390 91ff              pop     zh
003391 91ef              pop     zl
003392 915f              pop     ph
003393 914f              pop     pl
003394 9409              mijmp
                 
003395 e71c              fdw     R_TO_P_L
                 PFETCH_L:
003396 7082
003397 0040              .db     NFA|2,"p@",0
                 PFETCH:
003398 939a
003399 938a              pushtos
00339a 01ca              movw    tosl, pl
00339b 940c 3e79         jmp     FETCH
                 
00339d e72c              fdw     PFETCH_L
                 PSTORE_L:
00339e 7082
00339f 0021              .db     NFA|2,"p!",0
                 PSTORE:
0033a0 939a
0033a1 938a              pushtos
0033a2 01ca              movw    tosl, pl
0033a3 940c 3e31         jmp     STORE
                 
0033a5 e73c              fdw     PSTORE_L
                 PCSTORE_L:
0033a6 7083
0033a7 2163              .db     NFA|3,"pc!"
                 PCSTORE:
0033a8 939a
0033a9 938a              pushtos
0033aa 01ca              movw    tosl, pl
0033ab 940c 3ec6         jmp     CSTORE
                 
0033ad e74c              fdw     PCSTORE_L
                 PPLUS_L:
0033ae 70a2
0033af 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
0033b0 0d46              add     pl, r_one
0033b1 1d55              adc     ph, zero
0033b2 9508              ret   
                 
0033b3 e75c              fdw     PPLUS_L
                 PNPLUS_L:
0033b4 7083
0033b5 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
0033b6 0f48              add     pl, tosl
0033b7 1f59              adc     ph, tosh
0033b8 9189
0033b9 9199              poptos
0033ba 9508              ret
                 
0033bb e768              fdw     PNPLUS_L
                 UEMIT_L:
0033bc 2785
0033bd 6d65
0033be 7469              .db     NFA|5,"'emit"
                 UEMIT_:
0033bf d137              rcall   DOUSER
0033c0 ffe8              .dw     uemit
                         
0033c1 e778              fdw     UEMIT_L
                 UKEY_L:
0033c2 2784
0033c3 656b
0033c4 0079              .db     NFA|4,"'key",0
                 UKEY_:
0033c5 d131              rcall   DOUSER
0033c6 ffea              .dw     ukey
                 
0033c7 e784              fdw     UKEY_L
                 UKEYQ_L:
0033c8 2785
0033c9 656b
0033ca 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
0033cb d12b              rcall   DOUSER
0033cc ffec              .dw     ukeyq
                 
0033cd 3f83
0033ce 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
0033cf 9700              sbiw    tosl, 0
0033d0 9189
0033d1 9199              poptos
0033d2 9508              ret
                 
0033d3 6483
0033d4 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
0033d5 9700              sbiw    tosl, 0
0033d6 9508              ret
                 
0033d7 e790              fdw     UKEYQ_L
                 UMSTAR_L:
0033d8 7583
0033d9 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
0033da 940c 3f70         jmp     umstar0
                 
0033dc e7b0              fdw     UMSTAR_L
                 UMSLASHMOD_L:
0033dd 7586
0033de 2f6d
0033df 6f6d
0033e0 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
0033e1 940c 2f91         jmp     umslashmod0
                 
                 
0033e3 e7ba              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
0033e4 7585
0033e5 6d2f
0033e6 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
0033e7 d373              rcall   FALSE_
0033e8 debb              rcall   SWOP
0033e9 940c 2f91         jmp     umslashmod0
                 
0033eb e7c8              fdw     USLASHMOD_L
                 STAR_L:
0033ec 2a81              .db     NFA|1,"*"
                 STAR: 
0033ed dfec              rcall   UMSTAR
0033ee 940c 329d         jmp     DROP
                 
0033f0 e7d8              fdw     STAR_L
                 USLASH_L:
0033f1 7582
0033f2 002f              .db     NFA|2,"u/",0
                 USLASH:
0033f3 dff3              rcall   USLASHMOD
0033f4 940c 3410         jmp     NIP
                 
0033f6 e7e2              fdw     USLASH_L
                 USSMOD_L:
0033f7 7586
0033f8 2f2a
0033f9 6f6d
0033fa 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
0033fb dec2              rcall   TOR
0033fc dfdd              rcall   UMSTAR
0033fd deca              rcall   RFROM
0033fe 940c 33e1         jmp     UMSLASHMOD
                 
                 
003400 e7ee              fdw     USSMOD_L
                 SLASH_L:
003401 2f81              .db     NFA|1,"/"
                 SLASH: 
003402 dddb              rcall   TWODUP
003403 df05              rcall   XOR_
003404 deb9              rcall   TOR
003405 ded8              rcall   ABS_
003406 de9d              rcall   SWOP
003407 ded6              rcall   ABS_
003408 de9b              rcall   SWOP
003409 dfe9              rcall   USLASH
00340a debd              rcall   RFROM
00340b 940c 341f         jmp     QNEGATE
                 
00340d e802              fdw     SLASH_L
                 NIP_L:
00340e 6ea3
00340f 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
003410 9109              ld      t0, y+
003411 9109              ld      t0, y+
003412 9508              ret
                     
003413 e81c              fdw     NIP_L
                 TUCK_L:
003414 7484
003415 6375
003416 006b              .db     NFA|4,"tuck",0
                 TUCK:
003417 de8c              rcall   SWOP
003418 940c 32ae         jmp     OVER
                 
00341a e828              fdw     TUCK_L
                 QNEGATE_L:
00341b 3f87
00341c 656e
00341d 6167
00341e 6574              .db     NFA|7,"?negate"
                 QNEGATE:
00341f d3af              rcall   ZEROLESS
003420 dfae              rcall   ZEROSENSE
003421 f009              breq    QNEGATE1
003422 def8              rcall   NEGATE
                 QNEGATE1:
003423 9508              ret
                 
003424 e836              fdw     QNEGATE_L
                 MAX_L:
003425 6d83
003426 7861              .db     NFA|3,"max"
003427 ddb6      MAX:    rcall   TWODUP
003428 df3c              rcall   LESS
003429 cde0              rjmp    MINMAX
                 
00342a e84a              fdw     MAX_L
                 MIN_L:
00342b 6d83
00342c 6e69              .db     NFA|3,"min"
00342d ddb0      MIN:    rcall   TWODUP
00342e df3b              rcall   GREATER
00342f cdda              rjmp    MINMAX
                 
003430 6382
003431 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
003432 940c 3ea3         jmp     CFETCH
                 
003434 6382
003435 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003436 940c 3ec6         jmp     CSTORE
                 
003438 e856              fdw     MIN_L
                 UPTR_L:
003439 7582
00343a 0070              .db     NFA|2,"up",0
00343b dca7      UPTR:   rcall   DOCREATE
00343c 0002              .dw     2 ; upl
                 
00343d e872              fdw     UPTR_L
                 HOLD_L:
00343e 6884
00343f 6c6f
003440 0064              .db     NFA|4,"hold",0
003441 d322      HOLD:   rcall   TRUE_
003442 d09a              rcall   HP
003443 defe              rcall   PLUSSTORE
003444 d098              rcall   HP
003445 d2b3              rcall   FETCH_A
003446 940c 3ec6         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
003448 e87c              fdw     HOLD_L
                 LESSNUM_L:
003449 3c82
00344a 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
00344b d096              rcall   PAD
00344c d090              rcall   HP
00344d 940c 3e31         jmp     STORE
                 
                 ; >digit   n -- c            convert to 0..9a..z
00344f e892              fdw     LESSNUM_L
                 TODIGIT_L:
003450 3e86
003451 6964
003452 6967
003453 0074              .db     NFA|6,">digit",0
                 TODIGIT: 
003454 d36d              rcall   DUP
003455 d363              rcall   DOLIT
003456 0009              .dw     9
003457 df12              rcall   GREATER
003458 d360              rcall   DOLIT
003459 0027              .dw     0x27
00345a de9e              rcall   AND_
00345b de87              rcall   PLUS
00345c d35c              rcall   DOLIT
00345d 0030              .dw     0x30
00345e 940c 32e3         jmp     PLUS
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
003460 e8a0              fdw     TODIGIT_L
                 NUM_L:
003461 2381              .db     NFA|1,"#"
                 NUM:
003462 d087              rcall   BASE
003463 d295              rcall   FETCH_A
003464 d193              rcall   UDSLASHMOD
003465 de50              rcall   ROT
003466 dfed              rcall   TODIGIT
003467 940c 3441         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
003469 e8c2              fdw     NUM_L
                 NUMS_L:
00346a 2382
00346b 0073              .db     NFA|2,"#s",0
                 NUMS:
00346c dff5              rcall   NUM
00346d dd70              rcall   TWODUP
00346e de92              rcall   OR_
00346f df5f              rcall   ZEROSENSE
003470 f7d9              brne    NUMS
003471 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
003472 e8d4              fdw     NUMS_L
                 NUMGREATER_L:
003473 2382
003474 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
003475 dd61              rcall   TWODROP
003476 d066              rcall   HP
003477 d281              rcall   FETCH_A
003478 d069              rcall   PAD
003479 de34              rcall   OVER
00347a 940c 32f0         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
00347c e8e6              fdw     NUMGREATER_L
                 SIGN_L:
00347d 7384
00347e 6769
00347f 006e              .db     NFA|4,"sign",0
                 SIGN:   
003480 d34e              rcall   ZEROLESS
003481 df4d              rcall   ZEROSENSE
003482 f019              breq    SIGN1
003483 d335              rcall   DOLIT
003484 002d              .dw     0x2D
003485 dfbb              rcall   HOLD
                 SIGN1:
003486 9508              ret
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
003487 e8fa              fdw     SIGN_L
                 UDOT_L:
003488 7582
003489 002e              .db     NFA|2,"u.",0
                 UDOT:
00348a dfc0              rcall   LESSNUM
00348b d2cf              rcall   FALSE_
00348c dfdf              rcall   NUMS
00348d dfe7              rcall   NUMGREATER
00348e ddc9              rcall   TYPE
00348f 940c 31ee         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
003491 e910              fdw     UDOT_L
                 UDOTR_L:
003492 7583
003493 722e              .db     NFA|3,"u.r"
                 UDOTR:
003494 dfb6              rcall   LESSNUM
003495 de90              rcall   ONEMINUS
003496 de27              rcall   TOR
003497 d2c3              rcall   FALSE_
003498 c001              rjmp    UDOTR2
                 UDOTR1:
003499 dfc8              rcall   NUM
                 UDOTR2: 
00349a d5cb              rcall   XNEXT
00349b f7e8              brcc    UDOTR1
00349c 911f              pop     t1
00349d 910f              pop     t0
00349e dfcd              rcall   NUMS
00349f dfd5              rcall   NUMGREATER
0034a0 ddb7              rcall   TYPE
0034a1 940c 31ee         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
0034a3 e924              fdw     UDOTR_L
                 DOT_L:
0034a4 2e81              .db     NFA|1,"."
0034a5 dfa5      DOT:    rcall   LESSNUM
0034a6 d31b              rcall   DUP
0034a7 de36              rcall   ABS_
0034a8 d2b2              rcall   FALSE_
0034a9 dfc2              rcall   NUMS
0034aa de0b              rcall   ROT
0034ab dfd4              rcall   SIGN
0034ac dfc8              rcall   NUMGREATER
0034ad ddaa              rcall   TYPE
0034ae 940c 31ee         jmp     SPACE_
                 
0034b0 e948              FDW     DOT_L
                 DECIMAL_L:
0034b1 6487
0034b2 6365
0034b3 6d69
0034b4 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
0034b5 d27d              rcall   TEN
0034b6 d033              rcall   BASE
0034b7 940c 3e31         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
0034b9 e962              Fdw     DECIMAL_l
                 HEX_L:
0034ba 6883
0034bb 7865              .db     NFA|3,"hex"
                 HEX:
0034bc d2fc              rcall   DOLIT
0034bd 0010              .dw     16
0034be d02b              rcall   BASE
0034bf 940c 3e31         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
0034c1 e974              Fdw     HEX_L
                 BIN_L:
0034c2 6283
0034c3 6e69              .db     NFA|3,"bin"
0034c4 dca4      BIN:    rcall   CELL
0034c5 d024              rcall   BASE
0034c6 940c 3e31         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
0034c8 e984              fdw     BIN_L
                 RSAVE_L:
0034c9 7285
0034ca 6173
0034cb 6576              .db     NFA|5,"rsave"
0034cc d02a      RSAVE_: rcall   DOUSER
0034cd fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
0034ce e992              fdw     RSAVE_L
                 ULINK_L:
0034cf 7585
0034d0 696c
0034d1 6b6e              .db     NFA|5,"ulink"
0034d2 d024      ULINK_: rcall   DOUSER
0034d3 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034d4 e99e              fdw     ULINK_L
                 TASK_L:
0034d5 7484
0034d6 7361
0034d7 006b              .db     NFA|4,"task",0
0034d8 d01e      TASK:   rcall   DOUSER
0034d9 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034da e9aa              fdw     TASK_L
                 HP_L:
0034db 6882
0034dc 0070              .db     NFA|2,"hp",0
0034dd d019      HP:     rcall   DOUSER
0034de 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
0034df e9b6              fdw     HP_L
                 PAD_L:
0034e0 7083
0034e1 6461              .db     NFA|3,"pad"
                 PAD:
0034e2 d19a              rcall   TIB
0034e3 d191              rcall   TIBSIZE
0034e4 940c 32e3         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
0034e6 e9c0              fdw     PAD_L
                 BASE_L:
0034e7 6284
0034e8 7361
0034e9 0065              .db     NFA|4,"base",0
                 BASE:
0034ea d00c              rcall   DOUSER
0034eb ffee              .dw     ubase
                 
                 ; USER   n --
0034ec e9ce              fdw     BASE_L
                 USER_L:
0034ed 7584
0034ee 6573
0034ef 0072              .db     NFA|4,"user",0
                 USER:
0034f0 d31a              rcall   CREATE
0034f1 dc77              rcall   CELL
0034f2 de28              rcall   NEGATE
0034f3 d4a1              rcall   IALLOT
0034f4 940e 3f4a         call    ICOMMA
0034f6 d364              rcall   XDOES
                 DOUSER:
                         m_pop_zh
0034f7 91ff              pop     zh
0034f8 91ef              pop     zl
0034f9 dbf8              rcall   FETCHLIT
0034fa 0d82              add     tosl, upl
0034fb 1d93              adc     tosh, uph
0034fc 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
0034fd e9da              fdw     USER_L
                 SOURCE_L:
0034fe 7386
0034ff 756f
003500 6372
003501 0065              .db     NFA|6,"source",0
                 SOURCE:
003502 d18c              rcall   TICKSOURCE
003503 940c 31c4         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
003505 e9fc              fdw      SOURCE_L
                 SLASHSTRING_L:
003506 2f87
003507 7473
003508 6972
003509 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
00350a dd99              rcall   SWOP
00350b dda2              rcall   OVER
00350c dde3              rcall   MINUS
00350d ddb0              rcall   TOR
00350e ddd4              rcall   PLUS
00350f ddb8              rcall   RFROM
003510 9508              ret
                 
                 ; \     Skip the rest of the line
003511 ea0c              fdw     SLASHSTRING_L
                 BSLASH_L:
003512 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
003513 dfee              rcall   SOURCE
003514 d173              rcall   TOIN
003515 d057              rcall   STORE_A
003516 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
003517 940c 329d         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
003519 ea24              fdw     BSLASH_L
                 PARSE_L:
00351a 7085
00351b 7261
00351c 6573              .db     NFA|5,"parse"
                 PARSE:
00351d d2a4              rcall   DUP             ; c c
00351e dfe3              rcall   SOURCE          ; c c a u
00351f d168              rcall   TOIN            ; c c a u a
003520 d1d8              rcall   FETCH_A         ; c c a u n
003521 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
003522 d29f              rcall   DUP             ; c c a u u
003523 dd9a              rcall   TOR             ; c c a u                  R: u (new tib len
003524 dd91              rcall   ROT             ; c a u c
003525 db12              rcall   SKIP            ; c a u        
003526 dd87              rcall   OVER            ; c a u a
003527 dd96              rcall   TOR             ; c a u                    R: u a (start of word
003528 dd8d              rcall   ROT             ; a u c
003529 db29              rcall   SCAN            ; a u      end of word, tib left       
00352a deaa              rcall   DUPZEROSENSE
00352b f009              breq    PARSE1
00352c ddf9              rcall   ONEMINUS
00352d dd9a      PARSE1: rcall   RFROM           ; a u a
00352e dd99              rcall   RFROM           ; a u a u
00352f dd86              rcall   ROT             ; a a u u
003530 ddbf              rcall   MINUS           ; a a n  ( addition to toin
003531 d156              rcall   TOIN
003532 de0f              rcall   PLUSSTORE       ; aend astart
003533 dee3              rcall   TUCK            ; astart aend astart
003534 940c 32f0         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
003536 ea34              fdw     PARSE_L
                 WORD_L:
003537 7784
003538 726f
003539 0064              .db     NFA|4,"word",0
                 WORD:
00353a dfe2              rcall   PARSE           ; c-addr wlen
00353b dd68              rcall   SWOP
00353c dde9              rcall   ONEMINUS
00353d ded9              rcall   TUCK
00353e 940c 3ec6         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
003540 ea6e              fdw     WORD_L
                 CMOVE_L:
003541 6385
003542 6f6d
003543 6576              .db     NFA|5,"cmove"
                 CMOVE:
003544 dd5f              rcall   SWOP
003545 de3f              rcall   STORE_P_TO_R
003546 dd77              rcall   TOR
003547 c003              rjmp    CMOVE2
                 CMOVE1:
003548 d016              rcall   CFETCHPP
003549 de5e              rcall   PCSTORE
00354a de65              rcall   PPLUS
                 CMOVE2:
00354b d51a              rcall   XNEXT
00354c f7d8              brcc    CMOVE1
00354d 911f              pop     t1
00354e 910f              pop     t0
00354f de40              rcall   R_TO_P
003550 940c 329d         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
003552 ea82              fdw     CMOVE_L
                 PLACE_L:
003553 7085
003554 616c
003555 6563              .db     NFA|5,"place"
                 PLACE: 
003556 dc87              rcall   TWODUP
003557 dede              rcall   CSTORE_A
003558 dc39              rcall   CHARPLUS
003559 dd4a              rcall   SWOP
00355a 940c 3544         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
00355c eaa6              fdw     PLACE_L
                 CFETCHPP_L:
00355d 6383
00355e 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
00355f d262              rcall   DUP
003560 ddc0              rcall   ONEPLUS
003561 dd42              rcall   SWOP
003562 940c 3ea3         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
003564 eaba              fdw     CFETCHPP_L
                 FETCHPP_L:
003565 4082
003566 002b              .db     NFA|2,"@+",0
                 FETCHPP:
003567 d25a              rcall   DUP
003568 ddc2              rcall   TWOPLUS
003569 dd3a              rcall   SWOP
00356a 940c 3e79         jmp     FETCH
                 
00356c 2181              .db     NFA|1,"!"
                 STORE_A:        
00356d 940c 3e31         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
00356f eaca              fdw    FETCHPP_L
                 NTOC_L:
003570 6e83
003571 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
003572 dfec              rcall   CFETCHPP
003573 d245              rcall   DOLIT
003574 000f              .dw     0x0f
003575 dd83              rcall   AND_
003576 dd6c              rcall   PLUS
003577 940c 317c         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
003579 eae0              fdw    NTOC_L
                 CTON_L:
00357a 6383
00357b 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
00357c d350              rcall   TWOMINUS
00357d d244              rcall   DUP
00357e deb3              rcall   CFETCH_A
00357f d239              rcall   DOLIT
003580 007f              .dw     0x007F
003581 dde8              rcall   GREATER
003582 de4c              rcall   ZEROSENSE
003583 f3c1              breq    CFATONFA
003584 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
003585 eaf4              fdw     CTON_L
                 BRACFIND_L:
003586 2883
003587 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
003588 dc55              rcall   TWODUP
                 ;        rcall   OVER
                 ;        rcall   CFETCH_A
003589 da8b              rcall   NEQUAL
00358a de4a              rcall   DUPZEROSENSE
00358b f021              breq    findi2
00358c dd10              rcall   DROP
00358d d33f              rcall   TWOMINUS ;;;      NFATOLFA
00358e d16a              rcall   FETCH_A
00358f d232              rcall   DUP
                 findi2:
003590 de3e              rcall   ZEROSENSE
003591 f7b1              brne    findi1
003592 de42              rcall   DUPZEROSENSE
003593 f041              breq    findi3
003594 de7b              rcall   NIP
003595 d22c              rcall   DUP
003596 dfdb              rcall   NFATOCFA
003597 dd0c              rcall   SWOP
003598 d009              rcall   IMMEDQ
003599 d22e              rcall   ZEROEQUAL
00359a dc76              rcall   ONE
00359b dd65              rcall   OR_
                 findi3: 
00359c 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
00359d eb0c              fdw     BRACFIND_L
                 IMMEDQ_L:
00359e 6986
00359f 6d6d
0035a0 6465
0035a1 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
0035a2 de8f              rcall   CFETCH_A
0035a3 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
0035a4 d214              rcall   DOLIT
0035a5 0040              .dw     IMMED
0035a6 940c 32f9         jmp     AND_
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
0035a8 eb3c              fdw     IMMEDQ_L
                 FIND_L:
0035a9 6684
0035aa 6e69
0035ab 0064              .db     NFA|4,"find",0
                 FIND:   
0035ac d20c              rcall   DOLIT
0035ad f690              fdw     kernellink
0035ae dfd9              rcall   findi
0035af de25              rcall   DUPZEROSENSE
0035b0 f421              brne    FIND1
0035b1 dceb              rcall   DROP
0035b2 d332              rcall   LATEST_
0035b3 d145              rcall   FETCH_A
0035b4 dfd3              rcall   findi
                 FIND1:
0035b5 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
0035b6 eb52              fdw     FIND_L
                 DIGITQ_L:
0035b7 6486
0035b8 6769
0035b9 7469
0035ba 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
0035bb d206              rcall   DUP             ; c c       c c
0035bc d1fc              rcall   DOLIT
0035bd 0039              .dw     0x39            ; c c 39    c c 39
0035be ddab              rcall   GREATER         ; c 0       c ffff
0035bf de0f              rcall   ZEROSENSE
0035c0 f019              breq    DIGITQ1
0035c1 d1f7              rcall   DOLIT
0035c2 0027              .dw     0x27
0035c3 dd2c              rcall   MINUS
                 DIGITQ1:        
0035c4 d1f4              rcall   DOLIT
0035c5 0030              .dw     0x30            ; c 30
0035c6 dd29              rcall   MINUS           ; 1
0035c7 d1fa              rcall   DUP             ; 1 1
0035c8 df21              rcall   BASE            ; 1 1 base
0035c9 d12f              rcall   FETCH_A         ; 1 1 10
0035ca dd9a              rcall   LESS            ; 1 ffff
0035cb dce2              rcall   OVER            ; 1 ffff 1
0035cc d202              rcall   ZEROLESS        ; 1 ffff 0
0035cd dd45              rcall   INVERT
0035ce 940c 32f9         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035d0 eb6e              fdw     DIGITQ_L
                 SIGNQ_L:
0035d1 7385
0035d2 6769
0035d3 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035d4 dcd9              rcall   OVER
0035d5 de5c              rcall   CFETCH_A
0035d6 d1e2              rcall   DOLIT
0035d7 002c              .dw     ','
0035d8 dd17              rcall   MINUS
0035d9 d1e8              rcall   DUP
0035da dd03              rcall   ABS_
0035db dc35              rcall   ONE
0035dc dd83              rcall   EQUAL
0035dd dd1b              rcall   AND_
0035de ddf6              rcall   DUPZEROSENSE
0035df f029              breq    QSIGN1
0035e0 dd40              rcall   ONEPLUS
0035e1 dcdc              rcall   TOR
0035e2 dc2e              rcall   ONE
0035e3 df26              rcall   SLASHSTRING
0035e4 dce3              rcall   RFROM
0035e5 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
0035e6 eba2              fdw     SIGNQ_L
                 UDSTAR_L:
0035e7 7583
0035e8 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035e9 d1d8              rcall   DUP
0035ea dcd3              rcall   TOR
0035eb ddee              rcall   UMSTAR
0035ec dcb0              rcall   DROP
0035ed dcb6              rcall   SWOP
0035ee dcd9              rcall   RFROM
0035ef ddea              rcall   UMSTAR
0035f0 dcc5              rcall   ROT
0035f1 940c 32e3         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
0035f3 ebce              fdw     UDSTAR_L
                 UDSLASHMOD_L:
0035f4 7586
0035f5 2f64
0035f6 6f6d
0035f7 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
0035f8 dcc5              rcall   TOR             ; ud.l ud.h 
0035f9 d161              rcall   FALSE_          ; ud.l ud.h 0
0035fa dcd7              rcall   RFETCH          ; ud.l ud.h 0 u
0035fb dde5              rcall   UMSLASHMOD      ; ud.l r.h q.h
0035fc dcb9              rcall   ROT             ; r.h q.h ud.l
0035fd dcb8              rcall   ROT             ; q.h ud.l r.h
0035fe dcc9              rcall   RFROM           ; q.h ud.l r.h u
0035ff dde1              rcall   UMSLASHMOD      ; q.h r.l q.l
003600 940c 32b6         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
003602 ebe8              fdw     UDSLASHMOD_L
                 TONUMBER_L:
003603 3e87
003604 756e
003605 626d
003606 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
003607 ddcd              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
003608 f0b1              breq    TONUM3
003609 dcb4              rcall   TOR
00360a d1b7              rcall   DUP
00360b dcb2              rcall   TOR             ; ud.l ud.h adr
00360c de25              rcall   CFETCH_A
00360d dfad              rcall   DIGITQ          ; ud.l ud.h digit flag
00360e ddc0              rcall   ZEROSENSE
00360f f421              brne    TONUM2
003610 dc8c              rcall   DROP
003611 dcb6              rcall   RFROM
003612 dcb5              rcall   RFROM
003613 c00b              rjmp    TONUM3
                 TONUM2: 
003614 dca9              rcall   TOR             ; ud.l ud.h digit
003615 ded4              rcall   BASE
003616 d0e2              rcall   FETCH_A
003617 dfd1              rcall   UDSTAR
003618 dcaf              rcall   RFROM
003619 dcd1              rcall   MPLUS
00361a dcad              rcall   RFROM
00361b dcac              rcall   RFROM
                         
00361c dbf4              rcall   ONE
00361d deec              rcall   SLASHSTRING
00361e cfe8              rjmp    TONUM1
                 TONUM3: 
00361f 9508              ret
                 
                 BASEQV:   
003620 e96a              fdw     DECIMAL
003621 e978              fdw     HEX
003622 e988              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
003623 ec06              fdw     TONUMBER_L
                 NUMBERQ_L:
003624 6e87
003625 6d75
003626 6562
003627 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
003628 d199              rcall   DUP             ; a a
003629 d131              rcall   FALSE_          ; a a 0 0
00362a d130              rcall   FALSE_          ; a a 0 0
00362b dc8a              rcall   ROT             ; a 0 0 a
00362c df32              rcall   CFETCHPP        ; a 0 0 a' u
00362d dfa6              rcall   SIGNQ           ; a 0 0 a' u f
00362e dc8f              rcall   TOR             ; a 0 0 a' u
                 
00362f deba              rcall   BASE
003630 d0c8              rcall   FETCH_A
003631 dc8c              rcall   TOR             ; a 0 0 a' u
                         
003632 dc7b              rcall   OVER
003633 ddfe              rcall   CFETCH_A
                         
003634 d184              rcall   DOLIT
003635 0023              .dw     '#'
003636 dcb9              rcall   MINUS
003637 d18a              rcall   DUP
003638 d180              rcall   DOLIT
003639 0003              .dw     3
00363a dd35              rcall   ULESS
00363b dd93              rcall   ZEROSENSE
00363c f041              breq    BASEQ1
00363d db4d              rcall   CELLS
                         
00363e d17a              rcall   DOLIT
00363f ec40              fdw     BASEQV
003640 dca2              rcall   PLUS
003641 da6c              rcall   FEXECUTE
                 
003642 dbce              rcall   ONE
003643 dec6              rcall   SLASHSTRING
003644 c001              rjmp    BASEQ2
                 BASEQ1:
003645 dc57              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
003646 dfc0              rcall   TONUMBER        ; a ud.l ud.h  a' u
003647 dc80              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
003648 dea1              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
003649 df23              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
00364a d177              rcall   DUP
00364b d281              rcall   TWOMINUS
00364c d182              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
00364d dd81              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
00364e f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
00364f dc78              rcall   RFROM           ; a ud.l ud.h a' u sign
003650 dc4c              rcall   DROP
003651 db85              rcall   TWODROP
                 QNUM_ERR1:      
003652 db84              rcall   TWODROP
003653 d107              rcall   FALSE_          ; a 0           Not a number
003654 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
003655 db8f              rcall   TWOSWAP         ; a a' u ud.l ud.h 
003656 dc71              rcall   RFROM           ; a a' u ud.l ud.d sign
003657 dd77              rcall   ZEROSENSE
003658 f009              breq    QNUMD1
003659 d438              rcall   DNEGATE
                 QNUMD1: 
00365a db8a              rcall   TWOSWAP         ; a d.l d.h a' u
00365b dd73              rcall   ZEROSENSE       ; a d.l d.h a'
00365c f061              breq    QNUM1
00365d 940e 3ea3         call    CFETCH
00365f d159              rcall   DOLIT
003660 002e              .dw     '.'
003661 dc8e              rcall   MINUS
003662 dd6c              rcall   ZEROSENSE       ; a d.l d.h
003663 f771              brne    QNUM_ERR1
003664 dc51              rcall   ROT             ; d.l d.h a
003665 dc37              rcall   DROP            ; d.l d.h
003666 d152              rcall   DOLIT         ; 
003667 0002              .dw     2               ; d.l ud.h 2    Double number
003668 c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
003669 db6d              rcall   TWODROP         ; a n
00366a dda5              rcall   NIP             ; n
00366b dba5              rcall   ONE             ; n 1           Single number
                 QNUM3:  
00366c 9508              ret
                 
                 
00366d 7384
00366e 6177
00366f 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003670 940c 32a4         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003672 ec48              fdw     NUMBERQ_L
                 TIBSIZE_L:
003673 7483
003674 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
003675 de62              rcall   TASK
003676 d082              rcall   FETCH_A
003677 9608              adiw    tosl, 8
003678 940c 3e79         jmp     FETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00367a ece6              fdw     TIBSIZE_L
                 TIB_L:
00367b 7483
00367c 6269              .db     NFA|3,"tib"
                 TIB:
00367d d005              rcall   TIU
00367e 940c 3e79         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003680 ecf6              fdw     TIB_L
                 TIU_L:
003681 7483
003682 7569              .db     NFA|3,"tiu"
                 TIU:
003683 de73              rcall   DOUSER
003684 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
003685 ed02              fdw     TIU_L
                 TOIN_L:
003686 3e83
003687 6e69              .db     NFA|3,">in"
                 TOIN:
003688 de6e              rcall   DOUSER
003689 fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00368a ed0c              fdw     TOIN_L
                 TICKSOURCE_L:
00368b 2787
00368c 6f73
00368d 7275
00368e 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
00368f de67              rcall   DOUSER
003690 fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
003691 ed16              fdw     TICKSOURCE_L
                 INTERPRET_L:
003692 6989
003693 746e
003694 7265
003695 7270
003696 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
003697 dff7              rcall   TICKSOURCE
003698 db34              rcall   TWOSTORE
003699 d0c1              rcall   FALSE_
00369a dfed              rcall   TOIN
00369b ded1              rcall   STORE_A
                 IPARSEWORD:
00369c d235              rcall   BL
00369d de9c              rcall   WORD
                 
00369e d123              rcall   DUP
00369f dd92              rcall   CFETCH_A
0036a0 dd2e              rcall   ZEROSENSE
0036a1 f409              brne    IPARSEWORD1
0036a2 c053              rjmp    INOWORD
                 IPARSEWORD1:
0036a3 df08              rcall   FIND            ; sets also wflags
0036a4 dd30              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
0036a5 f1a1              breq    INUMBER         ; NUMBER?
0036a6 dc7a              rcall   ONEPLUS         ; 0 = normal 2 = immediate
0036a7 d231              rcall   STATE_
0036a8 d11f              rcall   ZEROEQUAL
0036a9 dc57              rcall   OR_
0036aa dd24              rcall   ZEROSENSE
0036ab f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
0036ac fe94              sbrs    wflags, 4       ; Compile only check
0036ad c00a              rjmp    IEXECUTE        ; Not a compile only word
0036ae d22a              rcall   STATE_          ; Compile only word check
0036af dbb5              rcall   XSQUOTE
0036b0 430c
0036b1 4d4f
0036b2 4950
0036b3 454c
0036b4 4f20
0036b5 4c4e
0036b6 0059              .db     12,"COMPILE ONLY",0
0036b7 d0ee              rcall   QABORT
                 IEXECUTE:
0036b8 7b6f              cbr     FLAGS1, (1<<noclear)
0036b9 d9e9              rcall   EXECUTE
0036ba fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
0036bb cfe0              rjmp    IPARSEWORD
0036bc 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036bd 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036be cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
0036bf 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036c0 d101              rcall   DUP
0036c1 d0f7              rcall   DOLIT
0036c2 ef90              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
0036c3 dc9c              rcall   EQUAL
0036c4 dd0a              rcall   ZEROSENSE
0036c5 f011              breq    ICOMPILE_2
0036c6 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
0036c7 c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
0036c8 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036c9 d0f8              rcall   DUP
0036ca d0ee              rcall   DOLIT
0036cb ef84              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
0036cc dc93              rcall   EQUAL
0036cd dd01              rcall   ZEROSENSE
0036ce f009              breq    ICOMPILE
0036cf 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036d0 fe95              sbrs    wflags, 5       ; Inline check
0036d1 c003              rjmp    ICOMMAXT
0036d2 940e 3a3d         call    INLINE0
0036d4 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
0036d5 d124              rcall   COMMAXT_A
0036d6 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
0036d7 fc94              sbrc    wflags, 4            ; Compile only ?
0036d8 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0036d9 cfc2              rjmp    IPARSEWORD
                 INUMBER: 
0036da 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036db 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036dc dbc0              rcall   DROP
0036dd df4a              rcall   NUMBERQ
0036de dcf6              rcall   DUPZEROSENSE
0036df f081              breq    IUNKNOWN
0036e0 d1f8              rcall   STATE_
0036e1 dced              rcall   ZEROSENSE
0036e2 f059              breq    INUMBER1
0036e3 2f08              mov     t0, tosl
0036e4 9189
0036e5 9199              poptos
0036e6 ff01              sbrs    t0, 1
0036e7 c003              rjmp    ISINGLE
                 IDOUBLE:
0036e8 df87              rcall   SWOP_A
0036e9 940e 3e05         call    LITERAL
                 ISINGLE:        
0036eb 940e 3e05         call    LITERAL
0036ed cfae              rjmp    IPARSEWORD
                 
                 INUMBER1:
0036ee dbae              rcall   DROP
0036ef cfac              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
0036f0 dbac              rcall   DROP 
0036f1 d045              rcall   DP_TO_RAM
0036f2 de6c              rcall   CFETCHPP
0036f3 db64              rcall   TYPE
0036f4 d066              rcall   FALSE_
0036f5 d0a7              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
0036f6 940c 329d         jmp     DROP
                 
0036f8 4081              .db     NFA|1,"@"
                 FETCH_A:        
0036f9 940c 3e79         jmp     FETCH
                 
                 ;;;    bitmask -- 
0036fb ed24              fdw     INTERPRET_L
                 SHB_L:
0036fc 7383
0036fd 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
0036fe d1e6              rcall   LATEST_
0036ff dff9              rcall   FETCH_A
003700 d0c1              rcall   DUP
003701 dd30              rcall   CFETCH_A
003702 dbb3              rcall   ROT
003703 dbfd              rcall   OR_
003704 df6b              rcall   SWOP_A
003705 940c 3ec6         jmp     CSTORE
                         
003707 edf8              fdw     SHB_L
                 IMMEDIATE_L:
003708 6989
003709 6d6d
00370a 6465
00370b 6169
00370c 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
00370d d0ab              rcall   DOLIT
00370e 0040              .dw     IMMED
00370f 940c 36fe         jmp     SHB
                 
                 ;***************************************************************
003711 ee10              fdw     IMMEDIATE_L
                 INLINED_L:
003712 6987
003713 6c6e
003714 6e69
003715 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
003716 d0a2              rcall   DOLIT
003717 0020              .dw     INLINE
003718 940c 36fe         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
00371a ee24              fdw     INLINED_L
                 DOTSTATUS_L:
00371b 2e83
00371c 7473              .db     NFA|3,".st"
                 DOTSTATUS:
00371d d09b              rcall   DOLIT
00371e 003c              .dw     '<'
00371f d96e              rcall   EMIT
003720 940e 3f5c         call    DOTBASE
003722 d96b              rcall   EMIT
003723 d095              rcall   DOLIT
003724 002c              .dw     ','
003725 d968              rcall   EMIT
003726 940e 2f81         call    MEMQ
003728 db2f              rcall   TYPE
003729 d08f              rcall   DOLIT
00372a 003e              .dw     '>'
00372b d962              rcall   EMIT
00372c 940c 3954         jmp     DOTS
                 
00372e 3e82
00372f 0072              .db     NFA|2,">r",0
003730 940c 32be TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
003732 6181              .db     NFA|1,"a"
                 TEN:
003733 d9af              rcall   DOCREATE
003734 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
003735 6483
003736 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
003737 d081              rcall   DOLIT
003738 0900              .dw     dp_start
003739 d1ba              rcall   INI
00373a dff8              rcall   TEN
00373b 940c 3544         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
00373d 3e83
00373e 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
00373f d079              rcall   DOLIT
003740 0900              .dw     dp_start
003741 dc43              rcall   STORE_P_TO_R
003742 d1b1              rcall   INI
003743 d075              rcall   DOLIT
003744 0004              .dw     4
003745 db78              rcall   TOR
                 DP_TO_EEPROM_0: 
003746 de20              rcall   FETCHPP
003747 d07a              rcall   DUP
003748 dc4f              rcall   PFETCH
003749 dc0e              rcall   NOTEQUAL
00374a dc84              rcall   ZEROSENSE
00374b f011              breq    DP_TO_EEPROM_1
00374c dc53              rcall   PSTORE
00374d c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
00374e db4e              rcall   DROP
                 DP_TO_EEPROM_2:
00374f d3fa              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
003750 d315              rcall   XNEXT
003751 f7a0              brcc    DP_TO_EEPROM_0
003752 911f              pop     t1
003753 910f              pop     t0
003754 dc3b              rcall   R_TO_P
003755 940c 329d         jmp     DROP
                 
003757 ee36              fdw     DOTSTATUS_L
                 FALSE_L:
003758 6685
003759 6c61
00375a 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
00375b 939a
00375c 938a              pushtos
00375d 2788              clr     tosl
00375e 2799              clr     tosh
00375f 9508              ret
                 
003760 eeb0              fdw     FALSE_L
                 TRUE_L:
003761 7484
003762 7572
003763 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
003764 939a
003765 938a              pushtos
003766 ef8f              ser     tosl
003767 ef9f              ser     tosh
003768 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
003769 eec2              fdw     TRUE_L
                 QUIT_L:
00376a 7184
00376b 6975
00376c 0074              .db     NFA|4,"quit",0
                 QUIT:
00376d d9a3              rcall   RPEMPTY
00376e d107              rcall   LEFTBRACKET
00376f d9cc              rcall   FRAM
                 QUIT0:  
003770 d5d0              rcall   IFLUSH
                         ;; Copy INI and DP's from eeprom to ram
003771 dfc5              rcall   DP_TO_RAM
                 QUIT1: 
003772 d909              rcall   check_sp
003773 d08b              rcall   CR
003774 df08              rcall   TIB
003775 d04c              rcall   DUP
003776 defe              rcall   TIBSIZE
003777 dfbb              rcall   TEN                 ; Reserve 10 bytes for hold buffer
003778 db77              rcall   MINUS
003779 daa1              rcall   ACCEPT
00377a da73              rcall   SPACE_
00377b df1b              rcall   INTERPRET
00377c d15c              rcall   STATE_
00377d dc51              rcall   ZEROSENSE
00377e f799              brne    QUIT1
00377f dfbf              rcall   DP_TO_EEPROM
                          
003780 dae4              rcall    XSQUOTE
003781 2003
003782 6b6f              .db     3," ok"
003783 dad4              rcall    TYPE
003784 d007              rcall   PROMPT_
003785 cfea              rjmp    QUIT0
003786 9508              ret
                 
003787 eed4              fdw     QUIT_L
                 PROMPT_L:
003788 7086
003789 6f72
00378a 706d
00378b 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
00378c 940e 3f00         call    DEFER_DOES
00378e 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
00378f ef10              fdw     PROMPT_L
                 ABORT_L:
003790 6185
003791 6f62
003792 7472              .db     NFA|5,"abort"
                 ABORT:
003793 d157              rcall   S0
003794 df64              rcall   FETCH_A
003795 d977              rcall   SPSTORE
003796 940c 376d         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
003798 ef20              fdw     ABORT_L
                 QABORTQ_L:
003799 3f87
00379a 6261
00379b 726f
00379c 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
00379d dac7              rcall   XSQUOTE
00379e 3f01              .db     1,"?"
00379f 940c 37a6         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
0037a1 ef32              fdw     QABORTQ_L
                 QABORT_L:
0037a2 3f86
0037a3 6261
0037a4 726f
0037a5 0074              .db     NFA|6,"?abort",0
                 QABORT:
0037a6 db0f              rcall   ROT
0037a7 dc27              rcall   ZEROSENSE
0037a8 f419              brne    QABO1
                 QABORT1:        
0037a9 da44              rcall   SPACE_
0037aa daad              rcall   TYPE
0037ab dfe7              rcall   ABORT  ; ABORT never returns
0037ac 940c 31d7 QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
0037ae ef44              fdw     QABORT_L
                 ABORTQUOTE_L:
0037af 61d6
0037b0 6f62
0037b1 7472
0037b2 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
0037b3 dac4              rcall   SQUOTE
0037b4 d946              rcall   DOCOMMAXT
0037b5 ef4c              fdw     QABORT
0037b6 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
0037b7 6c83
0037b8 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
0037b9 91ff              pop     zh
0037ba 91ef              pop     zl
0037bb d936              rcall   FETCHLIT
0037bc 95f7              ror     zh
0037bd 95e7              ror     zl
0037be 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
0037bf e5a0              fdw     RFETCH_L
                 DUP_L:
0037c0 64a3
0037c1 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
0037c2 939a
0037c3 938a              pushtos
0037c4 9508              ret
                 
0037c5 e6ac              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
0037c6 3082
0037c7 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:
0037c8 9701              sbiw    tosl, 1
0037c9 0b88              sbc     tosl, tosl
0037ca 0b99              sbc     tosh, tosh
0037cb 9508              ret
                 
0037cc ef8c              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
0037cd 3082
0037ce 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
0037cf 0f99              lsl     tosh
0037d0 0b88              sbc     tosl, tosl
0037d1 0b99              sbc     tosh, tosh
0037d2 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037d3 ef5e              fdw     ABORTQUOTE_L
                 TICK_L:
0037d4 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037d5 d0fc              rcall   BL
0037d6 dd63              rcall   WORD
0037d7 ddd4              rcall   FIND
0037d8 940c 379d         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
0037da efa8              fdw     TICK_L
                 CHAR_L:
0037db 6384
0037dc 6168
0037dd 0072              .db     NFA|4,"char",0
                 CHAR:
0037de d0f3              rcall   BL
0037df dd3d              rcall   PARSE
0037e0 dabc              rcall   DROP
0037e1 940c 3ea3         jmp     CFETCH
                 
                 ; (    --                     skip input until )
0037e3 efb6              fdw     CHAR_L
                 PAREN_L:
0037e4 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
0037e5 dfd3              rcall   DOLIT
0037e6 0029              .dw     ')'
0037e7 dd35              rcall   PARSE
0037e8 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
0037e9 940c 31d7         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
0037eb 6985
0037ec 6568
0037ed 6572              .db     NFA|5,"ihere"
                 IHERE:
0037ee d066              rcall   IDP
0037ef cf09              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
0037f0 efc8              fdw     PAREN_L
                 BRACCHAR_L:
0037f1 5bd6
0037f2 6863
0037f3 7261
0037f4 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
0037f5 dfe8              rcall   CHAR
0037f6 940c 3e05         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
0037f8 6383
0037f9 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
0037fa 940c 319c         jmp     COMMAXT
                 
                 ; CR      --                      output newline
0037fc efe2              fdw     BRACCHAR_L
                 CR_L:
0037fd 6382
0037fe 0072              .db     NFA|2,"cr",0
                 CR:
0037ff dfb9              rcall   DOLIT
003800 000d              .dw     0x0d       ; CR \r
003801 d88c              rcall   EMIT
003802 dfb6              rcall   DOLIT
003803 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
003804 940c 308e         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
003806 effa              fdw     CR_L
                 CREATE_L:
003807 6386
003808 6572
003809 7461
00380a 0065              .db     NFA|6,"create",0
                 CREATE:
00380b d0c6              rcall   BL
00380c dd2d              rcall   WORD            ; Parse a word
                 
00380d dfb4              rcall   DUP             ; Remember parsed word at rhere
00380e dd9d              rcall   FIND
00380f dc00              rcall   NIP
003810 dfb7              rcall   ZEROEQUAL
003811 da53              rcall   XSQUOTE
003812 410f
003813 524c
003814 4145
003815 5944
003816 4420
003817 4645
003818 4e49
003819 4445              .db     15,"ALREADY DEFINED"
00381a df8b              rcall   QABORT         ; ABORT if word has already been defined
00381b dfa6              rcall   DUP             ; Check the word length 
00381c dc15              rcall   CFETCH_A
00381d d9f3              rcall   ONE
00381e df9a              rcall   DOLIT
00381f 0010              .dw     16
003820 db2d              rcall   WITHIN
003821 df7b              rcall   QABORTQ          ; Abort if there is no name for create
                 
003822 d0c2              rcall   LATEST_
003823 ded5              rcall   FETCH_A
003824 940e 3f4a         call    ICOMMA          ; Link field
003826 dd38              rcall   CFETCHPP        ; str len
003827 dfc6              rcall   IHERE
003828 df99              rcall   DUP             
003829 d0bb              rcall   LATEST_         ; new 'latest' link
00382a dd42              rcall   STORE_A         ; str len ihere
00382b dd2a              rcall   PLACE           ; 
00382c dfc1              rcall   IHERE           ; ihere
00382d dc04              rcall   CFETCH_A
00382e df8a              rcall   DOLIT
00382f 0080              .dw     NFA
003830 decd              rcall   SHB
003831 daef              rcall   ONEPLUS
003832 d949              rcall   ALIGNED
003833 d161              rcall   IALLOT          ; The header has now been created
003834 df84              rcall   DOLIT             
003835 e1c6              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
003836 d96e              rcall   STORECFF1       ; Append an exeution token, CALL !
003837 d93a              rcall   ALIGN
003838 d91a              rcall   HERE            ; compiles the current dataspace dp into the dictionary
003839 d90f              rcall   CSE_
00383a db94              rcall   ZEROSENSE
00383b f409              brne    CREATE2
00383c daee              rcall   TWOPLUS
                 CREATE2:
00383d 940c 3f4a         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
00383f f00e              fdw    CREATE_L
                 POSTPONE_L:
003840 70d8
003841 736f
003842 7074
003843 6e6f
003844 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
003845 d08c              rcall   BL
003846 dcf3              rcall   WORD
003847 dd64              rcall   FIND
003848 df79              rcall   DUP
003849 df53              rcall   QABORTQ
00384a df84              rcall   ZEROLESS
00384b db83              rcall   ZEROSENSE
00384c f021              breq    POSTPONE1
00384d d8ad              rcall   DOCOMMAXT
00384e e1f6              fdw     DOCOMMAXT
00384f 940c 3f4a         jmp     ICOMMA
                 POSTPONE1:
003851 940c 319c         jmp     COMMAXT
                 
                 
                 IDP_L:
003853 6983
003854 7064              .db     NFA|3,"idp"
                 IDP:
003855 d88d              rcall   DOCREATE
003856 01d9              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
003857 2887
003858 6f64
003859 7365
00385a 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
00385b da6c              rcall   RFROM
00385c d088              rcall   LATEST_
00385d de9b              rcall   FETCH_A
00385e dd13              rcall   NFATOCFA
00385f dff5              rcall   IDP
003860 de98              rcall   FETCH_A
003861 dece              rcall   TOR_A
003862 dff2              rcall   IDP
003863 dd09              rcall   STORE_A
003864 0f88              lsl     tosl
003865 1f99              rol     tosh
003866 d93e              rcall   STORECFF1 ; Always stores a 4 byte call
003867 da60              rcall   RFROM
003868 dfec              rcall   IDP
003869 940c 3e31         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
00386b f080              fdw     POSTPONE_L
                 DOES_L:
00386c 64d5
00386d 656f
00386e 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
00386f d88b      DOES:   rcall   DOCOMMAXT
003870 f0b6              fdw     XDOES
003871 d889              rcall   DOCOMMAXT
003872 e1d6              fdw     DODOES
003873 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
003874 f0d8              fdw     DOES_L
                 LEFTBRACKET_L:
003875 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
003876 7000              cbr     t0, 0xff
003877 9300 01ec         sts     state, t0
003879 9508              ret
                 
                 
                 ; ]        --      enter compiling state
00387a f0ea              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
00387b 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
00387c 6f0f              sbr     t0, 0xff
00387d 9300 01ec         sts     state, t0
00387f 9508              ret
                 
                 ; :        --           begin a colon definition
003880 f0f6              fdw     RIGHTBRACKET_L
                 COLON_L:
003881 3a81              .db     NFA|1,":"
                 COLON:
003882 df88              rcall   CREATE
003883 dff8              rcall   RIGHTBRACKET
003884 940c 31bd         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
003886 f102              fdw     COLON_L
                 NONAME_L:
003887 3a87
003888 6f6e
003889 616e
00388a 656d              .db     NFA|7,":noname"
                 NONAME:
00388b df62              rcall   IHERE
00388c 940c 387c         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
00388e f10e              fdw     NONAME_L
                 SEMICOLON_L:
00388f 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
003890 dfe5              rcall   LEFTBRACKET
003891 fd61              sbrc    FLAGS1, fTAILC
003892 c026              rjmp    ADD_RETURN_1
003893 df5a              rcall   IHERE
003894 d02b              rcall   MINUS_FETCH
003895 018c              movw    t0, tosl
003896 7f10              andi    t1, 0xf0
003897 5d10              subi    t1, 0xd0
003898 f059              breq    RCALL_TO_JMP
003899 9189
00389a 9199              poptos
00389b d024              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
00389c 508e              subi    tosl, 0x0e
                 .endif
00389d 4994              sbci    tosh, 0x94
00389e f4c9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
00389f e08c              ldi     tosl, 0x0c
                 .endif
0038a0 e994              ldi     tosh, 0x94
0038a1 da02              rcall   SWOP
0038a2 940c 3e31         jmp     STORE
                 RCALL_TO_JMP:
0038a4 db6b              rcall   NIP
0038a5 709f              andi    tosh, 0x0f
0038a6 fd93              sbrc    tosh, 3
0038a7 6f90              ori     tosh, 0xf0
0038a8 da8d              rcall   TWOSTAR
0038a9 df44              rcall   IHERE
0038aa da38              rcall   PLUS
0038ab df0d              rcall   DOLIT
0038ac fffe              .dw     -2
0038ad d0e7              rcall   IALLOT
0038ae df0a              rcall   DOLIT
                 .ifdef EIND
                 .else
0038af 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
0038b0 940e 3f4a         call    ICOMMA
0038b2 5890              sub_pflash_tos
0038b3 9488              rampv_to_c
0038b4 9597              ror     tosh
0038b5 9587              ror     tosl
0038b6 940c 3f4a         jmp     ICOMMA
                 ADD_RETURN:
0038b8 d91e              rcall   TWODROP
                 ADD_RETURN_1:
0038b9 deff              rcall   DOLIT   ; Compile a ret
0038ba 9508              .dw     0x9508
0038bb 940c 3f4a         jmp    ICOMMA
                 
                 
                 
0038bd f11e              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
0038be 2d82
0038bf 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
0038c0 d00c              rcall   TWOMINUS
0038c1 df00              rcall   DUP
0038c2 940c 3e79         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
0038c4 f17c              fdw     MINUS_FETCH_L
                 BRACTICK_L:
0038c5 5bd3
0038c6 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
0038c7 df0d              rcall   TICK       ; get xt of 'xxx'
0038c8 940c 3e05         jmp     LITERAL
                 
                 ; 2-    n -- n-2
0038ca f18a              fdw     BRACTICK_L
                 TWOMINUS_L:
0038cb 32a2
0038cc 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
0038cd 9702              sbiw    tosl, 2
0038ce 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038cf f196              fdw     TWOMINUS_L
                 BL_l:
0038d0 6282
0038d1 006c              .db     NFA|2,"bl",0
                 BL:
0038d2 940e 30e3         call    DOCREATE
0038d4 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038d5 f1a0              fdw     BL_L
                 STATE_L:
0038d6 7385
0038d7 6174
0038d8 6574              .db     NFA|5,"state"
                 STATE_:
0038d9 939a
0038da 938a              pushtos
0038db 9180 01ec         lds     tosl, state
0038dd 9190 01ec         lds     tosh, state
0038df 9508              ret
                 
                 ; LATEST    -- a-addr           
0038e0 f1ac              fdw     STATE_L
                 LATEST_L:
0038e1 6c86
0038e2 7461
0038e3 7365
0038e4 0074              .db     NFA|6,"latest",0
                 LATEST_:
0038e5 940e 30e3         call    DOCREATE
0038e7 01df              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
0038e8 f1c2              fdw     LATEST_L
                 S0_L:
0038e9 7382
0038ea 0030              .db     NFA|2,"s0",0
                 S0:
0038eb dc0b              rcall   DOUSER
0038ec ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
0038ed f1d2              fdw     S0_L
                 R0_L:
0038ee 7282
0038ef 0030              .db     NFA|2,"r0",0
                 R0_:
0038f0 dc06              rcall   DOUSER
0038f1 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
0038f2 6983
0038f3 696e              .db     NFA|3,"ini"
                 INI:
0038f4 940e 30e3          call   DOCREATE
0038f6 01d7              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
0038f7 f1dc              fdw     R0_L
                 TICKS_L:
0038f8 7485
0038f9 6369
0038fa 736b              .db     NFA|5,"ticks"
                 TICKS:
0038fb 939a
0038fc 938a              pushtos
0038fd b70f              in_     t0, SREG
0038fe 94f8              cli
0038ff 2d8e              mov     tosl, ms_count
003900 2d9f              mov     tosh, ms_count1
003901 bf0f              out_    SREG, t0
003902 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
003903 f1f0              fdw     TICKS_L
                 MS_L:
003904 6d82
003905 0073              .db     NFA|2,"ms",0
                 MS:
003906 dff4              rcall   TICKS
003907 d9db              rcall   PLUS
                 MS1:    
003908 d621              rcall   PAUSE
003909 deb8              rcall   DUP
00390a dff0              rcall   TICKS
00390b d9e4              rcall   MINUS
00390c dec2              rcall   ZEROLESS
00390d dac1              rcall   ZEROSENSE
00390e f3c9              breq    MS1
00390f 940c 329d         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
003911 f208              fdw     MS_L
                 DOTID_L:
003912 2e83
003913 6469              .db     NFA|3,".id"
                 DOTID:
003914 dc4a              rcall   CFETCHPP
003915 dea3              rcall   DOLIT
003916 000f              .dw     0x0f
003917 d9e1              rcall   AND_
003918 d9a5              rcall   TOR
003919 c003              rjmp    DOTID3
                 DOTID1:
00391a dc44              rcall   CFETCHPP
00391b d00a              rcall   TO_PRINTABLE
00391c dee7              rcall   EMIT_A
                 DOTID3:
00391d d148              rcall   XNEXT
00391e f7d8              brcc    DOTID1  
00391f 911f              pop     t1
003920 910f              pop     t0
003921 940c 329d         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
003923 f224              fdw     DOTID_L
                 TO_PRINTABLE_L:
003924 3e83
003925 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:
003926 2799              clr     tosh   
003927 3080              cpi     tosl, 0
003928 f012              brmi    TO_PRINTABLE1
003929 3280              cpi     tosl, 0x20
00392a f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
00392b e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
00392c 9508              ret
                 
                  ; WORDS    --          list all words in dict.
00392d f248              fdw     TO_PRINTABLE_L
                 WORDS_L:
00392e 7785
00392f 726f
003930 7364              .db     NFA|5,"words"
003931 de29              rcall   FALSE_
003932 decc              rcall   CR
003933 de85              rcall   DOLIT
003934 f690              fdw     kernellink
003935 d005              rcall   WDS1
003936 de24              rcall   FALSE_
003937 dec7              rcall   CR
003938 dec6                      rcall   CR
003939 dfab              rcall   LATEST_
00393a ddbe              rcall   FETCH_A
00393b de86      WDS1:   rcall   DUP
00393c dfd7              rcall   DOTID
00393d dd32              rcall   SWOP_A
00393e d9e2              rcall   ONEPLUS
00393f de82              rcall   DUP
003940 de78              rcall   DOLIT
003941 0007              .dw     7
003942 d9b6              rcall   AND_
003943 da8b              rcall   ZEROSENSE
003944 f021              breq    WDS2
003945 de73              rcall   DOLIT
003946 0009              .dw     9
003947 debc              rcall   EMIT_A
003948 c001              rjmp    WDS3
                 WDS2:   
003949 deb5              rcall   CR
                 WDS3:
00394a dd25              rcall   SWOP_A
                 
00394b df81              rcall   TWOMINUS
00394c ddac              rcall   FETCH_A
00394d da87              rcall   DUPZEROSENSE
00394e f761              brne    WDS1
00394f 940c 31d7         jmp     TWODROP
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
003951 f25c              fdw     WORDS_L
                 DOTS_L:
003952 2e82
003953 0073              .db     NFA|2,".s",0
                 DOTS:
003954 d899              rcall   SPACE_
003955 de6c              rcall   DUP          ; push tosl:tosh to memory
003956 940e 3106         call    SPFETCH
003958 df92              rcall   S0
003959 dd9f              rcall   FETCH_A
00395a df72              rcall   TWOMINUS
                 DOTS1:
00395b d882              rcall   TWODUP
00395c da08              rcall   LESS
00395d da71              rcall   ZEROSENSE
00395e f019              breq    DOTS2
00395f df60              rcall   MINUS_FETCH
003960 db29              rcall   UDOT
003961 cff9              rjmp    DOTS1
                 DOTS2:  
003962 d93a              rcall   DROP
003963 940c 31d7         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
003965 f2a4              fdw     DOTS_L
                 DUMP_L:
003966 6484
003967 6d75
003968 0070              .db     NFA|4,"dump",0
                 DUMP:
003969 de4f              rcall   DOLIT
00396a 0010              .dw     16
00396b da87              rcall   USLASH
00396c d951              rcall   TOR
00396d c020              rjmp    DUMP7
                 DUMP1:  
00396e de90              rcall   CR
00396f de52              rcall   DUP
003970 de48              rcall   DOLIT
003971 0004              .dw     4
003972 db21              rcall   UDOTR
003973 de45              rcall   DOLIT
003974 003a              .dw     ':'
003975 de8e              rcall   EMIT_A
003976 de42              rcall   DOLIT
003977 000f              .dw     15
003978 d945              rcall   TOR
                 DUMP2:
003979 dbe5              rcall   CFETCHPP
00397a de3e              rcall   DOLIT
00397b 0002              .dw     2
00397c db17              rcall   UDOTR
00397d d0e8              rcall   XNEXT
00397e f7d0              brcc    DUMP2
00397f 911f              pop     t1
003980 910f              pop     t0
                 
003981 de37              rcall   DOLIT
003982 0010              .dw     16
003983 d96c              rcall   MINUS
003984 de34              rcall   DOLIT
003985 000f              .dw     15
003986 d937              rcall   TOR
                 DUMP4:  
003987 dbd7              rcall   CFETCHPP
003988 df9d              rcall   TO_PRINTABLE
003989 de7a              rcall   EMIT_A
00398a d0db              rcall   XNEXT
00398b f7d8              brcc    DUMP4
00398c 911f              pop     t1
00398d 910f              pop     t0
                 DUMP7:
00398e d0d7              rcall   XNEXT
00398f f6f0              brcc    DUMP1
003990 911f              pop     t1
003991 910f              pop     t0
003992 940c 329d         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
003994 2081              .db     NFA|1," "
                 IALLOT:
003995 debf              rcall   IDP
003996 940c 3342         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
003998 f2cc              fdw     DUMP_L
                 X_TO_R_L:
003999 7883
00399a 723e              .db     NFA|3,"x>r"
                 X_TO_R:
00399b 01fc              movw    zl, tosl
00399c 9189
00399d 9199              poptos
00399e d009              rcall   TO_XA
00399f 9631              adiw    zl, 1
0039a0 9382              st      -z, tosl
0039a1 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
0039a2 9252              st      -z, zero
0039a3 01cf              movw    tosl, zl
0039a4 9508              ret
                 ;***************************************************************
0039a5 f332              fdw     X_TO_R_L
                 TO_XA_L:
0039a6 3e83
0039a7 6178              .db NFA|3,">xa"
                 TO_XA:
0039a8 5890               sub_pflash_tos
0039a9 9488               rampv_to_c
0039aa 9597               ror tosh
0039ab 9587               ror tosl
0039ac 9508               ret
                 
0039ad f34c               fdw     TO_XA_L
                 XA_FROM_L:
0039ae 7883
0039af 3e61              .db NFA|3,"xa>"
                 XA_FROM:
0039b0 0f88               lsl     tosl
0039b1 1f99               rol     tosh
0039b2 5890               add_pflash_tos
0039b3 9508               ret
                 ;***************************************************************
0039b4 f35c               fdw    XA_FROM_L
                 PFL_L:
0039b5 7083
0039b6 6c66              .db     NFA|3,"pfl"
                 PFL:
0039b7 940e 30e3          call   DOCREATE
0039b9 8000              .dw     OFLASH
                 ;***************************************************************
0039ba f36a              fdw    PFL_L
                 ZFL_L:
0039bb 7a83
0039bc 6c66              .db     NFA|3, "zfl"
                 ZFL:
0039bd 940e 30e3          call   DOCREATE
0039bf 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
0039c0 2c84
0039c1 303f
0039c2 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
0039c3 fd65              sbrc    FLAGS1, idup
0039c4 c003              rjmp    COMMAZEROSENSE1
0039c5 ddf3              rcall   DOLIT
0039c6 e79e              fdw     ZEROSENSE
0039c7 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
0039c8 d004              rcall   IDPMINUS
0039c9 ddef              rcall   DOLIT
0039ca e7aa              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
0039cb 7d6f              cbr     FLAGS1, (1<<idup)
0039cc c070              rjmp    INLINE0
                 
                 IDPMINUS:
0039cd ddeb              rcall   DOLIT
0039ce fffc              .dw     -4
0039cf cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
0039d0 d96b              rcall   TWOSLASH
0039d1 709f              andi    tosh, 0x0f
0039d2 6c90              ori     tosh, 0xc0
0039d3 940c 3f4a         jmp     ICOMMA
                 
                 
                 BRCCC:
0039d5 dde3              rcall   DOLIT
0039d6 f008              .dw     0xf008      ; brcc pc+2
0039d7 940c 3f4a         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
0039d9 dddf              rcall   DOLIT
0039da f409              .dw     0xf409      ; brne pc+2
0039db fd64              sbrc    FLAGS1, izeroeq
0039dc 7f9b              andi    tosh, ~4
0039dd 940c 3f4a         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
0039df f376              fdw     ZFL_L
                 IF_L:
0039e0 69d2
0039e1 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
0039e2 fd64              sbrc    FLAGS1, izeroeq
0039e3 dfe9              rcall   IDPMINUS
0039e4 dfde              rcall   COMMAZEROSENSE
0039e5 dff3              rcall   BRNEC
0039e6 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039e7 de06              rcall   IHERE
0039e8 dd72              rcall   FALSE_
0039e9 940c 39d0         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
0039eb f3c0              fdw     IF_L
                 ELSE_L:
0039ec 65d4
0039ed 736c
0039ee 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
0039ef ddfe              rcall   IHERE
0039f0 dd6a              rcall   FALSE_
0039f1 dfde              rcall   RJMPC
0039f2 dc7d              rcall   SWOP_A      ; else-addr  if-addr 
0039f3 940c 39f9         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
0039f5 f3d8              fdw     ELSE_L
                 THEN_L:
0039f6 74d4
0039f7 6568
0039f8 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
0039f9 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039fa ddf3              rcall   IHERE
0039fb d8b2              rcall   OVER
0039fc d8f3              rcall   MINUS
0039fd decf              rcall   TWOMINUS
0039fe d93d              rcall   TWOSLASH
0039ff ddb9              rcall   DOLIT
003a00 c000              .dw     0xc000      ;  back-addr mask 
003a01 d8ff              rcall   OR_
003a02 dc6d              rcall   SWOP_A
003a03 940c 3e31         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
003a05 f3ec              fdw     THEN_L
                 BEGIN_L:
003a06 62d5
003a07 6765
003a08 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
003a09 940c 37ee         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
003a0b f40c              fdw     BEGIN_L
                 UNTIL_L:
003a0c 75d5
003a0d 746e
003a0e 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
003a0f 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a10 fd64              sbrc    FLAGS1, izeroeq
003a11 dfbb              rcall   IDPMINUS
003a12 dfb0              rcall   COMMAZEROSENSE
003a13 dfc5              rcall   BRNEC
003a14 7e6f              cbr     FLAGS1, (1<<izeroeq)
003a15 940c 3a1b         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
003a17 f418              fdw     UNTIL_L
                 AGAIN_L:
003a18 61d5
003a19 6167
003a1a 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
003a1b 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a1c ddd1              rcall   IHERE
003a1d d8d2              rcall   MINUS
003a1e deae              rcall   TWOMINUS
003a1f 940c 39d0         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
003a21 f430              fdw     AGAIN_L
                 WHILE_L:
003a22 77d5
003a23 6968
003a24 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
003a25 dfbc              rcall   IF_
003a26 940c 32a4         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
003a28 f444              fdw     WHILE_L
                 REPEAT_L:
003a29 72d6
003a2a 7065
003a2b 6165
003a2c 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
003a2d dfed              rcall   AGAIN_
003a2e 940c 39f9         jmp     THEN_
                 
003a30 f452              fdw     REPEAT_L
                 INLINE_L:
003a31 69d6
003a32 6c6e
003a33 6e69
003a34 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a35 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a36 7d6f              cbr      FLAGS1, (1<<idup)
003a37 dd9d              rcall    TICK
003a38 940c 3a3d         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a3a f462              fdw      INLINE_L
                 INLINEC_L:
003a3b 6983
003a3c 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a3d db29              rcall   FETCHPP
003a3e dd83              rcall   DUP
003a3f dd79              rcall   DOLIT
003a40 9508              .dw     0x9508
003a41 d916              rcall   NOTEQUAL
003a42 d98c              rcall   ZEROSENSE
003a43 f011              breq    INLINE1
003a44 d505              rcall   ICOMMA
003a45 cff7              rjmp    INLINE0
                 INLINE1:
003a46 940c 31d7         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a48 f476              fdw     INLINEC_L
                 FOR_L:
003a49 66d3
003a4a 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a4b 940e 30fb         call    DOCOMMAXT
003a4d e57c              fdw     TOR
003a4e dd9f              rcall   IHERE
003a4f dd0b              rcall   FALSE_
003a50 df7f              rcall   RJMPC
003a51 dd9c              rcall   IHERE
003a52 940c 32a4         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a54 f492              fdw     FOR_L
                 NEXT_L:
003a55 6ed4
003a56 7865
003a57 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a58 dfa0              rcall   THEN_
003a59 940e 30fb         call    DOCOMMAXT
003a5b f4cc              fdw     XNEXT
003a5c df78              rcall   BRCCC
                 
003a5d dfbd              rcall   AGAIN_
                 
003a5e dd5a              rcall   DOLIT
003a5f f4de              fdw     XNEXT1
003a60 940c 3a3d         jmp     INLINE0
                 ; (next) decrement top of return stack
003a62 2887
003a63 656e
003a64 7478
003a65 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003a66 91ff              pop     zh
003a67 91ef              pop     zl
003a68 91bf              pop     xh
003a69 91af              pop     xl
003a6a 9711              sbiw    xl, 1
003a6b 93af              push    xl
003a6c 93bf              push    xh
003a6d 9409              mijmp
003a6e 9508              ret
                 XNEXT1:
003a6f 911f              pop     t1
003a70 910f              pop     t0
003a71 9508              ret
                 
                 ; leave clear top of return stack
003a72 f4aa              fdw     NEXT_L
                 LEAVE_L:
003a73 6595
003a74 646e
003a75 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003a76 91ff              pop     zh
003a77 91ef              pop     zl
003a78 911f              pop     t1
003a79 910f              pop     t0
003a7a 2700              clr     t0
003a7b 2711              clr     t1
003a7c 930f              push    t0
003a7d 931f              push    t1
003a7e 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003a7f f4e6              fdw      LEAVE_L
                 RDROP_L:
003a80 72d5
003a81 7264
003a82 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003a83 dd35              rcall   DOLIT
003a84 f4de              fdw     XNEXT1
003a85 940c 3a3d         jmp     INLINE0
                 ;***************************************************
003a87 f500              fdw     RDROP_L
                 STOD_L:
003a88 7383
003a89 643e              .db     NFA|3,"s>d"
                 STOD:
003a8a ff97              sbrs    tosh, 7
003a8b cccf              rjmp    FALSE_
003a8c ccd7              rjmp    TRUE_
                 ;***************************************************
003a8d f510              fdw     STOD_L
                 DNEGATE_L:
003a8e 6487
003a8f 656e
003a90 6167
003a91 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003a92 d049              rcall   DINVERT
003a93 940e 3211         call    ONE
003a95 940c 32eb         jmp     MPLUS
                 ;***************************************************
003a97 f51c              fdw     DNEGATE_L
                 QDNEGATE_L:
003a98 3f88
003a99 6e64
003a9a 6765
003a9b 7461
003a9c 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003a9d dd31              rcall   ZEROLESS
003a9e d930              rcall   ZEROSENSE
003a9f f009              breq    QDNEGATE1
003aa0 dff1              rcall   DNEGATE
                 QDNEGATE1:
003aa1 9508              ret
                 
                 ;***************************************************
003aa2 f530              fdw     QDNEGATE_L
                 DABS_L:
003aa3 6484
003aa4 6261
003aa5 0073              .db     NFA|4,"dabs",0
                 DABS:
003aa6 dd1b              rcall   DUP
003aa7 940c 3a9d         jmp     QDNEGATE
                 ;***************************************************
003aa9 f546              fdw     DABS_L
                 DPLUS_L:
003aaa 6482
003aab 002b              .db     NFA|2,"d+",0
                 DPLUS:
003aac 91a9              ld      xl, Y+
003aad 91b9              ld      xh, Y+
003aae 91e9              ld      t6, Y+
003aaf 91f9              ld      t7, Y+
003ab0 9109              ld      t0, Y+
003ab1 9119              ld      t1, Y+
003ab2 0fa0              add     xl, t0
003ab3 1fb1              adc     xh, t1
003ab4 1f8e              adc     tosl, t6
003ab5 1f9f              adc     tosh, t7
003ab6 93ba              st      -Y, xh
003ab7 93aa              st      -Y, xl
003ab8 9508              ret
                 
                 ;***************************************************
003ab9 f554              fdw     DPLUS_L
                 DMINUS_L:
003aba 6482
003abb 002d              .db     NFA|2,"d-",0
                 DMINUS:
003abc dfd5              rcall   DNEGATE
003abd 940c 3aac         jmp     DPLUS
                 ;***************************************************
003abf f574              fdw     DMINUS_L
                 DTWOSLASH_L:
003ac0 6483
003ac1 2f32              .db     NFA|3,"d2/"
003ac2 9109              ld      t0, y+
003ac3 9119              ld      t1, y+
003ac4 9595              asr     tosh
003ac5 9587              ror     tosl
003ac6 9517              ror     t1
003ac7 9507              ror     t0
003ac8 931a              st      -y, t1
003ac9 930a              st      -y, t0
003aca 9508              ret
                 ;***************************************************
003acb f580              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003acc 6483
003acd 2a32              .db     NFA|3,"d2*"
003ace 9109              ld      t0, y+
003acf 9119              ld      t1, y+
003ad0 0f00              lsl     t0
003ad1 1f11              rol     t1
003ad2 1f88              rol     tosl
003ad3 1f99              rol     tosh
003ad4 931a              st      -y, t1
003ad5 930a              st      -y, t0
003ad6 9508              ret
                 ;***************************************************
003ad7 f598              fdw     DTWOSTAR_L
                 DINVERT_L:
003ad8 6487
003ad9 6e69
003ada 6576
003adb 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003adc 91a9              ld      xl, y+
003add 91b9              ld      xh, y+
003ade 95a0              com     xl
003adf 95b0              com     xh
003ae0 9580              com     tosl
003ae1 9590              com     tosh
003ae2 93ba              st      -y, xh
003ae3 93aa              st      -y, xl
003ae4 9508              ret
                 ;***************************************************
003ae5 f5b0              fdw     DINVERT_L
                 DZEROEQUAL_L:
003ae6 6483
003ae7 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003ae8 91a9              ld      xl, y+
003ae9 91b9              ld      xh, y+
003aea 2b89              or      tosl, tosh
003aeb 2b8a              or      tosl, xl
003aec 2b8b              or      tosl, xh
003aed f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003aee ef8f              ser     tosl
003aef ef9f              ser     tosh
003af0 9508              ret
                 
                 ;***************************************************
003af1 f5cc              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003af2 6483
003af3 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003af4 91a9              ld      xl, y+
003af5 91b9              ld      xh, y+
003af6 3090              cpi     tosh, 0
003af7 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003af8 2788              clr     tosl
003af9 2799              clr     tosh
003afa 9508              ret
                 ;***************************************************
003afb f5e4              fdw     DZEROLESS_L
                 DEQUAL_L:
003afc 6482
003afd 003d              .db     NFA|2,"d=",0
003afe dfbd              rcall   DMINUS
003aff 940c 3ae8         jmp     DZEROEQUAL
                 ;***************************************************
003b01 f5f8              fdw     DEQUAL_L
                 DLESS_L:
003b02 6482
003b03 003c              .db     NFA|2,"d<",0
                 DLESS:
003b04 dfb7              rcall   DMINUS
003b05 940c 3af4         jmp     DZEROLESS
                 ;***************************************************
003b07 f604              fdw     DLESS_L
                 DGREATER_L:
003b08 6482
003b09 003e              .db     NFA|2,"d>",0
                 DGREATER:
003b0a 940e 31e5         call    TWOSWAP
003b0c 940c 3b04         jmp     DLESS
                 ;***************************************************
003b0e f610              fdw     DGREATER_L
                 UDDOT_L:
003b0f 7583
003b10 2e64              .db     NFA|3,"ud."
003b11 d939              rcall   LESSNUM
003b12 d959              rcall   NUMS
003b13 d961              rcall   NUMGREATER
003b14 940e 3258         call    TYPE
003b16 940c 31ee         jmp     SPACE_
                 ;***************************************************
003b18 f61e              fdw     UDDOT_L
                 DDOT_L:
003b19 6482
003b1a 002e              .db     NFA|2,"d.",0
003b1b d92f              rcall   LESSNUM
003b1c 940e 37c2         call    DUP
003b1e 940e 32be         call    TOR
003b20 df85              rcall   DABS
003b21 d94a              rcall   NUMS
003b22 940e 32c8         call    RFROM
003b24 d95b              rcall   SIGN
003b25 d94f              rcall   NUMGREATER
003b26 940e 3258         call    TYPE
003b28 940c 31ee         jmp     SPACE_
                 ;****************************************************
003b2a f632              fdw      DDOT_L
                 MEMHI_L:
003b2b 6882
003b2c 0069              .db     NFA|2,"hi",0
                 MEMHI:
003b2d dc8b              rcall   DOLIT
003b2e f66a              fdw     FLASHHI
003b2f 940e 3149         call    CSE_
003b31 940e 32e3         call    PLUS
003b33 940c 3e79         jmp     FETCH
                 FLASHHI:
003b35 deff              .dw      FLASH_HI
003b36 0cff              .dw      EEPROM_HI
003b37 08ff              .dw      RAM_HI
                 
                 .if FLASHEND > 0x3fff
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
                 .endif
                 
                 ;***************************************************
                 
003b38 f656              fdw      MEMHI_L
                 L_FETCH_P:
003b39 40a2
003b3a 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b3b 939a
003b3c 938a              pushtos
003b3d 01ca              movw    tosl, pl
003b3e 9508              ret
                 ;***************************************************
003b3f f672              fdw     L_FETCH_P
                 L_PCFETCH:
003b40 7083
003b41 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b42 939a
003b43 938a              pushtos
003b44 01ca              movw    tosl, pl
003b45 940c 3ea3         jmp     CFETCH
                 ;***************************************************
003b47 f680              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b48 70a3
003b49 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b4a 0d47              add     pl, r_two
003b4b 1d55              adc     ph, zero
003b4c 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b4d 0000              .dw     0
                 L_MARKER:
                 lastword:
003b4e 6d86
003b4f 7261
003b50 656b
003b51 0072              .db     NFA|6,"marker",0
                 MARKER:
003b52 940e 312e         call    ROM_
003b54 dcb6              rcall   CREATE
003b55 dc63              rcall   DOLIT
003b56 0900              .dw     dp_start
003b57 940e 3153         call    HERE
003b59 dbd9              rcall   TEN
003b5a d9e9              rcall   CMOVE
003b5b dbd7              rcall   TEN
003b5c 940e 3296         call    ALLOT
003b5e 940e 313c         call    FRAM
003b60 dcfa              rcall   XDOES
003b61 940e 30eb         call    DODOES
003b63 dd90              rcall   INI
003b64 dbce              rcall   TEN
003b65 940c 3544         jmp     CMOVE
                 
                 
                 ;;; Enable load led
003b67 dfa2              fdw     BUSY_L
                 LOADON_L:
003b68 6c85
003b69 616f
003b6a 2b64              .db     NFA|5,"load+"
003b6b 6170              sbr     FLAGS2, (1<<fLOADled)
003b6c 9508              ret
                 
                 ;;; Disable load led
003b6d f6d0              fdw     LOADON_L
                 LOADOFF_L:
003b6e 6c85
003b6f 616f
003b70 2d64              .db     NFA|5,"load-"
003b71 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
003b72 9825              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003b73 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003b74 9508              ret
                 ;;; Enable load led
003b75 f6dc              fdw     LOADOFF_L
                 LOAD_L:
003b76 6c84
003b77 616f
003b78 0064              .db     NFA|4,"load",0
003b79 939a
003b7a 938a              pushtos
003b7b 9180 01e8         lds     tosl, load_res
003b7d 9190 01e9         lds     tosh, load_res+1
003b7f 939a
003b80 938a              pushtos
003b81 9180 01ea         lds     tosl, load_res+2
003b83 2799              clr     tosh
003b84 939a
003b85 938a              pushtos
003b86 e680              ldi     tosl, low(CPU_LOAD_VAL)
003b87 e99f              ldi     tosh, high(CPU_LOAD_VAL)
003b88 940e 33e1         call    UMSLASHMOD
003b8a 940c 3410         jmp     NIP 
                 
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
003b8c 0200              .dw      0x0200                ; cse, state
003b8d 02a7              .dw      utibbuf-4             ; S0
003b8e 026a              .dw      usbuf-1               ; R0
003b8f f914              fdw      OP_TX_
003b90 f962              fdw      OP_RX_
003b91 f9a2              fdw      OP_RXQ
003b92 000a              .dw      BASE_DEFAULT          ; BASE
003b93 02ab              .dw      utibbuf               ; TIB
003b94 df8a              fdw      OPERATOR_AREA         ; TASK
003b95 0000              .dw      0                     ; ustatus & uflg
003b96 0000              .dw      0                     ; source
003b97 0000              .dw      0                     ; source
003b98 0000              .dw      0                     ; TOIN
003b99 0209              .dw      up0                   ; Task link
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003b9a fe00              sbrs    t2, PORF
003b9b c003              rjmp    RQ_EXTR
003b9c dc1c              rcall   DOLIT
003b9d 0050              .dw     'P'
003b9e dc65              rcall   EMIT_A
                 RQ_EXTR:
003b9f fe01              sbrs    t2, EXTRF
003ba0 c003              rjmp    RQ_BORF
003ba1 dc17              rcall   DOLIT
003ba2 0045              .dw     'E'
003ba3 dc60              rcall   EMIT_A
                 RQ_BORF:
003ba4 fe02              sbrs    t2, BORF
003ba5 c003              rjmp    RQ_WDRF
003ba6 dc12              rcall   DOLIT
003ba7 0042              .dw     'B'
003ba8 dc5b              rcall   EMIT_A
                 RQ_WDRF:
003ba9 fe03              sbrs    t2, WDRF
003baa c003              rjmp    RQ_DIVZERO
003bab dc0d              rcall   DOLIT
003bac 0057              .dw     'W'
003bad dc56              rcall   EMIT_A
                 RQ_DIVZERO:
003bae fe16              sbrs    t3, 6 ; T bit MATH error
003baf c003              rjmp    RQ_END
003bb0 dc08              rcall   DOLIT
003bb1 004d              .dw     'M'
003bb2 dc51              rcall   EMIT_A
                 RQ_END: 
003bb3 940c 31ee         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
003bb5 ff75              sbrs    FLAGS2, fLOAD
003bb6 c00d              rjmp    CPU_LOAD_END
003bb7 b70f              in_     t0, SREG
003bb8 94f8              cli
003bb9 7d7f              cbr     FLAGS2, (1<<fLOAD)
003bba 9240 01e8         sts     load_res, loadreg0
003bbc 92c0 01e9         sts     load_res+1,loadreg1
003bbe 92d0 01ea         sts     load_res+2, loadreg2
003bc0 2444              clr     loadreg0
003bc1 24cc              clr     loadreg1
003bc2 24dd              clr     loadreg2
003bc3 bf0f              out_    SREG, t0
                 CPU_LOAD_END:
                 .endif
                 .if CPU_LOAD_LED == 1
003bc4 ff74              sbrs    FLAGS2, fLOADled
003bc5 c002              rjmp    LOAD_LED_END
003bc6 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003bc7 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003bc8 ff76              sbrs    FLAGS2, fIDLE
003bc9 c009              rjmp    IDLE_LOAD1
003bca e009              ldi     t0, low(up0)
003bcb 1620              cp      upl, t0
003bcc f431              brne    IDLE_LOAD1
                 .ifdef SMCR
003bcd e001              ldi     t0, (1<<SE)
003bce bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
003bcf 9250 0081         out_    TCCR1B, zero    ; Stop load counter
                 .endif
003bd1 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003bd2 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003bd3 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003bd4 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003bd5 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d56 RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d03b                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d039                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d037                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
003c08 d035                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
003c0a d033                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d031                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
003c0e d02f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
003c10 d02d                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
003c12 d02b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
003c14 d029                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
003c16 d027                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
003c18 d025                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
003c1a d023                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
003c1c c035                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
003c1e d01f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
003c20 d01d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
003c22 d01b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
003c24 d019                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d017                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d015                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
                 .else
003c2a d013                  rcall FF_ISR
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d011                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d00f                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d00d                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d00b                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
003c33 919f              pop     tosh
003c34 918f              pop     tosl
003c35 911f              pop     t1
003c36 910f              pop     t0
003c37 91ff              pop     zh
003c38 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
003c39 91a9              ld      xl, y+
003c3a 91b9              ld      xh, y+
003c3b bfbf              out_    SREG, xh
003c3c 91b9              ld      xh, y+
003c3d 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
003c3e 9260 0081         out_    TCCR1B, r_one   ; Start load counter
                 .endif
                 .endif
003c40 93ba              st      -y, xh
003c41 b7bf              in_     xh, SREG
003c42 93ba              st      -y, xh
003c43 93aa              st      -y, xl
                         m_pop_xh
003c44 91bf              pop     xh
003c45 91af              pop     xl
003c46 93ef              push    zl
003c47 93ff              push    zh
003c48 930f              push    t0
003c49 931f              push    t1
003c4a 938f              push    tosl
003c4b 939f              push    tosh
                 .if low(ivec) == 0x80
003c4c e7bf              ldi     xh, low(ivec-1)
003c4d 0fab              add     xl, xh
                 .else
                 .endif
003c4e e0b1              ldi     xh, high(ivec)
003c4f 91ed              ld      zl, x+
003c50 91fd              ld      zh, x+
003c51 9409              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
003c52 9260 0081         out_    TCCR1B, r_one   ; Start load counter
                 .endif
                 .endif
003c54 93ba              st      -y, xh
003c55 b7bf              in_     xh, SREG
003c56 93ba              st      -y, xh
003c57 93aa              st      -y, xl
003c58 0ce6              add     ms_count,  r_one
003c59 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
                 LOAD_ADD:
003c5a 91a0 0084         in_     xl, TCNT1L
003c5c 91b0 0085         in_     xh, TCNT1H
003c5e 9250 0085         out_    TCNT1H, zero
003c60 9270 0084         out_    TCNT1L, r_two
                 
003c62 0e4a              add     loadreg0, xl
003c63 1ecb              adc     loadreg1, xh
003c64 1cd5              adc     loadreg2, zero
                 
003c65 20ee              tst     ms_count
003c66 f409              brne    LOAD_ADD_END
003c67 6270              sbr     FLAGS2, (1<<fLOAD)
                 LOAD_ADD_END:
                 .endif
003c68 cfd0              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
003c69 ebe7              ldi     zl, low(rbuf0)
003c6a e0f1              ldi     zh, high(rbuf0)
003c6b 91a0 01b4         lds     xl, rbuf0_wr
003c6d 0fea              add     zl, xl
003c6e 1df5              adc     zh, zero
003c6f 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
003c71 30bf              cpi     xh, 0xf
003c72 f409              brne    pc+2
003c73 cf8c              rjmp    RESET_
                 .endif
                 .endif
003c74 83b0              st      z, xh
003c75 95a3              inc     xl
003c76 71af              andi    xl, (RX0_BUF_SIZE-1)
003c77 93a0 01b4         sts     rbuf0_wr, xl
003c79 91a0 01b6         lds     xl, rbuf0_lv
003c7b 95a3              inc     xl
003c7c 93a0 01b6         sts     rbuf0_lv, xl
003c7e 31ae              cpi     xl, RX0_BUF_SIZE-2
003c7f f409              brne    PC+2
003c80 d004              rcall   RX0_OVF
003c81 30a4              cpi     xl, RX0_OFF_FILL
003c82 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c83 d021              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
003c84 cfae              rjmp    FF_ISR_EXIT
                 RX0_OVF:
003c85 e7fc              ldi     zh, '|'
003c86 c020              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
003c87 f6ec              fdw(LOAD_L)
                 TX0_L:
003c88 7483
003c89 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c8a 3181              cpi     tosl, XON
003c8b f061              breq    XXON_TX0_TOS
003c8c 3183              cpi     tosl, XOFF
003c8d f091              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c8e d29b              rcall   PAUSE
003c8f 9100 00c0         in_     t0, UCSR0A
003c91 ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003c92 cffb              rjmp    TX0_LOOP
003c93 9380 00c6         out_    UDR0_, tosl
003c95 9189
003c96 9199              poptos
003c97 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003c98 9189
003c99 9199              poptos
003c9a c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003c9b ff70              sbrs    FLAGS2, ixoff_tx0
003c9c 9508              ret
                 XXON_TX0_1:
003c9d 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003c9e e1f1              ldi     zh, XON
003c9f c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003ca0 9189
003ca1 9199              poptos
003ca2 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003ca3 fd70              sbrc    FLAGS2, ixoff_tx0
003ca4 9508              ret     
                 XXOFF_TX0_1:
003ca5 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003ca6 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003ca7 91e0 00c0         in_     zl, UCSR0A
003ca9 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003caa cffc              rjmp    TX0_SEND
003cab 93f0 00c6         out_    UDR0_, zh
003cad 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003cae f910              fdw(TX0_L)
                 RX0_L:
003caf 7283
003cb0 3078              .db     NFA|3,"rx0"
                 RX0_:
003cb1 d278              rcall   PAUSE
003cb2 d01e              rcall   RX0Q
003cb3 940e 33cf         call    ZEROSENSE
003cb5 f3d9              breq    RX0_
003cb6 939a
003cb7 938a              pushtos
003cb8 ebe7              ldi     zl, low(rbuf0)
003cb9 e0f1              ldi     zh, high(rbuf0)
003cba 91a0 01b5         lds     xl, rbuf0_rd
003cbc 0fea              add     zl, xl
003cbd 1df5              adc     zh, zero
003cbe 8180              ld      tosl, z
003cbf 2799              clr     tosh
003cc0 b70f              in_     t0, SREG
003cc1 94f8              cli
003cc2 95a3              inc     xl
003cc3 71af              andi    xl, (RX0_BUF_SIZE-1)
003cc4 93a0 01b5         sts     rbuf0_rd, xl
003cc6 91a0 01b6         lds     xl, rbuf0_lv
003cc8 95aa              dec     xl
003cc9 93a0 01b6         sts     rbuf0_lv, xl
003ccb bf0f              out_    SREG, t0
003ccc 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003ccd f95e              fdw     RX0_L
                 RX0Q_L:
003cce 7284
003ccf 3078
003cd0 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003cd1 91a0 01b6         lds     xl, rbuf0_lv
003cd3 11a5              cpse    xl, zero
003cd4 940c 3764         jmp     TRUE_
                 .if U0FC_TYPE == 1
003cd6 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003cd7 940c 375b         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003cd9 dc7a              rcall   DOTS
003cda 940e 3265         call    XSQUOTE
003cdc 4103
003cdd 3f44              .db     3,"AD?"
003cde 940e 3258         call    TYPE
003ce0 cab2              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003ce1 5890      	sub_pflash_tos
                 .ifdef  RAMPZ
                 .endif
                 XUPDATEBUF:
003ce2 9380 01e3         sts     iaddrl, tosl
003ce4 9390 01e4         sts     iaddrh, tosh
                 .ifdef RAMPZ
                 .endif
003ce6 359f              cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
003ce7 f788              brcc    ISTORERR
                 XUPDATEBUF2:	
003ce8 9100 01e3 	lds     t0, iaddrl
003cea 7800              andi    t0, ~(PAGESIZEB-1)
003ceb 110a              cpse    t0, ibasel
003cec c005              rjmp    IFILL_BUFFER
003ced 9100 01e4         lds     t0, iaddrh
003cef 110b              cpse    t0, ibaseh
003cf0 c001              rjmp    IFILL_BUFFER
                 .ifdef RAMPZ
                 .endif
003cf1 9508              ret
                 
                 IFILL_BUFFER:
003cf2 d04e              rcall   IFLUSH
003cf3 9100 01e3         lds     t0, iaddrl
003cf5 7800              andi    t0, ~(PAGESIZEB-1)
003cf6 2ea0              mov     ibasel, t0
003cf7 90b0 01e4         lds     ibaseh, iaddrh
                 .ifdef RAMPZ
                 .endif
                 IFILL_BUFFER_1:
003cf9 e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003cfa 01f5              movw    zl, ibasel
003cfb e0a0              ldi     xl, low(ibuf)
003cfc e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003cfd 9115              lpm_    t1, z+
003cfe 931d              st      x+, t1
003cff 950a              dec     t0
003d00 f7e1              brne    IFILL_BUFFER_2
                 .ifdef RAMPZ
                 .endif
003d01 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d02 dab6              rcall   DOLIT
003d03 0013              .dw     XOFF
003d04 940e 308e         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d06 dab2              rcall   DOLIT
003d07 000a              .dw     10
003d08 dbfd              rcall   MS
                         ; Disable interrupts
003d09 94f8              cli
003d0a 01f5              movw    zl, ibasel
                 .ifdef RAMPZ
                 .endif
003d0b e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003d0c d029              rcall   DO_SPM
003d0d e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003d0e d027              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003d0f e800              ldi     t0, low(PAGESIZEB);init loop variable
003d10 e0a0              ldi     xl, low(ibuf)
003d11 e0b1              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
003d12 900d              ld      r0, x+
003d13 901d              ld      r1, x+
003d14 e011              ldi     t1, (1<<SPMEN)
003d15 d020              rcall   DO_SPM
003d16 9632              adiw    zl, 2
003d17 5002              subi    t0, 2
003d18 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d19 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d1a 40f0              sbci    zh, high(PAGESIZEB)
003d1b e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d1c d019              rcall   DO_SPM
                         ; re-enable the RWW section
003d1d d012              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d1e e800              ldi     t0, low(PAGESIZEB);init loop variable
003d1f 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d20 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d21 9005              lpm_    r0, z+
003d22 901d              ld      r1, x+
003d23 1001              cpse    r0, r1
003d24 c031              rjmp    WARM_     ; reset
003d25 5001              subi    t0, 1
003d26 f7d1              brne    IWRITE_BUFFER2
003d27 ef0f      	ser     t0
003d28 2eb0      	mov     ibaseh, t0
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
003d29 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d2a 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d2b da8d              rcall   DOLIT
003d2c 0011              .dw     XON
003d2d 940e 308e         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d2f 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d30 b687              in_     t8, SPMCSR
003d31 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d32 9508              ret
                         ; re-enable the RWW section
003d33 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d34 d001              rcall   DO_SPM
003d35 cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d36 b687              in_     t8, SPMCSR
003d37 fc80              sbrc    t8, SPMEN
003d38 cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d39 bf17              out_    SPMCSR, t1
003d3a 95e8              spm
003d3b 9508              ret
                 
003d3c fe4e              fdw     PAUSE_L
                 IFLUSH_L:
003d3d 6986
003d3e 6c66
003d3f 7375
003d40 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d41 fd60              sbrc    FLAGS1, idirty
003d42 cfbf              rjmp    IWRITE_BUFFER
003d43 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d44 f99c              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d45 6585
003d46 706d
003d47 7974              .db     NFA|5,"empty"
                 EMPTY:
003d48 da70              rcall   DOLIT
003d49 ff12              fdw     COLDLIT
003d4a da6e              rcall   DOLIT
003d4b 0900              .dw     dp_start
003d4c da6c              rcall   DOLIT
003d4d 000c              .dw     coldlitsize
003d4e 940e 3544         call    CMOVE
003d50 940c 3737         jmp     DP_TO_RAM
                         
                 ;*******************************************************
003d52 fa8a              fdw     EMPTY_L
                 WARM_L:
003d53 7784
003d54 7261
003d55 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d56 94f8              cli           ; Disable interrupts
003d57 27aa              clr     xl
003d58 27bb              clr     xh
003d59 e1c9              ldi     yl, 25
003d5a e0d0              ldi     yh, 0
                 WARM_1:
003d5b 93dd              st      x+, yh
003d5c 50c1              subi    yl, 1
003d5d f7e9              brne    WARM_1
                 
003d5e b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d5f b604              in_     t2, MCUSR
003d60 9250 0034         sts     MCUSR, zero
                 .endif
003d62 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d63 925d              st      x+, zero
003d64 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d65 f7e9              brne    WARM_2
                 
                 ; Init empty flash buffer
003d66 94ba      	dec     ibaseh
                 .ifdef RAMPZ
                 .endif
                 
                 ; Init constant registers
003d67 e0c1              ldi     yl, 1
003d68 2e6c              mov     r_one, yl
003d69 e0c2              ldi     yl, 2
003d6a 2e7c              mov     r_two, yl
                 ; Init Stack pointer
003d6b eac7              ldi     yl, low(utibbuf-4)
003d6c e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d6d e60a              ldi     t0, low(usbuf-1)
003d6e e012              ldi     t1, high(usbuf-1)
003d6f bf0d              out     spl, t0
003d70 bf1e              out     sph, t1
                 ; Init user pointer
003d71 e009              ldi     t0, low(up0)
003d72 e012              ldi     t1, high(up0)
003d73 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d74 da44              rcall   DOLIT
003d75 f718              fdw     WARMLIT
003d76 da42              rcall   DOLIT
003d77 01eb              .dw     cse
003d78 da40              rcall   DOLIT
003d79 001c              .dw     warmlitsize
003d7a 940e 3544         call    CMOVE
                 ; init cold data to eeprom
003d7c da3c              rcall   DOLIT
003d7d 0900              .dw     dp_start
003d7e d0fa              rcall   FETCH
003d7f d9e4              rcall   TRUE_
003d80 940e 3360         call    EQUAL
003d82 940e 33cf         call    ZEROSENSE
003d84 f009              breq    WARM_3  
003d85 dfc2              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d86 be65              out_    MCUCR, r_one   ; (1<<IVCE)
003d87 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
003d88 bc74              out_    TCCR0A, r_two  ; CTC
003d89 e003              ldi     t0, ms_pre_tmr0
003d8a bd05              out_    TCCR0B, t0
003d8b ef09              ldi     t0, ms_value_tmr0
003d8c bd07              out_    OCR0A, t0
003d8d 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
003d8f da29              rcall   DOLIT
003d90 3c69              .dw     RX0_ISR
003d91 da27              rcall   DOLIT
                 .ifdef URXC0addr
                 .else
003d92 01a4              .dw     URXCaddr+ivec
                 .endif
003d93 d09d              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, zero
003d94 e607              ldi     t0, ubrr0val
003d95 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003d97 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003d98 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003d9a e006              ldi     t0, (3<<UCSZ00)|URSEL_
003d9b 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003d9d 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d9e d998              rcall   DP_TO_RAM
003d9f 9478              sei
                 
003da0 ddf9              rcall   RQ_EMIT
003da1 d023              rcall   VER
                 ; Turnkey ?
003da2 d180              rcall   TURNKEY
003da3 940e 33cf         call    ZEROSENSE
003da5 f0d1              breq    STARTQ2
003da6 940e 3265         call    XSQUOTE
003da8 4503
003da9 4353              .db     3,"ESC"
003daa 940e 3258         call    TYPE
003dac da0c              rcall   DOLIT
003dad 07d0              .dw     TURNKEY_DELAY
003dae db57              rcall   MS
003daf 940e 309b         call    KEYQ
003db1 940e 33cf         call    ZEROSENSE
003db3 f049              breq    STARTQ1
003db4 940e 3094         call    KEY
003db6 da02              rcall   DOLIT
003db7 001b              .dw     0x1b
003db8 940e 3360         call    EQUAL
003dba 940e 33cf         call    ZEROSENSE
003dbc f419              brne    STARTQ2
                 STARTQ1:
003dbd d165              rcall   TURNKEY
003dbe 940e 30a3         call    EXECUTE
                 STARTQ2:
003dc0 940c 3793         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
003dc2 faa6              fdw     WARM_L
                 VER_L:
003dc3 7683
003dc4 7265              .db     NFA|3,"ver"
                 VER:
003dc5 940e 3265         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
003dc7 4624
003dc8 616c
003dc9 6873
003dca 6f46
003dcb 7472
003dcc 2068
003dcd 2035
003dce 5441
003dcf 656d
003dd0 6167
003dd1 3233
003dd2 5038
003dd3 3020
003dd4 2e32
003dd5 3730
003dd6 322e
003dd7 3130
003dd8 0d36
avr/src/ff-atmega.asm(5375): warning: .cseg .db misalignment - padding zero byte
003dd9 000a              .db     partlen+datelen+16,"FlashForth 5 ",partstring," ", DATE,0xd,0xa
003dda 940c 3258         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003ddc fb86              fdw     VER_L
                 EI_L:
003ddd 65a2
003dde 0069              .db     NFA|INLINE|2,"ei",0
003ddf 9478              sei
003de0 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003de1 fbba              fdw     EI_L
                 DI_L:
003de2 64a2
003de3 0069              .db     NFA|INLINE|2,"di",0
003de4 94f8              cli
003de5 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003de6 fbc4              fdw     DI_L
                 IRQ_SEMI_L:
003de7 3bc2
003de8 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003de9 d9cf              rcall   DOLIT
                 .ifdef EIND
                 .else
003dea 940c              .dw     0x940C     ; jmp
                 .endif
003deb d15e              rcall   ICOMMA
003dec d9cc              rcall   DOLIT
003ded 3c33              .dw     FF_ISR_EXIT
003dee d15b              rcall   ICOMMA
003def 940c 3876         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003df1 fbce              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003df2 6984
003df3 746e
003df4 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003df5 01fc              movw    zl, tosl
003df6 9731              sbiw    zl, 1
003df7 0fee              lsl     zl
                 .if low(ivec) == 0x80
003df8 e8f0                      ldi     zh, low(ivec)
003df9 0fef                      add     zl,  zh
                 .endif
003dfa e0f1              ldi     zh, high(ivec)
003dfb 9189
003dfc 9199              poptos
003dfd dbaa              rcall   TO_XA
003dfe 940c 3e36         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003e00 fbe4              fdw     IRQ_V_L
                 LITERAL_L:
003e01 6cc7
003e02 7469
003e03 7265
003e04 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003e05 d9b3              rcall   DOLIT
003e06 ef84              fdw     DUP
003e07 dc35              rcall   INLINE0
003e08 940e 37c2         call    DUP
003e0a 2f98              mov     tosh, tosl
003e0b 9592              swap    tosh
003e0c 709f              andi    tosh, 0xf
003e0d 708f              andi    tosl, 0xf
003e0e 6e90              ori     tosh, 0xe0
003e0f 6880              ori     tosl, 0x80
003e10 d139              rcall   ICOMMA
003e11 2f89              mov     tosl, tosh
003e12 9592              swap    tosh
003e13 709f              andi    tosh, 0xf
003e14 708f              andi    tosl, 0xf
003e15 6e90              ori     tosh, 0xe0
003e16 6980              ori     tosl, 0x90
003e17 940c 3f4a         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e19 d039              rcall   LOCKEDQ
003e1a dec6              rcall   IUPDATEBUF
                 ISTORE1:
003e1b 9189
003e1c 9199              poptos
003e1d e0a0              ldi     xl, low(ibuf)
003e1e e0b1              ldi     xh, high(ibuf)
003e1f 9100 01e3         lds     t0, iaddrl
003e21 770f              andi    t0, (PAGESIZEB-1)
003e22 0fa0              add     xl, t0
003e23 938d              st      x+, tosl
003e24 939d              st      x+, tosh
003e25 9189
003e26 9199              poptos
003e27 6061              sbr     FLAGS1, (1<<idirty)
003e28 9508              ret
                 
003e29 fc02              fdw     LITERAL_L
                 TO_A_L:
003e2a 3e82
003e2b 0061              .db     NFA|2, ">a",0
003e2c eee1              ldi     zl, low(areg)
003e2d e0f1              ldi     zh, high(areg)
003e2e c007              rjmp    STORE_RAM_2
                 
003e2f fc54              fdw     TO_A_L
                 STORE_L:
003e30 2181              .db     NFA|1, "!"
                 STORE:
003e31 3099              cpi     tosh, high(PEEPROM)
003e32 f440              brcc    STORE1
                 STORE_RAM:
003e33 01fc              movw    zl, tosl
003e34 9189
003e35 9199              poptos
                 STORE_RAM_2:
003e36 8391              std     Z+1, tosh
003e37 8380              std     Z+0, tosl
003e38 9189
003e39 9199              poptos
003e3a 9508              ret
                 STORE1:
003e3b 3890              cpi     tosh, high(OFLASH)
003e3c f6e0              brcc    ISTORE
                 ESTORE:
003e3d d015              rcall   LOCKEDQ
003e3e 99f9              sbic    eecr, eewe
003e3f cffd              rjmp    ESTORE
003e40 5099              subi    tosh, high(PEEPROM)
003e41 bd81              out     eearl, tosl
003e42 bd92              out     eearh, tosh
003e43 9189
003e44 9199              poptos
003e45 bd80              out     eedr, tosl
003e46 9afa              sbi     eecr, eemwe
003e47 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
003e48 99f9              sbic    eecr, eewe
003e49 cffe              rjmp    ESTORE1
                 
003e4a b581              in      tosl, eearl
003e4b 9583              inc     tosl
003e4c bd81              out     eearl, tosl
                 
003e4d bd90              out     eedr, tosh
003e4e 9afa              sbi     eecr, eemwe
003e4f 9af9              sbi     eecr, eewe
                 
003e50 9189
003e51 9199              poptos
003e52 9508              ret
                 LOCKEDQ:
003e53 ff62              sbrs    FLAGS1, fLOCK
003e54 9508              ret
003e55 dafe              rcall   DOTS
003e56 940e 3265         call    XSQUOTE
003e58 4103
003e59 3f44              .db     3,"AD?"
003e5a 940e 3258         call    TYPE
003e5c cf63              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e5d 01fc              movw    z, tosl
003e5e 58f0              sub_pflash_z
                 .ifdef RAMPZ
                 .endif
003e5f 11fb              cpse    zh, ibaseh
003e60 c00b              rjmp    IIFETCH
003e61 2f0e              mov     t0, zl
003e62 7800              andi    t0, ~(PAGESIZEB-1)
003e63 150a              cp      t0, ibasel
003e64 f439              brne    IIFETCH
003e65 e0a0              ldi     xl, low(ibuf)
003e66 e0b1              ldi     xh, high(ibuf)
003e67 77ef              andi    zl, (PAGESIZEB-1)
003e68 0fae              add     xl, zl
003e69 918d              ld      tosl, x+
003e6a 919d              ld      tosh, x+
003e6b 9508              ret
                 IIFETCH:
003e6c 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e6d 9195              lpm_    tosh, z+
003e6e 9508              ret
                                 
003e6f fc60              fdw     STORE_L
                 A_FROM_L:
003e70 6182
003e71 003e              .db     NFA|2, "a>",0
003e72 939a
003e73 938a              pushtos
003e74 eee1              ldi     zl, low(areg)
003e75 e0f1              ldi     zh, high(areg)
003e76 c005              rjmp    FETCH_RAM_2
                 
                 .if FLASHEND > 0x3fff
                 .else
003e77 fce0              fdw     A_FROM_L
                 .endif
                 FETCH_L:
003e78 4081              .db     NFA|1, "@"
                 FETCH:
003e79 3099              cpi     tosh, high(PEEPROM)
003e7a f420              brcc    FETCH1
                 FETCH_RAM:
003e7b 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e7c 9181              ld      tosl, z+
003e7d 9191              ld      tosh, z+
003e7e 9508              ret
                 FETCH1:
003e7f 3890              cpi     tosh, high(OFLASH)
003e80 f6e0              brcc    IFETCH
                 EFETCH:
003e81 99f9              sbic    eecr, eewe
003e82 cffe              rjmp    EFETCH
003e83 5099              subi    tosh, high(PEEPROM)
003e84 bd81              out     eearl, tosl
003e85 bd92              out     eearh, tosh
003e86 9af8              sbi     eecr, eere
003e87 b580              in      tosl, eedr
003e88 b591              in      tosh, eearl
003e89 9593              inc     tosh
003e8a bd91              out     eearl, tosh
003e8b 9af8              sbi     eecr, eere
003e8c b590              in      tosh, eedr
003e8d 9508              ret
                 
                 ICFETCH:
003e8e 01fc              movw    z, tosl
003e8f 58f0              sub_pflash_z
                 .ifdef RAMPZ
                 .endif
003e90 11fb              cpse    zh, ibaseh
003e91 c00b              rjmp    IICFETCH
003e92 2f0e              mov     t0, zl
003e93 7800              andi    t0, ~(PAGESIZEB-1)
003e94 150a              cp      t0, ibasel
003e95 f439              brne    IICFETCH
003e96 e0a0              ldi     xl, low(ibuf)
003e97 e0b1              ldi     xh, high(ibuf)
003e98 77ef              andi    zl, (PAGESIZEB-1)
003e99 0fae              add     xl, zl
003e9a 918d              ld      tosl, x+
003e9b 2799              clr     tosh
003e9c 9508              ret
                 IICFETCH:
003e9d 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e9e 2799              clr     tosh
003e9f 9508              ret
                 
003ea0 fcf0              fdw     FETCH_L
                 CFETCH_L:
003ea1 6382
003ea2 0040              .db     NFA|2, "c@",0
                 CFETCH:
003ea3 3099              cpi     tosh, high(PEEPROM)
003ea4 f420              brcc    CFETCH1
                 CFETCH_RAM:
003ea5 01fc              movw    zl, tosl
003ea6 9181              ld      tosl, z+
003ea7 2799              clr     tosh
003ea8 9508              ret
                 CFETCH1:
003ea9 3890              cpi     tosh, high(OFLASH)
003eaa f718              brcc    ICFETCH
                 ECFETCH:
003eab 99f9              sbic    eecr, eewe
003eac cffe              rjmp    ECFETCH
003ead 5099              subi    tosh, high(PEEPROM)
003eae bd81              out     eearl, tosl
003eaf bd92              out     eearh, tosh
003eb0 9af8              sbi     eecr, eere
003eb1 b580              in      tosl, eedr
003eb2 2799              clr     tosh
003eb3 9508              ret
                 
                 ICSTORE:
003eb4 df9e              rcall   LOCKEDQ
003eb5 de2b              rcall   IUPDATEBUF
003eb6 9189
003eb7 9199              poptos
003eb8 e0a0              ldi     xl, low(ibuf)
003eb9 e0b1              ldi     xh, high(ibuf)
003eba 9100 01e3         lds     t0, iaddrl
003ebc 770f              andi    t0, (PAGESIZEB-1)
003ebd 0fa0              add     xl, t0
003ebe 938d              st      x+, tosl
003ebf 9189
003ec0 9199              poptos
003ec1 6061              sbr     FLAGS1, (1<<idirty)
003ec2 9508              ret
                 
003ec3 fd42              fdw     CFETCH_L
                 CSTORE_L:
003ec4 6382
003ec5 0021              .db     NFA|2, "c!",0
                 CSTORE:
003ec6 3099              cpi     tosh, high(PEEPROM)
003ec7 f438              brcc    CSTORE1
                 CSTORE_RAM:
003ec8 01fc              movw zl, tosl
003ec9 9189
003eca 9199              poptos
003ecb 8380              std Z+0, tosl
003ecc 9189
003ecd 9199              poptos
003ece 9508              ret
                 CSTORE1:
003ecf 3890              cpi     tosh, high(OFLASH)
003ed0 f718              brcc    ICSTORE
                 ECSTORE:
003ed1 df81              rcall   LOCKEDQ
003ed2 99f9              sbic    eecr, eewe
003ed3 cffd              rjmp    ECSTORE
003ed4 5099              subi    tosh, high(PEEPROM)
003ed5 bd81              out     eearl, tosl
003ed6 bd92              out     eearh, tosh
003ed7 9189
003ed8 9199              poptos
003ed9 bd80              out     eedr, tosl
003eda 9afa              sbi     eecr, eemwe
003edb 9af9              sbi     eecr, eewe
003edc 9189
003edd 9199              poptos
003ede 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
003edf fd88              fdw     CSTORE_L
                 
                 FLOCK_L:
003ee0 6683
003ee1 2d6c              .db     NFA|3,"fl-"
003ee2 6064              sbr     FLAGS1, (1<<fLOCK)
003ee3 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003ee4 fdc0              fdw     FLOCK_L
                 FUNLOCK_L:
003ee5 6683
003ee6 2b6c              .db     NFA|3,"fl+"
003ee7 7f6b              cbr     FLAGS1, (1<<fLOCK)
003ee8 9508              ret
                 
                 
                 
003ee9 fdca              fdw     FUNLOCK_L
                 VALUE_L:
003eea 7685
003eeb 6c61
003eec 6575              .db     NFA|5,"value"
                 VALUE:
003eed d91d              rcall   CREATE
003eee 940e 3158         call    COMMA
003ef0 d96a              rcall   XDOES
                 VALUE_DOES:
003ef1 940e 30eb         call    DODOES
003ef3 940c 3e79         jmp     FETCH
                 
003ef5 fdd4              fdw     VALUE_L
                 DEFER_L:
003ef6 6485
003ef7 6665
003ef8 7265              .db     NFA|5,"defer"
                 DEFER:
003ef9 d911              rcall   CREATE
003efa 940e 37b9         call    DOLIT
003efc ef26              fdw     ABORT
003efd 940e 3158         call    COMMA
003eff d95b              rcall   XDOES
                 DEFER_DOES:
003f00 940e 30eb         call    DODOES
003f02 940c 30ae         jmp     FEXECUTE
                 
003f04 fdec              fdw     DEFER_L
                 IS_L:
003f05 69c2
003f06 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003f07 940e 37d5         call    TICK
003f09 940e 332b         call    TWOPLUS
003f0b 940e 332b         call    TWOPLUS
003f0d df6b              rcall   FETCH
003f0e d9ca              rcall   STATE_
003f0f 940e 33cf         call    ZEROSENSE
003f11 f029              breq    IS1
003f12 def2              rcall   LITERAL
003f13 940e 30fb         call    DOCOMMAXT
003f15 fc62              fdw     STORE
003f16 c001              rjmp    IS2
                 IS1:
003f17 df19              rcall   STORE
                 IS2:
003f18 9508              ret
                 
003f19 fe0a              fdw     IS_L
                 TO_L:
003f1a 74c2
003f1b 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003f1c 940c 3f07         jmp     IS
                 
003f1e fe34              fdw     TO_L
                 TURNKEY_L:
003f1f 7487
003f20 7275
003f21 6b6e
003f22 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003f23 940e 3ef1         call    VALUE_DOES      ; Must be call for IS to work.
003f25 01d7              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003f26 fe3e              fdw     TURNKEY_L
                 PAUSE_L:
003f27 7085
003f28 7561
003f29 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003f2a dc8a              rcall   IDLE_LOAD
                 .endif
003f2b b71f              in_     t1, SREG
003f2c 94f8              cli
003f2d 93df              push    yh        ; SP
003f2e 93cf              push    yl
003f2f 939f              push    tosh      ; TOS
003f30 938f              push    tosl
003f31 935f              push    ph        ; P
003f32 934f              push    pl
003f33 01f1              movw    zl, upl
003f34 b70e              in      t0, sph
003f35 9302              st      -z, t0
003f36 b70d              in      t0, spl
003f37 9302              st      -z, t0
003f38 91b2              ld      xh, -z     ; UP
003f39 91a2              ld      xl, -z
003f3a 011d              movw    upl, xl
003f3b 910e              ld      t0, -x
003f3c bf0e              out     sph, t0
003f3d 910e              ld      t0, -x
003f3e bf0d              out     spl, t0
003f3f 914f              pop     pl
003f40 915f              pop     ph
003f41 918f              pop     tosl
003f42 919f              pop     tosh
003f43 91cf              pop     yl
003f44 91df              pop     yh
003f45 bf1f              out_    SREG, t1
003f46 9508              ret
                 
                 
003f47 df7a              fdw     OPERATOR_L
                 ICOMMA_L:
003f48 6982
003f49 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f4a 940e 37ee         call    IHERE
003f4c dee4              rcall   STORE
003f4d 940e 3169         call    CELL
003f4f 940c 3995         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f51 fe90              fdw     ICOMMA_L
                 ICCOMMA_L:
003f52 6983
003f53 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f54 940e 37ee         call    IHERE
003f56 df6f              rcall   CSTORE
003f57 940e 3211         call    ONE
003f59 940c 3995         jmp     IALLOT
                 
                 L_DOTBASE:
003f5b 2081              .db      NFA|1," "
                 DOTBASE:
003f5c 940e 34ea         call    BASE
003f5e df1a              rcall   FETCH
003f5f 3180              cpi     tosl, 0x10
003f60 f411              brne    DOTBASE1
003f61 e284              ldi     tosl,'$'
003f62 c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f63 308a              cpi     tosl, 0xa
003f64 f411              brne    DOTBASE2
003f65 e283              ldi     tosl, '#'
003f66 c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f67 3082              cpi     tosl, 0x2
003f68 f411              brne    DOTBASE3
003f69 e285              ldi     tosl, '%'
003f6a c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f6b e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f6c 9508              ret
                 
                 MEMQADDR_N:
003f6d e256              fdw     ROM_N
003f6e e264              fdw     EROM_N
003f6f e274              fdw     FRAM_N
                 ;*******************************************************
                 umstar0:
003f70 920f              push t2
003f71 921f              push t3
003f72 9109              ld  t0, Y+
003f73 9119              ld  t1, Y+
003f74 9f80              mul tosl,t0
003f75 01d0              movw t4, r0 ; r0=t2, r1=t3
003f76 27ee              clr t6
003f77 27ff              clr t7
003f78 9f90              mul tosh, t0
003f79 0db0              add t5, r0
003f7a 1de1              adc t6, r1
003f7b 1df5              adc t7, zero
003f7c 9f81              mul tosl, t1
003f7d 0db0              add t5, r0
003f7e 1de1              adc t6, r1
003f7f 1df5              adc t7, zero
003f80 9f91              mul tosh, t1
003f81 0de0              add t6, r0
003f82 1df1              adc t7, r1
003f83 93ba              st -Y, t5
003f84 93aa              st -Y, t4
003f85 01cf              movw tosl, t6
003f86 901f              pop t3
003f87 900f              pop t2
003f88 9508              ret
                 
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
003f89 0000      STARTV: .dw      0
003f8a 8000      DPC:    .dw      OFLASH
003f8b 090c      DPE:    .dw      ehere
003f8c 030b      DPD:    .dw      dpdata
003f8d f69c      LW:     fdw      lastword
003f8e ee3a      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  16 r1 :  17 r2 :   5 r3 :   1 r4 :   3 r5 :  17 r6 :   6 r7 :   7 
r8 :   4 r9 :   4 r10:   6 r11:   6 r12:   3 r13:   3 r14:   3 r15:   2 
r16: 126 r17:  52 r18:   0 r19:   0 r20:  14 r21:   7 r22:  34 r23:  15 
r24: 220 r25: 184 r26:  62 r27:  46 r28:   9 r29:   5 r30:  72 r31:  49 
x  :  17 y  : 179 z  :  31 
Registers used: 33 out of 35 (94.3%)

ATmega328P instruction use summary:
.lds  :   0 .sts  :   0 adc   :  18 add   :  19 adiw  :  10 and   :   3 
andi  :  20 asr   :   2 bclr  :   4 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  19 brcs  :   1 break :   0 breq  :  44 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   5 
brne  :  37 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  92 cbi   :   3 cbr   :  20 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :  22 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   7 cp    :   4 cpc   :   2 
cpi   :  23 cpse  :   6 dec   :   4 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  14 in    :  19 inc   :   6 jmp   : 162 
ld    : 125 ldd   :   2 ldi   :  68 lds   :  22 lpm   :   7 lsl   :  11 
lsr   :   2 mov   :  15 movw  :  38 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   6 ori   :   7 out   :  32 pop   :  82 
push  :  28 rcall : 981 ret   : 128 reti  :   1 rjmp  :  92 rol   :  14 
ror   :  18 sbc   :   8 sbci  :   3 sbi   :  11 sbic  :   5 sbis  :   0 
sbiw  :   9 sbr   :  17 sbrc  :  12 sbrs  :  17 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   7 ses   :   0 set   :   1 sev   :   0 
sez   :   0 sleep :   1 spm   :   2 st    :  82 std   :   3 sts   :  26 
sub   :   2 subi  :  20 swap  :   2 tst   :   3 wdr   :   0 
Instructions used: 71 out of 113 (62.8%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007f1e   5590   2500   8090   32768  24.7%
[.dseg] 0x000100 0x00030d      0    525    525    2048  25.6%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 8 warnings
