
AVRASM ver. 2.1.42  E:\avr\src\ff-atmega.asm Sun Mar 02 14:43:21 2014

E:\avr\src\ff-atmega.asm(34): Including file 'E:\avr\src\config.inc'
E:\avr\src\config.inc(8): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m328def.inc'
E:\avr\src\ff-atmega.asm(72): warning: Register r26 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(73): warning: Register r27 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(74): warning: Register r30 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(75): warning: Register r31 already defined by the .DEF directive
E:\avr\src\ff-atmega.asm(238): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
E:\avr\src\ff-atmega.asm(239): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
E:\avr\src\ff-atmega.asm(240): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          02.03.2014                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2013  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"   ; 
                 ;.include "m2560def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 .include "m328def.inc"    ; Tested
                 
                 ;***** Created: 2011-08-25 20:59 ******* Source: ATmega328.xml ***********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328
                 ;* Date              : 2011-08-25
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328DEF_INC_
                 #define _M328DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328
                 #pragma AVRPART ADMIN PART_NAME ATmega328
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x14
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturbs the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program.
                 .equ BAUDRATE0 = 38400              ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 84                   ; 74 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 1
                 
                 
                 
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def iaddrl=r12       ; Not in interrupt
                   .def iaddrh=r13       ; Not in interrupt
                   .def ms_count  = r14       ; Not in interrupt
                   .def ms_count1 = r15       ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def il = r18         ; FOR..LOOP INDEX variable
                   .def ih = r19
                   .def pl = r20         ; P Register
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*256/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fBUSY=     7   ; 1 = busy
                 .equ fIDLE=     6   ; 1 = busy
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)              ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - KERNEL_START
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                 	
                 ;;; USER AREA for the OPERATOR task
                 ;.equ uaddsize=     0          ; No additional user variables 
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001d7           dpSTART:    .byte 2
0001d9           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001db           dpEEPROM:   .byte 2
0001dd           dpRAM:      .byte 2
0001df           dpLATEST:   .byte 2
                 
0001e1           areg:       .byte 2 ; A register data
0001e3           load_acc:   .byte 3 ; Load measurement accumulator
0001e6           load:       .byte 1 ; Cpu load in percent
0001e7           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0001e8           state:      .byte 1 ; Compilation state
0001e9           uvars:      .byte   (-us0)
000205           up0:        .byte   2
000207           urbuf:      .byte   ursize
000267           usbuf:      .byte   ussize
0002a7           utibbuf:    .byte   utibsize
0002fb           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
002f80 94e8              clt
002f81 2388              tst  tosl
002f82 f429              brne umslashmodstart
002f83 2399              tst  tosh
002f84 f419              brne umslashmodstart
002f85 9468              set  ; Set T flag
002f86 940c 3d5d         jmp  WARM_
                 umslashmodstart:
002f88 01dc              movw t4, tosl
                 
002f89 9019              ld t3, Y+
002f8a 91e9              ld t6, Y+
                   
002f8b 9189              ld tosl, Y+
002f8c 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
002f8d e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
002f8e 27ff              clr t7
002f8f 0f88              lsl tosl
002f90 1f99              rol tosh
002f91 1c11              rol t3
002f92 1fee              rol t6
002f93 1fff              rol t7
                 
                         ; try subtracting divisor
002f94 161a              cp  t3, t4
002f95 07eb              cpc t6, t5
002f96 05f5              cpc t7,zero
                 
002f97 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
002f98 9583              inc tosl
002f99 1a1a              sub t3, t4
002f9a 0beb              sbc t6, t5
                 
                 umslashmod2:
002f9b 950a              dec  t0
002f9c f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
002f9d 93ea              st -Y,t6
002f9e 921a              st -Y,t3
                 
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
002f9f 9508              ret
                 ; *******************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fa0 0000              .dw     0
                 EXIT_L:
002fa1 6584
002fa2 6978
002fa3 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fa4 910f              pop     t0
002fa5 910f              pop     t0
002fa6 9508              ret
                 
                 ; idle
002fa7 df42              fdw(EXIT_L)
                 IDLE_L:
002fa8 6984
002fa9 6c64
002faa 0065              .db     NFA|4,"idle",0
                 IDLE:
002fab 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fac 9508              ret
                         
                 ; busy
002fad df50              fdw(IDLE_L)
                 BUSY_L:
002fae 6284
002faf 7375
002fb0 0079              .db     NFA|4,"busy",0
                 BUSY:
002fb1 6470              sbr     FLAGS2, (1<<fIDLE)
002fb2 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fb3 feac              fdw     ICCOMMA_L
                 MSET_L:
002fb4 6d84
002fb5 6573
002fb6 0074              .db     NFA|4,"mset",0
                 MSET:
002fb7 01fc              movw    zl, tosl
002fb8 9189
002fb9 9199              poptos
002fba 8100              ld      t0, z
002fbb 2b08              or      t0, tosl
002fbc 8300              st      z, t0
002fbd 9189
002fbe 9199              poptos
002fbf 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002fc0 df68              fdw     MSET_L
                 MCLR_L:
002fc1 6d84
002fc2 6c63
002fc3 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002fc4 01fc              movw    zl, tosl
002fc5 9189
002fc6 9199              poptos
002fc7 8100              ld      t0, z
002fc8 9580              com     tosl
002fc9 2308              and     t0, tosl
002fca 8300              st      z, t0
002fcb 9189
002fcc 9199              poptos
002fcd 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
002fce df82              fdw     MCLR_L
                 LSHIFT_L:
002fcf 6c86
002fd0 6873
002fd1 6669
002fd2 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
002fd3 01fc              movw    zl, tosl
002fd4 9189
002fd5 9199              poptos
                 LSHIFT1:
002fd6 9731              sbiw    zl, 1
002fd7 f01a              brmi    LSHIFT2
002fd8 0f88              lsl     tosl
002fd9 1f99              rol     tosh
002fda cffb              rjmp    LSHIFT1
                 LSHIFT2:
002fdb 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
002fdc df9e              fdw     LSHIFT_L
                 RSHIFT_L:
002fdd 7286
002fde 6873
002fdf 6669
002fe0 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
002fe1 01fc              movw    zl, tosl
002fe2 9189
002fe3 9199              poptos
                 RSHIFT1:
002fe4 9731              sbiw    zl, 1
002fe5 f01a              brmi    RSHIFT2
002fe6 9596              lsr     tosh
002fe7 9587              ror     tosl
002fe8 cffb              rjmp    RSHIFT1
                 RSHIFT2:
002fe9 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
002fea d545              rcall   CFETCHPP
002feb d298              rcall   ROT
002fec d543              rcall   CFETCHPP
002fed 940c 3284         jmp     ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
002fef dfba              fdw     RSHIFT_L
                 NEQUAL_L:
002ff0 6e82
002ff1 003d              .db     NFA|2,"n=",0
                 NEQUAL:
002ff2 dff7              rcall   NEQUALSFETCH
002ff3 708f              andi    tosl, 0xf
002ff4 d337              rcall   EQUAL
002ff5 d3a6              rcall   ZEROSENSE
002ff6 f0b1              breq    NEQUAL5
002ff7 d2fb              rcall   ONEMINUS
002ff8 d537              rcall   CFETCHPP
002ff9 d291              rcall   TOR
002ffa c00c              rjmp    NEQUAL4
                 NEQUAL2:
002ffb dfee              rcall   NEQUALSFETCH
002ffc d328              rcall   NOTEQUAL
002ffd d39e              rcall   ZEROSENSE
002ffe f021              breq    NEQUAL3
002fff d733              rcall   TRUE_
003000 940e 3a46         call    LEAVE
003002 c004              rjmp    NEQUAL4
                 NEQUAL3:
003003 d29b              rcall   RFETCH
003004 d397              rcall   ZEROSENSE
003005 f409              brne    NEQUAL4
003006 d723              rcall   FALSE_
                 NEQUAL4:
003007 940e 3a36         call    XNEXT
003009 f788              brcc    NEQUAL2
00300a 911f              pop     t1
00300b 910f              pop     t0
00300c c001              rjmp    NEQUAL6
                 NEQUAL5:
00300d d725              rcall   TRUE_
                 NEQUAL6:
00300e d3ce              rcall   NIP
00300f 940c 33dd         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
003011 dfe0              fdw     NEQUAL_L
                 SKIP_L:
003012 7384
003013 696b
003014 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003015 d275              rcall   TOR
                 SKIP1:
003016 d77a              rcall   DUP
003017 d384              rcall   ZEROSENSE
003018 f049              breq    SKIP2
003019 d262              rcall   OVER
00301a d3e4              rcall   CFETCH_A
00301b d283              rcall   RFETCH
00301c d30f              rcall   EQUAL
00301d d37e              rcall   ZEROSENSE
00301e f019              breq    SKIP2
00301f d1bf              rcall   ONE
003020 d4ba              rcall   SLASHSTRING
003021 cff4              rjmp    SKIP1
                 SKIP2:
003022 910f              pop     t0
003023 910f              pop     t0
003024 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
003025 e024              fdw     SKIP_L
                 SCAN_L:
003026 7384
003027 6163
003028 006e              .db     NFA|4,"scan",0
                 SCAN:
003029 d328              rcall   STORE_P_TO_R
00302a d260              rcall   TOR
00302b c008              rjmp    SCAN3
                 SCAN1:
00302c d503              rcall   CFETCHPP
00302d 940e 3b0b         call    FETCH_P
00302f d2fc              rcall   EQUAL
003030 d36b              rcall   ZEROSENSE
003031 f011              breq    SCAN3
003032 d2c0              rcall   ONEMINUS
003033 c003              rjmp    SCAN4
                 SCAN3:
003034 940e 3a36         call    XNEXT
003036 f7a8              brcc    SCAN1
                 SCAN4:
003037 d25d              rcall   RFROM
003038 d2b5              rcall   ONEPLUS
003039 d323              rcall   R_TO_P
00303a 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
00303b e04c              fdw     SCAN_L
                 MTST_L:
00303c 6d84
00303d 7374
00303e 0074              .db     NFA|4,"mtst",0
                 MTST:
00303f 940e 3e9b         call    CFETCH
003041 940c 32c6         jmp     AND_
                 
003043 e078              fdw     MTST_L
                 FCY_L:
003044 4683
003045 7963              .db     NFA|3,"Fcy"
003046 d06a              rcall   DOCREATE
003047 3e80              .dw     FREQ_OSC / 1000
                 
                 ;*******************************************************
                 ; Assembler
                 ;*******************************************************
                 ; FIXME
                 ;*******************************************************
                         
                 
                 ;;; Check parameter stack pointer
003048 7383
003049 3f70              .db     NFA|3,"sp?"
                 check_sp:
00304a d089              rcall   SPFETCH
00304b 940e 38c1         call    R0_
00304d d67a              rcall   FETCH_A
00304e 940e 38bc         call    S0
003050 d677              rcall   FETCH_A
003051 d29c              rcall   ONEPLUS
003052 d2c8              rcall   WITHIN
003053 d1df              rcall   XSQUOTE
003054 5303
003055 3f50              .db     3,"SP?"
003056 d71e              rcall   QABORT
003057 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
003058 e088              fdw     FCY_L
                 EMIT_L:
003059 6584
00305a 696d
00305b 0074              .db     NFA|4,"emit",0
                 EMIT:
00305c d32f              rcall   UEMIT_
00305d 940c 307c         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
00305f e0b2              fdw     EMIT_L
                 KEY_L:
003060 6b83
003061 7965              .db     NFA|3,"key"
                 KEY:
003062 d32f              rcall   UKEY_
003063 940c 307c         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003065 e0c0              fdw     KEY_L
                 KEYQ_L:
003066 6b84
003067 7965
003068 003f              .db     NFA|4,"key?",0
                 KEYQ:
003069 d32e              rcall   UKEYQ_
00306a 940c 307c         jmp     FEXECUTE
                 
00306c e0cc              fdw     KEYQ_L
                 EXECUTE_L:
00306d 6587
00306e 6578
00306f 7563
003070 6574              .db     NFA|7,"execute"
                 EXECUTE:
003071 01fc              movw    zl, tosl
003072 58f0              sub_pflash_z
003073 9189
003074 9199              poptos
003075 9488              rampv_to_c
003076 95f7              ror     zh
003077 95e7              ror     zl
003078 9409              mijmp
                 
003079 e0da              fdw     EXECUTE_L
                 FEXECUTE_L:
00307a 4083
00307b 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
00307c d64b              rcall   FETCH_A
00307d 940c 3071         jmp     EXECUTE
                 
00307f e0f4              fdw     FEXECUTE_L
                 VARIABLE_L:
003080 7688
003081 7261
003082 6169
003083 6c62
003084 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
003085 d09b              rcall   HERE
003086 d0b0              rcall   CELL
003087 d1dc              rcall   ALLOT
003088 940c 309c 	jmp	CONSTANT_
                 
00308a e100              fdw     VARIABLE_L
                 TWOVARIABLE_L:
00308b 3289
00308c 6176
00308d 6972
00308e 6261
00308f 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
003090 d090              rcall   HERE
003091 d6f6              rcall   DOLIT
003092 0004              .dw     0x4
003093 d1d0              rcall   ALLOT
003094 940c 309c 	jmp	CONSTANT_
                 
003096 e116              fdw     TWOVARIABLE_L
                 CONSTANT_L:
003097 6388
003098 6e6f
003099 7473
00309a 6e61
00309b 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
00309c d7b6              rcall   COLON
00309d 940e 3dfd         call    LITERAL
00309f 940c 3861         jmp     SEMICOLON
                 
0030a1 e12e              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030a2 3289
0030a3 6f63
0030a4 736e
0030a5 6174
0030a6 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030a7 d1ca              rcall   SWOP
0030a8 d7aa              rcall   COLON
0030a9 940e 3dfd         call    LITERAL
0030ab 940e 3dfd         call    LITERAL
0030ad 940c 3861         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030af 2883
0030b0 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030b1 91ff              pop     zh
0030b2 91ef              pop     zl
0030b3 d00c              rcall   FETCHLIT
                         m_pop_zh
0030b4 91ff              pop     zh
0030b5 91ef              pop     zl
0030b6 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030b7 2883
0030b8 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030b9 91bf              pop     xh
0030ba 91af              pop     xl
                         m_pop_zh
0030bb 91ff              pop     zh
0030bc 91ef              pop     zl
0030bd d002              rcall   FETCHLIT
0030be 01fd              movw    z, x
0030bf 9409              mijmp    ; (z)
                 FETCHLIT:
0030c0 939a
0030c1 938a              pushtos
0030c2 0fee              lsl     zl
0030c3 1fff              rol     zh
0030c4 9185              lpm_    tosl, z+
0030c5 9195              lpm_    tosh, z+
0030c6 9508              ret
                 
0030c7 2883
0030c8 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
0030c9 91ff              pop     zh
0030ca 91ef              pop     zl
0030cb dff4              rcall   FETCHLIT
0030cc 95f7      	ror     zh
0030cd 95e7              ror     zl
0030ce 93ef              push    zl
0030cf 93ff              push    zh
                         m_push_t0
0030d0 c099              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
0030d1 e144              fdw     TWOCONSTANT_L
                 SPFETCH_L:
0030d2 7383
0030d3 4070              .db     NFA|3,"sp@"
                 SPFETCH:
0030d4 01fe              movw    z, y
0030d5 939a
0030d6 938a              pushtos
0030d7 01cf              movw    tosl, z
0030d8 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
0030d9 7383
0030da 2170              .db     NFA|3,"sp!"
                 SPSTORE:
0030db 01ec              movw    y, tosl
0030dc 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
0030dd 7283
0030de 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
0030df 91bf              pop     xh
0030e0 91af              pop     xl
0030e1 d7df              rcall   R0_
0030e2 d5e5              rcall   FETCH_A
0030e3 bf8d              out     spl, tosl
0030e4 bf9e              out     sph, tosh
0030e5 9189
0030e6 9199              poptos
0030e7 01fd              movw    zl, xl
0030e8 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
0030e9 e1a4              fdw     SPFETCH_L
                 RPFETCH_L:
0030ea 72b3
0030eb 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
0030ec 939a
0030ed 938a              pushtos
0030ee b78d              in      tosl, spl
0030ef b79e              in      tosh, sph
0030f0 9508              ret
                 
                 ;   ><  Swap bytes        
0030f1 e1d4              fdw     RPFETCH_L
                 SWAPB_L:
0030f2 3ea2
0030f3 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
0030f4 2f08              mov     t0, tosl
0030f5 2f89              mov     tosl, tosh
0030f6 2f90              mov     tosh, t0
0030f7 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
0030f8 e1e4              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
0030f9 6685
0030fa 616c
0030fb 6873              .db     NFA|5,"flash"
                 ROM_:
0030fc 9250 01e7         sts     cse, zero
0030fe 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
0030ff e1f2              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003100 6586
003101 7065
003102 6f72
003103 006d              .db     NFA|6,"eeprom",0
                 EROM:
003104 9270 01e7         sts     cse, r_two
003106 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
003107 e200              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
003108 7283
003109 6d61              .db     NFA|3,"ram"
                 FRAM:
00310a e004              ldi     t0, 4
00310b 9300 01e7         sts     cse, t0
00310d 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
00310e e210              fdw     RAM_L
                 DP_L:
00310f 6482
003110 0070              .db     NFA|2,"dp",0
                 DP:
003111 d714              rcall   IDP
003112 d004              rcall   CSE_
003113 940c 32b0         jmp     PLUS
                 
                 
                 ;;; 
003115 6383
003116 6573              .db     NFA|3,"cse"
                 CSE_:
003117 939a
003118 938a              pushtos
003119 9180 01e7         lds     tosl, cse
00311b 2799              clr     tosh
00311c 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
00311d e21e              fdw     DP_L
                 HERE_L:
00311e 6884
00311f 7265
003120 0065              .db     NFA|4,"here",0
                 HERE:
003121 dfef              rcall   DP
003122 940c 3e71         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003124 e23c              fdw     HERE_L
                 COMMA_L:
003125 2c81              .db     NFA|1,","
                 COMMA:
003126 dffa              rcall   HERE
003127 d416              rcall   STORE_A
003128 d00e              rcall   CELL
003129 940c 3264         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
00312b e24a              fdw     COMMA_L 
                 CCOMMA_L:
00312c 6382
00312d 002c              .db     NFA|2,"c,",0
                 CCOMMA:
00312e dff2              rcall   HERE
00312f d2d3              rcall   CSTORE_A
003130 d0ae              rcall   ONE
003131 940c 3264         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003133 e258              fdw     CCOMMA_L
                 CELL_L:
003134 6384
003135 6c65
003136 006c              .db     NFA|4,"cell",0
                 CELL:
003137 939a
003138 938a              pushtos
003139 e082              ldi     tosl, 2
00313a e090              ldi     tosh, 0
00313b 9508              ret
                 
                 ; ALIGN    --                         align DP
00313c e268              fdw     CELL_L
                 ALIGN_L:
00313d 6185
00313e 696c
00313f 6e67              .db     NFA|5,"align"
                 ALIGN:
003140 dfe0              rcall   HERE
003141 d008              rcall   ALIGNED
003142 dfce              rcall   DP
003143 940c 3e29         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
003145 e27a              fdw     ALIGN_L
                 ALIGNED_L:
003146 6187
003147 696c
003148 6e67
003149 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00314a 9601              adiw    tosl, 1
00314b d63c              rcall   DOLIT
00314c fffe              .dw     0xfffe
00314d 940c 32c6         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
00314f e28c              fdw     ALIGNED_L
                 CELLPLUS_L:
003150 63a5
003151 6c65
003152 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003153 9602              adiw    tosl, 2
003154 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
003155 e2a0              fdw     CELLPLUS_L
                 CELLS_L:
003156 63a5
003157 6c65
003158 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
003159 0f88              lsl     tosl
00315a 1f99              rol     tosh
00315b 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
00315c e2ac              fdw     CELLS_L
                 CHARPLUS_L:
00315d 63a5
00315e 6168
00315f 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
003160 9601              adiw    tosl, 1
003161 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
003162 e2ba              fdw     CHARPLUS_L
                 CHARS_L:
003163 63a5
003164 6168
003165 7372              .db     NFA|INLINE|5,"chars"
003166 9508      CHARS:  ret
                 
003167 e2c6              fdw     CHARS_L
                 COMMAXT_L:
003168 6383
003169 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
00316a d626              rcall   DUP
00316b d653              rcall   IHERE
00316c d150              rcall   MINUS
00316d d13d              rcall   ABS_ 
00316e d619              rcall   DOLIT
00316f 0ff0              .dw     0xff0
003170 d1c5              rcall   GREATER
003171 d22a              rcall   ZEROSENSE
003172 f059              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
003173 d614              rcall   DOLIT
                 .ifdef EIND
                 .else
003174 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
003175 940e 3f4e         call    ICOMMA
003177 5890              sub_pflash_tos
003178 9488              rampv_to_c
003179 9597              ror     tosh
00317a 9587              ror     tosl
00317b 940e 3f4e         call    ICOMMA
00317d c008              rjmp    STORECF2
                 STORECF1:
00317e d640              rcall   IHERE
00317f d13d              rcall   MINUS
003180 d71d              rcall   TWOMINUS
003181 d187              rcall   TWOSLASH
                         ;rcall   RCALL_
003182 709f              andi    tosh, 0x0f
003183 6d90              ori     tosh, 0xd0
003184 940e 3f4e         call    ICOMMA
                 STORECF2:
003186 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
003187 2186
003188 6f63
003189 6f6c
00318a 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
00318b d5fc              rcall   DOLIT
00318c fffa              .dw     0xfffa         ;  -6
00318d 940c 3965         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
00318f e2d0              fdw     COMMAXT_L
                 TWOFETCH_L:
003190 3282
003191 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
003192 d5fe              rcall   DUP
003193 d534              rcall   FETCH_A
003194 d0dd              rcall   SWOP
003195 dfbd              rcall   CELLPLUS
003196 940c 36c8         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
003198 e320              fdw     TWOFETCH_L
                 TWOSTORE_L:
003199 3282
00319a 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
00319b d0d6              rcall   SWOP
00319c d0df              rcall   OVER
00319d dfb5              rcall   CELLPLUS
00319e d39f              rcall   STORE_A
00319f 940c 3e29         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031a1 e332              fdw     TWOSTORE_L
                 TWODROP_L:
0031a2 3285
0031a3 7264
0031a4 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031a5 d0c5              rcall   DROP
0031a6 940c 326b         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031a8 e344              fdw     TWODROP_L
                 TWODUP_L:
0031a9 3284
0031aa 7564
0031ab 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031ac d0cf              rcall   OVER
0031ad 940c 327c         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031af e352              fdw     TWODUP_L
                 TWOSWAP_L:
0031b0 3285
0031b1 7773
0031b2 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031b3 d0d0              rcall   ROT
0031b4 d0d6              rcall   TOR
0031b5 d0ce              rcall   ROT
0031b6 d0de              rcall   RFROM
0031b7 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031b8 e360              fdw     TWOSWAP_L
                 SPACE_L:
0031b9 7385
0031ba 6170
0031bb 6563              .db     NFA|5,"space"
                 SPACE_:  
0031bc d6e6              rcall   BL
0031bd 940c 305c         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
0031bf e372              fdw     SPACE_L
                 SPACES_L:
0031c0 7386
0031c1 6170
0031c2 6563
0031c3 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
0031c4 d1dd              rcall   DUPZEROSENSE
0031c5 f019              breq    SPCS2
0031c6 dff5              rcall   SPACE_
0031c7 d12b              rcall   ONEMINUS
0031c8 cffb              rjmp    SPCS1
0031c9 940c 326b SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
0031cb e380              fdw     SPACES_L
                 UMIN_L:
0031cc 7584
0031cd 696d
0031ce 006e              .db     NFA|4,"umin",0
                 UMIN:
0031cf dfdc              rcall   TWODUP
0031d0 d173              rcall   UGREATER
0031d1 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
0031d2 e398              fdw     UMIN_L
                 UMAX_L:
0031d3 7584
0031d4 616d
0031d5 0078              .db     NFA|4,"umax",0
                 UMAX:
0031d6 dfd5              rcall   TWODUP
0031d7 d164              rcall   ULESS
                 MINMAX:
0031d8 d1c3              rcall   ZEROSENSE
0031d9 f009              breq    UMAX1
0031da d097              rcall   SWOP
0031db 940c 326b UMAX1:  jmp     DROP
                 
0031dd e3a6              fdw     UMAX_L
                 ONE_L:
0031de 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
0031df 939a
0031e0 938a              pushtos
0031e1 e081              ldi     tosl, 1
0031e2 e090              ldi     tosh, 0
0031e3 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
0031e4 e3bc              fdw     ONE_L
                 ACCEPT_L:
0031e5 6186
0031e6 6363
0031e7 7065
0031e8 0074              .db     NFA|6,"accept",0
                 ACCEPT:
0031e9 d092              rcall   OVER
0031ea d0c5              rcall   PLUS
0031eb d090              rcall   OVER
                 ACC1:
0031ec de75              rcall   KEY
                 
0031ed 308d              cpi     tosl, CR_
0031ee f429              brne    ACC_LF
                         
0031ef d543              rcall   TRUE_
0031f0 d02f              rcall   FCR
0031f1 d211              rcall   CSTORE_A
0031f2 d078              rcall   DROP
0031f3 c026              rjmp    ACC6
                 ACC_LF:
0031f4 308a              cpi     tosl, LF_
0031f5 f449              brne    ACC2
0031f6 d074              rcall   DROP
                 
0031f7 d028              rcall   FCR
0031f8 d206              rcall   CFETCH_A
0031f9 d1a2              rcall   ZEROSENSE
0031fa f0f9              breq    ACC6
0031fb d52e              rcall   FALSE_
0031fc d023              rcall   FCR
0031fd d205              rcall   CSTORE_A
0031fe cfed              rjmp    ACC1
                 ACC2:
0031ff d52a              rcall   FALSE_
003200 d01f              rcall   FCR
003201 d201              rcall   CSTORE_A
003202 d58e              rcall   DUP
003203 de58              rcall   EMIT
003204 d58c              rcall   DUP
003205 d582              rcall   DOLIT
003206 0008              .dw     BS_
003207 d124              rcall   EQUAL
003208 d193              rcall   ZEROSENSE
003209 f039              breq    ACC3
00320a d060              rcall   DROP
00320b d0e7              rcall   ONEMINUS
00320c d07e              rcall   TOR
00320d d06e              rcall   OVER
00320e d086              rcall   RFROM
00320f dfc6              rcall   UMAX
003210 cfdb              rjmp    ACC1
                 ACC3:
003211 d06a              rcall   OVER
003212 d1f0              rcall   CSTORE_A
003213 d0da              rcall   ONEPLUS
003214 d067              rcall   OVER
003215 dfb9              rcall   UMIN
003216 df95              rcall   TWODUP
003217 d10d              rcall   NOTEQUAL
003218 d183              rcall   ZEROSENSE
003219 f691              brne     ACC1
                 ACC6:
00321a d1c2              rcall   NIP
00321b d056              rcall   SWOP
00321c 940c 32bd         jmp     MINUS
                 
00321e 6683
00321f 7263              .db     NFA|3,"fcr"
                 FCR:
003220 d2a2              rcall   DOUSER
003221 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
003222 e3ca              fdw      ACCEPT_L
                 TYPE_L:
003223 7484
003224 7079
003225 0065              .db     NFA|4,"type",0
                 TYPE:
003226 d064              rcall   TOR
003227 c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
003228 d307              rcall   CFETCHPP
003229 de32              rcall   EMIT
                 TYPE2:
00322a 940e 3a36         call    XNEXT
00322c f7d8              brcc    TYPE1
00322d 911f              pop     t1
00322e 910f              pop     t0
00322f 940c 326b         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
003231 2883
003232 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
003233 d06b              rcall   RFETCH
003234 0f88              lsl     tosl
003235 1f99              rol     tosh
003236 5890              add_pflash_tos
003237 d2f8              rcall   CFETCHPP
003238 d558              rcall   DUP
003239 d0b4              rcall   ONEPLUS
00323a df0f              rcall   ALIGNED
00323b 9596              lsr     tosh
00323c 9587              ror     tosl
00323d d057              rcall   RFROM
00323e d071              rcall   PLUS
00323f 01fc              movw    zl, tosl
003240 9189
003241 9199              poptos
003242 9409              mijmp
                 
003243 e446              fdw     TYPE_L
                 SQUOTE_L:
003244 73d2
003245 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
003246 de82              rcall   DOCOMMAXT
003247 e466              fdw     XSQUOTE
003248 deb3              rcall   ROM_
003249 d005              rcall   CQUOTE
00324a 940c 310a         jmp     FRAM
                 
00324c e488              fdw     SQUOTE_L
                 CQUOTE_L:
00324d 2c82
00324e 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
00324f d538              rcall   DOLIT
003250 0022              .dw     0x22
003251 d29c              rcall   PARSE
003252 dece              rcall   HERE
003253 d028              rcall   OVER
003254 d099              rcall   ONEPLUS
003255 def4              rcall   ALIGNED
003256 d00d              rcall   ALLOT
003257 940c 3527         jmp     PLACE
                 
                 
003259 e49a              fdw     CQUOTE_L
                 DOTQUOTE_L:
00325a 2ed2
00325b 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
00325c dfe9              rcall   SQUOTE
00325d de6b              rcall   DOCOMMAXT
00325e e44c              fdw     TYPE
00325f 9508              ret
                 
003260 e4b4              fdw     DOTQUOTE_L
                 ALLOT_L:
003261 6185
003262 6c6c
003263 746f              .db     NFA|5,"allot"
                 ALLOT:
003264 deac              rcall   DP
003265 940c 330f         jmp     PLUSSTORE
                 
003267 e4c2              fdw     ALLOT_L
                 DROP_L:
003268 64a4
003269 6f72
00326a 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
00326b 9189
00326c 9199              poptos
00326d 9508              ret
                 
00326e e4d0              fdw     DROP_L
                 SWOP_L:
00326f 7384
003270 6177
003271 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
003272 9109              ld      t0, y+
003273 9119              ld      t1, y+
003274 939a
003275 938a              pushtos
003276 01c8              movw    tosl, t0
003277 9508              ret
                 
003278 e4de              fdw     SWOP_L
                 OVER_L:
003279 6f84
00327a 6576
00327b 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
00327c 939a
00327d 938a              pushtos
00327e 818a              ldd     tosl, y+2
00327f 819b              ldd     tosh, y+3
003280 9508              ret
                 
003281 e4f2              fdw     OVER_L
                 ROT_L:
003282 7283
003283 746f              .db     NFA|3, "rot"
                 ROT:
003284 d006              rcall   TOR
003285 dfec              rcall   SWOP
003286 d00e              rcall   RFROM
003287 cfea              rjmp    SWOP
                 
003288 e504              fdw     ROT_L
                 TOR_L:
003289 3e92
00328a 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
00328b 91ff              pop     zh
00328c 91ef              pop     zl
00328d 938f              push    tosl
00328e 939f              push    tosh
00328f 9189
003290 9199              poptos
003291 9409              mijmp
                 
003292 e512              fdw     TOR_L
                 RFROM_L:
003293 7292
003294 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
003295 91ff              pop     zh
003296 91ef              pop     zl
003297 939a
003298 938a              pushtos
003299 919f              pop     tosh
00329a 918f              pop     tosl
00329b 9409              mijmp
                 
00329c e526              fdw     RFROM_L
                 RFETCH_L:
00329d 7292
00329e 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
00329f 91ff              pop     zh
0032a0 91ef              pop     zl
0032a1 939a
0032a2 938a              pushtos
0032a3 919f              pop     tosh
0032a4 918f              pop     tosl
0032a5 938f              push    tosl
0032a6 939f              push    tosh
0032a7 9409              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
0032a8 ef1e              fdw     DUP_L
                 ABS_L:
0032a9 6183
0032aa 7362              .db     NFA|3,"abs"
                 ABS_:
0032ab d4e5              rcall   DUP
0032ac 940c 33ec         jmp     QNEGATE
                 
0032ae e552              fdw     ABS_L
                 PLUS_L:
0032af 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032b0 9109              ld      t0, Y+        
0032b1 9119              ld      t1, Y+
0032b2 0f80              add     tosl, t0
0032b3 1f91              adc     tosh, t1
0032b4 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032b5 e55e              fdw     PLUS_L
                 MPLUS_L:
0032b6 6d82
0032b7 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032b8 d7a1              rcall   STOD
0032b9 940c 3a7c         jmp     DPLUS
                 
0032bb e56c              fdw     MPLUS_L
                 MINUS_L:
0032bc 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
0032bd 9109              ld      t0, Y+
0032be 9119              ld      t1, Y+
0032bf 1b08              sub     t0, tosl
0032c0 0b19              sbc     t1, tosh
0032c1 01c8              movw    tosl, t0
0032c2 9508              ret
                 
0032c3 e578              fdw     MINUS_L
                 AND_L:
0032c4 6183
0032c5 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
0032c6 9109              ld      t0, Y+
0032c7 9119              ld      t1, Y+
0032c8 2380              and     tosl, t0
0032c9 2391              and     tosh, t1
0032ca 9508              ret
                 
0032cb e588              fdw     AND_L
                 OR_L:
0032cc 6f82
0032cd 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
0032ce 9109              ld      t0, Y+
0032cf 9119              ld      t1, Y+
0032d0 2b80              or      tosl, t0
0032d1 2b91              or      tosh, t1
0032d2 9508              ret
                 
0032d3 e598              fdw     OR_L
                 XOR_L:
0032d4 7883
0032d5 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
0032d6 9109              ld      t0, Y+
0032d7 9119              ld      t1, Y+
0032d8 2780              eor     tosl, t0
0032d9 2791              eor     tosh, t1
0032da 9508              ret
                 
0032db e5a8              fdw     XOR_L
                 INVERT_L:
0032dc 69a6
0032dd 766e
0032de 7265
0032df 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
0032e0 9580              com     tosl
0032e1 9590              com     tosh
0032e2 9508              ret
                 
0032e3 e5b8              fdw     INVERT_L
                 NEGATE_L:
0032e4 6e86
0032e5 6765
0032e6 7461
0032e7 0065              .db     NFA|6, "negate",0
                 NEGATE:
0032e8 dff7              rcall   INVERT
0032e9 940c 32ee         jmp     ONEPLUS
                 
0032eb e5c8              fdw     NEGATE_L
                 ONEPLUS_L:
0032ec 31a2
0032ed 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
0032ee 9601              adiw    tosl, 1
0032ef 9508              ret
                 
0032f0 e5d8              fdw     ONEPLUS_L
                 ONEMINUS_L:
0032f1 31a2
0032f2 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
0032f3 9701              sbiw    tosl, 1
0032f4 9508              ret
                 
0032f5 e5e2              fdw     ONEMINUS_L
                 TWOPLUS_L:
0032f6 32a2
0032f7 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
0032f8 9602              adiw    tosl, 2
0032f9 9508              ret
                 
0032fa e5ec              fdw     TWOPLUS_L
                 TOBODY_L:
0032fb 3ea5
0032fc 6f62
0032fd 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
0032fe 9604              adiw    tosl, 4
0032ff 9508              ret
                 
003300 e5f6              fdw     TOBODY_L
                 TWOSTAR_L:
003301 32a2
003302 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003303 0f88              lsl     tosl
003304 1f99              rol     tosh
003305 9508              ret
                 
003306 e602              fdw     TWOSTAR_L
                 TWOSLASH_L:
003307 32a2
003308 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
003309 9595              asr     tosh
00330a 9587              ror     tosl
00330b 9508              ret
                 
00330c e60e              fdw     TWOSLASH_L
                 PLUSSTORE_L:
00330d 2b82
00330e 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
00330f df62              rcall   SWOP
003310 df6b              rcall   OVER
003311 d3b6              rcall   FETCH_A
003312 df9d              rcall   PLUS
003313 df5e              rcall   SWOP
003314 940c 3e29         jmp     STORE
                 
003316 e61a              fdw     PLUSSTORE_L
                 WITHIN_L:
003317 7786
003318 7469
003319 6968
00331a 006e              .db     NFA|6,"within",0
                 WITHIN:
00331b df60              rcall   OVER
00331c dfa0              rcall   MINUS
00331d df6d              rcall   TOR
00331e df9e              rcall   MINUS
00331f df75              rcall   RFROM
003320 940c 333c         jmp     ULESS
                 
003322 e62e              fdw     WITHIN_L
                 NOTEQUAL_L:
003323 3c82
003324 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
003325 df97              rcall	MINUS        	; MINUS leaves a valid zero flag
003326 f409              brne	NOTEQUAL1
003327 c479              rjmp	FALSE_F
                 NOTEQUAL1:
003328 940c 3799         jmp	TRUE_F
                 
00332a ef3a              fdw     ZEROLESS_L
                 EQUAL_L:
00332b 3d81              .db     NFA|1, "="
                 EQUAL:
00332c df90              rcall   MINUS
00332d 940c 3797         jmp     ZEROEQUAL
                 
                 
00332f e656              fdw     EQUAL_L
                 LESS_L:
003330 3c81              .db     NFA|1,"<"
                 LESS:
003331 df8b              rcall   MINUS
003332 940c 379f         jmp     ZEROLESS
                 
003334 e660              fdw     LESS_L
                 GREATER_L:
003335 3e81              .db     NFA|1,">"
                 GREATER:
003336 df3b              rcall   SWOP
003337 940c 3331         jmp     LESS
                 
003339 e66a              fdw     GREATER_L
                 ULESS_L:
00333a 7582
00333b 003c              .db     NFA|2,"u<",0
                 ULESS:
00333c df80              rcall   MINUS
00333d f408              brcc    ULESS1        ; Carry test  
00333e c45a              rjmp    TRUE_F
                 ULESS1:
00333f 940c 37a1         jmp     FALSE_F
                 
                 
003341 e674              fdw     ULESS_L
                 UGREATER_L:
003342 7582
003343 003e              .db     NFA|2, "u>",0
                 UGREATER:
003344 df2d              rcall   SWOP
003345 940c 333c         jmp     ULESS
                 
003347 e684              fdw     UGREATER_L
                 STORE_P_L:
003348 2182
003349 0070              .db     NFA|2,"!p",0
                 STORE_P:
00334a 01ac              movw    pl, tosl
00334b 9189
00334c 9199              poptos
00334d 9508              ret
                 
00334e e690              fdw     STORE_P_L
                 STORE_P_TO_R_L:
00334f 2194
003350 3e70
003351 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
003352 91ff              pop     zh
003353 91ef              pop     zl
003354 934f              push    pl
003355 935f              push    ph
003356 01ac              movw    pl, tosl
003357 9189
003358 9199              poptos
003359 9409              mijmp
                 
00335a e69e              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
00335b 7293
00335c 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
00335d 91ff              pop     zh
00335e 91ef              pop     zl
00335f 915f              pop     ph
003360 914f              pop     pl
003361 9409              mijmp
                 
003362 e6b6              fdw     R_TO_P_L
                 PFETCH_L:
003363 7082
003364 0040              .db     NFA|2,"p@",0
                 PFETCH:
003365 939a
003366 938a              pushtos
003367 01ca              movw    tosl, pl
003368 940c 3e71         jmp     FETCH
                 
00336a e6c6              fdw     PFETCH_L
                 PSTORE_L:
00336b 7082
00336c 0021              .db     NFA|2,"p!",0
                 PSTORE:
00336d 939a
00336e 938a              pushtos
00336f 01ca              movw    tosl, pl
003370 940c 3e29         jmp     STORE
                 
003372 e6d6              fdw     PSTORE_L
                 PCSTORE_L:
003373 7083
003374 2163              .db     NFA|3,"pc!"
                 PCSTORE:
003375 939a
003376 938a              pushtos
003377 01ca              movw    tosl, pl
003378 940c 3ebe         jmp     CSTORE
                 
00337a e6e6              fdw     PCSTORE_L
                 PPLUS_L:
00337b 70a2
00337c 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
00337d 0d46              add     pl, r_one
00337e 1d55              adc     ph, zero
00337f 9508              ret   
                 
003380 e6f6              fdw     PPLUS_L
                 PNPLUS_L:
003381 7083
003382 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
003383 0f48              add     pl, tosl
003384 1f59              adc     ph, tosh
003385 9189
003386 9199              poptos
003387 9508              ret
                 
003388 e702              fdw     PNPLUS_L
                 UEMIT_L:
003389 2785
00338a 6d65
00338b 7469              .db     NFA|5,"'emit"
                 UEMIT_:
00338c d136              rcall   DOUSER
00338d ffe8              .dw     uemit
                         
00338e e712              fdw     UEMIT_L
                 UKEY_L:
00338f 2784
003390 656b
003391 0079              .db     NFA|4,"'key",0
                 UKEY_:
003392 d130              rcall   DOUSER
003393 ffea              .dw     ukey
                 
003394 e71e              fdw     UKEY_L
                 UKEYQ_L:
003395 2785
003396 656b
003397 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
003398 d12a              rcall   DOUSER
003399 ffec              .dw     ukeyq
                 
00339a 3f83
00339b 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
00339c 9700              sbiw    tosl, 0
00339d 9189
00339e 9199              poptos
00339f 9508              ret
                 
0033a0 6483
0033a1 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
0033a2 9700              sbiw    tosl, 0
0033a3 9508              ret
                 
0033a4 e72a              fdw     UKEYQ_L
                 UMSTAR_L:
0033a5 7583
0033a6 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
0033a7 940c 3f85         jmp     umstar0
                 
0033a9 e74a              fdw     UMSTAR_L
                 UMSLASHMOD_L:
0033aa 7586
0033ab 2f6d
0033ac 6f6d
0033ad 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
0033ae 940c 2f80         jmp     umslashmod0
                 
                 
0033b0 e754              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
0033b1 7585
0033b2 6d2f
0033b3 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
0033b4 d375              rcall   FALSE_
0033b5 debc              rcall   SWOP
0033b6 940c 2f80         jmp     umslashmod0
                 
0033b8 e762              fdw     USLASHMOD_L
                 STAR_L:
0033b9 2a81              .db     NFA|1,"*"
                 STAR: 
0033ba dfec              rcall   UMSTAR
0033bb 940c 326b         jmp     DROP
                 
0033bd e772              fdw     STAR_L
                 USLASH_L:
0033be 7582
0033bf 002f              .db     NFA|2,"u/",0
                 USLASH:
0033c0 dff3              rcall   USLASHMOD
0033c1 940c 33dd         jmp     NIP
                 
0033c3 e77c              fdw     USLASH_L
                 USSMOD_L:
0033c4 7586
0033c5 2f2a
0033c6 6f6d
0033c7 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
0033c8 dec2              rcall   TOR
0033c9 dfdd              rcall   UMSTAR
0033ca deca              rcall   RFROM
0033cb 940c 33ae         jmp     UMSLASHMOD
                 
                 
0033cd e788              fdw     USSMOD_L
                 SLASH_L:
0033ce 2f81              .db     NFA|1,"/"
                 SLASH: 
0033cf dddc              rcall   TWODUP
0033d0 df05              rcall   XOR_
0033d1 deb9              rcall   TOR
0033d2 ded8              rcall   ABS_
0033d3 de9e              rcall   SWOP
0033d4 ded6              rcall   ABS_
0033d5 de9c              rcall   SWOP
0033d6 dfe9              rcall   USLASH
0033d7 debd              rcall   RFROM
0033d8 940c 33ec         jmp     QNEGATE
                 
0033da e79c              fdw     SLASH_L
                 NIP_L:
0033db 6e83
0033dc 7069              .db     NFA|3,"nip"
                 NIP:
0033dd de94              rcall   SWOP
0033de 940c 326b         jmp     DROP
                     
0033e0 e7b6              fdw     NIP_L
                 TUCK_L:
0033e1 7484
0033e2 6375
0033e3 006b              .db     NFA|4,"tuck",0
                 TUCK:
0033e4 de8d              rcall   SWOP
0033e5 940c 327c         jmp     OVER
                 
0033e7 e7c2              fdw     TUCK_L
                 QNEGATE_L:
0033e8 3f87
0033e9 656e
0033ea 6167
0033eb 6574              .db     NFA|7,"?negate"
                 QNEGATE:
0033ec d3b2              rcall   ZEROLESS
0033ed dfae              rcall   ZEROSENSE
0033ee f009              breq    QNEGATE1
0033ef def8              rcall   NEGATE
                 QNEGATE1:
0033f0 9508              ret
                 
0033f1 e7d0              fdw     QNEGATE_L
                 MAX_L:
0033f2 6d83
0033f3 7861              .db     NFA|3,"max"
0033f4 ddb7      MAX:    rcall   TWODUP
0033f5 df3b              rcall   LESS
0033f6 cde1              rjmp    MINMAX
                 
0033f7 e7e4              fdw     MAX_L
                 MIN_L:
0033f8 6d83
0033f9 6e69              .db     NFA|3,"min"
0033fa ddb1      MIN:    rcall   TWODUP
0033fb df3a              rcall   GREATER
0033fc cddb              rjmp    MINMAX
                 
0033fd 6382
0033fe 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
0033ff 940c 3e9b         jmp     CFETCH
                 
003401 6382
003402 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003403 940c 3ebe         jmp     CSTORE
                 
003405 e7f0              fdw     MIN_L
                 UPTR_L:
003406 7582
003407 0070              .db     NFA|2,"up",0
003408 dca8      UPTR:   rcall   DOCREATE
003409 0002              .dw     2 ; upl
                 
00340a e80c              fdw     UPTR_L
                 HOLD_L:
00340b 6884
00340c 6c6f
00340d 0064              .db     NFA|4,"hold",0
00340e d324      HOLD:   rcall   TRUE_
00340f d09a              rcall   HP
003410 defe              rcall   PLUSSTORE
003411 d098              rcall   HP
003412 d2b5              rcall   FETCH_A
003413 940c 3ebe         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
003415 e816              fdw     HOLD_L
                 LESSNUM_L:
003416 3c82
003417 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
003418 d096              rcall   PAD
003419 d090              rcall   HP
00341a 940c 3e29         jmp     STORE
                 
                 ; >digit   n -- c            convert to 0..9a..z
00341c e82c              fdw     LESSNUM_L
                 TODIGIT_L:
00341d 3e86
00341e 6964
00341f 6967
003420 0074              .db     NFA|6,">digit",0
                 TODIGIT: 
003421 d36f              rcall   DUP
003422 d365              rcall   DOLIT
003423 0009              .dw     9
003424 df11              rcall   GREATER
003425 d362              rcall   DOLIT
003426 0027              .dw     0x27
003427 de9e              rcall   AND_
003428 de87              rcall   PLUS
003429 d35e              rcall   DOLIT
00342a 0030              .dw     0x30
00342b 940c 32b0         jmp     PLUS
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
00342d e83a              fdw     TODIGIT_L
                 NUM_L:
00342e 2381              .db     NFA|1,"#"
                 NUM:
00342f d086              rcall   BASE
003430 d297              rcall   FETCH_A
003431 d197              rcall   UDSLASHMOD
003432 de51              rcall   ROT
003433 dfed              rcall   TODIGIT
003434 940c 340e         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
003436 e85c              fdw     NUM_L
                 NUMS_L:
003437 2382
003438 0073              .db     NFA|2,"#s",0
                 NUMS:
003439 dff5              rcall   NUM
00343a dd71              rcall   TWODUP
00343b de92              rcall   OR_
00343c df5f              rcall   ZEROSENSE
00343d f7d9              brne    NUMS
00343e 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
00343f e86e              fdw     NUMS_L
                 NUMGREATER_L:
003440 2382
003441 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
003442 dd62              rcall   TWODROP
003443 d066              rcall   HP
003444 d283              rcall   FETCH_A
003445 d069              rcall   PAD
003446 de35              rcall   OVER
003447 940c 32bd         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
003449 e880              fdw     NUMGREATER_L
                 SIGN_L:
00344a 7384
00344b 6769
00344c 006e              .db     NFA|4,"sign",0
                 SIGN:   
00344d d351              rcall   ZEROLESS
00344e df4d              rcall   ZEROSENSE
00344f f019              breq    SIGN1
003450 d337              rcall   DOLIT
003451 002d              .dw     0x2D
003452 dfbb              rcall   HOLD
                 SIGN1:
003453 9508              ret
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
003454 e894              fdw     SIGN_L
                 UDOT_L:
003455 7582
003456 002e              .db     NFA|2,"u.",0
                 UDOT:
003457 dfc0              rcall   LESSNUM
003458 d2d1              rcall   FALSE_
003459 dfdf              rcall   NUMS
00345a dfe7              rcall   NUMGREATER
00345b ddca              rcall   TYPE
00345c 940c 31bc         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
00345e e8aa              fdw     UDOT_L
                 UDOTR_L:
00345f 7583
003460 722e              .db     NFA|3,"u.r"
                 UDOTR:
003461 dfb6              rcall   LESSNUM
003462 de90              rcall   ONEMINUS
003463 de27              rcall   TOR
003464 d2c5              rcall   FALSE_
003465 c001              rjmp    UDOTR2
                 UDOTR1:
003466 dfc8              rcall   NUM
                 UDOTR2: 
003467 d5ce              rcall   XNEXT
003468 f7e8              brcc    UDOTR1
003469 911f              pop     t1
00346a 910f              pop     t0
00346b dfcd              rcall   NUMS
00346c dfd5              rcall   NUMGREATER
00346d ddb8              rcall   TYPE
00346e 940c 31bc         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
003470 e8be              fdw     UDOTR_L
                 DOT_L:
003471 2e81              .db     NFA|1,"."
003472 dfa5      DOT:    rcall   LESSNUM
003473 d31d              rcall   DUP
003474 de36              rcall   ABS_
003475 d2b4              rcall   FALSE_
003476 dfc2              rcall   NUMS
003477 de0c              rcall   ROT
003478 dfd4              rcall   SIGN
003479 dfc8              rcall   NUMGREATER
00347a ddab              rcall   TYPE
00347b 940c 31bc         jmp     SPACE_
                 
00347d e8e2              FDW     DOT_L
                 DECIMAL_L:
00347e 6487
00347f 6365
003480 6d69
003481 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
003482 d27f              rcall   TEN
003483 d032              rcall   BASE
003484 940c 3e29         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
003486 e8fc              Fdw     DECIMAL_l
                 HEX_L:
003487 6883
003488 7865              .db     NFA|3,"hex"
                 HEX:
003489 d2fe              rcall   DOLIT
00348a 0010              .dw     16
00348b d02a              rcall   BASE
00348c 940c 3e29         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
00348e e90e              Fdw     HEX_L
                 BIN_L:
00348f 6283
003490 6e69              .db     NFA|3,"bin"
003491 dca5      BIN:    rcall   CELL
003492 d023              rcall   BASE
003493 940c 3e29         jmp     STORE
                 
                 #ifndef SKIP_MULTITASKING
                 ; RSAVE   -- a-addr     Saved return stack pointer
003495 e91e              fdw     BIN_L
                 RSAVE_L:
003496 7285
003497 6173
003498 6576              .db     NFA|5,"rsave"
003499 d029      RSAVE_: rcall   DOUSER
00349a fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
00349b e92c              fdw     RSAVE_L
                 ULINK_L:
00349c 7585
00349d 696c
00349e 6b6e              .db     NFA|5,"ulink"
00349f d023      ULINK_: rcall   DOUSER
0034a0 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034a1 e938              fdw     ULINK_L
                 #else
                 #endif
                 TASK_L:
0034a2 7484
0034a3 7361
0034a4 006b              .db     NFA|4,"task",0
0034a5 d01d      TASK:   rcall   DOUSER
0034a6 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034a7 e944              fdw     TASK_L
                 HP_L:
0034a8 6882
0034a9 0070              .db     NFA|2,"hp",0
0034aa d018      HP:     rcall   DOUSER
0034ab 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
0034ac e950              fdw     HP_L
                 PAD_L:
0034ad 7083
0034ae 6461              .db     NFA|3,"pad"
                 PAD:
0034af d19e              rcall   TIB
0034b0 d195              rcall   TIBSIZE
0034b1 940c 32b0         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
                 ;        fdw     PAD_L
                 BASE_L:
0034b3 6284
0034b4 7361
0034b5 0065              .db     NFA|4,"base",0
                 BASE:
0034b6 d00c              rcall   DOUSER
0034b7 ffee              .dw     ubase
                 
                 ; USER   n --
0034b8 e95a              fdw     PAD_L
                 USER_L:
0034b9 7584
0034ba 6573
0034bb 0072              .db     NFA|4,"user",0
                 USER:
0034bc d31f              rcall   CREATE
0034bd dc79              rcall   CELL
0034be de29              rcall	NEGATE
0034bf d4a5              rcall   IALLOT
0034c0 940e 3f4e         call    ICOMMA
0034c2 d369              rcall   XDOES
                 DOUSER:
0034c3 939a
0034c4 938a              pushtos
                         m_pop_zh
0034c5 91ff              pop     zh
0034c6 91ef              pop     zl
0034c7 0fee              lsl     zl
0034c8 1fff              rol     zh
0034c9 9185              lpm_    tosl, z+
0034ca 9195              lpm_    tosh, z+
0034cb 0d82              add     tosl, upl
0034cc 1d93              adc     tosh, uph
0034cd 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
0034ce e972              fdw     USER_L
                 SOURCE_L:
0034cf 7386
0034d0 756f
0034d1 6372
0034d2 0065              .db     NFA|6,"source",0
                 SOURCE:
0034d3 d18c              rcall   TICKSOURCE
0034d4 940c 3192         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
0034d6 e99e              fdw      SOURCE_L
                 SLASHSTRING_L:
0034d7 2f87
0034d8 7473
0034d9 6972
0034da 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
0034db dd96              rcall   SWOP
0034dc dd9f              rcall   OVER
0034dd dddf              rcall   MINUS
0034de ddac              rcall   TOR
0034df ddd0              rcall   PLUS
0034e0 ddb4              rcall   RFROM
0034e1 9508              ret
                 
                 ; \     Skip the rest of the line
0034e2 e9ae              fdw     SLASHSTRING_L
                 BSLASH_L:
0034e3 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
0034e4 dfee              rcall   SOURCE
0034e5 d173              rcall   TOIN
0034e6 d057              rcall   STORE_A
0034e7 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
0034e8 940c 326b         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
0034ea e9c6              fdw     BSLASH_L
                 PARSE_L:
0034eb 7085
0034ec 7261
0034ed 6573              .db     NFA|5,"parse"
                 PARSE:
0034ee d2a2              rcall   DUP             ; c c
0034ef dfe3              rcall   SOURCE          ; c c a u
0034f0 d168              rcall   TOIN            ; c c a u a
0034f1 d1d6              rcall   FETCH_A         ; c c a u n
0034f2 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
0034f3 d29d              rcall   DUP             ; c c a u u
0034f4 dd96              rcall   TOR             ; c c a u                  R: u (new tib len
0034f5 dd8e              rcall   ROT             ; c a u c
0034f6 db1e              rcall   SKIP            ; c a u        
0034f7 dd84              rcall   OVER            ; c a u a
0034f8 dd92              rcall   TOR             ; c a u                    R: u a (start of word
0034f9 dd8a              rcall   ROT             ; a u c
0034fa db2e              rcall   SCAN            ; a u      end of word, tib left       
0034fb dea6              rcall   DUPZEROSENSE
0034fc f009              breq    PARSE1
0034fd ddf5              rcall   ONEMINUS
0034fe dd96      PARSE1: rcall   RFROM           ; a u a
0034ff dd95              rcall   RFROM           ; a u a u
003500 dd83              rcall   ROT             ; a a u u
003501 ddbb              rcall   MINUS           ; a a n  ( addition to toin
003502 d156              rcall   TOIN
003503 de0b              rcall   PLUSSTORE       ; aend astart
003504 dedf              rcall   TUCK            ; astart aend astart
003505 940c 32bd         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
003507 e9d6              fdw     PARSE_L
                 WORD_L:
003508 7784
003509 726f
00350a 0064              .db     NFA|4,"word",0
                 WORD:
00350b dfe2              rcall   PARSE           ; c-addr wlen
00350c dd65              rcall   SWOP
00350d dde5              rcall   ONEMINUS
00350e ded5              rcall   TUCK
00350f 940c 3ebe         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
003511 ea10              fdw     WORD_L
                 CMOVE_L:
003512 6385
003513 6f6d
003514 6576              .db     NFA|5,"cmove"
                 CMOVE:
003515 dd5c              rcall   SWOP
003516 de3b              rcall   STORE_P_TO_R
003517 dd73              rcall   TOR
003518 c003              rjmp    CMOVE2
                 CMOVE1:
003519 d016              rcall   CFETCHPP
00351a de5a              rcall   PCSTORE
00351b de61              rcall   PPLUS
                 CMOVE2:
00351c d519              rcall   XNEXT
00351d f7d8              brcc    CMOVE1
00351e 911f              pop     t1
00351f 910f              pop     t0
003520 de3c              rcall   R_TO_P
003521 940c 326b         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
003523 ea24              fdw     CMOVE_L
                 PLACE_L:
003524 7085
003525 616c
003526 6563              .db     NFA|5,"place"
                 PLACE: 
003527 dc84              rcall   TWODUP
003528 deda              rcall   CSTORE_A
003529 dc36              rcall   CHARPLUS
00352a dd47              rcall   SWOP
00352b 940c 3515         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
00352d ea48              fdw     PLACE_L
                 CFETCHPP_L:
00352e 6383
00352f 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
003530 d260              rcall   DUP
003531 ddbc              rcall   ONEPLUS
003532 dd3f              rcall   SWOP
003533 940c 3e9b         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
003535 ea5c              fdw     CFETCHPP_L
                 FETCHPP_L:
003536 4082
003537 002b              .db     NFA|2,"@+",0
                 FETCHPP:
003538 d258              rcall   DUP
003539 ddbe              rcall   TWOPLUS
00353a dd37              rcall   SWOP
00353b 940c 3e71         jmp     FETCH
                 
00353d 2181              .db     NFA|1,"!"
                 STORE_A:        
00353e 940c 3e29         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
003540 ea6c              fdw    FETCHPP_L
                 NTOC_L:
003541 6e83
003542 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
003543 dfec              rcall   CFETCHPP
003544 d243              rcall   DOLIT
003545 000f              .dw     0x0f
003546 dd7f              rcall   AND_
003547 dd68              rcall   PLUS
003548 940c 314a         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
00354a ea82              fdw    NTOC_L
                 CTON_L:
00354b 6383
00354c 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
00354d d350              rcall   TWOMINUS
00354e d242              rcall   DUP
00354f deaf              rcall   CFETCH_A
003550 d237              rcall   DOLIT
003551 007f              .dw     0x007F
003552 dde3              rcall   GREATER
003553 de48              rcall   ZEROSENSE
003554 f3c1              breq    CFATONFA
003555 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
003556 ea96              fdw     CTON_L
                 BRACFIND_L:
003557 2883
003558 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
003559 dc52              rcall   TWODUP
                 ;        rcall   OVER
                 ;        rcall   CFETCH_A
00355a da97              rcall   NEQUAL
00355b de46              rcall   DUPZEROSENSE
00355c f021              breq    findi2
00355d dd0d              rcall   DROP
00355e d33f              rcall   TWOMINUS ;;;      NFATOLFA
00355f d168              rcall   FETCH_A
003560 d230              rcall   DUP
                 findi2:
003561 de3a              rcall   ZEROSENSE
003562 f7b1              brne    findi1
003563 de3e              rcall   DUPZEROSENSE
003564 f041              breq    findi3
003565 de77              rcall   NIP
003566 d22a              rcall   DUP
003567 dfdb              rcall   NFATOCFA
003568 dd09              rcall   SWOP
003569 d009              rcall   IMMEDQ
00356a d22c              rcall   ZEROEQUAL
00356b dc73              rcall   ONE
00356c dd61              rcall   OR_
                 findi3: 
00356d 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
00356e eaae              fdw     BRACFIND_L
                 IMMEDQ_L:
00356f 6986
003570 6d6d
003571 6465
003572 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
003573 de8b              rcall   CFETCH_A
003574 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
003575 d212              rcall   DOLIT
003576 0040              .dw     IMMED
003577 940c 32c6         jmp     AND_
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
003579 eade              fdw     IMMEDQ_L
                 FIND_L:
00357a 6684
00357b 6e69
00357c 0064              .db     NFA|4,"find",0
                 FIND:   
00357d d20a              rcall   DOLIT
00357e f630              fdw     kernellink
00357f dfd9              rcall   findi
003580 de21              rcall   DUPZEROSENSE
003581 f421              brne    FIND1
003582 dce8              rcall   DROP
003583 d332              rcall   LATEST_
003584 d143              rcall   FETCH_A
003585 dfd3              rcall   findi
                 FIND1:
003586 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
003587 eaf4              fdw     FIND_L
                 DIGITQ_L:
003588 6486
003589 6769
00358a 7469
00358b 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
00358c d204              rcall   DUP             ; c c       c c
00358d d1fa              rcall   DOLIT
00358e 0039              .dw     0x39            ; c c 39    c c 39
00358f dda6              rcall   GREATER         ; c 0       c ffff
003590 de0b              rcall   ZEROSENSE
003591 f019              breq    DIGITQ1
003592 d1f5              rcall   DOLIT
003593 0027              .dw     0x27
003594 dd28              rcall   MINUS
                 DIGITQ1:        
003595 d1f2              rcall   DOLIT
003596 0030              .dw     0x30            ; c 30
003597 dd25              rcall   MINUS           ; 1
003598 d1f8              rcall   DUP             ; 1 1
003599 df1c              rcall   BASE            ; 1 1 base
00359a d12d              rcall   FETCH_A         ; 1 1 10
00359b dd95              rcall   LESS            ; 1 ffff
00359c dcdf              rcall   OVER            ; 1 ffff 1
00359d d201              rcall   ZEROLESS        ; 1 ffff 0
00359e dd41              rcall   INVERT
00359f 940c 32c6         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035a1 eb10              fdw     DIGITQ_L
                 SIGNQ_L:
0035a2 7385
0035a3 6769
0035a4 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035a5 dcd6              rcall   OVER
0035a6 de58              rcall   CFETCH_A
0035a7 d1e0              rcall   DOLIT
0035a8 002c              .dw     ','
0035a9 dd13              rcall   MINUS
0035aa d1e6              rcall   DUP
0035ab dcff              rcall   ABS_
0035ac dc32              rcall   ONE
0035ad dd7e              rcall   EQUAL
0035ae dd17              rcall   AND_
0035af ddf2              rcall   DUPZEROSENSE
0035b0 f029              breq    QSIGN1
0035b1 dd3c              rcall   ONEPLUS
0035b2 dcd8              rcall   TOR
0035b3 dc2b              rcall   ONE
0035b4 df26              rcall   SLASHSTRING
0035b5 dcdf              rcall   RFROM
0035b6 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
0035b7 eb44              fdw     SIGNQ_L
                 UDSTAR_L:
0035b8 7583
0035b9 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035ba d1d6              rcall   DUP
0035bb dccf              rcall   TOR
0035bc ddea              rcall   UMSTAR
0035bd dcad              rcall   DROP
0035be dcb3              rcall   SWOP
0035bf dcd5              rcall   RFROM
0035c0 dde6              rcall   UMSTAR
0035c1 dcc2              rcall   ROT
0035c2 940c 32b0         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
0035c4 eb70              fdw     UDSTAR_L
                 UDSLASHMOD_L:
0035c5 7586
0035c6 2f64
0035c7 6f6d
0035c8 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
0035c9 dcc1              rcall   TOR             ; ud.l ud.h 
0035ca d15f              rcall   FALSE_          ; ud.l ud.h 0
0035cb dcd3              rcall   RFETCH          ; ud.l ud.h 0 u
0035cc dde1              rcall   UMSLASHMOD      ; ud.l r.h q.h
0035cd dcb6              rcall   ROT             ; r.h q.h ud.l
0035ce dcb5              rcall   ROT             ; q.h ud.l r.h
0035cf dcc5              rcall   RFROM           ; q.h ud.l r.h u
0035d0 dddd              rcall   UMSLASHMOD      ; q.h r.l q.l
0035d1 940c 3284         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
0035d3 eb8a              fdw     UDSLASHMOD_L
                 TONUMBER_L:
0035d4 3e87
0035d5 756e
0035d6 626d
0035d7 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
0035d8 ddc9              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
0035d9 f0b1              breq    TONUM3
0035da dcb0              rcall   TOR
0035db d1b5              rcall   DUP
0035dc dcae              rcall   TOR             ; ud.l ud.h adr
0035dd de21              rcall   CFETCH_A
0035de dfad              rcall   DIGITQ          ; ud.l ud.h digit flag
0035df ddbc              rcall   ZEROSENSE
0035e0 f421              brne    TONUM2
0035e1 dc89              rcall   DROP
0035e2 dcb2              rcall   RFROM
0035e3 dcb1              rcall   RFROM
0035e4 c00b              rjmp    TONUM3
                 TONUM2: 
0035e5 dca5              rcall   TOR             ; ud.l ud.h digit
0035e6 decf              rcall   BASE
0035e7 d0e0              rcall   FETCH_A
0035e8 dfd1              rcall   UDSTAR
0035e9 dcab              rcall   RFROM
0035ea dccd              rcall   MPLUS
0035eb dca9              rcall   RFROM
0035ec dca8              rcall   RFROM
                         
0035ed dbf1              rcall   ONE
0035ee deec              rcall   SLASHSTRING
0035ef cfe8              rjmp    TONUM1
                 TONUM3: 
0035f0 9508              ret
                 
                 BASEQV:   
0035f1 e904              fdw     DECIMAL
0035f2 e912              fdw     HEX
0035f3 e922              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
0035f4 eba8              fdw     TONUMBER_L
                 NUMBERQ_L:
0035f5 6e87
0035f6 6d75
0035f7 6562
0035f8 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
0035f9 d197              rcall   DUP             ; a a
0035fa d12f              rcall   FALSE_          ; a a 0 0
0035fb d12e              rcall   FALSE_          ; a a 0 0
0035fc dc87              rcall   ROT             ; a 0 0 a
0035fd df32              rcall   CFETCHPP        ; a 0 0 a' u
0035fe dfa6              rcall   SIGNQ           ; a 0 0 a' u f
0035ff dc8b              rcall   TOR             ; a 0 0 a' u
                 
003600 deb5              rcall   BASE
003601 d0c6              rcall   FETCH_A
003602 dc88              rcall   TOR             ; a 0 0 a' u
                         
003603 dc78              rcall   OVER
003604 ddfa              rcall   CFETCH_A
                         
003605 d182              rcall   DOLIT
003606 0023              .dw     '#'
003607 dcb5              rcall   MINUS
003608 d188              rcall   DUP
003609 d17e              rcall   DOLIT
00360a 0003              .dw     3
00360b dd30              rcall   ULESS
00360c dd8f              rcall   ZEROSENSE
00360d f041              breq    BASEQ1
00360e db4a              rcall   CELLS
                         
00360f d178              rcall   DOLIT
003610 ebe2              fdw     BASEQV
003611 dc9e              rcall   PLUS
003612 da69              rcall   FEXECUTE
                 
003613 dbcb              rcall   ONE
003614 dec6              rcall   SLASHSTRING
003615 c001              rjmp    BASEQ2
                 BASEQ1:
003616 dc54              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
003617 dfc0              rcall   TONUMBER        ; a ud.l ud.h  a' u
003618 dc7c              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
003619 de9c              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
00361a df23              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
00361b d175              rcall   DUP
00361c d281              rcall   TWOMINUS
00361d d181              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
00361e dd7d              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
00361f f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
003620 dc74              rcall   RFROM           ; a ud.l ud.h a' u sign
003621 dc49              rcall   DROP
003622 db82              rcall   TWODROP
                 QNUM_ERR1:      
003623 db81              rcall   TWODROP
003624 d105              rcall   FALSE_          ; a 0           Not a number
003625 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
003626 db8c              rcall   TWOSWAP         ; a a' u ud.l ud.h 
003627 dc6d              rcall   RFROM           ; a a' u ud.l ud.d sign
003628 dd73              rcall   ZEROSENSE
003629 f009              breq    QNUMD1
00362a d437              rcall   DNEGATE
                 QNUMD1: 
00362b db87              rcall   TWOSWAP         ; a d.l d.h a' u
00362c dd6f              rcall   ZEROSENSE       ; a d.l d.h a'
00362d f061              breq    QNUM1
00362e 940e 3e9b         call    CFETCH
003630 d157              rcall   DOLIT
003631 002e              .dw     '.'
003632 dc8a              rcall   MINUS
003633 dd68              rcall   ZEROSENSE       ; a d.l d.h
003634 f771              brne    QNUM_ERR1
003635 dc4e              rcall   ROT             ; d.l d.h a
003636 dc34              rcall   DROP            ; d.l d.h
003637 d150              rcall   DOLIT         ; 
003638 0002              .dw     2               ; d.l ud.h 2    Double number
003639 c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
00363a db6a              rcall   TWODROP         ; a n
00363b dda1              rcall   NIP             ; n
00363c dba2              rcall   ONE             ; n 1           Single number
                 QNUM3:  
00363d 9508              ret
                 
                 
00363e 7384
00363f 6177
003640 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003641 940c 3272         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003643 ebea              fdw     NUMBERQ_L
                 TIBSIZE_L:
003644 7483
003645 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
003646 de5e              rcall   TASK
003647 d080              rcall   FETCH_A
003648 9605              adiw    tosl, 5
003649 940c 3e9b         jmp     CFETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00364b ec88              fdw     TIBSIZE_L
                 TIB_L:
00364c 7483
00364d 6269              .db     NFA|3,"tib"
                 TIB:
00364e d005              rcall   TIU
00364f 940c 3e71         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003651 ec98              fdw     TIB_L
                 TIU_L:
003652 7483
003653 7569              .db     NFA|3,"tiu"
                 TIU:
003654 de6e              rcall   DOUSER
003655 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
003656 eca4              fdw     TIU_L
                 TOIN_L:
003657 3e83
003658 6e69              .db     NFA|3,">in"
                 TOIN:
003659 de69              rcall   DOUSER
00365a fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00365b ecae              fdw     TOIN_L
                 TICKSOURCE_L:
00365c 2787
00365d 6f73
00365e 7275
00365f 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
003660 de62              rcall   DOUSER
003661 fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
003662 ecb8              fdw     TICKSOURCE_L
                 INTERPRET_L:
003663 6989
003664 746e
003665 7265
003666 7270
003667 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
003668 dff7              rcall   TICKSOURCE
003669 db31              rcall   TWOSTORE
00366a d0bf              rcall   FALSE_
00366b dfed              rcall   TOIN
00366c ded1              rcall   STORE_A
                 IPARSEWORD:
00366d d235              rcall   BL
00366e de9c              rcall   WORD
                 
00366f d121              rcall   DUP
003670 dd8e              rcall   CFETCH_A
003671 dd2a              rcall   ZEROSENSE
003672 f409              brne    IPARSEWORD1
003673 c051              rjmp    INOWORD
                 IPARSEWORD1:
003674 df08              rcall   FIND            ; sets also wflags
003675 dd2c              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
003676 f1a1              breq    INUMBER         ; NUMBER?
003677 dc76              rcall   ONEPLUS         ; 0 = normal 2 = immediate
003678 d231              rcall   STATE_
003679 d11d              rcall   ZEROEQUAL
00367a dc53              rcall   OR_
00367b dd20              rcall   ZEROSENSE
00367c f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
00367d fe94              sbrs    wflags, 4       ; Compile only check
00367e c00a              rjmp    IEXECUTE        ; Not a compile only word
00367f d22a              rcall   STATE_          ; Compile only word check
003680 dbb2              rcall   XSQUOTE
003681 430c
003682 4d4f
003683 4950
003684 454c
003685 4f20
003686 4c4e
003687 0059              .db     12,"COMPILE ONLY",0
003688 d0ec              rcall   QABORT
                 IEXECUTE:
003689 7b6f              cbr     FLAGS1, (1<<noclear)
00368a d9e6              rcall   EXECUTE
00368b fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
00368c cfe0              rjmp    IPARSEWORD
00368d 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
00368e 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
00368f cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
003690 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
003691 d0ff              rcall   DUP
003692 d0f5              rcall   DOLIT
003693 ef2e              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
003694 dc97              rcall   EQUAL
003695 dd06              rcall   ZEROSENSE
003696 f011              breq    ICOMPILE_2
003697 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
003698 c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
003699 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
00369a d0f6              rcall   DUP
00369b d0ec              rcall   DOLIT
00369c ef22              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
00369d dc8e              rcall   EQUAL
00369e dcfd              rcall   ZEROSENSE
00369f f009              breq    ICOMPILE
0036a0 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036a1 fe95              sbrs    wflags, 5       ; Inline check
0036a2 c003              rjmp    ICOMMAXT
0036a3 940e 3a0d         call    INLINE0
0036a5 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
0036a6 d124              rcall   COMMAXT_A
0036a7 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
0036a8 fc94              sbrc    wflags, 4            ; Compile only ?
0036a9 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0036aa cfc2              rjmp    IPARSEWORD
                 INUMBER: 
0036ab 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036ac 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036ad dbbd              rcall   DROP
0036ae df4a              rcall   NUMBERQ
0036af dcf2              rcall   DUPZEROSENSE
0036b0 f071              breq    IUNKNOWN
0036b1 d1f8              rcall   STATE_
0036b2 dce9              rcall   ZEROSENSE
0036b3 f049              breq    INUMBER1
0036b4 2f08              mov     t0, tosl
0036b5 9189
0036b6 9199              poptos
0036b7 ff01              sbrs    t0, 1
0036b8 c002              rjmp    ISINGLE
                 IDOUBLE:
0036b9 df87              rcall   SWOP_A
0036ba d742              rcall   LITERAL
                 ISINGLE:        
0036bb d741              rcall   LITERAL
0036bc cfb0              rjmp    IPARSEWORD
                 
                 INUMBER1:
0036bd dbad              rcall   DROP
0036be cfae              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
0036bf dbab              rcall   DROP 
0036c0 d045              rcall   DP_TO_RAM
0036c1 de6e              rcall   CFETCHPP
0036c2 db63              rcall   TYPE
0036c3 d066              rcall   FALSE_
0036c4 d0a7              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
0036c5 940c 326b         jmp     DROP
                 
0036c7 4081              .db     NFA|1,"@"
                 FETCH_A:        
0036c8 940c 3e71         jmp     FETCH
                 
                 ;;;    bitmask -- 
0036ca ecc6              fdw     INTERPRET_L
                 SHB_L:
0036cb 7383
0036cc 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
0036cd d1e8              rcall   LATEST_
0036ce dff9              rcall   FETCH_A
0036cf d0c1              rcall   DUP
0036d0 dd2e              rcall   CFETCH_A
0036d1 dbb2              rcall   ROT
0036d2 dbfb              rcall   OR_
0036d3 df6d              rcall   SWOP_A
0036d4 940c 3ebe         jmp     CSTORE
                         
0036d6 ed96              fdw     SHB_L
                 IMMEDIATE_L:
0036d7 6989
0036d8 6d6d
0036d9 6465
0036da 6169
0036db 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
0036dc d0ab              rcall   DOLIT
0036dd 0040              .dw     IMMED
0036de 940c 36cd         jmp     SHB
                 
                 ;***************************************************************
0036e0 edae              fdw     IMMEDIATE_L
                 INLINED_L:
0036e1 6987
0036e2 6c6e
0036e3 6e69
0036e4 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
0036e5 d0a2              rcall   DOLIT
0036e6 0020              .dw     INLINE
0036e7 940c 36cd         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
0036e9 edc2              fdw     INLINED_L
                 DOTSTATUS_L:
0036ea 2e83
0036eb 7473              .db     NFA|3,".st"
                 DOTSTATUS:
0036ec d09b              rcall   DOLIT
0036ed 003c              .dw     '<'
0036ee d96d              rcall   EMIT
0036ef 940e 3f60         call    DOTBASE
0036f1 d96a              rcall   EMIT
0036f2 d095              rcall   DOLIT
0036f3 002c              .dw     ','
0036f4 d967              rcall   EMIT
0036f5 940e 3f75         call    MEMQ
0036f7 db2e              rcall   TYPE
0036f8 d08f              rcall   DOLIT
0036f9 003e              .dw     '>'
0036fa d961              rcall   EMIT
0036fb 940c 3924         jmp     DOTS
                 
0036fd 3e82
0036fe 0072              .db     NFA|2,">r",0
0036ff 940c 328b TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
003701 6181              .db     NFA|1,"a"
                 TEN:
003702 d9ae              rcall   DOCREATE
003703 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
003704 6483
003705 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
003706 d081              rcall   DOLIT
003707 0900              .dw     dp_start
003708 d1bc              rcall   INI
003709 dff8              rcall   TEN
00370a 940c 3515         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
00370c 3e83
00370d 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
00370e d079              rcall   DOLIT
00370f 0900              .dw     dp_start
003710 dc41              rcall   STORE_P_TO_R
003711 d1b3              rcall   INI
003712 d075              rcall   DOLIT
003713 0004              .dw     4
003714 db76              rcall   TOR
                 DP_TO_EEPROM_0: 
003715 de22              rcall   FETCHPP
003716 d07a              rcall   DUP
003717 dc4d              rcall   PFETCH
003718 dc0c              rcall   NOTEQUAL
003719 dc82              rcall   ZEROSENSE
00371a f011              breq    DP_TO_EEPROM_1
00371b dc51              rcall   PSTORE
00371c c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
00371d db4d              rcall   DROP
                 DP_TO_EEPROM_2:
00371e d3fb              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
00371f d316              rcall   XNEXT
003720 f7a0              brcc    DP_TO_EEPROM_0
003721 911f              pop     t1
003722 910f              pop     t0
003723 dc39              rcall   R_TO_P
003724 940c 326b         jmp     DROP
                 
003726 edd4              fdw     DOTSTATUS_L
                 FALSE_L:
003727 6685
003728 6c61
003729 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
00372a 939a
00372b 938a              pushtos
00372c 2788              clr     tosl
00372d 2799              clr     tosh
00372e 9508              ret
                 
00372f ee4e              fdw     FALSE_L
                 TRUE_L:
003730 7484
003731 7572
003732 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
003733 939a
003734 938a              pushtos
003735 ef8f              ser     tosl
003736 ef9f              ser     tosh
003737 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
003738 ee60              fdw     TRUE_L
                 QUIT_L:
003739 7184
00373a 6975
00373b 0074              .db     NFA|4,"quit",0
                 QUIT:
00373c d9a2              rcall   RPEMPTY
00373d d109              rcall   LEFTBRACKET
00373e d9cb              rcall   FRAM
                 QUIT0:  
00373f d608              rcall   IFLUSH
                         ;; Copy INI and DP's from eeprom to ram
003740 dfc5              rcall   DP_TO_RAM
                 QUIT1: 
003741 d908              rcall   check_sp
003742 d08d              rcall   CR
003743 df0a              rcall   TIB
003744 d04c              rcall   DUP
003745 df00              rcall   TIBSIZE
003746 dfbb              rcall   TEN                 ; Reserve 10 bytes for hold buffer
003747 db75              rcall   MINUS
003748 daa0              rcall   ACCEPT
003749 da72              rcall   SPACE_
00374a df1d              rcall   INTERPRET
00374b d15e              rcall   STATE_
00374c dc4f              rcall   ZEROSENSE
00374d f799              brne    QUIT1
00374e dfbf              rcall   DP_TO_EEPROM
                          
00374f dae3              rcall    XSQUOTE
003750 2003
003751 6b6f              .db     3," ok"
003752 dad3              rcall    TYPE
003753 d007              rcall   PROMPT_
003754 cfea              rjmp    QUIT0
003755 9508              ret
                 
003756 ee72              fdw     QUIT_L
                 PROMPT_L:
003757 7086
003758 6f72
003759 706d
00375a 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
00375b 940e 3ef8         call    DEFER_DOES
00375d 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
00375e eeae              fdw     PROMPT_L
                 ABORT_L:
00375f 6185
003760 6f62
003761 7472              .db     NFA|5,"abort"
                 ABORT:
003762 d159              rcall   S0
003763 df64              rcall   FETCH_A
003764 d976              rcall   SPSTORE
003765 940c 373c         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
003767 eebe              fdw     ABORT_L
                 QABORTQ_L:
003768 3f87
003769 6261
00376a 726f
00376b 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
00376c dac6              rcall   XSQUOTE
00376d 3f01              .db     1,"?"
00376e 940c 3775         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
003770 eed0              fdw     QABORTQ_L
                 QABORT_L:
003771 3f86
003772 6261
003773 726f
003774 0074              .db     NFA|6,"?abort",0
                 QABORT:
003775 db0e              rcall   ROT
003776 dc25              rcall   ZEROSENSE
003777 f419              brne    QABO1
                 QABORT1:        
003778 da43              rcall   SPACE_
003779 daac              rcall   TYPE
00377a dfe7              rcall   ABORT  ; ABORT never returns
00377b 940c 31a5 QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
00377d eee2              fdw     QABORT_L
                 ABORTQUOTE_L:
00377e 61d6
00377f 6f62
003780 7472
003781 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
003782 dac3              rcall   SQUOTE
003783 d945              rcall   DOCOMMAXT
003784 eeea              fdw     QABORT
003785 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
003786 6c83
003787 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
003788 91ff              pop     zh
003789 91ef              pop     zl
00378a d935              rcall   FETCHLIT
00378b 95f7              ror     zh
00378c 95e7              ror     zl
00378d 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
00378e e53a              fdw     RFETCH_L
                 DUP_L:
00378f 64a3
003790 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
003791 939a
003792 938a              pushtos
003793 9508              ret
                 
003794 e646              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
003795 3082
003796 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:      
003797 2b98              or      tosh, tosl
003798 f441              brne    FALSE_F
                 TRUE_F:
003799 ef9f              ser     tosh
00379a ef8f              ser     tosl
                 ZEROEQUAL_1:
00379b 9508              ret
                 
00379c ef2a              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
00379d 3082
00379e 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
00379f 2399              tst     tosh
0037a0 f3c2              brmi    TRUE_F
                 FALSE_F:
0037a1 2799              clr     tosh
0037a2 2788              clr     tosl
0037a3 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037a4 eefc              fdw     ABORTQUOTE_L
                 TICK_L:
0037a5 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037a6 d0fc              rcall   BL
0037a7 dd63              rcall   WORD
0037a8 ddd4              rcall   FIND
0037a9 940c 376c         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
0037ab ef4a              fdw     TICK_L
                 CHAR_L:
0037ac 6384
0037ad 6168
0037ae 0072              .db     NFA|4,"char",0
                 CHAR:
0037af d0f3              rcall   BL
0037b0 dd3d              rcall   PARSE
0037b1 dab9              rcall   DROP
0037b2 940c 3e9b         jmp     CFETCH
                 
                 ; (    --                     skip input until )
0037b4 ef58              fdw     CHAR_L
                 PAREN_L:
0037b5 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
0037b6 dfd1              rcall   DOLIT
0037b7 0029              .dw     ')'
0037b8 dd35              rcall   PARSE
0037b9 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
0037ba 940c 31a5         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
0037bc 6985
0037bd 6568
0037be 6572              .db     NFA|5,"ihere"
                 IHERE:
0037bf d066              rcall   IDP
0037c0 cf07              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
0037c1 ef6a              fdw     PAREN_L
                 BRACCHAR_L:
0037c2 5bd6
0037c3 6863
0037c4 7261
0037c5 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
0037c6 dfe8              rcall   CHAR
0037c7 940c 3dfd         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
0037c9 6383
0037ca 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
0037cb 940c 316a         jmp     COMMAXT
                 
                 ; CR      --                      output newline
0037cd ef84              fdw     BRACCHAR_L
                 CR_L:
0037ce 6382
0037cf 0072              .db     NFA|2,"cr",0
                 CR:
0037d0 dfb7              rcall   DOLIT
0037d1 000d              .dw     0x0d       ; CR \r
0037d2 d889              rcall   EMIT
0037d3 dfb4              rcall   DOLIT
0037d4 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
0037d5 940c 305c         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
0037d7 ef9c              fdw     CR_L
                 CREATE_L:
0037d8 6386
0037d9 6572
0037da 7461
0037db 0065              .db     NFA|6,"create",0
                 CREATE:
0037dc d0c6              rcall   BL
0037dd dd2d              rcall   WORD            ; Parse a word
                 
0037de dfb2              rcall   DUP             ; Remember parsed word at rhere
0037df dd9d              rcall   FIND
0037e0 dbfc              rcall   NIP
0037e1 dfb5              rcall   ZEROEQUAL
0037e2 da50              rcall   XSQUOTE
0037e3 410f
0037e4 524c
0037e5 4145
0037e6 5944
0037e7 4420
0037e8 4645
0037e9 4e49
0037ea 4445              .db     15,"ALREADY DEFINED"
0037eb df89              rcall   QABORT         ; ABORT if word has already been defined
0037ec dfa4              rcall   DUP             ; Check the word length 
0037ed dc11              rcall   CFETCH_A
0037ee d9f0              rcall   ONE
0037ef df98              rcall   DOLIT
0037f0 0010              .dw     16
0037f1 db29              rcall   WITHIN
0037f2 df79              rcall   QABORTQ          ; Abort if there is no name for create
                 
0037f3 d0c2              rcall   LATEST_
0037f4 ded3              rcall   FETCH_A
0037f5 940e 3f4e         call    ICOMMA          ; Link field
0037f7 dd38              rcall   CFETCHPP        ; str len
0037f8 dfc6              rcall   IHERE
0037f9 df97              rcall   DUP             
0037fa d0bb              rcall   LATEST_         ; new 'latest' link
0037fb dd42              rcall   STORE_A         ; str len ihere
0037fc dd2a              rcall   PLACE           ; 
0037fd dfc1              rcall   IHERE           ; ihere
0037fe dc00              rcall   CFETCH_A
0037ff df88              rcall   DOLIT
003800 0080              .dw     NFA
003801 decb              rcall   SHB
003802 daeb              rcall   ONEPLUS
003803 d946              rcall   ALIGNED
003804 d160              rcall   IALLOT          ; The header has now been created
003805 df82              rcall   DOLIT             
003806 e162              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
003807 d96b              rcall   STORECFF1       ; Append an exeution token, CALL !
003808 d937              rcall   ALIGN
003809 d917              rcall   HERE            ; compiles the current dataspace dp into the dictionary
00380a d90c              rcall   CSE_
00380b db90              rcall   ZEROSENSE
00380c f409              brne    CREATE2
00380d daea              rcall   TWOPLUS
                 CREATE2:
00380e 940c 3f4e         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
003810 efb0              fdw    CREATE_L
                 POSTPONE_L:
003811 70d8
003812 736f
003813 7074
003814 6e6f
003815 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
003816 d08c              rcall   BL
003817 dcf3              rcall   WORD
003818 dd64              rcall   FIND
003819 df77              rcall   DUP
00381a df51              rcall   QABORTQ
00381b df83              rcall   ZEROLESS
00381c db7f              rcall   ZEROSENSE
00381d f021              breq    POSTPONE1
00381e d8aa              rcall   DOCOMMAXT
00381f e192              fdw     DOCOMMAXT
003820 940c 3f4e         jmp     ICOMMA
                 POSTPONE1:
003822 940c 316a         jmp     COMMAXT
                 
                 
                 IDP_L:
003824 6983
003825 7064              .db     NFA|3,"idp"
                 IDP:
003826 d88a              rcall   DOCREATE
003827 01d9              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
003828 2887
003829 6f64
00382a 7365
00382b 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
00382c da68              rcall   RFROM
00382d d088              rcall   LATEST_
00382e de99              rcall   FETCH_A
00382f dd13              rcall   NFATOCFA
003830 dff5              rcall   IDP
003831 de96              rcall   FETCH_A
003832 decc              rcall   TOR_A
003833 dff2              rcall   IDP
003834 dd09              rcall   STORE_A
003835 0f88              lsl     tosl
003836 1f99              rol     tosh
003837 d93b              rcall   STORECFF1 ; Always stores a 4 byte call
003838 da5c              rcall   RFROM
003839 dfec              rcall   IDP
00383a 940c 3e29         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
00383c f022              fdw     POSTPONE_L
                 DOES_L:
00383d 64d5
00383e 656f
00383f 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
003840 d888      DOES:   rcall   DOCOMMAXT
003841 f058              fdw     XDOES
003842 d886              rcall   DOCOMMAXT
003843 e172              fdw     DODOES
003844 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
003845 f07a              fdw     DOES_L
                 LEFTBRACKET_L:
003846 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
003847 7000              cbr     t0, 0xff
003848 9300 01e8         sts     state, t0
00384a 9508              ret
                 
                 
                 ; ]        --      enter compiling state
00384b f08c              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
00384c 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
00384d 6f0f              sbr     t0, 0xff
00384e 9300 01e8         sts     state, t0
003850 9508              ret
                 
                 ; :        --           begin a colon definition
003851 f098              fdw     RIGHTBRACKET_L
                 COLON_L:
003852 3a81              .db     NFA|1,":"
                 COLON:
003853 df88              rcall   CREATE
003854 dff8              rcall   RIGHTBRACKET
003855 940c 318b         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
003857 f0a4              fdw     COLON_L
                 NONAME_L:
003858 3a87
003859 6f6e
00385a 616e
00385b 656d              .db     NFA|7,":noname"
                 NONAME:
00385c df62              rcall   IHERE
00385d 940c 384d         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
00385f f0b0              fdw     NONAME_L
                 SEMICOLON_L:
003860 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
003861 dfe5              rcall   LEFTBRACKET
003862 fd61              sbrc    FLAGS1, fTAILC
003863 c026              rjmp    ADD_RETURN_1
003864 df5a              rcall   IHERE
003865 d02b              rcall   MINUS_FETCH
003866 018c              movw    t0, tosl
003867 7f10              andi    t1, 0xf0
003868 5d10              subi    t1, 0xd0
003869 f059              breq    RCALL_TO_JMP
00386a 9189
00386b 9199              poptos
00386c d024              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
00386d 508e              subi    tosl, 0x0e
                 .endif
00386e 4994              sbci    tosh, 0x94
00386f f4c9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
003870 e08c              ldi     tosl, 0x0c
                 .endif
003871 e994              ldi     tosh, 0x94
003872 d9ff              rcall   SWOP
003873 940c 3e29         jmp     STORE
                 RCALL_TO_JMP:
003875 db67              rcall   NIP
003876 709f              andi    tosh, 0x0f
003877 fd93              sbrc    tosh, 3
003878 6f90              ori     tosh, 0xf0
003879 da89              rcall   TWOSTAR
00387a df44              rcall   IHERE
00387b da34              rcall   PLUS
00387c df0b              rcall   DOLIT
00387d fffe              .dw     -2
00387e d0e6              rcall   IALLOT
00387f df08              rcall   DOLIT
                 .ifdef EIND
                 .else
003880 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
003881 940e 3f4e         call    ICOMMA
003883 5890              sub_pflash_tos
003884 9488              rampv_to_c
003885 9597              ror     tosh
003886 9587              ror     tosl
003887 940c 3f4e         jmp     ICOMMA
                 ADD_RETURN:
003889 d91b              rcall   TWODROP
                 ADD_RETURN_1:
00388a defd              rcall   DOLIT   ; Compile a ret
00388b 9508              .dw     0x9508
00388c 940c 3f4e         jmp    ICOMMA
                 
                 
                 
00388e f0c0              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
00388f 2d82
003890 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
003891 d00c              rcall   TWOMINUS
003892 defe              rcall   DUP
003893 940c 3e71         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
003895 f11e              fdw     MINUS_FETCH_L
                 BRACTICK_L:
003896 5bd3
003897 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
003898 df0d              rcall   TICK       ; get xt of 'xxx'
003899 940c 3dfd         jmp     LITERAL
                 
                 ; 2-    n -- n-2
00389b f12c              fdw     BRACTICK_L
                 TWOMINUS_L:
00389c 32a2
00389d 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
00389e 9702              sbiw    tosl, 2
00389f 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038a0 f138              fdw     TWOMINUS_L
                 BL_l:
0038a1 6282
0038a2 006c              .db     NFA|2,"bl",0
                 BL:
0038a3 940e 30b1         call    DOCREATE
0038a5 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038a6 f142              fdw     BL_L
                 STATE_L:
0038a7 7385
0038a8 6174
0038a9 6574              .db     NFA|5,"state"
                 STATE_:
0038aa 939a
0038ab 938a              pushtos
0038ac 9180 01e8         lds     tosl, state
0038ae 9190 01e8         lds     tosh, state
0038b0 9508              ret
                 
                 ; LATEST    -- a-addr           
0038b1 f14e              fdw     STATE_L
                 LATEST_L:
0038b2 6c86
0038b3 7461
0038b4 7365
0038b5 0074              .db     NFA|6,"latest",0
                 LATEST_:
0038b6 940e 30b1         call    DOCREATE
0038b8 01df              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
0038b9 f164              fdw     LATEST_L
                 S0_L:
0038ba 7382
0038bb 0030              .db     NFA|2,"s0",0
                 S0:
0038bc dc06              rcall   DOUSER
0038bd ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
0038be f174              fdw     S0_L
                 R0_L:
0038bf 7282
0038c0 0030              .db     NFA|2,"r0",0
                 R0_:
0038c1 dc01              rcall   DOUSER
0038c2 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
0038c3 6983
0038c4 696e              .db     NFA|3,"ini"
                 INI:
0038c5 940e 30b1          call   DOCREATE
0038c7 01d7              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
0038c8 f17e              fdw     R0_L
                 TICKS_L:
0038c9 7485
0038ca 6369
0038cb 736b              .db     NFA|5,"ticks"
                 TICKS:
0038cc 939a
0038cd 938a              pushtos
0038ce b60f              in_     t2, SREG
0038cf 94f8              cli
0038d0 2d8e              mov     tosl, ms_count
0038d1 2d9f              mov     tosh, ms_count1
0038d2 be0f              out_    SREG, t2
0038d3 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
0038d4 f192              fdw     TICKS_L
                 MS_L:
0038d5 6d82
0038d6 0073              .db     NFA|2,"ms",0
                 MS:
0038d7 dff4              rcall   TICKS
0038d8 d9d7              rcall   PLUS
                 MS1:    
0038d9 d648              rcall   PAUSE
0038da deb6              rcall   DUP
0038db dff0              rcall   TICKS
0038dc d9e0              rcall   MINUS
0038dd dec1              rcall   ZEROLESS
0038de dabd              rcall   ZEROSENSE
0038df f3c9              breq    MS1
0038e0 940c 326b         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
0038e2 f1aa              fdw     MS_L
                 DOTID_L:
0038e3 2e83
0038e4 6469              .db     NFA|3,".id"
                 DOTID:
0038e5 dc4a              rcall   CFETCHPP
0038e6 dea1              rcall   DOLIT
0038e7 000f              .dw     0x0f
0038e8 d9dd              rcall   AND_
0038e9 d9a1              rcall   TOR
0038ea c003              rjmp    DOTID3
                 DOTID1:
0038eb dc44              rcall   CFETCHPP
0038ec d00a              rcall   TO_PRINTABLE
0038ed dee7              rcall   EMIT_A
                 DOTID3:
0038ee d147              rcall   XNEXT
0038ef f7d8              brcc    DOTID1  
0038f0 911f              pop     t1
0038f1 910f              pop     t0
0038f2 940c 326b         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
0038f4 f1c6              fdw     DOTID_L
                 TO_PRINTABLE_L:
0038f5 3e83
0038f6 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:   
0038f7 3080              cpi     tosl, 0
0038f8 f012              brmi    TO_PRINTABLE1
0038f9 3280              cpi     tosl, 0x20
0038fa f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
0038fb e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
0038fc 9508              ret
                 
                  ; WORDS    --          list all words in dict.
0038fd f1ea              fdw     TO_PRINTABLE_L
                 WORDS_L:
0038fe 7785
0038ff 726f
003900 7364              .db     NFA|5,"words"
003901 de28              rcall   FALSE_
003902 decd              rcall   CR
003903 de84              rcall   DOLIT
003904 f630              fdw     kernellink
003905 d005              rcall   WDS1
003906 de23              rcall   FALSE_
003907 dec8              rcall   CR
003908 dec7              rcall   CR
003909 dfac              rcall   LATEST_
00390a ddbd              rcall   FETCH_A
00390b de85      WDS1:   rcall   DUP
00390c dfd8              rcall   DOTID
00390d dd33              rcall   SWOP_A
00390e d9df              rcall   ONEPLUS
00390f de81              rcall   DUP
003910 de77              rcall   DOLIT
003911 0007              .dw     7
003912 d9b3              rcall   AND_
003913 da88              rcall   ZEROSENSE
003914 f021              breq    WDS2
003915 de72              rcall   DOLIT
003916 0009              .dw     9
003917 debd              rcall   EMIT_A
003918 c001              rjmp    WDS3
                 WDS2:   
003919 deb6              rcall   CR
                 WDS3:
00391a dd26              rcall   SWOP_A
                 
00391b df82              rcall   TWOMINUS
00391c ddab              rcall   FETCH_A
00391d da84              rcall   DUPZEROSENSE
00391e f761              brne    WDS1
00391f 940c 31a5         jmp     TWODROP
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
003921 f1fc              fdw     WORDS_L
                 DOTS_L:
003922 2e82
003923 0073              .db     NFA|2,".s",0
                 DOTS:
003924 d897              rcall   SPACE_
003925 de6b              rcall   DUP          ; push tosl:tosh to memory
003926 940e 30d4         call    SPFETCH
003928 df93              rcall   S0
003929 dd9e              rcall   FETCH_A
00392a df73              rcall   TWOMINUS
                 DOTS1:
00392b d880              rcall   TWODUP
00392c da04              rcall   LESS
00392d da6e              rcall   ZEROSENSE
00392e f019              breq    DOTS2
00392f df61              rcall   MINUS_FETCH
003930 db26              rcall   UDOT
003931 cff9              rjmp    DOTS1
                 DOTS2:  
003932 d938              rcall   DROP
003933 940c 31a5         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
003935 f244              fdw     DOTS_L
                 DUMP_L:
003936 6484
003937 6d75
003938 0070              .db     NFA|4,"dump",0
                 DUMP:
003939 de4e              rcall   DOLIT
00393a 0010              .dw     16
00393b da84              rcall   USLASH
00393c d94e              rcall   TOR
00393d c020              rjmp    DUMP7
                 DUMP1:  
00393e de91              rcall   CR
00393f de51              rcall   DUP
003940 de47              rcall   DOLIT
003941 0004              .dw     4
003942 db1e              rcall   UDOTR
003943 de44              rcall   DOLIT
003944 003a              .dw     ':'
003945 de8f              rcall   EMIT_A
003946 de41              rcall   DOLIT
003947 000f              .dw     15
003948 d942              rcall   TOR
                 DUMP2:
003949 dbe6              rcall   CFETCHPP
00394a de3d              rcall   DOLIT
00394b 0002              .dw     2
00394c db14              rcall   UDOTR
00394d d0e8              rcall   XNEXT
00394e f7d0              brcc    DUMP2
00394f 911f              pop     t1
003950 910f              pop     t0
                 
003951 de36              rcall   DOLIT
003952 0010              .dw     16
003953 d969              rcall   MINUS
003954 de33              rcall   DOLIT
003955 000f              .dw     15
003956 d934              rcall   TOR
                 DUMP4:  
003957 dbd8              rcall   CFETCHPP
003958 df9e              rcall   TO_PRINTABLE
003959 de7b              rcall   EMIT_A
00395a d0db              rcall   XNEXT
00395b f7d8              brcc    DUMP4
00395c 911f              pop     t1
00395d 910f              pop     t0
                 DUMP7:
00395e d0d7              rcall   XNEXT
00395f f6f0              brcc    DUMP1
003960 911f              pop     t1
003961 910f              pop     t0
003962 940c 326b         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
003964 2081              .db     NFA|1," "
                 IALLOT:
003965 dec0              rcall   IDP
003966 940c 330f         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
003968 f26c              fdw     DUMP_L
                 X_TO_R_L:
003969 7883
00396a 723e              .db     NFA|3,"x>r"
                 X_TO_R:
00396b 01fc              movw    zl, tosl
00396c 9189
00396d 9199              poptos
00396e d009              rcall   TO_XA
00396f 9631              adiw    zl, 1
003970 9382              st      -z, tosl
003971 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
003972 9252              st      -z, zero
003973 01cf              movw    tosl, zl
003974 9508              ret
                 ;***************************************************************
003975 f2d2              fdw     X_TO_R_L
                 TO_XA_L:
003976 3e83
003977 6178              .db NFA|3,">xa"
                 TO_XA:
003978 5890               sub_pflash_tos
003979 9488               rampv_to_c
00397a 9597               ror tosh
00397b 9587               ror tosl
00397c 9508               ret
                 
00397d f2ec               fdw     TO_XA_L
                 XA_FROM_L:
00397e 7883
00397f 3e61              .db NFA|3,"xa>"
                 XA_FROM:
003980 0f88               lsl     tosl
003981 1f99               rol     tosh
003982 5890               add_pflash_tos
003983 9508               ret
                 ;***************************************************************
003984 f2fc               fdw    XA_FROM_L
                 PFL_L:
003985 7083
003986 6c66              .db     NFA|3,"pfl"
                 PFL:
003987 940e 30b1          call   DOCREATE
003989 8000              .dw     PFLASH
                 ;***************************************************************
00398a f30a              fdw    PFL_L
                 ZFL_L:
00398b 7a83
00398c 6c66              .db     NFA|3, "zfl"
                 ZFL:
00398d 940e 30b1          call   DOCREATE
00398f 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
003990 2c84
003991 303f
003992 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
003993 fd65              sbrc    FLAGS1, idup
003994 c003              rjmp    COMMAZEROSENSE1
003995 ddf2              rcall   DOLIT
003996 e738              fdw     ZEROSENSE
003997 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
003998 d004              rcall   IDPMINUS
003999 ddee              rcall   DOLIT
00399a e744              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
00399b 7d6f              cbr     FLAGS1, (1<<idup)
00399c c070              rjmp    INLINE0
                 
                 IDPMINUS:
00399d ddea              rcall   DOLIT
00399e fffc              .dw     -4
00399f cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
0039a0 d968              rcall   TWOSLASH
0039a1 709f              andi    tosh, 0x0f
0039a2 6c90              ori     tosh, 0xc0
0039a3 940c 3f4e         jmp     ICOMMA
                 
                 
                 BRCCC:
0039a5 dde2              rcall   DOLIT
0039a6 f008              .dw     0xf008      ; brcc pc+2
0039a7 940c 3f4e         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
0039a9 ddde              rcall   DOLIT
0039aa f409              .dw     0xf409      ; brne pc+2
0039ab fd64              sbrc    FLAGS1, izeroeq
0039ac 7f9b              andi    tosh, ~4
0039ad 940c 3f4e         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
0039af f316              fdw     ZFL_L
                 IF_L:
0039b0 69d2
0039b1 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
0039b2 fd64              sbrc    FLAGS1, izeroeq
0039b3 dfe9              rcall   IDPMINUS
0039b4 dfde              rcall   COMMAZEROSENSE
0039b5 dff3              rcall   BRNEC
0039b6 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039b7 de07              rcall   IHERE
0039b8 dd71              rcall   FALSE_
0039b9 940c 39a0         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
0039bb f360              fdw     IF_L
                 ELSE_L:
0039bc 65d4
0039bd 736c
0039be 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
0039bf ddff              rcall   IHERE
0039c0 dd69              rcall   FALSE_
0039c1 dfde              rcall   RJMPC
0039c2 dc7e              rcall   SWOP_A      ; else-addr  if-addr 
0039c3 940c 39c9         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
0039c5 f378              fdw     ELSE_L
                 THEN_L:
0039c6 74d4
0039c7 6568
0039c8 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
0039c9 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039ca ddf4              rcall   IHERE
0039cb d8b0              rcall   OVER
0039cc d8f0              rcall   MINUS
0039cd ded0              rcall   TWOMINUS
0039ce d93a              rcall   TWOSLASH
0039cf ddb8              rcall   DOLIT
0039d0 c000              .dw     0xc000      ;  back-addr mask 
0039d1 d8fc              rcall   OR_
0039d2 dc6e              rcall   SWOP_A
0039d3 940c 3e29         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
0039d5 f38c              fdw     THEN_L
                 BEGIN_L:
0039d6 62d5
0039d7 6765
0039d8 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
0039d9 940c 37bf         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
0039db f3ac              fdw     BEGIN_L
                 UNTIL_L:
0039dc 75d5
0039dd 746e
0039de 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
0039df 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039e0 fd64              sbrc    FLAGS1, izeroeq
0039e1 dfbb              rcall   IDPMINUS
0039e2 dfb0              rcall   COMMAZEROSENSE
0039e3 dfc5              rcall   BRNEC
0039e4 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039e5 940c 39eb 	    jmp     AGAIN_
                 
                 				; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
0039e7 f3b8              fdw     UNTIL_L
                 AGAIN_L:
0039e8 61d5
0039e9 6167
0039ea 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
0039eb 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039ec ddd2              rcall   IHERE
0039ed d8cf              rcall   MINUS
0039ee deaf              rcall   TWOMINUS
0039ef 940c 39a0         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
0039f1 f3d0              fdw     AGAIN_L
                 WHILE_L:
0039f2 77d5
0039f3 6968
0039f4 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
0039f5 dfbc              rcall   IF_
0039f6 940c 3272         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
0039f8 f3e4              fdw     WHILE_L
                 REPEAT_L:
0039f9 72d6
0039fa 7065
0039fb 6165
0039fc 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
0039fd dfed              rcall   AGAIN_
0039fe 940c 39c9         jmp     THEN_
                 
003a00 f3f2              fdw     REPEAT_L
                 INLINE_L:
003a01 69d6
003a02 6c6e
003a03 6e69
003a04 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a05 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a06 7d6f              cbr      FLAGS1, (1<<idup)
003a07 dd9e              rcall    TICK
003a08 940c 3a0d         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a0a f402              fdw      INLINE_L
                 INLINEC_L:
003a0b 6983
003a0c 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a0d db2a              rcall   FETCHPP
003a0e dd82              rcall   DUP
003a0f dd78              rcall   DOLIT
003a10 9508              .dw     0x9508
003a11 d913              rcall   NOTEQUAL
003a12 d989              rcall   ZEROSENSE
003a13 f011              breq    INLINE1
003a14 d539              rcall   ICOMMA
003a15 cff7              rjmp    INLINE0
                 INLINE1:
003a16 940c 31a5         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a18 f416              fdw     INLINEC_L
                 FOR_L:
003a19 66d3
003a1a 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a1b 940e 30c9         call    DOCOMMAXT
003a1d e516              fdw     TOR
003a1e dda0              rcall   IHERE
003a1f dd0a              rcall   FALSE_
003a20 df7f              rcall   RJMPC
003a21 dd9d              rcall   IHERE
003a22 940c 3272         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a24 f432              fdw     FOR_L
                 NEXT_L:
003a25 6ed4
003a26 7865
003a27 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a28 dfa0              rcall   THEN_
003a29 940e 30c9         call    DOCOMMAXT
003a2b f46c              fdw     XNEXT
003a2c df78              rcall   BRCCC
                 
003a2d dfbd              rcall   AGAIN_
                 
003a2e dd59              rcall   DOLIT
003a2f f47e              fdw     XNEXT1
003a30 940c 3a0d         jmp     INLINE0
                 ; (next) decrement top of return stack
003a32 2887
003a33 656e
003a34 7478
003a35 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003a36 91ff              pop     zh
003a37 91ef              pop     zl
003a38 91bf              pop     xh
003a39 91af              pop     xl
003a3a 9711              sbiw    xl, 1
003a3b 93af              push    xl
003a3c 93bf              push    xh
003a3d 9409              mijmp
003a3e 9508              ret
                 XNEXT1:
003a3f 911f              pop     t1
003a40 910f              pop     t0
003a41 9508              ret
                 
                 ; leave clear top of return stack
003a42 f44a              fdw     NEXT_L
                 LEAVE_L:
003a43 6595
003a44 646e
003a45 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003a46 91ff              pop     zh
003a47 91ef              pop     zl
003a48 911f              pop     t1
003a49 910f              pop     t0
003a4a 2700              clr     t0
003a4b 2711              clr     t1
003a4c 930f              push    t0
003a4d 931f              push    t1
003a4e 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003a4f f486              fdw      LEAVE_L
                 RDROP_L:
003a50 72d5
003a51 7264
003a52 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003a53 dd34              rcall   DOLIT
003a54 f47e              fdw     XNEXT1
003a55 940c 3a0d         jmp     INLINE0
                 ;***************************************************
003a57 f4a0              fdw     RDROP_L
                 STOD_L:
003a58 7383
003a59 643e              .db     NFA|3,"s>d"
                 STOD:
003a5a ff97              sbrs    tosh, 7
003a5b ccce              rjmp    FALSE_
003a5c ccd6              rjmp    TRUE_
                 ;***************************************************
003a5d f4b0              fdw     STOD_L
                 DNEGATE_L:
003a5e 6487
003a5f 656e
003a60 6167
003a61 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003a62 d049              rcall   DINVERT
003a63 940e 31df         call    ONE
003a65 940c 32b8         jmp     MPLUS
                 ;***************************************************
003a67 f4bc              fdw     DNEGATE_L
                 QDNEGATE_L:
003a68 3f88
003a69 6e64
003a6a 6765
003a6b 7461
003a6c 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003a6d dd31              rcall   ZEROLESS
003a6e d92d              rcall   ZEROSENSE
003a6f f009              breq    QDNEGATE1
003a70 dff1              rcall   DNEGATE
                 QDNEGATE1:
003a71 9508              ret
                 
                 ;***************************************************
003a72 f4d0              fdw     QDNEGATE_L
                 DABS_L:
003a73 6484
003a74 6261
003a75 0073              .db     NFA|4,"dabs",0
                 DABS:
003a76 dd1a              rcall   DUP
003a77 940c 3a6d         jmp     QDNEGATE
                 ;***************************************************
003a79 f4e6              fdw     DABS_L
                 DPLUS_L:
003a7a 6482
003a7b 002b              .db     NFA|2,"d+",0
                 DPLUS:
003a7c 91a9              ld      xl, Y+
003a7d 91b9              ld      xh, Y+
003a7e 9009              ld      t2, Y+
003a7f 9019              ld      t3, Y+
003a80 9109              ld      t0, Y+
003a81 9119              ld      t1, Y+
003a82 0fa0              add     xl, t0
003a83 1fb1              adc     xh, t1
003a84 1d80              adc     tosl, t2
003a85 1d91              adc     tosh, t3
003a86 93ba              st      -Y, xh
003a87 93aa              st      -Y, xl
003a88 9508              ret
                 
                 ;***************************************************
003a89 f4f4              fdw     DPLUS_L
                 DMINUS_L:
003a8a 6482
003a8b 002d              .db     NFA|2,"d-",0
                 DMINUS:
003a8c dfd5              rcall   DNEGATE
003a8d 940c 3a7c         jmp     DPLUS
                 ;***************************************************
003a8f f514              fdw     DMINUS_L
                 DTWOSLASH_L:
003a90 6483
003a91 2f32              .db     NFA|3,"d2/"
003a92 9109              ld      t0, y+
003a93 9119              ld      t1, y+
003a94 9595              asr     tosh
003a95 9587              ror     tosl
003a96 9517              ror     t1
003a97 9507              ror     t0
003a98 931a              st      -y, t1
003a99 930a              st      -y, t0
003a9a 9508              ret
                 ;***************************************************
003a9b f520              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003a9c 6483
003a9d 2a32              .db     NFA|3,"d2*"
003a9e 9109              ld      t0, y+
003a9f 9119              ld      t1, y+
003aa0 0f00              lsl     t0
003aa1 1f11              rol     t1
003aa2 1f88              rol     tosl
003aa3 1f99              rol     tosh
003aa4 931a              st      -y, t1
003aa5 930a              st      -y, t0
003aa6 9508              ret
                 ;***************************************************
003aa7 f538              fdw     DTWOSTAR_L
                 DINVERT_L:
003aa8 6487
003aa9 6e69
003aaa 6576
003aab 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003aac 91a9              ld      xl, y+
003aad 91b9              ld      xh, y+
003aae 95a0              com     xl
003aaf 95b0              com     xh
003ab0 9580              com     tosl
003ab1 9590              com     tosh
003ab2 93ba              st      -y, xh
003ab3 93aa              st      -y, xl
003ab4 9508              ret
                 ;***************************************************
003ab5 f550              fdw     DINVERT_L
                 DZEROEQUAL_L:
003ab6 6483
003ab7 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003ab8 91a9              ld      xl, y+
003ab9 91b9              ld      xh, y+
003aba 2b89              or      tosl, tosh
003abb 2b8a              or      tosl, xl
003abc 2b8b              or      tosl, xh
003abd f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003abe ef8f              ser     tosl
003abf ef9f              ser     tosh
003ac0 9508              ret
                 
                 ;***************************************************
003ac1 f56c              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003ac2 6483
003ac3 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003ac4 91a9              ld      xl, y+
003ac5 91b9              ld      xh, y+
003ac6 3090              cpi     tosh, 0
003ac7 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003ac8 2788              clr     tosl
003ac9 2799              clr     tosh
003aca 9508              ret
                 ;***************************************************
003acb f584              fdw     DZEROLESS_L
                 DEQUAL_L:
003acc 6482
003acd 003d              .db     NFA|2,"d=",0
003ace dfbd              rcall   DMINUS
003acf 940c 3ab8         jmp     DZEROEQUAL
                 ;***************************************************
003ad1 f598              fdw     DEQUAL_L
                 DLESS_L:
003ad2 6482
003ad3 003c              .db     NFA|2,"d<",0
                 DLESS:
003ad4 dfb7              rcall   DMINUS
003ad5 940c 3ac4         jmp     DZEROLESS
                 ;***************************************************
003ad7 f5a4              fdw     DLESS_L
                 DGREATER_L:
003ad8 6482
003ad9 003e              .db     NFA|2,"d>",0
                 DGREATER:
003ada 940e 31b3         call    TWOSWAP
003adc 940c 3ad4         jmp     DLESS
                 ;***************************************************
003ade f5b0              fdw     DGREATER_L
                 UDDOT_L:
003adf 7583
003ae0 2e64              .db     NFA|3,"ud."
003ae1 d936              rcall   LESSNUM
003ae2 d956              rcall   NUMS
003ae3 d95e              rcall   NUMGREATER
003ae4 940e 3226         call    TYPE
003ae6 940c 31bc         jmp     SPACE_
                 ;***************************************************
003ae8 f5be              fdw     UDDOT_L
                 DDOT_L:
003ae9 6482
003aea 002e              .db     NFA|2,"d.",0
003aeb d92c              rcall   LESSNUM
003aec 940e 3791         call    DUP
003aee 940e 328b         call    TOR
003af0 df85              rcall   DABS
003af1 d947              rcall   NUMS
003af2 940e 3295         call    RFROM
003af4 d958              rcall   SIGN
003af5 d94c              rcall   NUMGREATER
003af6 940e 3226         call    TYPE
003af8 940c 31bc         jmp     SPACE_
                 ;****************************************************
003afa f5d2              fdw      DDOT_L
                 MEMHI_L:
003afb 6882
003afc 0069              .db     NFA|2,"hi",0
                 MEMHI:
003afd dc8a              rcall   DOLIT
003afe f60a              fdw     FLASHHI
003aff 940e 3117         call    CSE_
003b01 940e 32b0         call    PLUS
003b03 940c 3e71         jmp     FETCH
                 FLASHHI:
003b05 d07f              .dw      FLASH_HI
003b06 0cff              .dw      EEPROM_HI
003b07 08ff              .dw      RAM_HI
                 ;***************************************************
                 
003b08 f5f6              fdw      MEMHI_L
                 L_FETCH_P:
003b09 40a2
003b0a 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b0b 939a
003b0c 938a              pushtos
003b0d 01ca              movw    tosl, pl
003b0e 9508              ret
                 ;***************************************************
003b0f f612              fdw     L_FETCH_P
                 L_PCFETCH:
003b10 7083
003b11 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b12 939a
003b13 938a              pushtos
003b14 01ca              movw    tosl, pl
003b15 940c 3e9b         jmp     CFETCH
                 ;***************************************************
003b17 f620              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b18 70a3
003b19 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b1a 0d47              add     pl, r_two
003b1b 1d55              adc     ph, zero
003b1c 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b1d 0000              .dw     0
                 L_MARKER:
                 lastword:
003b1e 6d86
003b1f 7261
003b20 656b
003b21 0072              .db     NFA|6,"marker",0
                 MARKER:
003b22 940e 30fc         call    ROM_
003b24 dcb7              rcall   CREATE
003b25 dc62              rcall   DOLIT
003b26 0900              .dw     dp_start
003b27 940e 3121         call    HERE
003b29 dbd8              rcall   TEN
003b2a d9ea              rcall   CMOVE
003b2b dbd6              rcall   TEN
003b2c 940e 3264         call    ALLOT
003b2e 940e 310a         call    FRAM
003b30 dcfb              rcall   XDOES
003b31 940e 30b9         call    DODOES
003b33 dd91              rcall   INI
003b34 dbcd              rcall   TEN
003b35 940c 3515         jmp     CMOVE
                 
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003b37 fe00              sbrs    t2, PORF
003b38 c003              rjmp    RQ_EXTR
003b39 dc4e              rcall   DOLIT
003b3a 0050              .dw     'P'
003b3b dc99              rcall   EMIT_A
                 RQ_EXTR:
003b3c fe01              sbrs    t2, EXTRF
003b3d c003              rjmp    RQ_BORF
003b3e dc49              rcall   DOLIT
003b3f 0045              .dw     'E'
003b40 dc94              rcall   EMIT_A
                 RQ_BORF:
003b41 fe02              sbrs    t2, BORF
003b42 c003              rjmp    RQ_WDRF
003b43 dc44              rcall   DOLIT
003b44 0042              .dw     'B'
003b45 dc8f              rcall   EMIT_A
                 RQ_WDRF:
003b46 fe03              sbrs    t2, WDRF
003b47 c003              rjmp    RQ_DIVZERO
003b48 dc3f              rcall   DOLIT
003b49 0057              .dw     'W'
003b4a dc8a              rcall   EMIT_A
                 RQ_DIVZERO:
003b4b fe16              sbrs    t3, 6 ; T bit
003b4c c003              rjmp    RQ_END
003b4d dc3a              rcall   DOLIT
003b4e 0044              .dw     'D'
003b4f dc85              rcall   EMIT_A
                 RQ_END: 
003b50 940c 31bc         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1	
003b52 ff75              sbrs    FLAGS2, fLOAD
003b53 c01f              rjmp    CPU_LOAD_END
003b54 939a
003b55 938a              pushtos
003b56 b60f              in_     t2, SREG
003b57 94f8              cli
003b58 7d7f              cbr     FLAGS2, (1<<fLOAD)
003b59 9180 01e3         lds     tosl, load_acc
003b5b 9190 01e4         lds     tosh, load_acc+1
003b5d 939a
003b5e 938a              pushtos
003b5f 9180 01e5         lds     tosl, load_acc+2
003b61 9250 01e3         sts     load_acc, zero
003b63 9250 01e4         sts     load_acc+1, zero
003b65 9250 01e5         sts     load_acc+2, zero
003b67 be0f              out_    SREG, t2
003b68 2799              clr     tosh
003b69 939a
003b6a 938a              pushtos
003b6b e080              ldi     tosl, low(CPU_LOAD_VAL)
003b6c ea90              ldi     tosh, high(CPU_LOAD_VAL)
003b6d 940e 33ae         call    UMSLASHMOD
003b6f 9380 01e6         sts     load, tosl
003b71 940e 31a5         call    TWODROP 
                 CPU_LOAD_END:
                 .endif
                 .if CPU_LOAD_LED == 1
003b73 ff74              sbrs    FLAGS2, fLOADled
003b74 c002              rjmp    LOAD_LED_END
003b75 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003b76 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003b77 fd76              sbrc    FLAGS2, fIDLE
003b78 c00b              rjmp    IDLE_LOAD1
003b79 fd77              sbrc    FLAGS2, fBUSY
003b7a c009              rjmp    IDLE_LOAD1
003b7b e005              ldi	    t0, low(up0)
003b7c 1620              cp      upl, t0
003b7d f431              brne    IDLE_LOAD1
                 .ifdef SMCR
003b7e e001              ldi     t0, (1<<SE)
003b7f bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
003b80 9250 0081         out_    TCCR1B, zero	; Stop load counter
                 .endif
003b82 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003b83 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003b84 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003b85 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003b86 9508              ret
                 .endif
                 
                 .if CPU_LOAD == 1	
                 LOAD_ADD:
003b87 91e0 01e3         lds     zl, load_acc
003b89 91f0 01e4         lds     zh, load_acc+1
003b8b 9100 01e5         lds     t0, load_acc+2
003b8d 91b0 0084         in_     xh, TCNT1L
003b8f 0feb              add     zl, xh
003b90 91b0 0085         in_     xh, TCNT1H
003b92 1ffb              adc     zh, xh
003b93 1d05              adc     t0, zero
003b94 9250 0085         out_    TCNT1H, zero
003b96 9250 0084         out_    TCNT1L, zero
003b98 93e0 01e3         sts     load_acc, zl
003b9a 93f0 01e4         sts     load_acc+1, zh
003b9c 9300 01e5         sts     load_acc+2, t0
003b9e 20ee              tst     ms_count
003b9f f409              brne    LOAD_ADD_END
003ba0 6270              sbr     FLAGS2, (1<<fLOAD)
                 LOAD_ADD_END:
003ba1 c09b              rjmp    FF_ISR_EXIT2
                 .endif
                 
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d5d RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d042                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d040                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d03e                  rcall FF_ISR
                 .org BOOT_START + 0x08
003c08 d03c                  rcall FF_ISR
                 .org BOOT_START + 0x0a
003c0a d03a                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d038                  rcall FF_ISR
                 .org BOOT_START + 0x0e
003c0e d036                  rcall FF_ISR
                 .org BOOT_START + 0x10
003c10 d034                  rcall FF_ISR
                 .org BOOT_START + 0x12
003c12 d032                  rcall FF_ISR
                 .org BOOT_START + 0x14
003c14 d030                  rcall FF_ISR
                 .org BOOT_START + 0x16
003c16 d02e                  rcall FF_ISR
                 .org BOOT_START + 0x18
003c18 d02c                  rcall FF_ISR
                 .org BOOT_START + 0x1a
003c1a d02a                  rcall FF_ISR
                 .org BOOT_START + 0x1c
003c1c d028                  rcall FF_ISR
                 .org BOOT_START + 0x1e
003c1e d026                  rcall FF_ISR
                 .org BOOT_START + 0x20
003c20 d024                  rcall FF_ISR
                 .org BOOT_START + 0x22
003c22 d022                  rcall FF_ISR
                 .org BOOT_START + 0x24
003c24 d020                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d01e                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d01c                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
003c2a d01a                  rcall FF_ISR
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d018                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d016                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d014                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d012                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE
                 FF_ISR_EXIT:
003c34 919f              pop     tosh
003c35 918f              pop     tosl
003c36 901f              pop     t3
003c37 900f              pop     t2
                 
003c38 911f              pop     t1
003c39 c003              rjmp    FF_ISR_EXIT2
                 MS_TIMER_ISR:
003c3a 0ce6              add     ms_count,  r_one
003c3b 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
003c3c cf4a              rjmp    LOAD_ADD	
                 .endif
                 FF_ISR_EXIT2:
003c3d 910f              pop     t0
003c3e 91ff              pop     zh
003c3f 91ef              pop     zl
                 FF_ISR_EXIT3:
003c40 91a9              ld      xl, y+
003c41 91b9              ld      xh, y+
003c42 bfbf              out_    SREG, xh
003c43 91b9              ld      xh, y+
003c44 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
003c45 9260 0081         out_    TCCR1B, r_one	; Start load counter
                 .endif
                 .endif
003c47 93ba              st      -y, xh
003c48 b7bf              in_     xh, SREG
003c49 93ba              st      -y, xh
003c4a 93aa              st      -y, xl
                         m_pop_xh
003c4b 91bf              pop     xh
003c4c 91af              pop     xl
003c4d 93ef              push    zl
003c4e 93ff              push    zh
003c4f 930f              push    t0
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
003c50 31ad              cpi     xl, low(OC0Aaddr+1)
                 .endif
                 .ifdef OC0addr
                 .endif
003c51 f341              breq    MS_TIMER_ISR
                 .endif
                 .if MS_TIMER == 1
                 .endif
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .endif
                 .ifdef OC2addr
                 .endif
                 .endif
                 
                 
                 .ifdef URXC0addr
                 .else
003c52 32a5              cpi     xl, low(URXCaddr+1)
                 .endif
003c53 f051              breq    RX0_ISR
                 .ifdef URXC1addr
                 .endif
                 
003c54 931f              push    t1
003c55 920f              push    t2
003c56 921f              push    t3
003c57 938f              push    tosl
003c58 939f              push    tosh
                 
003c59 50a1              subi    xl, 1
003c5a e0b1              ldi     xh, high(ivec)
003c5b 91ed              ld      zl, x+
003c5c 91fd              ld      zh, x+
003c5d 9409              mijmp    ;(z)
                 
                 ;;; *************************************************
                 RX0_ISR:
003c5e ebe7              ldi     zl, low(rbuf0)
003c5f e0f1              ldi     zh, high(rbuf0)
003c60 91a0 01b4         lds     xl, rbuf0_wr
003c62 0fea              add     zl, xl
003c63 1df5              adc     zh, zero
003c64 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
003c66 30bf              cpi     xh, 0xf
003c67 f409              brne    pc+2
003c68 cf97              rjmp    RESET_
                 .endif
003c69 83b0              st      z, xh
003c6a 95a3              inc     xl
003c6b 71af              andi    xl, (RX0_BUF_SIZE-1)
003c6c 93a0 01b4         sts     rbuf0_wr, xl
003c6e 91a0 01b6         lds     xl, rbuf0_lv
003c70 95a3              inc     xl
003c71 93a0 01b6         sts     rbuf0_lv, xl
003c73 31ae              cpi     xl, RX0_BUF_SIZE-2
003c74 f409              brne    PC+2
003c75 d004              rcall   RX0_OVF
003c76 30a4              cpi     xl, RX0_OFF_FILL
003c77 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c78 d03b              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
003c79 cfc3              rjmp    FF_ISR_EXIT2
                 RX0_OVF:
003c7a e7fc              ldi     zh, '|'
003c7b c03a              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;;; Enable load led
003c7c df5c              fdw     BUSY_L
                 LOADON_L:
003c7d 6c85
003c7e 616f
003c7f 2b64              .db     NFA|5,"load+"
003c80 6170              sbr     FLAGS2, (1<<fLOADled)
003c81 9508              ret
                 
                 ;;; Disable load led
003c82 f8fa              fdw     LOADON_L
                 LOADOFF_L:
003c83 6c85
003c84 616f
003c85 2d64              .db     NFA|5,"load-"
003c86 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
003c87 9825              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003c88 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003c89 9508              ret
                 ;;; Enable load led
003c8a f906              fdw     LOADOFF_L
                 LOAD_L:
003c8b 6c84
003c8c 616f
003c8d 0064              .db     NFA|4,"load",0
003c8e 939a
003c8f 938a              pushtos
003c90 2799              clr     tosh
003c91 9180 01e6         lds     tosl, load
003c93 9508              ret
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
003c94 f916              fdw(LOAD_L)
                 TX0_L:
003c95 7483
003c96 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c97 3181              cpi     tosl, XON
003c98 f071              breq    XXON_TX0_TOS
003c99 3183              cpi     tosl, XOFF
003c9a f0a1              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c9b 6870              sbr     FLAGS2, (1<<fBUSY)
003c9c d285              rcall   PAUSE
003c9d 9100 00c0         in_     t0, UCSR0A
003c9f ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003ca0 cffa              rjmp    TX0_LOOP
003ca1 9380 00c6         out_    UDR0_, tosl
003ca3 9189
003ca4 9199              poptos
003ca5 777f              cbr     FLAGS2, (1<<fBUSY)
003ca6 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003ca7 9189
003ca8 9199              poptos
003ca9 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003caa ff70              sbrs    FLAGS2, ixoff_tx0
003cab 9508              ret
                 XXON_TX0_1:
003cac 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003cad e1f1              ldi     zh, XON
003cae c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003caf 9189
003cb0 9199              poptos
003cb1 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003cb2 fd70              sbrc    FLAGS2, ixoff_tx0
003cb3 9508              ret     
                 XXOFF_TX0_1:
003cb4 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003cb5 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003cb6 91e0 00c0         in_     zl, UCSR0A
003cb8 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003cb9 cffc              rjmp    TX0_SEND
003cba 93f0 00c6         out_    UDR0_, zh
003cbc 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003cbd f92a              fdw(TX0_L)
                 RX0_L:
003cbe 7283
003cbf 3078              .db     NFA|3,"rx0"
                 RX0_:
003cc0 d261              rcall   PAUSE
003cc1 d01e              rcall   RX0Q
003cc2 940e 339c         call    ZEROSENSE
003cc4 f3d9              breq    RX0_
003cc5 939a
003cc6 938a              pushtos
003cc7 ebe7              ldi     zl, low(rbuf0)
003cc8 e0f1              ldi     zh, high(rbuf0)
003cc9 91a0 01b5         lds     xl, rbuf0_rd
003ccb 0fea              add     zl, xl
003ccc 1df5              adc     zh, zero
003ccd 8180              ld      tosl, z
003cce 2799              clr     tosh
003ccf b60f              in_     t2, SREG
003cd0 94f8              cli
003cd1 95a3              inc     xl
003cd2 71af              andi    xl, (RX0_BUF_SIZE-1)
003cd3 93a0 01b5         sts     rbuf0_rd, xl
003cd5 91a0 01b6         lds     xl, rbuf0_lv
003cd7 95aa              dec     xl
003cd8 93a0 01b6         sts     rbuf0_lv, xl
003cda be0f              out_    SREG, t2
003cdb 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003cdc f97c              fdw     RX0_L
                 RX0Q_L:
003cdd 7284
003cde 3078
003cdf 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003ce0 91a0 01b6         lds     xl, rbuf0_lv
003ce2 11a5              cpse    xl, zero
003ce3 940c 3733         jmp     TRUE_
                 .if U0FC_TYPE == 1
003ce5 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003ce6 940c 372a         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003ce8 dc3b              rcall   DOTS
003ce9 940e 3233         call    XSQUOTE
003ceb 4103
003cec 3f44              .db     3,"AD?"
003ced 940e 3226         call    TYPE
003cef ca72              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibasehi != iaddrhi)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003cf0 2d0d              mov     t0, iaddrh
003cf1 3e00              cpi     t0, 0xe0       ; Dont allow kernel writes
003cf2 f7a8              brcc    ISTORERR
003cf3 2d0c              mov     t0, iaddrl
003cf4 7800              andi    t0, ~(PAGESIZEB-1)
003cf5 110a              cpse    t0, ibasel
003cf6 c003              rjmp    IFILL_BUFFER
003cf7 10db              cpse    iaddrh, ibaseh
003cf8 c001              rjmp    IFILL_BUFFER
003cf9 9508              ret
                 
                 IFILL_BUFFER:
003cfa d04d              rcall   IFLUSH
003cfb 2d0c              mov     t0, iaddrl
003cfc 7800              andi    t0, ~(PAGESIZEB-1)
003cfd 2ea0              mov     ibasel, t0
003cfe 2cbd              mov     ibaseh, iaddrh
                 IFILL_BUFFER_1:
003cff e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003d00 01f5              movw    zl, ibasel
003d01 58f0              sub_pflash_z
003d02 e0a0              ldi     xl, low(ibuf)
003d03 e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003d04 9115              lpm_    t1, z+
003d05 931d              st      x+, t1
003d06 950a              dec     t0
003d07 f7e1              brne    IFILL_BUFFER_2
003d08 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d09 da7e              rcall   DOLIT
003d0a 0013              .dw     XOFF
003d0b 940e 305c         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d0d da7a              rcall   DOLIT
003d0e 000a              .dw     10
003d0f dbc7              rcall   MS
                         ; Disable interrupts
003d10 94f8              cli
003d11 01f5              movw    zl, ibasel
003d12 58f0              sub_pflash_z
003d13 e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003d14 d028              rcall   DO_SPM
003d15 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003d16 d026              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003d17 e800              ldi     t0, low(PAGESIZEB);init loop variable
003d18 e0a0              ldi     xl, low(ibuf)
003d19 e0b1              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
003d1a 900d              ld      r0, x+
003d1b 901d              ld      r1, x+
003d1c e011              ldi     t1, (1<<SPMEN)
003d1d d01f              rcall   DO_SPM
003d1e 9632              adiw    zl, 2
003d1f 5002              subi    t0, 2
003d20 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d21 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d22 40f0              sbci    zh, high(PAGESIZEB)
003d23 e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d24 d018              rcall   DO_SPM
                         ; re-enable the RWW section
003d25 d011              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d26 e800              ldi     t0, low(PAGESIZEB);init loop variable
003d27 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d28 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d29 9005              lpm_    r0, z+
003d2a 901d              ld      r1, x+
003d2b 1001              cpse    r0, r1
003d2c c030              rjmp    WARM_     ; reset
003d2d 5001              subi    t0, 1
003d2e f7d1              brne    IWRITE_BUFFER2
                 
003d2f 24bb              clr     ibaseh
003d30 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d31 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d32 da55              rcall   DOLIT
003d33 0011              .dw     XON
003d34 940e 305c         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d36 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d37 b687              in_     t8, SPMCSR
003d38 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d39 9508              ret
                         ; re-enable the RWW section
003d3a e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d3b d001              rcall   DO_SPM
003d3c cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d3d b687              in_     t8, SPMCSR
003d3e fc80              sbrc    t8, SPMEN
003d3f cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d40 bf17              out_    SPMCSR, t1
003d41 95e8              spm
003d42 9508              ret
                 
                                 
003d43 fe3e              fdw     PAUSE_L
                 IFLUSH_L:
003d44 6986
003d45 6c66
003d46 7375
003d47 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d48 fd60              sbrc    FLAGS1, idirty
003d49 cfbf              rjmp    IWRITE_BUFFER
003d4a 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d4b f9ba              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d4c 6585
003d4d 706d
003d4e 7974              .db     NFA|5,"empty"
                 EMPTY:
003d4f da38              rcall   DOLIT
003d50 ff50              fdw     COLDLIT
003d51 da36              rcall   DOLIT
003d52 0900              .dw     dp_start
003d53 da34              rcall   DOLIT
003d54 000c              .dw     coldlitsize
003d55 940e 3515         call    CMOVE
003d57 940c 3706         jmp     DP_TO_RAM
                         
                 ;*******************************************************
003d59 fa98              fdw     EMPTY_L
                 WARM_L:
003d5a 7784
003d5b 7261
003d5c 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d5d 94f8              cli           ; Disable interrupts
003d5e 27aa              clr     xl
003d5f 27bb              clr     xh
003d60 e1c9              ldi     yl, 25
003d61 e0d0              ldi     yh, 0
                 WARM_1:
003d62 93dd              st      x+, yh
003d63 50c1              subi    yl, 1
003d64 f7e9              brne    WARM_1
                 
003d65 b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d66 b604              in_     t2, MCUSR
003d67 9250 0034         sts     MCUSR, zero
                 .endif
003d69 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d6a 925d              st      x+, zero
003d6b 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d6c f7e9              brne    WARM_2
003d6d e0c1              ldi     yl, 1
003d6e 2e6c              mov     r_one, yl
003d6f e0c2              ldi     yl, 2
003d70 2e7c              mov     r_two, yl
                 ; Init Stack pointer
003d71 eac3              ldi     yl, low(utibbuf-4)
003d72 e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d73 e606              ldi     t0, low(usbuf-1)
003d74 e012              ldi     t1, high(usbuf-1)
003d75 bf0d              out     spl, t0
003d76 bf1e              out     sph, t1
                 ; Init user pointer
003d77 e005              ldi     t0, low(up0)
003d78 e012              ldi     t1, high(up0)
003d79 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d7a da0d              rcall   DOLIT
003d7b ff34              fdw     WARMLIT
003d7c da0b              rcall   DOLIT
003d7d 01e7              .dw     cse
003d7e da09              rcall   DOLIT
003d7f 001c              .dw     warmlitsize
003d80 940e 3515         call    CMOVE
                 ; init cold data to eeprom
003d82 da05              rcall   DOLIT
003d83 0900              .dw     dp_start
003d84 d0ec              rcall   FETCH
003d85 d9ad              rcall   TRUE_
003d86 940e 332c         call    EQUAL
003d88 940e 339c         call    ZEROSENSE
003d8a f009              breq    WARM_3  
003d8b dfc3              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d8c be65              out_    MCUCR, r_one   ; (1<<IVCE)
003d8d be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 ; Init ms timer
                 .ifdef TIMSK0
003d8e bc74              out_    TCCR0A, r_two  ; CTC
003d8f e003              ldi     t0, ms_pre_tmr0
003d90 bd05              out_    TCCR0B, t0
003d91 ef09              ldi     t0, ms_value_tmr0
003d92 bd07              out_    OCR0A, t0
003d93 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
                         ; Set baud rate
                 ;        out_    UBRR0H, zero
003d95 e109              ldi     t0, ubrr0val
003d96 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003d98 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003d99 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003d9b e006              ldi     t0, (3<<UCSZ00)|URSEL_
003d9c 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003d9e 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d9f d966              rcall   DP_TO_RAM
003da0 9478              sei
                 
003da1 dd95              rcall   RQ_EMIT
003da2 d023              rcall   VER
                 ; Turnkey ?
003da3 d177              rcall   TURNKEY
003da4 940e 339c         call    ZEROSENSE
003da6 f0d1              breq    STARTQ2
003da7 940e 3233         call    XSQUOTE
003da9 4503
003daa 4353              .db     3,"ESC"
003dab 940e 3226         call    TYPE
003dad d9da              rcall   DOLIT
003dae 07d0              .dw     TURNKEY_DELAY
003daf db27              rcall   MS
003db0 940e 3069         call    KEYQ
003db2 940e 339c         call    ZEROSENSE
003db4 f049              breq    STARTQ1
003db5 940e 3062         call    KEY
003db7 d9d0              rcall   DOLIT
003db8 001b              .dw     0x1b
003db9 940e 332c         call    EQUAL
003dbb 940e 339c         call    ZEROSENSE
003dbd f419              brne    STARTQ2
                 STARTQ1:
003dbe d15c              rcall   TURNKEY
003dbf 940e 3071         call    EXECUTE
                 STARTQ2:
003dc1 940c 3762         jmp     ABORT
                 
003dc3 fab4              fdw     WARM_L
                 VER_L:
003dc4 7683
003dc5 7265              .db     NFA|3,"ver"
                 VER:
003dc6 940e 3233         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
003dc8 4617
003dc9 616c
003dca 6873
003dcb 6f46
003dcc 7472
003dcd 2068
003dce 7441
003dcf 656d
003dd0 6167
003dd1 3520
003dd2 302e
003dd3 0a0d              .db 23,"FlashForth Atmega 5.0",0xd,0xa
003dd4 940c 3226         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003dd6 fb88              fdw     VER_L
                 EI_L:
003dd7 65a2
003dd8 0069              .db     NFA|INLINE|2,"ei",0
003dd9 9478              sei
003dda 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003ddb fbae              fdw     EI_L
                 DI_L:
003ddc 64a2
003ddd 0069              .db     NFA|INLINE|2,"di",0
003dde 94f8              cli
003ddf 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003de0 fbb8              fdw     DI_L
                 IRQ_SEMI_L:
003de1 3bc2
003de2 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003de3 d9a4              rcall   DOLIT
                 .ifdef EIND
                 .else
003de4 940c              .dw     0x940C     ; jmp
                 .endif
003de5 d168              rcall   ICOMMA
003de6 d9a1              rcall   DOLIT
003de7 3c34              .dw     FF_ISR_EXIT
003de8 d165              rcall   ICOMMA
003de9 940c 3847         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003deb fbc2              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003dec 6984
003ded 746e
003dee 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003def 01fc              movw    zl, tosl
003df0 9731              sbiw    zl, 1
003df1 0fee              lsl     zl
003df2 e0f1              ldi     zh, high(ivec)
003df3 9189
003df4 9199              poptos
003df5 db82              rcall   TO_XA
003df6 940c 3e2e         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003df8 fbd8              fdw     IRQ_V_L
                 LITERAL_L:
003df9 6cc7
003dfa 7469
003dfb 7265
003dfc 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003dfd d98a              rcall   DOLIT
003dfe ef22              fdw     DUP
003dff dc0d              rcall   INLINE0
003e00 940e 3791         call    DUP
003e02 2f98              mov     tosh, tosl
003e03 9592              swap    tosh
003e04 709f              andi    tosh, 0xf
003e05 708f              andi    tosl, 0xf
003e06 6e90              ori     tosh, 0xe0
003e07 6880              ori     tosl, 0x80
003e08 d145              rcall   ICOMMA
003e09 2f89              mov     tosl, tosh
003e0a 9592              swap    tosh
003e0b 709f              andi    tosh, 0xf
003e0c 708f              andi    tosl, 0xf
003e0d 6e90              ori     tosh, 0xe0
003e0e 6980              ori     tosl, 0x90
003e0f 940c 3f4e         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e11 d039              rcall   LOCKEDQ
003e12 016c              movw    iaddrl, tosl
003e13 dedc              rcall   IUPDATEBUF
003e14 9189
003e15 9199              poptos
003e16 e0a0              ldi     xl, low(ibuf)
003e17 e0b1              ldi     xh, high(ibuf)
003e18 2d0c              mov     t0, iaddrl
003e19 770f              andi    t0, (PAGESIZEB-1)
003e1a 0fa0              add     xl, t0
003e1b 938d              st      x+, tosl
003e1c 939d              st      x+, tosh
003e1d 9189
003e1e 9199              poptos
003e1f 6061              sbr     FLAGS1, (1<<idirty)
003e20 9508              ret
                 
003e21 fbf2              fdw     LITERAL_L
                 TO_A_L:
003e22 3e82
003e23 0061              .db     NFA|2, ">a",0
003e24 eee1              ldi     zl, low(areg)
003e25 e0f1              ldi     zh, high(areg)
003e26 c007              rjmp    STORE_RAM_2
                 
003e27 fc44              fdw     TO_A_L
                 STORE_L:
003e28 2181              .db     NFA|1, "!"
                 STORE:
003e29 3099              cpi     tosh, high(PEEPROM)
003e2a f440              brcc    STORE1
                 STORE_RAM:
003e2b 01fc              movw    zl, tosl
003e2c 9189
003e2d 9199              poptos
                 STORE_RAM_2:
003e2e 8391              std     Z+1, tosh
003e2f 8380              std     Z+0, tosl
003e30 9189
003e31 9199              poptos
003e32 9508              ret
                 STORE1:
003e33 3890              cpi     tosh, high(OFLASH)
003e34 f6e0              brcc    ISTORE
                 ESTORE:
003e35 d015              rcall   LOCKEDQ
003e36 99f9              sbic    eecr, eewe
003e37 cffd              rjmp    ESTORE
003e38 5099              subi    tosh, high(PEEPROM)
003e39 bd81              out     eearl, tosl
003e3a bd92              out     eearh, tosh
003e3b 9189
003e3c 9199              poptos
003e3d bd80              out     eedr, tosl
003e3e 9afa              sbi     eecr, eemwe
003e3f 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
003e40 99f9              sbic    eecr, eewe
003e41 cffe              rjmp    ESTORE1
                 
003e42 b581              in      tosl, eearl
003e43 9583              inc     tosl
003e44 bd81              out     eearl, tosl
                 
003e45 bd90              out     eedr, tosh
003e46 9afa              sbi     eecr, eemwe
003e47 9af9              sbi     eecr, eewe
                 
003e48 9189
003e49 9199              poptos
003e4a 9508              ret
                 LOCKEDQ:
003e4b ff62              sbrs    FLAGS1, fLOCK
003e4c 9508              ret
003e4d dad6              rcall   DOTS
003e4e 940e 3233         call    XSQUOTE
003e50 4103
003e51 3f44              .db     3,"AD?"
003e52 940e 3226         call    TYPE
003e54 cf6c              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e55 01fc              movw    z, tosl
003e56 11fb              cpse    zh, ibaseh
003e57 c00b              rjmp    IIFETCH
003e58 2f0e              mov     t0, zl
003e59 7800              andi    t0, ~(PAGESIZEB-1)
003e5a 150a              cp      t0, ibasel
003e5b f439              brne    IIFETCH
003e5c e0a0              ldi     xl, low(ibuf)
003e5d e0b1              ldi     xh, high(ibuf)
003e5e 77ef              andi    zl, (PAGESIZEB-1)
003e5f 0fae              add     xl, zl
003e60 918d              ld      tosl, x+
003e61 919d              ld      tosh, x+
003e62 9508              ret
                 IIFETCH:
003e63 58f0              sub_pflash_z
003e64 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e65 9195              lpm_    tosh, z+
                 .ifdef RAMPZ
                 .endif
003e66 9508              ret
                                 
003e67 fc50              fdw     STORE_L
                 A_FROM_L:
003e68 6182
003e69 003e              .db     NFA|2, "a>",0
003e6a 939a
003e6b 938a              pushtos
003e6c eee1              ldi     zl, low(areg)
003e6d e0f1              ldi     zh, high(areg)
003e6e c005              rjmp    FETCH_RAM_2
                 
003e6f fcd0              fdw     A_FROM_L
                 FETCH_L:
003e70 4081              .db     NFA|1, "@"
                 FETCH:
003e71 3099              cpi     tosh, high(PEEPROM)
003e72 f420              brcc    FETCH1
                 FETCH_RAM:
003e73 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e74 9181              ld      tosl, z+
003e75 9191              ld      tosh, z+
003e76 9508              ret
                 FETCH1:
003e77 3890              cpi     tosh, high(OFLASH)
003e78 f6e0              brcc    IFETCH
                 EFETCH:
003e79 99f9              sbic    eecr, eewe
003e7a cffe              rjmp    EFETCH
003e7b 5099              subi    tosh, high(PEEPROM)
003e7c bd81              out     eearl, tosl
003e7d bd92              out     eearh, tosh
003e7e 9af8              sbi     eecr, eere
003e7f b580              in      tosl, eedr
003e80 b591              in      tosh, eearl
003e81 9593              inc     tosh
003e82 bd91              out     eearl, tosh
003e83 9af8              sbi     eecr, eere
003e84 b590              in      tosh, eedr
003e85 9508              ret
                 
                 ICFETCH:
003e86 01fc              movw    z, tosl
003e87 11fb              cpse    zh, ibaseh
003e88 c00b              rjmp    IICFETCH
003e89 2f0e              mov     t0, zl
003e8a 7800              andi    t0, ~(PAGESIZEB-1)
003e8b 150a              cp      t0, ibasel
003e8c f439              brne    IICFETCH
003e8d e0a0              ldi     xl, low(ibuf)
003e8e e0b1              ldi     xh, high(ibuf)
003e8f 77ef              andi    zl, (PAGESIZEB-1)
003e90 0fae              add     xl, zl
003e91 918d              ld      tosl, x+
003e92 2799              clr     tosh
003e93 9508              ret
                 IICFETCH:
003e94 58f0              sub_pflash_z
003e95 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e96 2799              clr     tosh
                 .ifdef RAMPZ
                 .endif
003e97 9508              ret
                 
003e98 fce0              fdw     FETCH_L
                 CFETCH_L:
003e99 6382
003e9a 0040              .db     NFA|2, "c@",0
                 CFETCH:
003e9b 3099              cpi     tosh, high(PEEPROM)
003e9c f420              brcc    CFETCH1
                 CFETCH_RAM:
003e9d 01fc              movw    zl, tosl
003e9e 9181              ld      tosl, z+
003e9f 2799              clr     tosh
003ea0 9508              ret
                 CFETCH1:
003ea1 3890              cpi     tosh, high(OFLASH)
003ea2 f718              brcc    ICFETCH
                 ECFETCH:
003ea3 99f9              sbic    eecr, eewe
003ea4 cffe              rjmp    ECFETCH
003ea5 5099              subi    tosh, high(PEEPROM)
003ea6 bd81              out     eearl, tosl
003ea7 bd92              out     eearh, tosh
003ea8 9af8              sbi     eecr, eere
003ea9 b580              in      tosl, eedr
003eaa 2799              clr     tosh
003eab 9508              ret
                 
                 ICSTORE:
003eac df9e              rcall   LOCKEDQ
003ead 016c              movw    iaddrl, tosl
003eae de41              rcall   IUPDATEBUF
003eaf 9189
003eb0 9199              poptos
003eb1 e0a0              ldi     xl, low(ibuf)
003eb2 e0b1              ldi     xh, high(ibuf)
003eb3 2d0c              mov     t0, iaddrl
003eb4 770f              andi    t0, (PAGESIZEB-1)
003eb5 0fa0              add     xl, t0
003eb6 938d              st      x+, tosl
003eb7 9189
003eb8 9199              poptos
003eb9 6061              sbr     FLAGS1, (1<<idirty)
003eba 9508              ret
                 
003ebb fd32              fdw     CFETCH_L
                 CSTORE_L:
003ebc 6382
003ebd 0021              .db     NFA|2, "c!",0
                 CSTORE:
003ebe 3099              cpi     tosh, high(PEEPROM)
003ebf f438              brcc    CSTORE1
                 CSTORE_RAM:
003ec0 01fc              movw zl, tosl
003ec1 9189
003ec2 9199              poptos
003ec3 8380              std Z+0, tosl
003ec4 9189
003ec5 9199              poptos
003ec6 9508              ret
                 CSTORE1:
003ec7 3890              cpi     tosh, high(OFLASH)
003ec8 f718              brcc    ICSTORE
                 ECSTORE:
003ec9 df81              rcall   LOCKEDQ
003eca 99f9              sbic    eecr, eewe
003ecb cffd              rjmp    ECSTORE
003ecc 5099              subi    tosh, high(PEEPROM)
003ecd bd81              out     eearl, tosl
003ece bd92              out     eearh, tosh
003ecf 9189
003ed0 9199              poptos
003ed1 bd80              out     eedr, tosl
003ed2 9afa              sbi     eecr, eemwe
003ed3 9af9              sbi     eecr, eewe
003ed4 9189
003ed5 9199              poptos
003ed6 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
003ed7 fd78              fdw     CSTORE_L
                 
                 FLOCK_L:
003ed8 6683
003ed9 2d6c              .db     NFA|3,"fl-"
003eda 6064              sbr     FLAGS1, (1<<fLOCK)
003edb 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003edc fdb0              fdw     FLOCK_L
                 FUNLOCK_L:
003edd 6683
003ede 2b6c              .db     NFA|3,"fl+"
003edf 7f6b              cbr     FLAGS1, (1<<fLOCK)
003ee0 9508              ret
                 
                 
                 
003ee1 fdba              fdw     FUNLOCK_L
                 VALUE_L:
003ee2 7685
003ee3 6c61
003ee4 6575              .db     NFA|5,"value"
                 VALUE:
003ee5 d8f6              rcall   CREATE
003ee6 940e 3126         call    COMMA
003ee8 d943              rcall   XDOES
                 VALUE_DOES:
003ee9 940e 30b9         call    DODOES
003eeb 940c 3e71         jmp     FETCH
                 
003eed fdc4              fdw     VALUE_L
                 DEFER_L:
003eee 6485
003eef 6665
003ef0 7265              .db     NFA|5,"defer"
                 DEFER:
003ef1 d8ea              rcall   CREATE
003ef2 940e 3788         call    DOLIT
003ef4 eec4              fdw     ABORT
003ef5 940e 3126         call    COMMA
003ef7 d934              rcall   XDOES
                 DEFER_DOES:
003ef8 940e 30b9         call    DODOES
003efa 940c 307c         jmp     FEXECUTE
                 
003efc fddc              fdw     DEFER_L
                 IS_L:
003efd 69c2
003efe 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003eff 940e 37a6         call    TICK
003f01 940e 32f8         call    TWOPLUS
003f03 940e 32f8         call    TWOPLUS
003f05 df6b              rcall   FETCH
003f06 d9a3              rcall   STATE_
003f07 940e 339c         call    ZEROSENSE
003f09 f029              breq    IS1
003f0a def2              rcall   LITERAL
003f0b 940e 30c9         call    DOCOMMAXT
003f0d fc52              fdw     STORE
003f0e c001              rjmp    IS2
                 IS1:
003f0f df19              rcall   STORE
                 IS2:
003f10 9508              ret
                 
003f11 fdfa              fdw     IS_L
                 TO_L:
003f12 74c2
003f13 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003f14 940c 3eff         jmp     IS
                 
003f16 fe24              fdw     TO_L
                 TURNKEY_L:
003f17 7487
003f18 7275
003f19 6b6e
003f1a 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003f1b 940e 3ee9         call    VALUE_DOES      ; Must be call for IS to work.
003f1d 01d7              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003f1e fe2e              fdw     TURNKEY_L
                 PAUSE_L:
003f1f 7085
003f20 7561
003f21 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003f22 dc2f              rcall   IDLE_LOAD
                 .endif
003f23 b60f              in_     t2, SREG
003f24 94f8              cli
003f25 93df              push    yh        ; SP
003f26 93cf              push    yl
003f27 939f              push    tosh      ; TOS
003f28 938f              push    tosl
003f29 935f              push    ph        ; P
003f2a 934f              push    pl
003f2b 01f1              movw    zl, upl
003f2c b70e              in      t0, sph
003f2d 9302              st      -z, t0
003f2e b70d              in      t0, spl
003f2f 9302              st      -z, t0
003f30 91b2              ld      xh, -z     ; UP
003f31 91a2              ld      xl, -z
003f32 011d              movw    upl, xl
003f33 910e              ld      t0, -x
003f34 bf0e              out     sph, t0
003f35 910e              ld      t0, -x
003f36 bf0d              out     spl, t0
003f37 914f              pop     pl
003f38 915f              pop     ph
003f39 918f              pop     tosl
003f3a 919f              pop     tosh
003f3b 91cf              pop     yl
003f3c 91df              pop     yh
003f3d be0f              out_    SREG, t2
003f3e 9508              ret
                 
                 
003f3f fa88              fdw     IFLUSH_L
                 OPERATOR_L:
003f40 6f88
003f41 6570
003f42 6172
003f43 6f74
003f44 0072              .db     NFA|8,"operator",0
                 OPERATOR:
003f45 940e 30b1         call    DOCREATE
003f47 fe90              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
003f48 0205              .dw     up0
003f49 6000              .db     0, ursize
003f4a 5440              .db     ussize, utibsize
                 
003f4b fe80              fdw     OPERATOR_L
                 ICOMMA_L:
003f4c 6982
003f4d 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f4e 940e 37bf         call    IHERE
003f50 ded8              rcall   STORE
003f51 940e 3137         call    CELL
003f53 940c 3965         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f55 fe98              fdw     ICOMMA_L
                 ICCOMMA_L:
003f56 6983
003f57 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f58 940e 37bf         call    IHERE
003f5a df63              rcall   CSTORE
003f5b 940e 31df         call    ONE
003f5d 940c 3965         jmp     IALLOT
                 
                 L_DOTBASE:
003f5f 2081              .db      NFA|1," "
                 DOTBASE:
003f60 940e 34b6         call    BASE
003f62 df0e              rcall   FETCH
003f63 3180              cpi     tosl, 0x10
003f64 f411              brne    DOTBASE1
003f65 e284              ldi     tosl,'$'
003f66 c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f67 308a              cpi     tosl, 0xa
003f68 f411              brne    DOTBASE2
003f69 e283              ldi     tosl, '#'
003f6a c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f6b 3082              cpi     tosl, 0x2
003f6c f411              brne    DOTBASE3
003f6d e285              ldi     tosl, '%'
003f6e c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f6f e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f70 9508              ret
                 
                 MEMQADDR_N:
003f71 e1f2              fdw     ROM_N
003f72 e200              fdw     EROM_N
003f73 e210              fdw     FRAM_N
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
003f74 2081              .db     NFA|1," "
                 MEMQ:
003f75 940e 3117         call    CSE_
003f77 940e 3788         call    DOLIT
003f79 fee2              fdw     MEMQADDR_N
003f7a 940e 32b0         call    PLUS
003f7c 940e 36c8         call    FETCH_A
003f7e 940e 3530         call    CFETCHPP
003f80 940e 3788         call    DOLIT
003f82 000f              .dw     NFAmask
003f83 940c 32c6         jmp     AND_
                 
                 ;*******************************************************
                 umstar0:
003f85 9109              ld  t0, Y+
003f86 9119              ld  t1, Y+
003f87 9f80              mul tosl,t0
003f88 01d0              movw t4, r0 ; r0=t2, r1=t3
003f89 27ee              clr t6
003f8a 27ff              clr t7
003f8b 9f90              mul tosh, t0
003f8c 0db0              add t5, r0
003f8d 1de1              adc t6, r1
003f8e 1df5              adc t7, zero
003f8f 9f81              mul tosl, t1
003f90 0db0              add t5, r0
003f91 1de1              adc t6, r1
003f92 1df5              adc t7, zero
003f93 9f91              mul tosh, t1
003f94 0de0              add t6, r0
003f95 1df1              adc t7, r1
003f96 93ba              st -Y, t5
003f97 93aa              st -Y, t4
003f98 01cf              movw tosl, t6
003f99 9508              ret
                 
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
003f9a 0200              .dw      0x0200                ; cse, state
003f9b 02a3              .dw      utibbuf-4             ; S0
003f9c 0266              .dw      usbuf-1               ; R0
003f9d f92e              fdw      OP_TX_
003f9e f980              fdw      OP_RX_
003f9f f9c0              fdw      OP_RXQ
003fa0 000a              .dw      BASE_DEFAULT          ; BASE
003fa1 02a7              .dw      utibbuf               ; TIB
003fa2 fe90              fdw      OPERATOR_AREA         ; TASK
003fa3 0000              .dw      0                     ; ustatus & uflg
003fa4 0000              .dw      0                     ; source
003fa5 0000              .dw      0                     ; source
003fa6 0000              .dw      0                     ; TOIN
003fa7 0205              .dw      up0                   ; Task link
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 .equ coldlitsize=12
                 ;.section user_eedata
                 COLDLIT:
003fa8 0000      STARTV: .dw      0
003fa9 8000      DPC:    .dw      OFLASH
003faa 090c      DPE:    .dw      ehere
003fab 02fb      DPD:    .dw      dpdata
003fac f63c      LW:     fdw      lastword
003fad edd8      STAT:   fdw      DOTSTATUS
                 
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328 register use summary:
r0 :  24 r1 :  17 r2 :   5 r3 :   1 r4 :   0 r5 :  21 r6 :   5 r7 :   6 
r8 :   4 r9 :   4 r10:   6 r11:   5 r12:   6 r13:   3 r14:   3 r15:   2 
r16: 119 r17:  50 r18:   0 r19:   0 r20:  14 r21:   7 r22:  34 r23:  18 
r24: 220 r25: 180 r26:  61 r27:  43 r28:   9 r29:   5 r30:  73 r31:  51 
x  :  17 y  : 178 z  :  33 
Registers used: 32 out of 35 (91.4%)

ATmega328 instruction use summary:
.lds  :   0 .sts  :   0 adc   :  18 add   :  17 adiw  :   9 and   :   3 
andi  :  20 asr   :   2 bclr  :   4 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  20 brcs  :   1 break :   0 breq  :  45 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   6 
brne  :  37 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  91 cbi   :   3 cbr   :  21 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :  22 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   7 cp    :   4 cpc   :   2 
cpi   :  25 cpse  :   6 dec   :   3 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  14 in    :  18 inc   :   6 jmp   : 163 
ld    : 123 ldd   :   2 ldi   :  66 lds   :  20 lpm   :   9 lsl   :  11 
lsr   :   2 mov   :  20 movw  :  40 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   7 ori   :   7 out   :  32 pop   :  80 
push  :  26 rcall : 972 ret   : 126 reti  :   1 rjmp  :  95 rol   :  15 
ror   :  18 sbc   :   2 sbci  :   3 sbi   :  11 sbic  :   5 sbis  :   0 
sbiw  :   8 sbr   :  18 sbrc  :  14 sbrs  :  16 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   6 ses   :   0 set   :   1 sev   :   0 
sez   :   0 sleep :   1 spm   :   2 st    :  83 std   :   3 sts   :  27 
sub   :   2 subi  :  22 swap  :   2 tst   :   4 wdr   :   0 
Instructions used: 71 out of 113 (62.8%)

ATmega328 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007f5c   5574   2472   8046   32768  24.6%
[.dseg] 0x000100 0x0002fd      0    509    509    2048  24.9%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 7 warnings
