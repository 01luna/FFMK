
AVRASM ver. 2.1.30  avr/src/ff-atmega.asm Sun Nov 27 19:04:14 2016

avr/src/ff-atmega.asm(34): Including file 'avr/src/config.inc'
avr/src/config.inc(8): Including file 'avrasm2/inc\m328pdef.inc'
avr/src/ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
avr/src/ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
avr/src/ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
avr/src/ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
avr/src/ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
avr/src/ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
avr/src/ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          11.11.2016                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2016  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 ;.include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 .include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega328P.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328Pdef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328P
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328P
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328PDEF_INC_
                 #define _M328PDEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328P
                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x0f
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 .equ	BODSE	= 5	; BOD Sleep Enable
                 .equ	BODS	= 6	; BOD Sleep
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328PDEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program. Or use the ff-shell.py which adds CR LF flow control.
                 .equ BAUDRATE0 = 9600               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 0
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 64          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 90                   ; 80 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 ; Debug flash and eeprom writes
                 ; Prints F=Write to FLASH E=Write to EEPROM
                 .equ DEBUG_FLASH = 0
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #define partstring "ATmega328P"
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "11.11.2016"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def al = r18
                   .def ah = r19
                   .def pl = r20         ; P Register and FOR..LOOP INDEX variable
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*255/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fIDLE=     6   ; 0 = busy, 1 = idle
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001d7           dpSTART:    .byte 2
0001d9           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001db           dpEEPROM:   .byte 2
0001dd           dpRAM:      .byte 2
0001df           dpLATEST:   .byte 2
                 
0001e1           iaddrl:     .byte 1
0001e2           iaddrh:     .byte 1
                 .ifdef RAMPZ
                 .endif
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1       
                 .endif
                 .endif
                 
0001e3           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0001e4           state:      .byte 1 ; Compilation state
0001e5           uvars:      .byte   (-us0)
000201           up0:        .byte   2
000203           urbuf:      .byte   ursize
000243           usbuf:      .byte   ussize
000283           utibbuf:    .byte   utibsize
0002dd           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .if (FLASHEND == 0x1ffff)
                 .else
                 .org KERNEL_START
                 .endif
                 ;***********************************************************
                 CMP:
002f80 940e 32d0         call    TOR
002f82 c009              rjmp    CMP2
                 CMP1:
002f83 940e 301e         call    NEQUALSFETCH
002f85 940e 3302         call    MINUS
002f87 940e 33e1         call    ZEROSENSE
002f89 f011              breq    CMP2
002f8a 940c 393a         jmp     TWODROPZ
                 CMP2:
002f8c 940e 3a6e         call    XNEXT
002f8e f7a0              brcc    CMP1
002f8f 940c 3936         jmp     TWODROPNZ
                 .if (FLASHEND == 0x1ffff)
                 .endif
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
002f91 2081              .db     NFA|1," "
                 MEMQ:
002f92 940e 315c         call    CSE_
002f94 940e 37ab         call    DOLIT
002f96 feba              fdw     MEMQADDR_N
002f97 940e 32f5         call    PLUS
002f99 940e 36ee         call    FETCH_A
002f9b 940e 3569         call    CFETCHPP
002f9d 940e 37ab         call    DOLIT
002f9f 000f              .dw     NFAmask
002fa0 940c 330b         jmp     AND_
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
002fa2 94e8              clt
002fa3 2388              tst  tosl
002fa4 f429              brne umslashmodstart
002fa5 2399              tst  tosh
002fa6 f419              brne umslashmodstart
002fa7 9468              set  ; Set T flag
002fa8 940c 3d44         jmp  WARM_
                 umslashmodstart:
002faa 920f              push t2
002fab 921f              push t3
002fac 01dc              movw t4, tosl
                 
002fad 9019              ld t3, Y+
002fae 91e9              ld t6, Y+
                   
002faf 9189              ld tosl, Y+
002fb0 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
002fb1 e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
002fb2 27ff              clr t7
002fb3 0f88              lsl tosl
002fb4 1f99              rol tosh
002fb5 1c11              rol t3
002fb6 1fee              rol t6
002fb7 1fff              rol t7
                 
                         ; try subtracting divisor
002fb8 161a              cp  t3, t4
002fb9 07eb              cpc t6, t5
002fba 05f5              cpc t7,zero
                 
002fbb f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
002fbc 9583              inc tosl
002fbd 1a1a              sub t3, t4
002fbe 0beb              sbc t6, t5
                 
                 umslashmod2:
002fbf 950a              dec  t0
002fc0 f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
002fc1 93ea              st -Y,t6
002fc2 921a              st -Y,t3
002fc3 901f              pop t3
002fc4 900f              pop t2
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
002fc5 9508              ret
                 ;*********************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fc6 0000              .dw     0
                 EXIT_L:
002fc7 6584
002fc8 6978
002fc9 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fca 910f              pop     t0
002fcb 910f              pop     t0
002fcc 9508              ret
                 
002fcd fa56              fdw     IFLUSH_L
                 OPERATOR_L:
002fce 6f88
002fcf 6570
002fd0 6172
002fd1 6f74
002fd2 0072              .db     NFA|8,"operator",0
                 OPERATOR:
002fd3 940e 30f6         call    DOCREATE
002fd5 dfac              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
002fd6 0201              .dw     up0
002fd7 0000
002fd8 0040              .dw     0, ursize
002fd9 0040
002fda 005a              .dw     ussize, utibsize
                 
                 ; idle
002fdb df8e              fdw(EXIT_L)
                 IDLE_L:
002fdc 6984
002fdd 6c64
002fde 0065              .db     NFA|4,"idle",0
                 IDLE:
002fdf 6470              sbr     FLAGS2, (1<<fIDLE)
002fe0 9508              ret
                         
                 ; busy
002fe1 dfb8              fdw(IDLE_L)
                 BUSY_L:
002fe2 6284
002fe3 7375
002fe4 0079              .db     NFA|4,"busy",0
                 BUSY:
002fe5 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fe6 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fe7 fe84              fdw     ICCOMMA_L
                 MSET_L:
002fe8 6d84
002fe9 6573
002fea 0074              .db     NFA|4,"mset",0
                 MSET:
002feb 01fc              movw    zl, tosl
002fec 9189
002fed 9199              poptos
002fee 8100              ld      t0, z
002fef 2b08              or      t0, tosl
002ff0 8300              st      z, t0
002ff1 9189
002ff2 9199              poptos
002ff3 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002ff4 dfd0              fdw     MSET_L
                 MCLR_L:
002ff5 6d84
002ff6 6c63
002ff7 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002ff8 01fc              movw    zl, tosl
002ff9 9189
002ffa 9199              poptos
002ffb 8100              ld      t0, z
002ffc 9580              com     tosl
002ffd 2308              and     t0, tosl
002ffe 8300              st      z, t0
002fff 9189
003000 9199              poptos
003001 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
003002 dfea              fdw     MCLR_L
                 LSHIFT_L:
003003 6c86
003004 6873
003005 6669
003006 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
003007 01fc              movw    zl, tosl
003008 9189
003009 9199              poptos
                 LSHIFT1:
00300a 9731              sbiw    zl, 1
00300b f01a              brmi    LSHIFT2
00300c 0f88              lsl     tosl
00300d 1f99              rol     tosh
00300e cffb              rjmp    LSHIFT1
                 LSHIFT2:
00300f 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
003010 e006              fdw     LSHIFT_L
                 RSHIFT_L:
003011 7286
003012 6873
003013 6669
003014 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
003015 01fc              movw    zl, tosl
003016 9189
003017 9199              poptos
                 RSHIFT1:
003018 9731              sbiw    zl, 1
003019 f01a              brmi    RSHIFT2
00301a 9596              lsr     tosh
00301b 9587              ror     tosl
00301c cffb              rjmp    RSHIFT1
                 RSHIFT2:
00301d 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
00301e d54a              rcall   CFETCHPP
00301f d2a8              rcall   ROT
003020 d548              rcall   CFETCHPP
003021 c2a6              rjmp    ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
003022 e022              fdw     RSHIFT_L
                 NEQUAL_L:
003023 6e82
003024 003d              .db     NFA|2,"n=",0
                 NEQUAL:
003025 dff8              rcall   NEQUALSFETCH
003026 708f              andi    tosl, 0xf
003027 d34a              rcall   EQUAL
003028 d3b8              rcall   ZEROSENSE
003029 f0b1              breq    NEQUAL5
00302a d30d              rcall   ONEMINUS
00302b d53d              rcall   CFETCHPP
00302c d2a3              rcall   TOR
00302d c00c              rjmp    NEQUAL4
                 NEQUAL2:
00302e dfef              rcall   NEQUALSFETCH
00302f d33a              rcall   NOTEQUAL
003030 d3b0              rcall   ZEROSENSE
003031 f021              breq    NEQUAL3
003032 d724              rcall   TRUE_
003033 940e 3a7e         call    LEAVE
003035 c004              rjmp    NEQUAL4
                 NEQUAL3:
003036 d2ad              rcall   RFETCH
003037 d3a9              rcall   ZEROSENSE
003038 f409              brne    NEQUAL4
003039 d715              rcall   FALSE_
                 NEQUAL4:
00303a 940e 3a6e         call    XNEXT
00303c f788              brcc    NEQUAL2
00303d 911f              pop     t1
00303e 910f              pop     t0
00303f c001              rjmp    NEQUAL6
                 NEQUAL5:
003040 d716              rcall   TRUE_
                 NEQUAL6:
003041 d3e0              rcall   NIP
003042 940c 3422         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
003044 e046              fdw     NEQUAL_L
                 SKIP_L:
003045 7384
003046 696b
003047 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003048 d287              rcall   TOR
                 SKIP0:
003049 d39d              rcall   DUPZEROSENSE
00304a f089              breq    SKIP2
                 
00304b d274              rcall   OVER
00304c d3f7              rcall   CFETCH_A
                 
00304d d766              rcall   DUP
00304e d75c              rcall   DOLIT
00304f 0009              .dw     TAB_
003050 d321              rcall   EQUAL
003051 d38f              rcall   ZEROSENSE
003052 f429              brne    SKIP05    
003053 d290              rcall   RFETCH
003054 d31d              rcall   EQUAL
003055 d38b              rcall   ZEROSENSE
003056 f029              breq    SKIP2
003057 c001                      rjmp    SKIP1
                 SKIP05:
003058 d256              rcall   DROP
                 SKIP1:
003059 d1ca              rcall   ONE
00305a d4b9              rcall   SLASHSTRING
00305b cfed              rjmp    SKIP0
                 SKIP2:
00305c 910f              pop     t0
00305d 910f              pop     t0
00305e 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
00305f e08a              fdw     SKIP_L
                 SCAN_L:
003060 7384
003061 6163
003062 006e              .db     NFA|4,"scan",0
                 SCAN:
003063 d333              rcall   STORE_P_TO_R
003064 d26b              rcall   TOR
003065 c010              rjmp    SCAN3
                 SCAN1:
003066 d502              rcall   CFETCHPP
003067 d74c              rcall   DUP
003068 d742              rcall   DOLIT
003069 0009              .dw     TAB_
00306a d307              rcall   EQUAL
00306b d375              rcall   ZEROSENSE
00306c f011              breq    SCAN2
00306d d241              rcall   DROP
00306e c005              rjmp    SCAN25
                 SCAN2:
00306f 940e 3b41         call    FETCH_P
003071 d300              rcall   EQUAL
003072 d36e              rcall   ZEROSENSE
003073 f011              breq    SCAN3
                 SCAN25:
003074 d2c3              rcall   ONEMINUS
003075 c003              rjmp    SCAN4
                 SCAN3:
003076 940e 3a6e         call    XNEXT
003078 f768              brcc    SCAN1
                 SCAN4:
003079 d260              rcall   RFROM
00307a d2b8              rcall   ONEPLUS
00307b d326              rcall   R_TO_P
00307c 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
00307d e0c0              fdw     SCAN_L
                 MTST_L:
00307e 6d84
00307f 7374
003080 0074              .db     NFA|4,"mtst",0
                 MTST:
003081 01fc              movw    zl, tosl
003082 9181              ld      tosl, z+
003083 9109              ld      t0, Y+
003084 9119              ld      t1, Y+
003085 2380              and     tosl, t0
003086 2799              clr     tosh
003087 9508              ret
                 
                 
003088 e0fc              fdw     MTST_L
                 FCY_L:
003089 4683
00308a 7963              .db     NFA|3,"Fcy"
00308b d06a              rcall   DOCREATE
00308c 3e80              .dw     FREQ_OSC / 1000
                 
                 ;;; Check parameter stack pointer
00308d 7383
00308e 3f70              .db     NFA|3,"sp?"
                 check_sp:
00308f d089              rcall   SPFETCH
003090 940e 38e2         call    R0_
003092 d65b              rcall   FETCH_A
003093 940e 38dd         call    S0
003095 d658              rcall   FETCH_A
003096 d29c              rcall   ONEPLUS
003097 d2c8              rcall   WITHIN
003098 d1df              rcall   XSQUOTE
003099 5303
00309a 3f50              .db     3,"SP?"
00309b d6fc              rcall   QABORT
00309c 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
00309d e112              fdw     FCY_L
                 EMIT_L:
00309e 6584
00309f 696d
0030a0 0074              .db     NFA|4,"emit",0
                 EMIT:
0030a1 d32f              rcall   UEMIT_
0030a2 940c 30c1         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
0030a4 e13c              fdw     EMIT_L
                 KEY_L:
0030a5 6b83
0030a6 7965              .db     NFA|3,"key"
                 KEY:
0030a7 d32f              rcall   UKEY_
0030a8 940c 30c1         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
0030aa e14a              fdw     KEY_L
                 KEYQ_L:
0030ab 6b84
0030ac 7965
0030ad 003f              .db     NFA|4,"key?",0
                 KEYQ:
0030ae d32e              rcall   UKEYQ_
0030af 940c 30c1         jmp     FEXECUTE
                 
0030b1 e156              fdw     KEYQ_L
                 EXECUTE_L:
0030b2 6587
0030b3 6578
0030b4 7563
0030b5 6574              .db     NFA|7,"execute"
                 EXECUTE:
0030b6 01fc              movw    zl, tosl
0030b7 58f0              sub_pflash_z
0030b8 9189
0030b9 9199              poptos
0030ba 9488              rampv_to_c
0030bb 95f7              ror     zh
0030bc 95e7              ror     zl
0030bd 9409              mijmp
                 
0030be e164              fdw     EXECUTE_L
                 FEXECUTE_L:
0030bf 4083
0030c0 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
0030c1 d62c              rcall   FETCH_A
0030c2 940c 30b6         jmp     EXECUTE
                 
0030c4 e17e              fdw     FEXECUTE_L
                 VARIABLE_L:
0030c5 7688
0030c6 7261
0030c7 6169
0030c8 6c62
0030c9 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
0030ca d09b              rcall   HERE
0030cb d0b0              rcall   CELL
0030cc d1db              rcall   ALLOT
0030cd 940c 30e1         jmp     CONSTANT_
                 
0030cf e18a              fdw     VARIABLE_L
                 TWOVARIABLE_L:
0030d0 3289
0030d1 6176
0030d2 6972
0030d3 6261
0030d4 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
0030d5 d090              rcall   HERE
0030d6 d6d4              rcall   DOLIT
0030d7 0004              .dw     0x4
0030d8 d1cf              rcall   ALLOT
0030d9 940c 30e1         jmp     CONSTANT_
                 
0030db e1a0              fdw     TWOVARIABLE_L
                 CONSTANT_L:
0030dc 6388
0030dd 6e6f
0030de 7473
0030df 6e61
0030e0 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
0030e1 d792              rcall   COLON
0030e2 940e 3df3         call    LITERAL
0030e4 940c 3882         jmp     SEMICOLON
                 
0030e6 e1b8              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030e7 3289
0030e8 6f63
0030e9 736e
0030ea 6174
0030eb 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030ec d1c9              rcall   SWOP
0030ed d786              rcall   COLON
0030ee 940e 3df3         call    LITERAL
0030f0 940e 3df3         call    LITERAL
0030f2 940c 3882         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030f4 2883
0030f5 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030f6 91ff              pop     zh
0030f7 91ef              pop     zl
0030f8 d00c              rcall   FETCHLIT
                         m_pop_zh
0030f9 91ff              pop     zh
0030fa 91ef              pop     zl
0030fb 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030fc 2883
0030fd 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030fe 91bf              pop     xh
0030ff 91af              pop     xl
                         m_pop_zh
003100 91ff              pop     zh
003101 91ef              pop     zl
003102 d002              rcall   FETCHLIT
003103 01fd              movw    z, x
003104 9409              mijmp    ; (z)
                 FETCHLIT:
003105 939a
003106 938a              pushtos
003107 0fee              lsl     zl
003108 1fff              rol     zh
003109 9185              lpm_    tosl, z+
00310a 9195              lpm_    tosh, z+
00310b 9508              ret
                 
00310c 2883
00310d 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
00310e 91ff              pop     zh
00310f 91ef              pop     zl
003110 dff4              rcall   FETCHLIT
003111 95f7              ror     zh
003112 95e7              ror     zl
003113 93ef              push    zl
003114 93ff              push    zh
                         m_push_t0
003115 c099              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
003116 e1ce              fdw     TWOCONSTANT_L
                 SPFETCH_L:
003117 7383
003118 4070              .db     NFA|3,"sp@"
                 SPFETCH:
003119 01fe              movw    z, y
00311a 939a
00311b 938a              pushtos
00311c 01cf              movw    tosl, z
00311d 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
00311e 7383
00311f 2170              .db     NFA|3,"sp!"
                 SPSTORE:
003120 01ec              movw    y, tosl
003121 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
003122 7283
003123 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
003124 91bf              pop     xh
003125 91af              pop     xl
003126 d7bb              rcall   R0_
003127 d5c6              rcall   FETCH_A
003128 bf8d              out     spl, tosl
003129 bf9e              out     sph, tosh
00312a 9189
00312b 9199              poptos
00312c 01fd              movw    zl, xl
00312d 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
00312e e22e              fdw     SPFETCH_L
                 RPFETCH_L:
00312f 72b3
003130 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
003131 939a
003132 938a              pushtos
003133 b78d              in      tosl, spl
003134 b79e              in      tosh, sph
003135 9508              ret
                 
                 ;   ><  Swap bytes        
003136 e25e              fdw     RPFETCH_L
                 SWAPB_L:
003137 3ea2
003138 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
003139 2f08              mov     t0, tosl
00313a 2f89              mov     tosl, tosh
00313b 2f90              mov     tosh, t0
00313c 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
00313d e26e              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
00313e 6685
00313f 616c
003140 6873              .db     NFA|5,"flash"
                 ROM_:
003141 9250 01e3         sts     cse, zero
003143 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
003144 e27c              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003145 6586
003146 7065
003147 6f72
003148 006d              .db     NFA|6,"eeprom",0
                 EROM:
003149 9270 01e3         sts     cse, r_two
00314b 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
00314c e28a              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
00314d 7283
00314e 6d61              .db     NFA|3,"ram"
                 FRAM:
00314f e004              ldi     t0, 4
003150 9300 01e3         sts     cse, t0
003152 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
003153 e29a              fdw     RAM_L
                 DP_L:
003154 6482
003155 0070              .db     NFA|2,"dp",0
                 DP:
003156 d6f0              rcall   IDP
003157 d004              rcall   CSE_
003158 940c 32f5         jmp     PLUS
                 
                 
                 ;;; 
00315a 6383
00315b 6573              .db     NFA|3,"cse"
                 CSE_:
00315c 939a
00315d 938a              pushtos
00315e 9180 01e3         lds     tosl, cse
003160 2799              clr     tosh
003161 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
003162 e2a8              fdw     DP_L
                 HERE_L:
003163 6884
003164 7265
003165 0065              .db     NFA|4,"here",0
                 HERE:
003166 dfef              rcall   DP
003167 940c 3e69         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003169 e2c6              fdw     HERE_L
                 COMMA_L:
00316a 2c81              .db     NFA|1,","
                 COMMA:
00316b dffa              rcall   HERE
00316c d40a              rcall   STORE_A
00316d d00e              rcall   CELL
00316e 940c 32a8         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
003170 e2d4              fdw     COMMA_L 
                 CCOMMA_L:
003171 6382
003172 002c              .db     NFA|2,"c,",0
                 CCOMMA:
003173 dff2              rcall   HERE
003174 d2d3              rcall   CSTORE_A
003175 d0ae              rcall   ONE
003176 940c 32a8         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003178 e2e2              fdw     CCOMMA_L
                 CELL_L:
003179 6384
00317a 6c65
00317b 006c              .db     NFA|4,"cell",0
                 CELL:
00317c 939a
00317d 938a              pushtos
00317e e082              ldi     tosl, 2
00317f e090              ldi     tosh, 0
003180 9508              ret
                 
                 ; ALIGN    --                         align DP
003181 e2f2              fdw     CELL_L
                 ALIGN_L:
003182 6185
003183 696c
003184 6e67              .db     NFA|5,"align"
                 ALIGN:
003185 dfe0              rcall   HERE
003186 d008              rcall   ALIGNED
003187 dfce              rcall   DP
003188 940c 3e21         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
00318a e304              fdw     ALIGN_L
                 ALIGNED_L:
00318b 6187
00318c 696c
00318d 6e67
00318e 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00318f 9601              adiw    tosl, 1
003190 d61a              rcall   DOLIT
003191 fffe              .dw     0xfffe
003192 940c 330b         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
003194 e316              fdw     ALIGNED_L
                 CELLPLUS_L:
003195 63a5
003196 6c65
003197 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003198 9602              adiw    tosl, 2
003199 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
00319a e32a              fdw     CELLPLUS_L
                 CELLS_L:
00319b 63a5
00319c 6c65
00319d 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
00319e 0f88              lsl     tosl
00319f 1f99              rol     tosh
0031a0 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
0031a1 e336              fdw     CELLS_L
                 CHARPLUS_L:
0031a2 63a5
0031a3 6168
0031a4 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
0031a5 9601              adiw    tosl, 1
0031a6 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
0031a7 e344              fdw     CHARPLUS_L
                 CHARS_L:
0031a8 63a5
0031a9 6168
0031aa 7372              .db     NFA|INLINE|5,"chars"
0031ab 9508      CHARS:  ret
                 
0031ac e350              fdw     CHARS_L
                 COMMAXT_L:
0031ad 6383
0031ae 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
0031af d604              rcall   DUP
0031b0 d62f              rcall   IHERE
0031b1 d150              rcall   MINUS
0031b2 d13d              rcall   ABS_ 
0031b3 d5f7              rcall   DOLIT
0031b4 0ff0              .dw     0xff0
0031b5 d1c6              rcall   GREATER
0031b6 d22a              rcall   ZEROSENSE
0031b7 f059              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
0031b8 d5f2              rcall   DOLIT
                 .ifdef EIND
                 .else
0031b9 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
0031ba 940e 3f3a         call    ICOMMA
0031bc 5890              sub_pflash_tos
0031bd 9488              rampv_to_c
0031be 9597              ror     tosh
0031bf 9587              ror     tosl
0031c0 940e 3f3a         call    ICOMMA
0031c2 c008              rjmp    STORECF2
                 STORECF1:
0031c3 d61c              rcall   IHERE
0031c4 d13d              rcall   MINUS
0031c5 d6f9              rcall   TWOMINUS
0031c6 d187              rcall   TWOSLASH
                         ;rcall   RCALL_
0031c7 709f              andi    tosh, 0x0f
0031c8 6d90              ori     tosh, 0xd0
0031c9 940e 3f3a         call    ICOMMA
                 STORECF2:
0031cb 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
0031cc 2186
0031cd 6f63
0031ce 6f6c
0031cf 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
0031d0 d5da              rcall   DOLIT
0031d1 fffa              .dw     0xfffa         ;  -6
0031d2 940c 399d         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
0031d4 e35a              fdw     COMMAXT_L
                 TWOFETCH_L:
0031d5 3282
0031d6 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
0031d7 d5dc              rcall   DUP
0031d8 d515              rcall   FETCH_A
0031d9 d0dc              rcall   SWOP
0031da dfbd              rcall   CELLPLUS
0031db 940c 36ee         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
0031dd e3aa              fdw     TWOFETCH_L
                 TWOSTORE_L:
0031de 3282
0031df 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
0031e0 d0d5              rcall   SWOP
0031e1 d0de              rcall   OVER
0031e2 dfb5              rcall   CELLPLUS
0031e3 d393              rcall   STORE_A
0031e4 940c 3e21         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031e6 e3bc              fdw     TWOSTORE_L
                 TWODROP_L:
0031e7 3285
0031e8 7264
0031e9 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031ea d0c4              rcall   DROP
0031eb 940c 32af         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031ed e3ce              fdw     TWODROP_L
                 TWODUP_L:
0031ee 3284
0031ef 7564
0031f0 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031f1 d0ce              rcall   OVER
0031f2 940c 32c0         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031f4 e3dc              fdw     TWODUP_L
                 TWOSWAP_L:
0031f5 3285
0031f6 7773
0031f7 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031f8 d0cf              rcall   ROT
0031f9 d0d6              rcall   TOR
0031fa d0cd              rcall   ROT
0031fb d0de              rcall   RFROM
0031fc 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031fd e3ea              fdw     TWOSWAP_L
                 SPACE_L:
0031fe 7385
0031ff 6170
003200 6563              .db     NFA|5,"space"
                 SPACE_:  
003201 d6c2              rcall   BL
003202 940c 30a1         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
003204 e3fc              fdw     SPACE_L
                 SPACES_L:
003205 7386
003206 6170
003207 6563
003208 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
003209 d1dd              rcall   DUPZEROSENSE
00320a f019              breq    SPCS2
00320b dff5              rcall   SPACE_
00320c d12b              rcall   ONEMINUS
00320d cffb              rjmp    SPCS1
00320e 940c 32af SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
003210 e40a              fdw     SPACES_L
                 UMIN_L:
003211 7584
003212 696d
003213 006e              .db     NFA|4,"umin",0
                 UMIN:
003214 dfdc              rcall   TWODUP
003215 d173              rcall   UGREATER
003216 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
003217 e422              fdw     UMIN_L
                 UMAX_L:
003218 7584
003219 616d
00321a 0078              .db     NFA|4,"umax",0
                 UMAX:
00321b dfd5              rcall   TWODUP
00321c d165              rcall   ULESS
                 MINMAX:
00321d d1c3              rcall   ZEROSENSE
00321e f009              breq    UMAX1
00321f d096              rcall   SWOP
003220 940c 32af UMAX1:  jmp     DROP
                 
003222 e430              fdw     UMAX_L
                 ONE_L:
003223 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
003224 939a
003225 938a              pushtos
003226 e081              ldi     tosl, 1
003227 e090              ldi     tosh, 0
003228 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
003229 e446              fdw     ONE_L
                 ACCEPT_L:
00322a 6186
00322b 6363
00322c 7065
00322d 0074              .db     NFA|6,"accept",0
                 ACCEPT:
00322e d091              rcall   OVER
00322f d0c5              rcall   PLUS
003230 d08f              rcall   OVER
                 ACC1:
003231 de75              rcall   KEY
                 
003232 308d              cpi     tosl, CR_
003233 f429              brne    ACC_LF
                         
003234 d522              rcall   TRUE_
003235 d02f              rcall   FCR
003236 d211              rcall   CSTORE_A
003237 d077              rcall   DROP
003238 c026              rjmp    ACC6
                 ACC_LF:
003239 308a              cpi     tosl, LF_
00323a f449              brne    ACC2
00323b d073              rcall   DROP
                 
00323c d028              rcall   FCR
00323d d206              rcall   CFETCH_A
00323e d1a2              rcall   ZEROSENSE
00323f f0f9              breq    ACC6
003240 d50e              rcall   FALSE_
003241 d023              rcall   FCR
003242 d205              rcall   CSTORE_A
003243 cfed              rjmp    ACC1
                 ACC2:
003244 d50a              rcall   FALSE_
003245 d01f              rcall   FCR
003246 d201              rcall   CSTORE_A
003247 d56c              rcall   DUP
003248 de58              rcall   EMIT
003249 d56a              rcall   DUP
00324a d560              rcall   DOLIT
00324b 0008              .dw     BS_
00324c d125              rcall   EQUAL
00324d d193              rcall   ZEROSENSE
00324e f039              breq    ACC3
00324f d05f              rcall   DROP
003250 d0e7              rcall   ONEMINUS
003251 d07e              rcall   TOR
003252 d06d              rcall   OVER
003253 d086              rcall   RFROM
003254 dfc6              rcall   UMAX
003255 cfdb              rjmp    ACC1
                 ACC3:
003256 d069              rcall   OVER
003257 d1f0              rcall   CSTORE_A
003258 d0da              rcall   ONEPLUS
003259 d066              rcall   OVER
00325a dfb9              rcall   UMIN
00325b df95              rcall   TWODUP
00325c d10d              rcall   NOTEQUAL
00325d d183              rcall   ZEROSENSE
00325e f691              brne     ACC1
                 ACC6:
00325f d1c2              rcall   NIP
003260 d055              rcall   SWOP
003261 940c 3302         jmp     MINUS
                 
003263 6683
003264 7263              .db     NFA|3,"fcr"
                 FCR:
003265 d29b              rcall   DOUSER
003266 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
003267 e454              fdw      ACCEPT_L
                 TYPE_L:
003268 7484
003269 7079
00326a 0065              .db     NFA|4,"type",0
                 TYPE:
00326b d064              rcall   TOR
00326c c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
00326d d2fb              rcall   CFETCHPP
00326e de32              rcall   EMIT
                 TYPE2:
00326f 940e 3a6e         call    XNEXT
003271 f7d8              brcc    TYPE1
003272 911f              pop     t1
003273 910f              pop     t0
003274 940c 32af         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
003276 2883
003277 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
003278 d06b              rcall   RFETCH
003279 0f88              lsl     tosl
00327a 1f99              rol     tosh
00327b 5890              add_pflash_tos
00327c d2ec              rcall   CFETCHPP
00327d d536              rcall   DUP
00327e d0b4              rcall   ONEPLUS
00327f df0f              rcall   ALIGNED
003280 9596              lsr     tosh
003281 9587              ror     tosl
003282 d057              rcall   RFROM
003283 d071              rcall   PLUS
003284 01fc              movw    zl, tosl
003285 d029              rcall   DROP
003286 9409              mijmp
                 
003287 e4d0              fdw     TYPE_L
                 SQUOTE_L:
003288 73d2
003289 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
00328a de83              rcall   DOCOMMAXT
00328b e4f0              fdw     XSQUOTE
00328c deb4              rcall   ROM_
00328d d005              rcall   CQUOTE
00328e 940c 314f         jmp     FRAM
                 
003290 e510              fdw     SQUOTE_L
                 CQUOTE_L:
003291 2c82
003292 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
003293 d517              rcall   DOLIT
003294 0022              .dw     0x22
003295 d291              rcall   PARSE
003296 decf              rcall   HERE
003297 d028              rcall   OVER
003298 d09a              rcall   ONEPLUS
003299 def5              rcall   ALIGNED
00329a d00d              rcall   ALLOT
00329b 940c 3560         jmp     PLACE
                 
                 
00329d e522              fdw     CQUOTE_L
                 DOTQUOTE_L:
00329e 2ed2
00329f 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
0032a0 dfe9              rcall   SQUOTE
0032a1 de6c              rcall   DOCOMMAXT
0032a2 e4d6              fdw     TYPE
0032a3 9508              ret
                 
0032a4 e53c              fdw     DOTQUOTE_L
                 ALLOT_L:
0032a5 6185
0032a6 6c6c
0032a7 746f              .db     NFA|5,"allot"
                 ALLOT:
0032a8 dead              rcall   DP
0032a9 940c 3354         jmp     PLUSSTORE
                 
0032ab e54a              fdw     ALLOT_L
                 DROP_L:
0032ac 64a4
0032ad 6f72
0032ae 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
0032af 9189
0032b0 9199              poptos
0032b1 9508              ret
                 
0032b2 e558              fdw     DROP_L
                 SWOP_L:
0032b3 7384
0032b4 6177
0032b5 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
0032b6 9109              ld      t0, y+
0032b7 9119              ld      t1, y+
0032b8 939a
0032b9 938a              pushtos
0032ba 01c8              movw    tosl, t0
0032bb 9508              ret
                 
0032bc e566              fdw     SWOP_L
                 OVER_L:
0032bd 6f84
0032be 6576
0032bf 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
0032c0 939a
0032c1 938a              pushtos
0032c2 818a              ldd     tosl, y+2
0032c3 819b              ldd     tosh, y+3
0032c4 9508              ret
                 
0032c5 e57a              fdw     OVER_L
                 ROT_L:
0032c6 7283
0032c7 746f              .db     NFA|3, "rot"
                 ROT:
0032c8 d007              rcall   TOR
0032c9 dfec              rcall   SWOP
0032ca d00f              rcall   RFROM
0032cb 940c 32b6         jmp     SWOP
                 
0032cd e58c              fdw     ROT_L
                 TOR_L:
0032ce 3e92
0032cf 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
0032d0 91ff              pop     zh
0032d1 91ef              pop     zl
0032d2 938f              push    tosl
0032d3 939f              push    tosh
0032d4 9189
0032d5 9199              poptos
0032d6 9409              mijmp
                 
0032d7 e59c              fdw     TOR_L
                 RFROM_L:
0032d8 7292
0032d9 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
0032da 91ff              pop     zh
0032db 91ef              pop     zl
0032dc 939a
0032dd 938a              pushtos
0032de 919f              pop     tosh
0032df 918f              pop     tosl
0032e0 9409              mijmp
                 
0032e1 e5b0              fdw     RFROM_L
                 RFETCH_L:
0032e2 7292
0032e3 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
0032e4 91ff              pop     zh
0032e5 91ef              pop     zl
0032e6 939a
0032e7 938a              pushtos
0032e8 919f              pop     tosh
0032e9 918f              pop     tosl
0032ea 938f              push    tosl
0032eb 939f              push    tosh
0032ec 9409              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
0032ed ef64              fdw     DUP_L
                 ABS_L:
0032ee 6183
0032ef 7362              .db     NFA|3,"abs"
                 ABS_:
0032f0 d4c3              rcall   DUP
0032f1 940c 3431         jmp     QNEGATE
                 
0032f3 e5dc              fdw     ABS_L
                 PLUS_L:
0032f4 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032f5 9109              ld      t0, Y+        
0032f6 9119              ld      t1, Y+
0032f7 0f80              add     tosl, t0
0032f8 1f91              adc     tosh, t1
0032f9 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032fa e5e8              fdw     PLUS_L
                 MPLUS_L:
0032fb 6d82
0032fc 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032fd d792              rcall   STOD
0032fe 940c 3ab2         jmp     DPLUS
                 
003300 e5f6              fdw     MPLUS_L
                 MINUS_L:
003301 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
003302 9109              ld      t0, Y+
003303 9119              ld      t1, Y+
003304 1b08              sub     t0, tosl
003305 0b19              sbc     t1, tosh
003306 01c8              movw    tosl, t0
003307 9508              ret
                 
003308 e602              fdw     MINUS_L
                 AND_L:
003309 6183
00330a 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
00330b 9109              ld      t0, Y+
00330c 9119              ld      t1, Y+
00330d 2380              and     tosl, t0
00330e 2391              and     tosh, t1
00330f 9508              ret
                 
003310 e612              fdw     AND_L
                 OR_L:
003311 6f82
003312 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
003313 9109              ld      t0, Y+
003314 9119              ld      t1, Y+
003315 2b80              or      tosl, t0
003316 2b91              or      tosh, t1
003317 9508              ret
                 
003318 e622              fdw     OR_L
                 XOR_L:
003319 7883
00331a 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
00331b 9109              ld      t0, Y+
00331c 9119              ld      t1, Y+
00331d 2780              eor     tosl, t0
00331e 2791              eor     tosh, t1
00331f 9508              ret
                 
003320 e632              fdw     XOR_L
                 INVERT_L:
003321 69a6
003322 766e
003323 7265
003324 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
003325 9580              com     tosl
003326 9590              com     tosh
003327 9508              ret
                 
003328 e642              fdw     INVERT_L
                 NEGATE_L:
003329 6e86
00332a 6765
00332b 7461
00332c 0065              .db     NFA|6, "negate",0
                 NEGATE:
00332d dff7              rcall   INVERT
00332e 940c 3333         jmp     ONEPLUS
                 
003330 e652              fdw     NEGATE_L
                 ONEPLUS_L:
003331 31a2
003332 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
003333 9601              adiw    tosl, 1
003334 9508              ret
                 
003335 e662              fdw     ONEPLUS_L
                 ONEMINUS_L:
003336 31a2
003337 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
003338 9701              sbiw    tosl, 1
003339 9508              ret
                 
00333a e66c              fdw     ONEMINUS_L
                 TWOPLUS_L:
00333b 32a2
00333c 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
00333d 9602              adiw    tosl, 2
00333e 9508              ret
                 
00333f e676              fdw     TWOPLUS_L
                 TOBODY_L:
003340 3ea5
003341 6f62
003342 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
003343 9604              adiw    tosl, 4
003344 9508              ret
                 
003345 e680              fdw     TOBODY_L
                 TWOSTAR_L:
003346 32a2
003347 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003348 0f88              lsl     tosl
003349 1f99              rol     tosh
00334a 9508              ret
                 
00334b e68c              fdw     TWOSTAR_L
                 TWOSLASH_L:
00334c 32a2
00334d 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
00334e 9595              asr     tosh
00334f 9587              ror     tosl
003350 9508              ret
                 
003351 e698              fdw     TWOSLASH_L
                 PLUSSTORE_L:
003352 2b82
003353 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
003354 df61              rcall   SWOP
003355 df6a              rcall   OVER
003356 d397              rcall   FETCH_A
003357 df9d              rcall   PLUS
003358 df5d              rcall   SWOP
003359 940c 3e21         jmp     STORE
                 
00335b e6a4              fdw     PLUSSTORE_L
                 WITHIN_L:
00335c 7786
00335d 7469
00335e 6968
00335f 006e              .db     NFA|6,"within",0
                 WITHIN:
003360 df5f              rcall   OVER
003361 dfa0              rcall   MINUS
003362 df6d              rcall   TOR
003363 df9e              rcall   MINUS
003364 df75              rcall   RFROM
003365 940c 3382         jmp     ULESS
                 
003367 e6b8              fdw     WITHIN_L
                 NOTEQUAL_L:
003368 3c82
003369 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
00336a df97              rcall   MINUS           ; MINUS leaves a valid zero flag
00336b ef9f              ser     tosh
00336c ef8f              ser     tosl
00336d f409              brne    NOTEQUAL1
00336e 9601              adiw    tosl,1
                 NOTEQUAL1:
00336f 9508              ret
                 
003370 ef7e              fdw     ZEROLESS_L
                 EQUAL_L:
003371 3d81              .db     NFA|1, "="
                 EQUAL:
003372 df8f              rcall   MINUS
003373 940c 37ba         jmp     ZEROEQUAL
                 
                 
003375 e6e2              fdw     EQUAL_L
                 LESS_L:
003376 3c81              .db     NFA|1,"<"
                 LESS:
003377 df8a              rcall   MINUS
003378 940c 37c1         jmp     ZEROLESS
                 
00337a e6ec              fdw     LESS_L
                 GREATER_L:
00337b 3e81              .db     NFA|1,">"
                 GREATER:
00337c df39              rcall   SWOP
00337d 940c 3377         jmp     LESS
                 
00337f e6f6              fdw     GREATER_L
                 ULESS_L:
003380 7582
003381 003c              .db     NFA|2,"u<",0
                 ULESS:
003382 df7f              rcall   MINUS       ; Carry is valid after MINUS
003383 0b88              sbc     tosl, tosl
003384 0b99              sbc     tosh, tosh
003385 9508              ret
                 
003386 e700              fdw     ULESS_L
                 UGREATER_L:
003387 7582
003388 003e              .db     NFA|2, "u>",0
                 UGREATER:
003389 df2c              rcall   SWOP
00338a 940c 3382         jmp     ULESS
                 
00338c e70e              fdw     UGREATER_L
                 STORE_P_L:
00338d 2182
00338e 0070              .db     NFA|2,"!p",0
                 STORE_P:
00338f 01ac              movw    pl, tosl
003390 9189
003391 9199              poptos
003392 9508              ret
                 
003393 e71a              fdw     STORE_P_L
                 STORE_P_TO_R_L:
003394 2194
003395 3e70
003396 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
003397 91ff              pop     zh
003398 91ef              pop     zl
003399 934f              push    pl
00339a 935f              push    ph
00339b 01ac              movw    pl, tosl
00339c 9189
00339d 9199              poptos
00339e 9409              mijmp
                 
00339f e728              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
0033a0 7293
0033a1 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
0033a2 91ff              pop     zh
0033a3 91ef              pop     zl
0033a4 915f              pop     ph
0033a5 914f              pop     pl
0033a6 9409              mijmp
                 
0033a7 e740              fdw     R_TO_P_L
                 PFETCH_L:
0033a8 7082
0033a9 0040              .db     NFA|2,"p@",0
                 PFETCH:
0033aa 939a
0033ab 938a              pushtos
0033ac 01ca              movw    tosl, pl
0033ad 940c 3e69         jmp     FETCH
                 
0033af e750              fdw     PFETCH_L
                 PSTORE_L:
0033b0 7082
0033b1 0021              .db     NFA|2,"p!",0
                 PSTORE:
0033b2 939a
0033b3 938a              pushtos
0033b4 01ca              movw    tosl, pl
0033b5 940c 3e21         jmp     STORE
                 
0033b7 e760              fdw     PSTORE_L
                 PCSTORE_L:
0033b8 7083
0033b9 2163              .db     NFA|3,"pc!"
                 PCSTORE:
0033ba 939a
0033bb 938a              pushtos
0033bc 01ca              movw    tosl, pl
0033bd 940c 3eb6         jmp     CSTORE
                 
0033bf e770              fdw     PCSTORE_L
                 PPLUS_L:
0033c0 70a2
0033c1 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
0033c2 0d46              add     pl, r_one
0033c3 1d55              adc     ph, zero
0033c4 9508              ret   
                 
0033c5 e780              fdw     PPLUS_L
                 PNPLUS_L:
0033c6 7083
0033c7 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
0033c8 0f48              add     pl, tosl
0033c9 1f59              adc     ph, tosh
0033ca 9189
0033cb 9199              poptos
0033cc 9508              ret
                 
0033cd e78c              fdw     PNPLUS_L
                 UEMIT_L:
0033ce 2785
0033cf 6d65
0033d0 7469              .db     NFA|5,"'emit"
                 UEMIT_:
0033d1 d12f              rcall   DOUSER
0033d2 ffe8              .dw     uemit
                         
0033d3 e79c              fdw     UEMIT_L
                 UKEY_L:
0033d4 2784
0033d5 656b
0033d6 0079              .db     NFA|4,"'key",0
                 UKEY_:
0033d7 d129              rcall   DOUSER
0033d8 ffea              .dw     ukey
                 
0033d9 e7a8              fdw     UKEY_L
                 UKEYQ_L:
0033da 2785
0033db 656b
0033dc 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
0033dd d123              rcall   DOUSER
0033de ffec              .dw     ukeyq
                 
0033df 3f83
0033e0 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
0033e1 9700              sbiw    tosl, 0
0033e2 9189
0033e3 9199              poptos
0033e4 9508              ret
                 
0033e5 6483
0033e6 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
0033e7 9700              sbiw    tosl, 0
0033e8 9508              ret
                 
0033e9 e7b4              fdw     UKEYQ_L
                 UMSTAR_L:
0033ea 7583
0033eb 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
0033ec 940c 3f60         jmp     umstar0
                 
0033ee e7d4              fdw     UMSTAR_L
                 UMSLASHMOD_L:
0033ef 7586
0033f0 2f6d
0033f1 6f6d
0033f2 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
0033f3 940c 2fa2         jmp     umslashmod0
                 
                 
0033f5 e7de              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
0033f6 7585
0033f7 6d2f
0033f8 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
0033f9 d355              rcall   FALSE_
0033fa debb              rcall   SWOP
0033fb 940c 2fa2         jmp     umslashmod0
                 
0033fd e7ec              fdw     USLASHMOD_L
                 STAR_L:
0033fe 2a81              .db     NFA|1,"*"
                 STAR: 
0033ff dfec              rcall   UMSTAR
003400 940c 32af         jmp     DROP
                 
003402 e7fc              fdw     STAR_L
                 USLASH_L:
003403 7582
003404 002f              .db     NFA|2,"u/",0
                 USLASH:
003405 dff3              rcall   USLASHMOD
003406 940c 3422         jmp     NIP
                 
003408 e806              fdw     USLASH_L
                 USSMOD_L:
003409 7586
00340a 2f2a
00340b 6f6d
00340c 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
00340d dec2              rcall   TOR
00340e dfdd              rcall   UMSTAR
00340f deca              rcall   RFROM
003410 940c 33f3         jmp     UMSLASHMOD
                 
                 
003412 e812              fdw     USSMOD_L
                 SLASH_L:
003413 2f81              .db     NFA|1,"/"
                 SLASH: 
003414 dddc              rcall   TWODUP
003415 df05              rcall   XOR_
003416 deb9              rcall   TOR
003417 ded8              rcall   ABS_
003418 de9d              rcall   SWOP
003419 ded6              rcall   ABS_
00341a de9b              rcall   SWOP
00341b dfe9              rcall   USLASH
00341c debd              rcall   RFROM
00341d 940c 3431         jmp     QNEGATE
                 
00341f e826              fdw     SLASH_L
                 NIP_L:
003420 6ea3
003421 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
003422 9109              ld      t0, y+
003423 9109              ld      t0, y+
003424 9508              ret
                     
003425 e840              fdw     NIP_L
                 TUCK_L:
003426 7484
003427 6375
003428 006b              .db     NFA|4,"tuck",0
                 TUCK:
003429 de8c              rcall   SWOP
00342a 940c 32c0         jmp     OVER
                 
00342c e84c              fdw     TUCK_L
                 QNEGATE_L:
00342d 3f87
00342e 656e
00342f 6167
003430 6574              .db     NFA|7,"?negate"
                 QNEGATE:
003431 d38f              rcall   ZEROLESS
003432 dfae              rcall   ZEROSENSE
003433 f009              breq    QNEGATE1
003434 def8              rcall   NEGATE
                 QNEGATE1:
003435 9508              ret
                 
003436 e85a              fdw     QNEGATE_L
                 MAX_L:
003437 6d83
003438 7861              .db     NFA|3,"max"
003439 ddb7      MAX:    rcall   TWODUP
00343a df3c              rcall   LESS
00343b cde1              rjmp    MINMAX
                 
00343c e86e              fdw     MAX_L
                 MIN_L:
00343d 6d83
00343e 6e69              .db     NFA|3,"min"
00343f ddb1      MIN:    rcall   TWODUP
003440 df3b              rcall   GREATER
003441 cddb              rjmp    MINMAX
                 
003442 6382
003443 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
003444 940c 3e93         jmp     CFETCH
                 
003446 6382
003447 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003448 940c 3eb6         jmp     CSTORE
                 
00344a e87a              fdw     MIN_L
                 UPTR_L:
00344b 7582
00344c 0070              .db     NFA|2,"up",0
00344d dca8      UPTR:   rcall   DOCREATE
00344e 0002              .dw     2 ; upl
                 
00344f e896              fdw     UPTR_L
                 HOLD_L:
003450 6884
003451 6c6f
003452 0064              .db     NFA|4,"hold",0
003453 d303      HOLD:   rcall   TRUE_
003454 d092              rcall   HP
003455 defe              rcall   PLUSSTORE
003456 d090              rcall   HP
003457 d296              rcall   FETCH_A
003458 940c 3eb6         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
00345a e8a0              fdw     HOLD_L
                 LESSNUM_L:
00345b 3c82
00345c 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
00345d d08e              rcall   PAD
00345e d088              rcall   HP
00345f 940c 3e21         jmp     STORE
                 
                 ; digit   n -- c            convert to 0..9a..z
003461 e8b6              fdw     LESSNUM_L
                 TODIGIT_L:
003462 6485
003463 6769
003464 7469              .db     NFA|5,"digit"
                 TODIGIT:
003465 308a              cpi     tosl, 0xa
003466 f00c              brlt    TODIGIT1
003467 9687              adiw    tosl, 0x27
                 TODIGIT1:
003468 96c0              adiw    tosl, 0x30
003469 9508              ret
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
00346a e8c4              fdw     TODIGIT_L
                 NUM_L:
00346b 2381              .db     NFA|1,"#"
                 NUM:
00346c d087              rcall   BASE
00346d d280              rcall   FETCH_A
00346e d184              rcall   UDSLASHMOD
00346f de58              rcall   ROT
003470 dff4              rcall   TODIGIT
003471 940c 3453         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
003473 e8d6              fdw     NUM_L
                 NUMS_L:
003474 2382
003475 0073              .db     NFA|2,"#s",0
                 NUMS:
003476 dff5              rcall   NUM
003477 dd79              rcall   TWODUP
003478 de9a              rcall   OR_
003479 df67              rcall   ZEROSENSE
00347a f7d9              brne    NUMS
00347b 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
00347c e8e8              fdw     NUMS_L
                 NUMGREATER_L:
00347d 2382
00347e 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
00347f dd6a              rcall   TWODROP
003480 d066              rcall   HP
003481 d26c              rcall   FETCH_A
003482 d069              rcall   PAD
003483 de3c              rcall   OVER
003484 940c 3302         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
003486 e8fa              fdw     NUMGREATER_L
                 SIGN_L:
003487 7384
003488 6769
003489 006e              .db     NFA|4,"sign",0
                 SIGN:
00348a 3090              cpi     tosh, 0
00348b f41a              brpl    SIGN1
00348c d31e              rcall   DOLIT
00348d 002d              .dw     0x2D
00348e dfc4              rcall   HOLD
                 SIGN1:
00348f 940c 32af         jmp     DROP
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
003491 e90e              fdw     SIGN_L
                 UDOT_L:
003492 7582
003493 002e              .db     NFA|2,"u.",0
                 UDOT:
003494 dfc8              rcall   LESSNUM
003495 d2b9              rcall   FALSE_
003496 dfdf              rcall   NUMS
003497 dfe7              rcall   NUMGREATER
003498 ddd2              rcall   TYPE
003499 940c 3201         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
00349b e924              fdw     UDOT_L
                 UDOTR_L:
00349c 7583
00349d 722e              .db     NFA|3,"u.r"
                 UDOTR:
00349e dfbe              rcall   LESSNUM
00349f de98              rcall   ONEMINUS
0034a0 de2f              rcall   TOR
0034a1 d2ad              rcall   FALSE_
0034a2 c001              rjmp    UDOTR2
                 UDOTR1:
0034a3 dfc8              rcall   NUM
                 UDOTR2: 
0034a4 d5c9              rcall   XNEXT
0034a5 f7e8              brcc    UDOTR1
0034a6 911f              pop     t1
0034a7 910f              pop     t0
0034a8 dfcd              rcall   NUMS
0034a9 dfd5              rcall   NUMGREATER
0034aa ddc0              rcall   TYPE
0034ab 940c 3201         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
0034ad e938              fdw     UDOTR_L
                 DOT_L:
0034ae 2e81              .db     NFA|1,"."
0034af dfad      DOT:    rcall   LESSNUM
0034b0 d303              rcall   DUP
0034b1 de3e              rcall   ABS_
0034b2 d29c              rcall   FALSE_
0034b3 dfc2              rcall   NUMS
0034b4 de13              rcall   ROT
0034b5 dfd4              rcall   SIGN
0034b6 dfc8              rcall   NUMGREATER
0034b7 ddb3              rcall   TYPE
0034b8 940c 3201         jmp     SPACE_
                 
0034ba e95c              FDW     DOT_L
                 DECIMAL_L:
0034bb 6487
0034bc 6365
0034bd 6d69
0034be 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
0034bf d267              rcall   TEN
0034c0 d033              rcall   BASE
0034c1 940c 3e21         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
0034c3 e976              Fdw     DECIMAL_l
                 HEX_L:
0034c4 6883
0034c5 7865              .db     NFA|3,"hex"
                 HEX:
0034c6 d2e4              rcall   DOLIT
0034c7 0010              .dw     16
0034c8 d02b              rcall   BASE
0034c9 940c 3e21         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
0034cb e988              Fdw     HEX_L
                 BIN_L:
0034cc 6283
0034cd 6e69              .db     NFA|3,"bin"
0034ce dcad      BIN:    rcall   CELL
0034cf d024              rcall   BASE
0034d0 940c 3e21         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
0034d2 e998              fdw     BIN_L
                 RSAVE_L:
0034d3 7285
0034d4 6173
0034d5 6576              .db     NFA|5,"rsave"
0034d6 d02a      RSAVE_: rcall   DOUSER
0034d7 fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
0034d8 e9a6              fdw     RSAVE_L
                 ULINK_L:
0034d9 7585
0034da 696c
0034db 6b6e              .db     NFA|5,"ulink"
0034dc d024      ULINK_: rcall   DOUSER
0034dd fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034de e9b2              fdw     ULINK_L
                 TASK_L:
0034df 7484
0034e0 7361
0034e1 006b              .db     NFA|4,"task",0
0034e2 d01e      TASK:   rcall   DOUSER
0034e3 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034e4 e9be              fdw     TASK_L
                 HP_L:
0034e5 6882
0034e6 0070              .db     NFA|2,"hp",0
0034e7 d019      HP:     rcall   DOUSER
0034e8 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
0034e9 e9ca              fdw     HP_L
                 PAD_L:
0034ea 7083
0034eb 6461              .db     NFA|3,"pad"
                 PAD:
0034ec d185              rcall   TIB
0034ed d17c              rcall   TIBSIZE
0034ee 940c 32f5         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
0034f0 e9d4              fdw     PAD_L
                 BASE_L:
0034f1 6284
0034f2 7361
0034f3 0065              .db     NFA|4,"base",0
                 BASE:
0034f4 d00c              rcall   DOUSER
0034f5 ffee              .dw     ubase
                 
                 ; USER   n --
0034f6 e9e2              fdw     BASE_L
                 USER_L:
0034f7 7584
0034f8 6573
0034f9 0072              .db     NFA|4,"user",0
                 USER:
0034fa d302              rcall   CREATE
0034fb dc80              rcall   CELL
0034fc de30              rcall   NEGATE
0034fd d49f              rcall   IALLOT
0034fe 940e 3f3a         call    ICOMMA
003500 d34c              rcall   XDOES
                 DOUSER:
                         m_pop_zh
003501 91ff              pop     zh
003502 91ef              pop     zl
003503 dc01              rcall   FETCHLIT
003504 0d82              add     tosl, upl
003505 1d93              adc     tosh, uph
003506 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
003507 e9ee              fdw     USER_L
                 SOURCE_L:
003508 7386
003509 756f
00350a 6372
00350b 0065              .db     NFA|6,"source",0
                 SOURCE:
00350c d177              rcall   TICKSOURCE
00350d 940c 31d7         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
00350f ea10              fdw      SOURCE_L
                 SLASHSTRING_L:
003510 2f87
003511 7473
003512 6972
003513 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
003514 dda1              rcall   SWOP
003515 ddaa              rcall   OVER
003516 ddeb              rcall   MINUS
003517 ddb8              rcall   TOR
003518 dddc              rcall   PLUS
003519 ddc0              rcall   RFROM
00351a 9508              ret
                 
                 ; \     Skip the rest of the line
00351b ea20              fdw     SLASHSTRING_L
                 BSLASH_L:
00351c 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
00351d dfee              rcall   SOURCE
00351e d15e              rcall   TOIN
00351f d057              rcall   STORE_A
003520 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
003521 940c 32af         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
003523 ea38              fdw     BSLASH_L
                 PARSE_L:
003524 7085
003525 7261
003526 6573              .db     NFA|5,"parse"
                 PARSE:
003527 d28c              rcall   DUP             ; c c
003528 dfe3              rcall   SOURCE          ; c c a u
003529 d153              rcall   TOIN            ; c c a u a
00352a d1c3              rcall   FETCH_A         ; c c a u n
00352b dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
00352c d287              rcall   DUP             ; c c a u u
00352d dda2              rcall   TOR             ; c c a u                  R: u (new tib len
00352e dd99              rcall   ROT             ; c a u c
00352f db18              rcall   SKIP            ; c a u        
003530 dd8f              rcall   OVER            ; c a u a
003531 dd9e              rcall   TOR             ; c a u                    R: u a (start of word
003532 dd95              rcall   ROT             ; a u c
003533 db2f              rcall   SCAN            ; a u      end of word, tib left       
003534 deb2              rcall   DUPZEROSENSE
003535 f009              breq    PARSE1
003536 de01              rcall   ONEMINUS
003537 dda2      PARSE1: rcall   RFROM           ; a u a
003538 dda1              rcall   RFROM           ; a u a u
003539 dd8e              rcall   ROT             ; a a u u
00353a ddc7              rcall   MINUS           ; a a n  ( addition to toin
00353b d141              rcall   TOIN
00353c de17              rcall   PLUSSTORE       ; aend astart
00353d deeb              rcall   TUCK            ; astart aend astart
00353e 940c 3302         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
003540 ea48              fdw     PARSE_L
                 WORD_L:
003541 7784
003542 726f
003543 0064              .db     NFA|4,"word",0
                 WORD:
003544 dfe2              rcall   PARSE           ; c-addr wlen
003545 dd70              rcall   SWOP
003546 ddf1              rcall   ONEMINUS
003547 dee1              rcall   TUCK
003548 940c 3eb6         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
00354a ea82              fdw     WORD_L
                 CMOVE_L:
00354b 6385
00354c 6f6d
00354d 6576              .db     NFA|5,"cmove"
                 CMOVE:
00354e dd67              rcall   SWOP
00354f de47              rcall   STORE_P_TO_R
003550 dd7f              rcall   TOR
003551 c003              rjmp    CMOVE2
                 CMOVE1:
003552 d016              rcall   CFETCHPP
003553 de66              rcall   PCSTORE
003554 de6d              rcall   PPLUS
                 CMOVE2:
003555 d518              rcall   XNEXT
003556 f7d8              brcc    CMOVE1
003557 911f              pop     t1
003558 910f              pop     t0
003559 de48              rcall   R_TO_P
00355a 940c 32af         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
00355c ea96              fdw     CMOVE_L
                 PLACE_L:
00355d 7085
00355e 616c
00355f 6563              .db     NFA|5,"place"
                 PLACE: 
003560 dc90              rcall   TWODUP
003561 dee6              rcall   CSTORE_A
003562 dc42              rcall   CHARPLUS
003563 dd52              rcall   SWOP
003564 940c 354e         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
003566 eaba              fdw     PLACE_L
                 CFETCHPP_L:
003567 6383
003568 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
003569 d24a              rcall   DUP
00356a ddc8              rcall   ONEPLUS
00356b dd4a              rcall   SWOP
00356c 940c 3e93         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
00356e eace              fdw     CFETCHPP_L
                 FETCHPP_L:
00356f 4082
003570 002b              .db     NFA|2,"@+",0
                 FETCHPP:
003571 d242              rcall   DUP
003572 ddca              rcall   TWOPLUS
003573 dd42              rcall   SWOP
003574 940c 3e69         jmp     FETCH
                 
003576 2181              .db     NFA|1,"!"
                 STORE_A:        
003577 940c 3e21         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
003579 eade              fdw    FETCHPP_L
                 NTOC_L:
00357a 6e83
00357b 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
00357c dfec              rcall   CFETCHPP
00357d 708f              andi    tosl, 0x0f
00357e dd76              rcall   PLUS
00357f 940c 318f         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
003581 eaf4              fdw    NTOC_L
                 CTON_L:
003582 6383
003583 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
003584 d33a              rcall   TWOMINUS
003585 d22e              rcall   DUP
003586 debd              rcall   CFETCH_A
003587 940e 3e1a         call    TO_A
003589 ff27              sbrs    al, 7
00358a f3c9              breq    CFATONFA
00358b 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
00358c eb04              fdw     CTON_L
                 BRACFIND_L:
00358d 2883
00358e 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
00358f dc61              rcall   TWODUP
003590 da94              rcall   NEQUAL
003591 de55              rcall   DUPZEROSENSE
003592 f021              breq    findi2
003593 dd1b              rcall   DROP
003594 d32a              rcall   TWOMINUS ;;;      NFATOLFA
003595 d158              rcall   FETCH_A
003596 d21d              rcall   DUP
                 findi2:
003597 de49              rcall   ZEROSENSE
003598 f7b1              brne    findi1
003599 de4d              rcall   DUPZEROSENSE
00359a f041              breq    findi3
00359b de86              rcall   NIP
00359c d217              rcall   DUP
00359d dfde              rcall   NFATOCFA
00359e dd17              rcall   SWOP
00359f d009              rcall   IMMEDQ
0035a0 d219              rcall   ZEROEQUAL
0035a1 dc82              rcall   ONE
0035a2 dd70              rcall   OR_
                 findi3: 
0035a3 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
0035a4 eb1a              fdw     BRACFIND_L
                 IMMEDQ_L:
0035a5 6986
0035a6 6d6d
0035a7 6465
0035a8 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
0035a9 de9a              rcall   CFETCH_A
0035aa 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
0035ab 7480              andi    tosl, IMMED
0035ac 9508              ret
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
0035ad eb4a              fdw     IMMEDQ_L
                 FIND_L:
0035ae 6684
0035af 6e69
0035b0 0064              .db     NFA|4,"find",0
                 FIND:   
0035b1 d1f9              rcall   DOLIT
0035b2 f69c              fdw     kernellink
0035b3 dfdb              rcall   findi
0035b4 de32              rcall   DUPZEROSENSE
0035b5 f421              brne    FIND1
0035b6 dcf8              rcall   DROP
0035b7 d31f              rcall   LATEST_
0035b8 d135              rcall   FETCH_A
0035b9 dfd5              rcall   findi
                 FIND1:
0035ba 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
0035bb eb5c              fdw     FIND_L
                 DIGITQ_L:
0035bc 6486
0035bd 6769
0035be 7469
0035bf 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
0035c0 3480              cpi     tosl, 0x40
0035c1 f00c              brlt    DIGITQ1
0035c2 9787              sbiw    tosl, 0x27
                 DIGITQ1:        
0035c3 97c0              sbiw    tosl, 0x30      ; 1
0035c4 d1ef              rcall   DUP             ; 1 1
0035c5 df2e              rcall   BASE            ; 1 1 base
0035c6 d127              rcall   FETCH_A         ; 1 1 10
0035c7 ddaf              rcall   LESS            ; 1 ffff
0035c8 dcf7              rcall   OVER            ; 1 ffff 1
0035c9 d1f7              rcall   ZEROLESS        ; 1 ffff 0
0035ca dd5a              rcall   INVERT
0035cb 940c 330b         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035cd eb78              fdw     DIGITQ_L
                 SIGNQ_L:
0035ce 7385
0035cf 6769
0035d0 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035d1 dcee              rcall   OVER
0035d2 de71              rcall   CFETCH_A
0035d3 978c              sbiw    tosl, ','
0035d4 d1df              rcall   DUP
0035d5 dd1a              rcall   ABS_
0035d6 dc4d              rcall   ONE
0035d7 dd9a              rcall   EQUAL
0035d8 dd32              rcall   AND_
0035d9 de0d              rcall   DUPZEROSENSE
0035da f029              breq    QSIGN1
0035db dd57              rcall   ONEPLUS
0035dc dcf3              rcall   TOR
0035dd dc46              rcall   ONE
0035de df35              rcall   SLASHSTRING
0035df dcfa              rcall   RFROM
0035e0 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
0035e1 eb9c              fdw     SIGNQ_L
                 UDSTAR_L:
0035e2 7583
0035e3 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035e4 d1cf              rcall   DUP
0035e5 dcea              rcall   TOR
0035e6 de05              rcall   UMSTAR
0035e7 dcc7              rcall   DROP
0035e8 dccd              rcall   SWOP
0035e9 dcf0              rcall   RFROM
0035ea de01              rcall   UMSTAR
0035eb dcdc              rcall   ROT
0035ec 940c 32f5         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
0035ee ebc4              fdw     UDSTAR_L
                 UDSLASHMOD_L:
0035ef 7586
0035f0 2f64
0035f1 6f6d
0035f2 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
0035f3 dcdc              rcall   TOR             ; ud.l ud.h 
0035f4 d15a              rcall   FALSE_          ; ud.l ud.h 0
0035f5 dcee              rcall   RFETCH          ; ud.l ud.h 0 u
0035f6 ddfc              rcall   UMSLASHMOD      ; ud.l r.h q.h
0035f7 dcd0              rcall   ROT             ; r.h q.h ud.l
0035f8 dccf              rcall   ROT             ; q.h ud.l r.h
0035f9 dce0              rcall   RFROM           ; q.h ud.l r.h u
0035fa ddf8              rcall   UMSLASHMOD      ; q.h r.l q.l
0035fb 940c 32c8         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
0035fd ebde              fdw     UDSLASHMOD_L
                 TONUMBER_L:
0035fe 3e87
0035ff 756e
003600 626d
003601 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
003602 dde4              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
003603 f0b1              breq    TONUM3
003604 dccb              rcall   TOR
003605 d1ae              rcall   DUP
003606 dcc9              rcall   TOR             ; ud.l ud.h adr
003607 de3c              rcall   CFETCH_A
003608 dfb7              rcall   DIGITQ          ; ud.l ud.h digit flag
003609 ddd7              rcall   ZEROSENSE
00360a f421              brne    TONUM2
00360b dca3              rcall   DROP
00360c dccd              rcall   RFROM
00360d dccc              rcall   RFROM
00360e c00b              rjmp    TONUM3
                 TONUM2: 
00360f dcc0              rcall   TOR             ; ud.l ud.h digit
003610 dee3              rcall   BASE
003611 d0dc              rcall   FETCH_A
003612 dfd1              rcall   UDSTAR
003613 dcc6              rcall   RFROM
003614 dce8              rcall   MPLUS
003615 dcc4              rcall   RFROM
003616 dcc3              rcall   RFROM
                         
003617 dc0c              rcall   ONE
003618 defb              rcall   SLASHSTRING
003619 cfe8              rjmp    TONUM1
                 TONUM3: 
00361a 9508              ret
                 
                 BASEQV:   
00361b e97e              fdw     DECIMAL
00361c e98c              fdw     HEX
00361d e99c              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
00361e ebfc              fdw     TONUMBER_L
                 NUMBERQ_L:
00361f 6e87
003620 6d75
003621 6562
003622 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
003623 d190              rcall   DUP             ; a a
003624 d12a              rcall   FALSE_          ; a a 0 0
003625 d129              rcall   FALSE_          ; a a 0 0
003626 dca1              rcall   ROT             ; a 0 0 a
003627 df41              rcall   CFETCHPP        ; a 0 0 a' u
003628 dfa8              rcall   SIGNQ           ; a 0 0 a' u f
003629 dca6              rcall   TOR             ; a 0 0 a' u
                 
00362a dec9              rcall   BASE
00362b d0c2              rcall   FETCH_A
00362c dca3              rcall   TOR             ; a 0 0 a' u
                         
00362d dc92              rcall   OVER
00362e de15              rcall   CFETCH_A
                         
00362f 9783              sbiw    tosl, '#'
003630 3083              cpi     tosl, 3
003631 f440              brsh    BASEQ1
                 
003632 db6b              rcall   CELLS
003633 d177              rcall   DOLIT
003634 ec36              fdw     BASEQV
003635 dcbf              rcall   PLUS
003636 da8a              rcall   FEXECUTE
                 
003637 dbec              rcall   ONE
003638 dedb              rcall   SLASHSTRING
003639 c001              rjmp    BASEQ2
                 BASEQ1:
00363a dc74              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
00363b dfc6              rcall   TONUMBER        ; a ud.l ud.h  a' u
00363c dc9d              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
00363d deb6              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
00363e df38              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
00363f d174              rcall   DUP
003640 d27e              rcall   TWOMINUS
003641 d17f              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
003642 dd9e              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
003643 f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
003644 dc95              rcall   RFROM           ; a ud.l ud.h a' u sign
003645 dc69              rcall   DROP
003646 dba3              rcall   TWODROP
                 QNUM_ERR1:      
003647 dba2              rcall   TWODROP
003648 d106              rcall   FALSE_          ; a 0           Not a number
003649 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
00364a dbad              rcall   TWOSWAP         ; a a' u ud.l ud.h 
00364b dc8e              rcall   RFROM           ; a a' u ud.l ud.d sign
00364c dd94              rcall   ZEROSENSE
00364d f009              breq    QNUMD1
00364e d449              rcall   DNEGATE
                 QNUMD1: 
00364f dba8              rcall   TWOSWAP         ; a d.l d.h a' u
003650 dd90              rcall   ZEROSENSE       ; a d.l d.h a'
003651 f061              breq    QNUM1
003652 940e 3e93         call    CFETCH
003654 d156              rcall   DOLIT
003655 002e              .dw     '.'
003656 dcab              rcall   MINUS
003657 dd89              rcall   ZEROSENSE       ; a d.l d.h
003658 f771              brne    QNUM_ERR1
003659 dc6e              rcall   ROT             ; d.l d.h a
00365a dc54              rcall   DROP            ; d.l d.h
00365b d14f              rcall   DOLIT         ; 
00365c 0002              .dw     2               ; d.l ud.h 2    Double number
00365d c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
00365e db8b              rcall   TWODROP         ; a n
00365f ddc2              rcall   NIP             ; n
003660 dbc3              rcall   ONE             ; n 1           Single number
                 QNUM3:  
003661 9508              ret
                 
                 
003662 7384
003663 6177
003664 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003665 940c 32b6         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003667 ec3e              fdw     NUMBERQ_L
                 TIBSIZE_L:
003668 7483
003669 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
00366a de77              rcall   TASK
00366b d082              rcall   FETCH_A
00366c 9608              adiw    tosl, 8
00366d 940c 3e69         jmp     FETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00366f ecd0              fdw     TIBSIZE_L
                 TIB_L:
003670 7483
003671 6269              .db     NFA|3,"tib"
                 TIB:
003672 d005              rcall   TIU
003673 940c 3e69         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003675 ece0              fdw     TIB_L
                 TIU_L:
003676 7483
003677 7569              .db     NFA|3,"tiu"
                 TIU:
003678 de88              rcall   DOUSER
003679 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
00367a ecec              fdw     TIU_L
                 TOIN_L:
00367b 3e83
00367c 6e69              .db     NFA|3,">in"
                 TOIN:
00367d de83              rcall   DOUSER
00367e fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00367f ecf6              fdw     TOIN_L
                 TICKSOURCE_L:
003680 2787
003681 6f73
003682 7275
003683 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
003684 de7c              rcall   DOUSER
003685 fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
003686 ed00              fdw     TICKSOURCE_L
                 INTERPRET_L:
003687 6989
003688 746e
003689 7265
00368a 7270
00368b 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
00368c dff7              rcall   TICKSOURCE
00368d db52              rcall   TWOSTORE
00368e d0c0              rcall   FALSE_
00368f dfed              rcall   TOIN
003690 dee6              rcall   STORE_A
                 IPARSEWORD:
003691 d232              rcall   BL
003692 deb1              rcall   WORD
                 
003693 d120              rcall   DUP
003694 ddaf              rcall   CFETCH_A
003695 dd4b              rcall   ZEROSENSE
003696 f409              brne    IPARSEWORD1
003697 c053              rjmp    INOWORD
                 IPARSEWORD1:
003698 df18              rcall   FIND            ; sets also wflags
003699 dd4d              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
00369a f1a1              breq    INUMBER         ; NUMBER?
00369b dc97              rcall   ONEPLUS         ; 0 = normal 2 = immediate
00369c d22e              rcall   STATE_
00369d d11c              rcall   ZEROEQUAL
00369e dc74              rcall   OR_
00369f dd41              rcall   ZEROSENSE
0036a0 f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
0036a1 fe94              sbrs    wflags, 4       ; Compile only check
0036a2 c00a              rjmp    IEXECUTE        ; Not a compile only word
0036a3 d227              rcall   STATE_          ; Compile only word check
0036a4 dbd3              rcall   XSQUOTE
0036a5 430c
0036a6 4d4f
0036a7 4950
0036a8 454c
0036a9 4f20
0036aa 4c4e
0036ab 0059              .db     12,"COMPILE ONLY",0
0036ac d0eb              rcall   QABORT
                 IEXECUTE:
0036ad 7b6f              cbr     FLAGS1, (1<<noclear)
0036ae da07              rcall   EXECUTE
0036af fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
0036b0 cfe0              rjmp    IPARSEWORD
0036b1 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036b2 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036b3 cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
0036b4 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036b5 d0fe              rcall   DUP
0036b6 d0f4              rcall   DOLIT
0036b7 ef74              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
0036b8 dcb9              rcall   EQUAL
0036b9 dd27              rcall   ZEROSENSE
0036ba f011              breq    ICOMPILE_2
0036bb 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
0036bc c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
0036bd 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036be d0f5              rcall   DUP
0036bf d0eb              rcall   DOLIT
0036c0 ef68              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
0036c1 dcb0              rcall   EQUAL
0036c2 dd1e              rcall   ZEROSENSE
0036c3 f009              breq    ICOMPILE
0036c4 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036c5 fe95              sbrs    wflags, 5       ; Inline check
0036c6 c003              rjmp    ICOMMAXT
0036c7 940e 3a45         call    INLINE0
0036c9 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
0036ca d121              rcall   COMMAXT_A
0036cb 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
0036cc fc94              sbrc    wflags, 4            ; Compile only ?
0036cd 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0036ce cfc2              rjmp    IPARSEWORD
                 INUMBER: 
0036cf 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036d0 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036d1 dbdd              rcall   DROP
0036d2 df50              rcall   NUMBERQ
0036d3 dd13              rcall   DUPZEROSENSE
0036d4 f081              breq    IUNKNOWN
0036d5 d1f5              rcall   STATE_
0036d6 dd0a              rcall   ZEROSENSE
0036d7 f059              breq    INUMBER1
0036d8 2f08              mov     t0, tosl
0036d9 9189
0036da 9199              poptos
0036db ff01              sbrs    t0, 1
0036dc c003              rjmp    ISINGLE
                 IDOUBLE:
0036dd df87              rcall   SWOP_A
0036de 940e 3df3         call    LITERAL
                 ISINGLE:        
0036e0 940e 3df3         call    LITERAL
0036e2 cfae              rjmp    IPARSEWORD
                 
                 INUMBER1:
0036e3 dbcb              rcall   DROP
0036e4 cfac              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
0036e5 dbc9              rcall   DROP 
0036e6 d044              rcall   DP_TO_RAM
0036e7 de81              rcall   CFETCHPP
0036e8 db82              rcall   TYPE
0036e9 d065              rcall   FALSE_
0036ea d0a4              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
0036eb 940c 32af         jmp     DROP
                 
0036ed 4081              .db     NFA|1,"@"
                 FETCH_A:        
0036ee 940c 3e69         jmp     FETCH
                 
                 ;;;    bitmask -- 
0036f0 ed0e              fdw     INTERPRET_L
                 SHB_L:
0036f1 7383
0036f2 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
0036f3 d1e3              rcall   LATEST_
0036f4 dff9              rcall   FETCH_A
0036f5 d0be              rcall   DUP
0036f6 dd4d              rcall   CFETCH_A
0036f7 dbd0              rcall   ROT
0036f8 dc1a              rcall   OR_
0036f9 df6b              rcall   SWOP_A
0036fa 940c 3eb6         jmp     CSTORE
                         
0036fc ede2              fdw     SHB_L
                 IMMEDIATE_L:
0036fd 6989
0036fe 6d6d
0036ff 6465
003700 6169
003701 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
003702 d0a8              rcall   DOLIT
003703 0040              .dw     IMMED
003704 940c 36f3         jmp     SHB
                 
                 ;***************************************************************
003706 edfa              fdw     IMMEDIATE_L
                 INLINED_L:
003707 6987
003708 6c6e
003709 6e69
00370a 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
00370b d09f              rcall   DOLIT
00370c 0020              .dw     INLINE
00370d 940c 36f3         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
00370f ee0e              fdw     INLINED_L
                 DOTSTATUS_L:
003710 2e83
003711 7473              .db     NFA|3,".st"
                 DOTSTATUS:
003712 d098              rcall   DOLIT
003713 003c              .dw     '<'
003714 d98c              rcall   EMIT
003715 940e 3f4c         call    DOTBASE
003717 d989              rcall   EMIT
003718 d092              rcall   DOLIT
003719 002c              .dw     ','
00371a d986              rcall   EMIT
00371b 940e 2f92         call    MEMQ
00371d db4d              rcall   TYPE
00371e d08c              rcall   DOLIT
00371f 003e              .dw     '>'
003720 d980              rcall   EMIT
003721 940c 395c         jmp     DOTS
                 
003723 3e82
003724 0072              .db     NFA|2,">r",0
003725 940c 32d0 TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
                 ;        .db     NFA|1,"a"
                 TEN:
003727 d9ce              rcall   DOCREATE
003728 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
003729 6483
00372a 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
00372b d07f              rcall   DOLIT
00372c 0900              .dw     dp_start
00372d d1b8              rcall   INI
00372e dff8              rcall   TEN
00372f 940c 354e         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
003731 3e83
003732 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
003733 d077              rcall   DOLIT
003734 0900              .dw     dp_start
003735 dc61              rcall   STORE_P_TO_R
003736 d1af              rcall   INI
003737 d073              rcall   DOLIT
003738 0004              .dw     4
003739 db96              rcall   TOR
                 DP_TO_EEPROM_0: 
00373a de36              rcall   FETCHPP
00373b d078              rcall   DUP
00373c dc6d              rcall   PFETCH
00373d dc2c              rcall   NOTEQUAL
00373e dca2              rcall   ZEROSENSE
00373f f011              breq    DP_TO_EEPROM_1
                 .if DEBUG_FLASH == 1
                 .endif
003740 dc71              rcall   PSTORE
003741 c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
003742 db6c              rcall   DROP
                 DP_TO_EEPROM_2:
003743 d40c              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
003744 d329              rcall   XNEXT
003745 f7a0              brcc    DP_TO_EEPROM_0
003746 911f              pop     t1
003747 910f              pop     t0
003748 dc59              rcall   R_TO_P
003749 940c 32af         jmp     DROP
                 
00374b ee20              fdw     DOTSTATUS_L
                 FALSE_L:
00374c 6685
00374d 6c61
00374e 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
00374f d064              rcall DUP;pushtos
003750 2788              clr     tosl
003751 2799              clr     tosh
003752 9508              ret
                 
003753 ee98              fdw     FALSE_L
                 TRUE_L:
003754 7484
003755 7572
003756 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
003757 d05c              rcall DUP;pushtos
003758 ef8f              ser     tosl
003759 ef9f              ser     tosh
00375a 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
00375b eea8              fdw     TRUE_L
                 QUIT_L:
00375c 7184
00375d 6975
00375e 0074              .db     NFA|4,"quit",0
                 QUIT:
00375f d9c4              rcall   RPEMPTY
003760 d107              rcall   LEFTBRACKET
003761 d9ed              rcall   FRAM
                 QUIT0:  
                         ;; Copy INI and DP's from eeprom to ram
003762 dfc8              rcall   DP_TO_RAM
                 QUIT1: 
003763 d92b              rcall   check_sp
003764 d08c              rcall   CR
003765 df0c              rcall   TIB
003766 d04d              rcall   DUP
003767 df02              rcall   TIBSIZE
003768 dfbe              rcall   TEN                 ; Reserve 10 bytes for hold buffer
003769 db98              rcall   MINUS
00376a dac3              rcall   ACCEPT
00376b da95              rcall   SPACE_
00376c df1f              rcall   INTERPRET
00376d d15d              rcall   STATE_
00376e dc72              rcall   ZEROSENSE
00376f f799              brne    QUIT1
003770 d5be              rcall   IFLUSH
003771 dfc1              rcall   DP_TO_EEPROM
                          
003772 db05              rcall    XSQUOTE
003773 2003
003774 6b6f              .db     3," ok"
003775 daf5              rcall    TYPE
003776 d007              rcall   PROMPT_
003777 940c 3762         jmp     QUIT0
                 
                 
003779 eeb8              fdw     QUIT_L
                 PROMPT_L:
00377a 7086
00377b 6f72
00377c 706d
00377d 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
00377e 940e 3ef0         call    DEFER_DOES
003780 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
003781 eef4              fdw     PROMPT_L
                 ABORT_L:
003782 6185
003783 6f62
003784 7472              .db     NFA|5,"abort"
                 ABORT:
003785 d157              rcall   S0
003786 df67              rcall   FETCH_A
003787 d998              rcall   SPSTORE
003788 940c 375f         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
00378a ef04              fdw     ABORT_L
                 QABORTQ_L:
00378b 3f87
00378c 6261
00378d 726f
00378e 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
00378f dae8              rcall   XSQUOTE
003790 3f01              .db     1,"?"
003791 940c 3798         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
003793 ef16              fdw     QABORTQ_L
                 QABORT_L:
003794 3f86
003795 6261
003796 726f
003797 0074              .db     NFA|6,"?abort",0
                 QABORT:
003798 db2f              rcall   ROT
003799 dc47              rcall   ZEROSENSE
00379a f419              brne    QABO1
                 QABORT1:        
00379b da65              rcall   SPACE_
00379c dace              rcall   TYPE
00379d dfe7              rcall   ABORT  ; ABORT never returns
00379e 940c 31ea QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
0037a0 ef28              fdw     QABORT_L
                 ABORTQUOTE_L:
0037a1 61d6
0037a2 6f62
0037a3 7472
0037a4 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
0037a5 dae4              rcall   SQUOTE
0037a6 d967              rcall   DOCOMMAXT
0037a7 ef30              fdw     QABORT
0037a8 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
0037a9 6c83
0037aa 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
0037ab 91ff              pop     zh
0037ac 91ef              pop     zl
0037ad d957              rcall   FETCHLIT
0037ae 95f7              ror     zh
0037af 95e7              ror     zl
0037b0 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
0037b1 e5c4              fdw     RFETCH_L
                 DUP_L:
0037b2 64a3
0037b3 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
0037b4 939a
0037b5 938a              pushtos
0037b6 9508              ret
                 
0037b7 e6d0              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
0037b8 3082
0037b9 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:
0037ba 9701              sbiw    tosl, 1
0037bb 0b88              sbc     tosl, tosl
0037bc 0b99              sbc     tosh, tosh
0037bd 9508              ret
                 
0037be ef70              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
0037bf 3082
0037c0 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
0037c1 0f99              lsl     tosh
0037c2 0b88              sbc     tosl, tosl
0037c3 0b99              sbc     tosh, tosh
0037c4 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037c5 ef42              fdw     ABORTQUOTE_L
                 TICK_L:
0037c6 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037c7 d0fc              rcall   BL
0037c8 dd7b              rcall   WORD
0037c9 dde7              rcall   FIND
0037ca 940c 378f         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
0037cc ef8c              fdw     TICK_L
                 CHAR_L:
0037cd 6384
0037ce 6168
0037cf 0072              .db     NFA|4,"char",0
                 CHAR:
0037d0 d0f3              rcall   BL
0037d1 dd55              rcall   PARSE
0037d2 dadc              rcall   DROP
0037d3 940c 3e93         jmp     CFETCH
                 
                 ; (    --                     skip input until )
0037d5 ef9a              fdw     CHAR_L
                 PAREN_L:
0037d6 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
0037d7 dfd3              rcall   DOLIT
0037d8 0029              .dw     ')'
0037d9 dd4d              rcall   PARSE
0037da 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
0037db 940c 31ea         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
0037dd 6985
0037de 6568
0037df 6572              .db     NFA|5,"ihere"
                 IHERE:
0037e0 d066              rcall   IDP
0037e1 cf0c              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
0037e2 efac              fdw     PAREN_L
                 BRACCHAR_L:
0037e3 5bd6
0037e4 6863
0037e5 7261
0037e6 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
0037e7 dfe8              rcall   CHAR
0037e8 940c 3df3         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
0037ea 6383
0037eb 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
0037ec 940c 31af         jmp     COMMAXT
                 
                 ; CR      --                      output newline
0037ee efc6              fdw     BRACCHAR_L
                 CR_L:
0037ef 6382
0037f0 0072              .db     NFA|2,"cr",0
                 CR:
0037f1 dfb9              rcall   DOLIT
0037f2 000d              .dw     0x0d       ; CR \r
0037f3 d8ad              rcall   EMIT
0037f4 dfb6              rcall   DOLIT
0037f5 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
0037f6 940c 30a1         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
0037f8 efde              fdw     CR_L
                 CREATE_L:
0037f9 6386
0037fa 6572
0037fb 7461
0037fc 0065              .db     NFA|6,"create",0
                 CREATE:
0037fd d0c6              rcall   BL
0037fe dd45              rcall   WORD            ; Parse a word
                 
0037ff dfb4              rcall   DUP             ; Remember parsed word at rhere
003800 ddb0              rcall   FIND
003801 dc20              rcall   NIP
003802 dfb7              rcall   ZEROEQUAL
003803 da74              rcall   XSQUOTE
003804 410f
003805 524c
003806 4145
003807 5944
003808 4420
003809 4645
00380a 4e49
00380b 4445              .db     15,"ALREADY DEFINED"
00380c df8b              rcall   QABORT         ; ABORT if word has already been defined
00380d dfa6              rcall   DUP             ; Check the word length 
00380e dc35              rcall   CFETCH_A
00380f da14              rcall   ONE
003810 df9a              rcall   DOLIT
003811 0010              .dw     16
003812 db4d              rcall   WITHIN
003813 df7b              rcall   QABORTQ          ; Abort if there is no name for create
                 
003814 d0c2              rcall   LATEST_
003815 ded8              rcall   FETCH_A
003816 940e 3f3a         call    ICOMMA          ; Link field
003818 dd50              rcall   CFETCHPP        ; str len
003819 dfc6              rcall   IHERE
00381a df99              rcall   DUP             
00381b d0bb              rcall   LATEST_         ; new 'latest' link
00381c dd5a              rcall   STORE_A         ; str len ihere
00381d dd42              rcall   PLACE           ; 
00381e dfc1              rcall   IHERE           ; ihere
00381f dc24              rcall   CFETCH_A
003820 df8a              rcall   DOLIT
003821 0080              .dw     NFA
003822 ded0              rcall   SHB
003823 db0f              rcall   ONEPLUS
003824 d96a              rcall   ALIGNED
003825 d177              rcall   IALLOT          ; The header has now been created
003826 df84              rcall   DOLIT             
003827 e1ec              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
003828 d98f              rcall   STORECFF1       ; Append an exeution token, CALL !
003829 d95b              rcall   ALIGN
00382a d93b              rcall   HERE            ; compiles the current dataspace dp into the dictionary
00382b d930              rcall   CSE_
00382c dbb4              rcall   ZEROSENSE
00382d f409              brne    CREATE2
00382e db0e              rcall   TWOPLUS
                 CREATE2:
00382f 940c 3f3a         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
003831 eff2              fdw    CREATE_L
                 POSTPONE_L:
003832 70d8
003833 736f
003834 7074
003835 6e6f
003836 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
003837 d08c              rcall   BL
003838 dd0b              rcall   WORD
003839 dd77              rcall   FIND
00383a df79              rcall   DUP
00383b df53              rcall   QABORTQ
00383c df84              rcall   ZEROLESS
00383d dba3              rcall   ZEROSENSE
00383e f021              breq    POSTPONE1
00383f d8ce              rcall   DOCOMMAXT
003840 e21c              fdw     DOCOMMAXT
003841 940c 3f3a         jmp     ICOMMA
                 POSTPONE1:
003843 940c 31af         jmp     COMMAXT
                 
                 
                 IDP_L:
003845 6983
003846 7064              .db     NFA|3,"idp"
                 IDP:
003847 d8ae              rcall   DOCREATE
003848 01d9              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
003849 2887
00384a 6f64
00384b 7365
00384c 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
00384d da8c              rcall   RFROM
00384e d088              rcall   LATEST_
00384f de9e              rcall   FETCH_A
003850 dd2b              rcall   NFATOCFA
003851 dff5              rcall   IDP
003852 de9b              rcall   FETCH_A
003853 ded1              rcall   TOR_A
003854 dff2              rcall   IDP
003855 dd21              rcall   STORE_A
003856 0f88              lsl     tosl
003857 1f99              rol     tosh
003858 d95f              rcall   STORECFF1 ; Always stores a 4 byte call
003859 da80              rcall   RFROM
00385a dfec              rcall   IDP
00385b 940c 3e21         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
00385d f064              fdw     POSTPONE_L
                 DOES_L:
00385e 64d5
00385f 656f
003860 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
003861 d8ac      DOES:   rcall   DOCOMMAXT
003862 f09a              fdw     XDOES
003863 d8aa              rcall   DOCOMMAXT
003864 e1fc              fdw     DODOES
003865 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
003866 f0bc              fdw     DOES_L
                 LEFTBRACKET_L:
003867 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
003868 7000              cbr     t0, 0xff
003869 9300 01e4         sts     state, t0
00386b 9508              ret
                 
                 
                 ; ]        --      enter compiling state
00386c f0ce              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
00386d 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
00386e 6f0f              sbr     t0, 0xff
00386f 9300 01e4         sts     state, t0
003871 9508              ret
                 
                 ; :        --           begin a colon definition
003872 f0da              fdw     RIGHTBRACKET_L
                 COLON_L:
003873 3a81              .db     NFA|1,":"
                 COLON:
003874 df88              rcall   CREATE
003875 dff8              rcall   RIGHTBRACKET
003876 940c 31d0         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
003878 f0e6              fdw     COLON_L
                 NONAME_L:
003879 3a87
00387a 6f6e
00387b 616e
00387c 656d              .db     NFA|7,":noname"
                 NONAME:
00387d df62              rcall   IHERE
00387e 940c 386e         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
003880 f0f2              fdw     NONAME_L
                 SEMICOLON_L:
003881 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
003882 dfe5              rcall   LEFTBRACKET
003883 fd61              sbrc    FLAGS1, fTAILC
003884 c026              rjmp    ADD_RETURN_1
003885 df5a              rcall   IHERE
003886 d02b              rcall   MINUS_FETCH
003887 018c              movw    t0, tosl
003888 7f10              andi    t1, 0xf0
003889 5d10              subi    t1, 0xd0
00388a f059              breq    RCALL_TO_JMP
00388b 9189
00388c 9199              poptos
00388d d024              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
00388e 508e              subi    tosl, 0x0e
                 .endif
00388f 4994              sbci    tosh, 0x94
003890 f4c9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
003891 e08c              ldi     tosl, 0x0c
                 .endif
003892 e994              ldi     tosh, 0x94
003893 da22              rcall   SWOP
003894 940c 3e21         jmp     STORE
                 RCALL_TO_JMP:
003896 db8b              rcall   NIP
003897 709f              andi    tosh, 0x0f
003898 fd93              sbrc    tosh, 3
003899 6f90              ori     tosh, 0xf0
00389a daad              rcall   TWOSTAR
00389b df44              rcall   IHERE
00389c da58              rcall   PLUS
00389d df0d              rcall   DOLIT
00389e fffe              .dw     -2
00389f d0fd              rcall   IALLOT
0038a0 df0a              rcall   DOLIT
                 .ifdef EIND
                 .else
0038a1 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
0038a2 940e 3f3a         call    ICOMMA
0038a4 5890              sub_pflash_tos
0038a5 9488              rampv_to_c
0038a6 9597              ror     tosh
0038a7 9587              ror     tosl
0038a8 940c 3f3a         jmp     ICOMMA
                 ADD_RETURN:
0038aa d93f              rcall   TWODROP
                 ADD_RETURN_1:
0038ab deff              rcall   DOLIT   ; Compile a ret
0038ac 9508              .dw     0x9508
0038ad 940c 3f3a         jmp    ICOMMA
                 
                 
                 
0038af f102              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
0038b0 2d82
0038b1 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
0038b2 d00c              rcall   TWOMINUS
0038b3 df00              rcall   DUP
0038b4 940c 3e69         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
0038b6 f160              fdw     MINUS_FETCH_L
                 BRACTICK_L:
0038b7 5bd3
0038b8 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
0038b9 df0d              rcall   TICK       ; get xt of 'xxx'
0038ba 940c 3df3         jmp     LITERAL
                 
                 ; 2-    n -- n-2
0038bc f16e              fdw     BRACTICK_L
                 TWOMINUS_L:
0038bd 32a2
0038be 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
0038bf 9702              sbiw    tosl, 2
0038c0 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038c1 f17a              fdw     TWOMINUS_L
                 BL_l:
0038c2 6282
0038c3 006c              .db     NFA|2,"bl",0
                 BL:
0038c4 940e 30f6         call    DOCREATE
0038c6 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038c7 f184              fdw     BL_L
                 STATE_L:
0038c8 7385
0038c9 6174
0038ca 6574              .db     NFA|5,"state"
                 STATE_:
0038cb 939a
0038cc 938a              pushtos
0038cd 9180 01e4         lds     tosl, state
0038cf 9190 01e4         lds     tosh, state
0038d1 9508              ret
                 
                 ; LATEST    -- a-addr           
0038d2 f190              fdw     STATE_L
                 LATEST_L:
0038d3 6c86
0038d4 7461
0038d5 7365
0038d6 0074              .db     NFA|6,"latest",0
                 LATEST_:
0038d7 940e 30f6         call    DOCREATE
0038d9 01df              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
0038da f1a6              fdw     LATEST_L
                 S0_L:
0038db 7382
0038dc 0030              .db     NFA|2,"s0",0
                 S0:
0038dd dc23              rcall   DOUSER
0038de ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
0038df f1b6              fdw     S0_L
                 R0_L:
0038e0 7282
0038e1 0030              .db     NFA|2,"r0",0
                 R0_:
0038e2 dc1e              rcall   DOUSER
0038e3 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
0038e4 6983
0038e5 696e              .db     NFA|3,"ini"
                 INI:
0038e6 940e 30f6          call   DOCREATE
0038e8 01d7              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
0038e9 f1c0              fdw     R0_L
                 TICKS_L:
0038ea 7485
0038eb 6369
0038ec 736b              .db     NFA|5,"ticks"
                 TICKS:  
0038ed 939a
0038ee 938a              pushtos
0038ef b70f              in_     t0, SREG
0038f0 94f8              cli
0038f1 2d8e              mov     tosl, ms_count
0038f2 2d9f              mov     tosh, ms_count1
0038f3 bf0f              out_    SREG, t0
0038f4 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
0038f5 f1d4              fdw     TICKS_L
                 MS_L:
0038f6 6d82
0038f7 0073              .db     NFA|2,"ms",0
                 MS:
0038f8 dff4              rcall   TICKS
0038f9 d9fb              rcall   PLUS
                 MS1:    
0038fa d61f              rcall   PAUSE
0038fb deb8              rcall   DUP
0038fc dff0              rcall   TICKS
0038fd da04              rcall   MINUS
0038fe dec2              rcall   ZEROLESS
0038ff dae1              rcall   ZEROSENSE
003900 f3c9              breq    MS1
003901 940c 32af         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
003903 f1ec              fdw     MS_L
                 DOTID_L:
003904 2e83
003905 6469              .db     NFA|3,".id"
                 DOTID:
003906 dc62              rcall   CFETCHPP
003907 dea3              rcall   DOLIT
003908 000f              .dw     0x0f
003909 da01              rcall   AND_
00390a d9c5              rcall   TOR
00390b c003              rjmp    DOTID3
                 DOTID1:
00390c dc5c              rcall   CFETCHPP
00390d d00a              rcall   TO_PRINTABLE
00390e dee7              rcall   EMIT_A
                 DOTID3:
00390f d15e              rcall   XNEXT
003910 f7d8              brcc    DOTID1  
003911 911f              pop     t1
003912 910f              pop     t0
003913 940c 32af         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
003915 f208              fdw     DOTID_L
                 TO_PRINTABLE_L:
003916 3e83
003917 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:
003918 2799              clr     tosh   
003919 3080              cpi     tosl, 0
00391a f012              brmi    TO_PRINTABLE1
00391b 3280              cpi     tosl, 0x20
00391c f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
00391d e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
00391e 9508              ret
                 
                 ;;;;;;;;;;;;;;
                 LIKEQ:
00391f dc49              rcall   CFETCHPP
003920 de8a              rcall   DOLIT
003921 000f              .dw     0x0f
003922 d9e8              rcall   AND_
003923 d992              rcall   SWOP
003924 da6a              rcall   STORE_P
003925 d990              rcall   SWOP
003926 dc42              rcall   CFETCHPP
003927 d9a0              rcall   ROT
003928 d997              rcall   OVER
003929 d9d8              rcall   MINUS
00392a da08              rcall   ONEPLUS
00392b de23              rcall   FALSE_
00392c db0c              rcall   MAX
00392d d9a2              rcall   TOR
00392e c009              rjmp    LIKEQ3
                 LIKEQ1:
00392f d8c1              rcall   TWODUP
003930 d210              rcall   FETCH_P
003931 da90              rcall   PPLUS
003932 d983              rcall   SWOP
003933 940e 2f80         call    CMP
003935 f011              breq    LIKEQ3
                 TWODROPNZ:
003936 9498              clz
003937 c003              rjmp    LIKEQ4
                 LIKEQ3:
003938 d135              rcall   XNEXT
003939 f7a8              brcc    LIKEQ1
                 TWODROPZ:
00393a 9418              sez
                 LIKEQ4:
00393b 911f              pop     t1
00393c 910f              pop     t0
00393d c00a              rjmp    TWODROP__
                 
                 ;;;;;;;;;;;;;;;;;;;;
                 LIKES:
00393e d8b2              rcall   TWODUP
00393f dfdf              rcall   LIKEQ
003940 f019              breq    LIKES1
003941 de72              rcall   DUP
003942 dfc3              rcall   DOTID
003943 d8bd              rcall   SPACE_
                 LIKES1:
003944 df7a              rcall   TWOMINUS
003945 dda8              rcall   FETCH_A
003946 daa0              rcall   DUPZEROSENSE
003947 f7b1              brne    LIKES
                 TWODROP__:
003948 940c 31ea         jmp     TWODROP
                 
                  ; WORDS    -- filter
00394a f22c              fdw     TO_PRINTABLE_L
                 WORDS_L:
00394b 7785
00394c 726f
00394d 7364              .db     NFA|5,"words"
00394e df75              rcall   BL
00394f dbf4              rcall   WORD
003950 de63              rcall   DUP
003951 de59              rcall   DOLIT
003952 f69c              fdw     kernellink
003953 d002              rcall   WDS1
003954 df82              rcall   LATEST_
003955 dd98              rcall   FETCH_A
003956 de9a      WDS1:   rcall   CR
003957 940c 393e         jmp     LIKES
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
003959 f296              fdw     WORDS_L
                 DOTS_L:
00395a 2e82
00395b 0073              .db     NFA|2,".s",0
                 DOTS:
00395c d8a4              rcall   SPACE_
00395d de56              rcall   DUP          ; push tosl:tosh to memory
00395e 940e 3119         call    SPFETCH
003960 df7c              rcall   S0
003961 dd8c              rcall   FETCH_A
003962 df5c              rcall   TWOMINUS
                 DOTS1:
003963 d88d              rcall   TWODUP
003964 da12              rcall   LESS
003965 da7b              rcall   ZEROSENSE
003966 f019              breq    DOTS2
003967 df4a              rcall   MINUS_FETCH
003968 db2b              rcall   UDOT
003969 cff9              rjmp    DOTS1
                 DOTS2:  
00396a d944              rcall   DROP
00396b 940c 31ea         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
00396d f2b4              fdw     DOTS_L
                 DUMP_L:
00396e 6484
00396f 6d75
003970 0070              .db     NFA|4,"dump",0
                 DUMP:
003971 de39              rcall   DOLIT
003972 0010              .dw     16
003973 da91              rcall   USLASH
003974 d95b              rcall   TOR
003975 c020              rjmp    DUMP7
                 DUMP1:  
003976 de7a              rcall   CR
003977 de3c              rcall   DUP
003978 de32              rcall   DOLIT
003979 0004              .dw     4
00397a db23              rcall   UDOTR
00397b de2f              rcall   DOLIT
00397c 003a              .dw     ':'
00397d de78              rcall   EMIT_A
00397e de2c              rcall   DOLIT
00397f 000f              .dw     15
003980 d94f              rcall   TOR
                 DUMP2:
003981 dbe7              rcall   CFETCHPP
003982 de28              rcall   DOLIT
003983 0002              .dw     2
003984 db19              rcall   UDOTR
003985 d0e8              rcall   XNEXT
003986 f7d0              brcc    DUMP2
003987 911f              pop     t1
003988 910f              pop     t0
                 
003989 de21              rcall   DOLIT
00398a 0010              .dw     16
00398b d976              rcall   MINUS
00398c de1e              rcall   DOLIT
00398d 000f              .dw     15
00398e d941              rcall   TOR
                 DUMP4:  
00398f dbd9              rcall   CFETCHPP
003990 df87              rcall   TO_PRINTABLE
003991 de64              rcall   EMIT_A
003992 d0db              rcall   XNEXT
003993 f7d8              brcc    DUMP4
003994 911f              pop     t1
003995 910f              pop     t0
                 DUMP7:
003996 d0d7              rcall   XNEXT
003997 f6f0              brcc    DUMP1
003998 911f              pop     t1
003999 910f              pop     t0
00399a 940c 32af         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
00399c 2081              .db     NFA|1," "
                 IALLOT:
00399d dea9              rcall   IDP
00399e 940c 3354         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
0039a0 f2dc              fdw     DUMP_L
                 X_TO_R_L:
0039a1 7883
0039a2 723e              .db     NFA|3,"x>r"
                 X_TO_R:
0039a3 01fc              movw    zl, tosl
0039a4 9189
0039a5 9199              poptos
0039a6 d009              rcall   TO_XA
0039a7 9631              adiw    zl, 1
0039a8 9382              st      -z, tosl
0039a9 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
0039aa 9252              st      -z, zero
0039ab 01cf              movw    tosl, zl
0039ac 9508              ret
                 ;***************************************************************
0039ad f342              fdw     X_TO_R_L
                 TO_XA_L:
0039ae 3e83
0039af 6178              .db NFA|3,">xa"
                 TO_XA:
0039b0 5890               sub_pflash_tos
0039b1 9488               rampv_to_c
0039b2 9597               ror tosh
0039b3 9587               ror tosl
0039b4 9508               ret
                 
0039b5 f35c               fdw     TO_XA_L
                 XA_FROM_L:
0039b6 7883
0039b7 3e61              .db NFA|3,"xa>"
                 XA_FROM:
0039b8 0f88               lsl     tosl
0039b9 1f99               rol     tosh
0039ba 5890               add_pflash_tos
0039bb 9508               ret
                 ;***************************************************************
0039bc f36c               fdw    XA_FROM_L
                 PFL_L:
0039bd 7083
0039be 6c66              .db     NFA|3,"pfl"
                 PFL:
0039bf 940e 30f6          call   DOCREATE
0039c1 8000              .dw     OFLASH
                 ;***************************************************************
0039c2 f37a              fdw    PFL_L
                 ZFL_L:
0039c3 7a83
0039c4 6c66              .db     NFA|3, "zfl"
                 ZFL:
0039c5 940e 30f6          call   DOCREATE
0039c7 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
0039c8 2c84
0039c9 303f
0039ca 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
0039cb fd65              sbrc    FLAGS1, idup
0039cc c003              rjmp    COMMAZEROSENSE1
0039cd dddd              rcall   DOLIT
0039ce e7c2              fdw     ZEROSENSE
0039cf c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
0039d0 d004              rcall   IDPMINUS
0039d1 ddd9              rcall   DOLIT
0039d2 e7ce              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
0039d3 7d6f              cbr     FLAGS1, (1<<idup)
0039d4 c070              rjmp    INLINE0
                 
                 IDPMINUS:
0039d5 ddd5              rcall   DOLIT
0039d6 fffc              .dw     -4
0039d7 cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
0039d8 d975              rcall   TWOSLASH
0039d9 709f              andi    tosh, 0x0f
0039da 6c90              ori     tosh, 0xc0
0039db 940c 3f3a         jmp     ICOMMA
                 
                 
                 BRCCC:
0039dd ddcd              rcall   DOLIT
0039de f008              .dw     0xf008      ; brcc pc+2
0039df 940c 3f3a         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
0039e1 ddc9              rcall   DOLIT
0039e2 f409              .dw     0xf409      ; brne pc+2
0039e3 fd64              sbrc    FLAGS1, izeroeq
0039e4 7f9b              andi    tosh, ~4
0039e5 940c 3f3a         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
0039e7 f386              fdw     ZFL_L
                 IF_L:
0039e8 69d2
0039e9 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
0039ea fd64              sbrc    FLAGS1, izeroeq
0039eb dfe9              rcall   IDPMINUS
0039ec dfde              rcall   COMMAZEROSENSE
0039ed dff3              rcall   BRNEC
0039ee 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039ef ddf0              rcall   IHERE
0039f0 dd5e              rcall   FALSE_
0039f1 940c 39d8         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
0039f3 f3d0              fdw     IF_L
                 ELSE_L:
0039f4 65d4
0039f5 736c
0039f6 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
0039f7 dde8              rcall   IHERE
0039f8 dd56              rcall   FALSE_
0039f9 dfde              rcall   RJMPC
0039fa dc6a              rcall   SWOP_A      ; else-addr  if-addr 
0039fb 940c 3a01         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
0039fd f3e8              fdw     ELSE_L
                 THEN_L:
0039fe 74d4
0039ff 6568
003a00 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
003a01 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a02 dddd              rcall   IHERE
003a03 d8bc              rcall   OVER
003a04 d8fd              rcall   MINUS
003a05 deb9              rcall   TWOMINUS
003a06 d947              rcall   TWOSLASH
003a07 dda3              rcall   DOLIT
003a08 c000              .dw     0xc000      ;  back-addr mask 
003a09 d909              rcall   OR_
003a0a dc5a              rcall   SWOP_A
003a0b 940c 3e21         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
003a0d f3fc              fdw     THEN_L
                 BEGIN_L:
003a0e 62d5
003a0f 6765
003a10 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
003a11 940c 37e0         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
003a13 f41c              fdw     BEGIN_L
                 UNTIL_L:
003a14 75d5
003a15 746e
003a16 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
003a17 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a18 fd64              sbrc    FLAGS1, izeroeq
003a19 dfbb              rcall   IDPMINUS
003a1a dfb0              rcall   COMMAZEROSENSE
003a1b dfc5              rcall   BRNEC
003a1c 7e6f              cbr     FLAGS1, (1<<izeroeq)
003a1d 940c 3a23         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
003a1f f428              fdw     UNTIL_L
                 AGAIN_L:
003a20 61d5
003a21 6167
003a22 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
003a23 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a24 ddbb              rcall   IHERE
003a25 d8dc              rcall   MINUS
003a26 de98              rcall   TWOMINUS
003a27 940c 39d8         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
003a29 f440              fdw     AGAIN_L
                 WHILE_L:
003a2a 77d5
003a2b 6968
003a2c 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
003a2d dfbc              rcall   IF_
003a2e 940c 32b6         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
003a30 f454              fdw     WHILE_L
                 REPEAT_L:
003a31 72d6
003a32 7065
003a33 6165
003a34 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
003a35 dfed              rcall   AGAIN_
003a36 940c 3a01         jmp     THEN_
                 
003a38 f462              fdw     REPEAT_L
                 INLINE_L:
003a39 69d6
003a3a 6c6e
003a3b 6e69
003a3c 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a3d 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a3e 7d6f              cbr      FLAGS1, (1<<idup)
003a3f dd87              rcall    TICK
003a40 940c 3a45         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a42 f472              fdw      INLINE_L
                 INLINEC_L:
003a43 6983
003a44 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a45 db2b              rcall   FETCHPP
003a46 dd6d              rcall   DUP
003a47 dd63              rcall   DOLIT
003a48 9508              .dw     0x9508
003a49 d920              rcall   NOTEQUAL
003a4a d996              rcall   ZEROSENSE
003a4b f011              breq    INLINE1
003a4c d4ed              rcall   ICOMMA
003a4d cff7              rjmp    INLINE0
                 INLINE1:
003a4e 940c 31ea         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a50 f486              fdw     INLINEC_L
                 FOR_L:
003a51 66d3
003a52 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a53 940e 310e         call    DOCOMMAXT
003a55 e5a0              fdw     TOR
003a56 dd89              rcall   IHERE
003a57 dcf7              rcall   FALSE_
003a58 df7f              rcall   RJMPC
003a59 dd86              rcall   IHERE
003a5a 940c 32b6         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a5c f4a2              fdw     FOR_L
                 NEXT_L:
003a5d 6ed4
003a5e 7865
003a5f 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a60 dfa0              rcall   THEN_
003a61 940e 310e         call    DOCOMMAXT
003a63 f4dc              fdw     XNEXT
003a64 df78              rcall   BRCCC
                 
003a65 dfbd              rcall   AGAIN_
                 
003a66 dd44              rcall   DOLIT
003a67 f4ee              fdw     XNEXT1
003a68 940c 3a45         jmp     INLINE0
                 ; (next) decrement top of return stack
003a6a 2887
003a6b 656e
003a6c 7478
003a6d 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003a6e 91ff              pop     zh
003a6f 91ef              pop     zl
003a70 91bf              pop     xh
003a71 91af              pop     xl
003a72 9711              sbiw    xl, 1
003a73 93af              push    xl
003a74 93bf              push    xh
003a75 9409              mijmp
003a76 9508              ret
                 XNEXT1:
003a77 911f              pop     t1
003a78 910f              pop     t0
003a79 9508              ret
                 
                 ; leave clear top of return stack
003a7a f4ba              fdw     NEXT_L
                 LEAVE_L:
003a7b 6595
003a7c 646e
003a7d 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003a7e 91ff              pop     zh
003a7f 91ef              pop     zl
003a80 911f              pop     t1
003a81 910f              pop     t0
003a82 925f              push    zero
003a83 925f              push    zero
003a84 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003a85 f4f6              fdw      LEAVE_L
                 RDROP_L:
003a86 72d5
003a87 7264
003a88 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003a89 dd21              rcall   DOLIT
003a8a f4ee              fdw     XNEXT1
003a8b 940c 3a45         jmp     INLINE0
                 ;***************************************************
003a8d f50c              fdw     RDROP_L
                 STOD_L:
003a8e 7383
003a8f 643e              .db     NFA|3,"s>d"
                 STOD:
003a90 ff97              sbrs    tosh, 7
003a91 ccbd              rjmp    FALSE_
003a92 ccc4              rjmp    TRUE_
                 ;***************************************************
003a93 f51c              fdw     STOD_L
                 DNEGATE_L:
003a94 6487
003a95 656e
003a96 6167
003a97 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003a98 d049              rcall   DINVERT
003a99 940e 3224         call    ONE
003a9b 940c 32fd         jmp     MPLUS
                 ;***************************************************
003a9d f528              fdw     DNEGATE_L
                 QDNEGATE_L:
003a9e 3f88
003a9f 6e64
003aa0 6765
003aa1 7461
003aa2 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003aa3 dd1d              rcall   ZEROLESS
003aa4 d93c              rcall   ZEROSENSE
003aa5 f009              breq    QDNEGATE1
003aa6 dff1              rcall   DNEGATE
                 QDNEGATE1:
003aa7 9508              ret
                 
                 ;***************************************************
003aa8 f53c              fdw     QDNEGATE_L
                 DABS_L:
003aa9 6484
003aaa 6261
003aab 0073              .db     NFA|4,"dabs",0
                 DABS:
003aac dd07              rcall   DUP
003aad 940c 3aa3         jmp     QDNEGATE
                 ;***************************************************
003aaf f552              fdw     DABS_L
                 DPLUS_L:
003ab0 6482
003ab1 002b              .db     NFA|2,"d+",0
                 DPLUS:
003ab2 91a9              ld      xl, Y+
003ab3 91b9              ld      xh, Y+
003ab4 91e9              ld      t6, Y+
003ab5 91f9              ld      t7, Y+
003ab6 9109              ld      t0, Y+
003ab7 9119              ld      t1, Y+
003ab8 0fa0              add     xl, t0
003ab9 1fb1              adc     xh, t1
003aba 1f8e              adc     tosl, t6
003abb 1f9f              adc     tosh, t7
003abc 93ba              st      -Y, xh
003abd 93aa              st      -Y, xl
003abe 9508              ret
                 
                 ;***************************************************
003abf f560              fdw     DPLUS_L
                 DMINUS_L:
003ac0 6482
003ac1 002d              .db     NFA|2,"d-",0
                 DMINUS:
003ac2 dfd5              rcall   DNEGATE
003ac3 940c 3ab2         jmp     DPLUS
                 ;***************************************************
003ac5 f580              fdw     DMINUS_L
                 DTWOSLASH_L:
003ac6 6483
003ac7 2f32              .db     NFA|3,"d2/"
003ac8 9109              ld      t0, y+
003ac9 9119              ld      t1, y+
003aca 9595              asr     tosh
003acb 9587              ror     tosl
003acc 9517              ror     t1
003acd 9507              ror     t0
003ace 931a              st      -y, t1
003acf 930a              st      -y, t0
003ad0 9508              ret
                 ;***************************************************
003ad1 f58c              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003ad2 6483
003ad3 2a32              .db     NFA|3,"d2*"
003ad4 9109              ld      t0, y+
003ad5 9119              ld      t1, y+
003ad6 0f00              lsl     t0
003ad7 1f11              rol     t1
003ad8 1f88              rol     tosl
003ad9 1f99              rol     tosh
003ada 931a              st      -y, t1
003adb 930a              st      -y, t0
003adc 9508              ret
                 ;***************************************************
003add f5a4              fdw     DTWOSTAR_L
                 DINVERT_L:
003ade 6487
003adf 6e69
003ae0 6576
003ae1 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003ae2 9109              ld      t0, y+
003ae3 9119              ld      t1, y+
003ae4 9500              com     t0
003ae5 9510              com     t1
003ae6 9580              com     tosl
003ae7 9590              com     tosh
003ae8 931a              st      -y, t1
003ae9 930a              st      -y, t0
003aea 9508              ret
                 ;***************************************************
003aeb f5bc              fdw     DINVERT_L
                 DZEROEQUAL_L:
003aec 6483
003aed 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003aee 91a9              ld      xl, y+
003aef 91b9              ld      xh, y+
003af0 2b89              or      tosl, tosh
003af1 2b8a              or      tosl, xl
003af2 2b8b              or      tosl, xh
003af3 f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003af4 ef8f              ser     tosl
003af5 ef9f              ser     tosh
003af6 9508              ret
                 
                 ;***************************************************
003af7 f5d8              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003af8 6483
003af9 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003afa 91a9              ld      xl, y+
003afb 91b9              ld      xh, y+
003afc 3090              cpi     tosh, 0
003afd f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003afe 2788              clr     tosl
003aff 2799              clr     tosh
003b00 9508              ret
                 ;***************************************************
003b01 f5f0              fdw     DZEROLESS_L
                 DEQUAL_L:
003b02 6482
003b03 003d              .db     NFA|2,"d=",0
003b04 dfbd              rcall   DMINUS
003b05 940c 3aee         jmp     DZEROEQUAL
                 ;***************************************************
003b07 f604              fdw     DEQUAL_L
                 DLESS_L:
003b08 6482
003b09 003c              .db     NFA|2,"d<",0
                 DLESS:
003b0a dfb7              rcall   DMINUS
003b0b 940c 3afa         jmp     DZEROLESS
                 ;***************************************************
003b0d f610              fdw     DLESS_L
                 DGREATER_L:
003b0e 6482
003b0f 003e              .db     NFA|2,"d>",0
                 DGREATER:
003b10 940e 31f8         call    TWOSWAP
003b12 940c 3b0a         jmp     DLESS
                 ;***************************************************
003b14 f61c              fdw     DGREATER_L
                 UDDOT_L:
003b15 7583
003b16 2e64              .db     NFA|3,"ud."
003b17 d945              rcall   LESSNUM
003b18 d95d              rcall   NUMS
003b19 d965              rcall   NUMGREATER
003b1a 940e 326b         call    TYPE
003b1c 940c 3201         jmp     SPACE_
                 ;***************************************************
003b1e f62a              fdw     UDDOT_L
                 DDOT_L:
003b1f 6482
003b20 002e              .db     NFA|2,"d.",0
003b21 d93b              rcall   LESSNUM
003b22 940e 37b4         call    DUP
003b24 940e 32d0         call    TOR
003b26 df85              rcall   DABS
003b27 d94e              rcall   NUMS
003b28 940e 32da         call    RFROM
003b2a d95f              rcall   SIGN
003b2b d953              rcall   NUMGREATER
003b2c 940e 326b         call    TYPE
003b2e 940c 3201         jmp     SPACE_
                 ;****************************************************
003b30 f63e              fdw      DDOT_L
                 MEMHI_L:
003b31 6882
003b32 0069              .db     NFA|2,"hi",0
                 MEMHI:
003b33 dc77              rcall   DOLIT
003b34 f676              fdw     FLASHHI
003b35 940e 315c         call    CSE_
003b37 940e 32f5         call    PLUS
003b39 940c 3e69         jmp     FETCH
                 FLASHHI:
003b3b deff              .dw      FLASH_HI
003b3c 0cff              .dw      EEPROM_HI
003b3d 08ff              .dw      RAM_HI
                 
                 .if FLASHEND > 0x3fff
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
                 .endif
                 
                 ;***************************************************
                 
003b3e f662              fdw      MEMHI_L
                 L_FETCH_P:
003b3f 40a2
003b40 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b41 939a
003b42 938a              pushtos
003b43 01ca              movw    tosl, pl
003b44 9508              ret
                 ;***************************************************
003b45 f67e              fdw     L_FETCH_P
                 L_PCFETCH:
003b46 7083
003b47 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b48 939a
003b49 938a              pushtos
003b4a 01ca              movw    tosl, pl
003b4b 940c 3e93         jmp     CFETCH
                 ;***************************************************
003b4d f68c              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b4e 70a3
003b4f 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b50 0d47              add     pl, r_two
003b51 1d55              adc     ph, zero
003b52 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b53 0000              .dw     0
                 L_MARKER:
                 lastword:
003b54 6d86
003b55 7261
003b56 656b
003b57 0072              .db     NFA|6,"marker",0
                 MARKER:
003b58 940e 3141         call    ROM_
003b5a dca2              rcall   CREATE
003b5b dc4f              rcall   DOLIT
003b5c 0900              .dw     dp_start
003b5d 940e 3166         call    HERE
003b5f dbc7              rcall   TEN
003b60 d9ed              rcall   CMOVE
003b61 dbc5              rcall   TEN
003b62 940e 32a8         call    ALLOT
003b64 940e 314f         call    FRAM
003b66 dce6              rcall   XDOES
003b67 940e 30fe         call    DODOES
003b69 dd7c              rcall   INI
003b6a dbbc              rcall   TEN
003b6b 940c 354e         jmp     CMOVE
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD_LED == 1
                 ;;; Enable load led
003b6d dfc4              fdw     BUSY_L
                 LOADON_L:
003b6e 6c85
003b6f 616f
003b70 2b64              .db     NFA|5,"load+"
003b71 6170              sbr     FLAGS2, (1<<fLOADled)
003b72 9508              ret
                 
                 ;;; Disable load led
003b73 f6dc              fdw     LOADON_L
                 LOADOFF_L:
003b74 6c85
003b75 616f
003b76 2d64              .db     NFA|5,"load-"
003b77 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
003b78 9825              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003b79 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003b7a 9508              ret
                 .endif
                 ;;; 
                 .if CPU_LOAD == 1
                 .if CPU_LOAD_LED == 1
                 .else
                 .endif
                 .endif
                 .endif
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
003b7b 0200              .dw      0x0200                ; cse, state
003b7c 027f              .dw      utibbuf-4             ; S0
003b7d 0242              .dw      usbuf-1               ; R0
003b7e f8f0              fdw      OP_TX_
003b7f f93e              fdw      OP_RX_
003b80 f97e              fdw      OP_RXQ
003b81 000a              .dw      BASE_DEFAULT          ; BASE
003b82 0283              .dw      utibbuf               ; TIB
003b83 dfac              fdw      OPERATOR_AREA         ; TASK
003b84 0000              .dw      0                     ; ustatus & uflg
003b85 0000              .dw      0                     ; source
003b86 0000              .dw      0                     ; source
003b87 0000              .dw      0                     ; TOIN
003b88 0201              .dw      up0                   ; Task link
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003b89 fe00              sbrs    t2, PORF
003b8a c003              rjmp    RQ_EXTR
003b8b dc1f              rcall   DOLIT
003b8c 0050              .dw     'P'
003b8d dc68              rcall   EMIT_A
                 RQ_EXTR:
003b8e fe01              sbrs    t2, EXTRF
003b8f c003              rjmp    RQ_BORF
003b90 dc1a              rcall   DOLIT
003b91 0045              .dw     'E'
003b92 dc63              rcall   EMIT_A
                 RQ_BORF:
003b93 fe02              sbrs    t2, BORF
003b94 c003              rjmp    RQ_WDRF
003b95 dc15              rcall   DOLIT
003b96 0042              .dw     'B'
003b97 dc5e              rcall   EMIT_A
                 RQ_WDRF:
003b98 fe03              sbrs    t2, WDRF
003b99 c003              rjmp    RQ_DIVZERO
003b9a dc10              rcall   DOLIT
003b9b 0057              .dw     'W'
003b9c dc59              rcall   EMIT_A
                 RQ_DIVZERO:
003b9d fe16              sbrs    t3, 6 ; T bit MATH error
003b9e c003              rjmp    RQ_END
003b9f dc0b              rcall   DOLIT
003ba0 004d              .dw     'M'
003ba1 dc54              rcall   EMIT_A
                 RQ_END: 
003ba2 940c 3201         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
                 .endif
                 .if CPU_LOAD_LED == 1
003ba4 ff74              sbrs    FLAGS2, fLOADled
003ba5 c002              rjmp    LOAD_LED_END
003ba6 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003ba7 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003ba8 ff76              sbrs    FLAGS2, fIDLE
003ba9 c007              rjmp    IDLE_LOAD1
003baa e001              ldi     t0, low(up0)
003bab 1620              cp      upl, t0
003bac f421              brne    IDLE_LOAD1
                 .ifdef SMCR
003bad e001              ldi     t0, (1<<SE)
003bae bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
                 .endif
003baf 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003bb0 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003bb1 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003bb2 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003bb3 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d44 RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d03b                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d039                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d037                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
003c08 d035                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
003c0a d033                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d031                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
003c0e d02f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
003c10 d02d                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
003c12 d02b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
003c14 d029                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
003c16 d027                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
003c18 d025                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
003c1a d023                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
003c1c c033                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
003c1e d01f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
003c20 d01d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
003c22 d01b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
003c24 d019                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d017                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d015                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
                 .else
003c2a d013                  rcall FF_ISR
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d011                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d00f                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d00d                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d00b                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
003c33 919f              pop     tosh
003c34 918f              pop     tosl
003c35 911f              pop     t1
003c36 910f              pop     t0
003c37 91ff              pop     zh
003c38 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
003c39 91a9              ld      xl, y+
003c3a 91b9              ld      xh, y+
003c3b bfbf              out_    SREG, xh
003c3c 91b9              ld      xh, y+
003c3d 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
003c3e 93ba              st      -y, xh
003c3f b7bf              in_     xh, SREG
003c40 93ba              st      -y, xh
003c41 93aa              st      -y, xl
                         m_pop_xh
003c42 91bf              pop     xh
003c43 91af              pop     xl
003c44 93ef              push    zl
003c45 93ff              push    zh
003c46 930f              push    t0
003c47 931f              push    t1
003c48 938f              push    tosl
003c49 939f              push    tosh
                 .if low(ivec) == 0x80
003c4a e7bf              ldi     xh, low(ivec-1)
003c4b 0fab              add     xl, xh
                 .else
                 .endif
003c4c e0b1              ldi     xh, high(ivec)
003c4d 91ed              ld      zl, x+
003c4e 91fd              ld      zh, x+
003c4f 9409              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
003c50 93ba              st      -y, xh
003c51 b7bf              in_     xh, SREG
003c52 93ba              st      -y, xh
003c53 93aa              st      -y, xl
003c54 0ce6              add     ms_count,  r_one
003c55 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
                 .endif
003c56 cfe2              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
003c57 ebe7              ldi     zl, low(rbuf0)
003c58 e0f1              ldi     zh, high(rbuf0)
003c59 91a0 01b4         lds     xl, rbuf0_wr
003c5b 0fea              add     zl, xl
003c5c 1df5              adc     zh, zero
003c5d 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
003c5f 30bf              cpi     xh, 0xf
003c60 f409              brne    pc+2
003c61 cf9e              rjmp    RESET_
                 .endif
                 .endif
003c62 83b0              st      z, xh
003c63 95a3              inc     xl
003c64 71af              andi    xl, (RX0_BUF_SIZE-1)
003c65 93a0 01b4         sts     rbuf0_wr, xl
003c67 91a0 01b6         lds     xl, rbuf0_lv
003c69 95a3              inc     xl
003c6a 93a0 01b6         sts     rbuf0_lv, xl
003c6c 31ae              cpi     xl, RX0_BUF_SIZE-2
003c6d f409              brne    PC+2
003c6e d004              rcall   RX0_OVF
003c6f 30a4              cpi     xl, RX0_OFF_FILL
003c70 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c71 d021              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
003c72 cfc0              rjmp    FF_ISR_EXIT
                 RX0_OVF:
003c73 e7fc              ldi     zh, '|'
003c74 c020              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .else
                 .if CPU_LOAD_LED == 1
003c75 f6e8              fdw(LOADOFF_L)
                 .else
                 .endif
                 .endif
                 .else
                 .endif
                 TX0_L:
003c76 7483
003c77 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c78 3181              cpi     tosl, XON
003c79 f061              breq    XXON_TX0_TOS
003c7a 3183              cpi     tosl, XOFF
003c7b f091              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c7c d29d              rcall   PAUSE
003c7d 9100 00c0         in_     t0, UCSR0A
003c7f ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003c80 cffb              rjmp    TX0_LOOP
003c81 9380 00c6         out_    UDR0_, tosl
003c83 9189
003c84 9199              poptos
003c85 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003c86 9189
003c87 9199              poptos
003c88 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003c89 ff70              sbrs    FLAGS2, ixoff_tx0
003c8a 9508              ret
                 XXON_TX0_1:
003c8b 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003c8c e1f1              ldi     zh, XON
003c8d c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003c8e 9189
003c8f 9199              poptos
003c90 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003c91 fd70              sbrc    FLAGS2, ixoff_tx0
003c92 9508              ret     
                 XXOFF_TX0_1:
003c93 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003c94 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003c95 91e0 00c0         in_     zl, UCSR0A
003c97 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003c98 cffc              rjmp    TX0_SEND
003c99 93f0 00c6         out_    UDR0_, zh
003c9b 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003c9c f8ec              fdw(TX0_L)
                 RX0_L:
003c9d 7283
003c9e 3078              .db     NFA|3,"rx0"
                 RX0_:
003c9f d27a              rcall   PAUSE
003ca0 d01e              rcall   RX0Q
003ca1 940e 33e1         call    ZEROSENSE
003ca3 f3d9              breq    RX0_
003ca4 939a
003ca5 938a              pushtos
003ca6 ebe7              ldi     zl, low(rbuf0)
003ca7 e0f1              ldi     zh, high(rbuf0)
003ca8 91a0 01b5         lds     xl, rbuf0_rd
003caa 0fea              add     zl, xl
003cab 1df5              adc     zh, zero
003cac 8180              ld      tosl, z
003cad 2799              clr     tosh
003cae b70f              in_     t0, SREG
003caf 94f8              cli
003cb0 95a3              inc     xl
003cb1 71af              andi    xl, (RX0_BUF_SIZE-1)
003cb2 93a0 01b5         sts     rbuf0_rd, xl
003cb4 91a0 01b6         lds     xl, rbuf0_lv
003cb6 95aa              dec     xl
003cb7 93a0 01b6         sts     rbuf0_lv, xl
003cb9 bf0f              out_    SREG, t0
003cba 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003cbb f93a              fdw     RX0_L
                 RX0Q_L:
003cbc 7284
003cbd 3078
003cbe 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003cbf 91a0 01b6         lds     xl, rbuf0_lv
003cc1 11a5              cpse    xl, zero
003cc2 940c 3757         jmp     TRUE_
                 .if U0FC_TYPE == 1
003cc4 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003cc5 940c 374f         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003cc7 dc94              rcall   DOTS
003cc8 940e 3278         call    XSQUOTE
003cca 4103
003ccb 3f44              .db     3,"AD?"
003ccc 940e 326b         call    TYPE
003cce cab6              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003ccf 5890      	sub_pflash_tos
                 .ifdef  RAMPZ
                 .endif
                 XUPDATEBUF:
003cd0 9380 01e1         sts     iaddrl, tosl
003cd2 9390 01e2         sts     iaddrh, tosh
                 .ifdef RAMPZ
                 .endif
003cd4 359f              cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
003cd5 f788              brcc    ISTORERR
                 XUPDATEBUF2:	
003cd6 9100 01e1 	lds     t0, iaddrl
003cd8 7800              andi    t0, ~(PAGESIZEB-1)
003cd9 110a              cpse    t0, ibasel
003cda c005              rjmp    IFILL_BUFFER
003cdb 9100 01e2         lds     t0, iaddrh
003cdd 110b              cpse    t0, ibaseh
003cde c001              rjmp    IFILL_BUFFER
                 .ifdef RAMPZ
                 .endif
003cdf 9508              ret
                 
                 IFILL_BUFFER:
003ce0 d04e              rcall   IFLUSH
003ce1 9100 01e1         lds     t0, iaddrl
003ce3 7800              andi    t0, ~(PAGESIZEB-1)
003ce4 2ea0              mov     ibasel, t0
003ce5 90b0 01e2         lds     ibaseh, iaddrh
                 .ifdef RAMPZ
                 .endif
                 IFILL_BUFFER_1:
003ce7 e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003ce8 01f5              movw    zl, ibasel
003ce9 e0a0              ldi     xl, low(ibuf)
003cea e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003ceb 9115              lpm_    t1, z+
003cec 931d              st      x+, t1
003ced 950a              dec     t0
003cee f7e1              brne    IFILL_BUFFER_2
                 .ifdef RAMPZ
                 .endif
003cef 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003cf0 daba              rcall   DOLIT
003cf1 0013              .dw     XOFF
003cf2 940e 30a1         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003cf4 dab6              rcall   DOLIT
003cf5 000a              .dw     10
003cf6 dc01              rcall   MS
                         ; Disable interrupts
003cf7 94f8              cli
003cf8 01f5              movw    zl, ibasel
                 .ifdef RAMPZ
                 .endif
003cf9 e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003cfa d029              rcall   DO_SPM
003cfb e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003cfc d027              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003cfd e800              ldi     t0, low(PAGESIZEB);init loop variable
003cfe e0a0              ldi     xl, low(ibuf)
003cff e0b1              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
003d00 900d              ld      r0, x+
003d01 901d              ld      r1, x+
003d02 e011              ldi     t1, (1<<SPMEN)
003d03 d020              rcall   DO_SPM
003d04 9632              adiw    zl, 2
003d05 5002              subi    t0, 2
003d06 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d07 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d08 40f0              sbci    zh, high(PAGESIZEB)
003d09 e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d0a d019              rcall   DO_SPM
                         ; re-enable the RWW section
003d0b d012              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d0c e800              ldi     t0, low(PAGESIZEB);init loop variable
003d0d 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d0e 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d0f 9005              lpm_    r0, z+
003d10 901d              ld      r1, x+
003d11 1001              cpse    r0, r1
003d12 c031              rjmp    WARM_     ; reset
003d13 5001              subi    t0, 1
003d14 f7d1              brne    IWRITE_BUFFER2
003d15 ef0f      	ser     t0
003d16 2eb0      	mov     ibaseh, t0
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
003d17 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d18 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d19 da91              rcall   DOLIT
003d1a 0011              .dw     XON
003d1b 940e 30a1         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 .if DEBUG_FLASH == 1
                 .endif
003d1d 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d1e b687              in_     t8, SPMCSR
003d1f fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d20 9508              ret
                         ; re-enable the RWW section
003d21 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d22 d001              rcall   DO_SPM
003d23 cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d24 b687              in_     t8, SPMCSR
003d25 fc80              sbrc    t8, SPMEN
003d26 cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d27 bf17              out_    SPMCSR, t1
003d28 95e8              spm
003d29 9508              ret
                 
003d2a fe2e              fdw     PAUSE_L
                 IFLUSH_L:
003d2b 6986
003d2c 6c66
003d2d 7375
003d2e 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d2f fd60              sbrc    FLAGS1, idirty
003d30 cfbf              rjmp    IWRITE_BUFFER
003d31 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d32 f978              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d33 6585
003d34 706d
003d35 7974              .db     NFA|5,"empty"
                 EMPTY:
003d36 da74              rcall   DOLIT
003d37 fef2              fdw     COLDLIT
003d38 da72              rcall   DOLIT
003d39 0900              .dw     dp_start
003d3a da70              rcall   DOLIT
003d3b 000c              .dw     coldlitsize
003d3c 940e 354e         call    CMOVE
003d3e 940c 372b         jmp     DP_TO_RAM
                         
                 ;*******************************************************
003d40 fa66              fdw     EMPTY_L
                 WARM_L:
003d41 7784
003d42 7261
003d43 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d44 94f8              cli           ; Disable interrupts
003d45 27aa              clr     xl
003d46 27bb              clr     xh
003d47 e1c9              ldi     yl, 25
003d48 e0d0              ldi     yh, 0
                 WARM_1:
003d49 93dd              st      x+, yh
003d4a 50c1              subi    yl, 1
003d4b f7e9              brne    WARM_1
                 
003d4c b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d4d b604              in_     t2, MCUSR
003d4e 9250 0034         sts     MCUSR, zero
                 .endif
003d50 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d51 925d              st      x+, zero
003d52 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d53 f7e9              brne    WARM_2
                 
                 ; Init empty flash buffer
003d54 94ba      	dec     ibaseh
                 .ifdef RAMPZ
                 .endif
                 
                 ; Init constant registers
003d55 e0c1              ldi     yl, 1
003d56 2e6c              mov     r_one, yl
003d57 e0c2              ldi     yl, 2
003d58 2e7c              mov     r_two, yl
                 ; Init Stack pointer
003d59 e7cf              ldi     yl, low(utibbuf-4)
003d5a e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d5b e402              ldi     t0, low(usbuf-1)
003d5c e012              ldi     t1, high(usbuf-1)
003d5d bf0d              out     spl, t0
003d5e bf1e              out     sph, t1
                 ; Init user pointer
003d5f e001              ldi     t0, low(up0)
003d60 e012              ldi     t1, high(up0)
003d61 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d62 da48              rcall   DOLIT
003d63 f6f6              fdw     WARMLIT
003d64 da46              rcall   DOLIT
003d65 01e3              .dw     cse
003d66 da44              rcall   DOLIT
003d67 001c              .dw     warmlitsize
003d68 940e 354e         call    CMOVE
                 ; init cold data to eeprom
003d6a da40              rcall   DOLIT
003d6b 0900              .dw     dp_start
003d6c d0fc              rcall   FETCH
003d6d d9e9              rcall   TRUE_
003d6e 940e 3372         call    EQUAL
003d70 940e 33e1         call    ZEROSENSE
003d72 f009              breq    WARM_3  
003d73 dfc2              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d74 be65              out_    MCUCR, r_one   ; (1<<IVCE)
003d75 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
003d76 bc74              out_    TCCR0A, r_two  ; CTC
003d77 e003              ldi     t0, ms_pre_tmr0
003d78 bd05              out_    TCCR0B, t0
003d79 ef09              ldi     t0, ms_value_tmr0
003d7a bd07              out_    OCR0A, t0
003d7b 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
003d7d da2d              rcall   DOLIT
003d7e 3c57              .dw     RX0_ISR
003d7f da2b              rcall   DOLIT
                 .ifdef URXC0addr
                 .else
003d80 01a4              .dw     URXCaddr+ivec
                 .endif
003d81 d09f              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, zero
003d82 e607              ldi     t0, ubrr0val
003d83 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003d85 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003d86 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003d88 e006              ldi     t0, (3<<UCSZ00)|URSEL_
003d89 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003d8b 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d8c d99e              rcall   DP_TO_RAM
003d8d 9478              sei
                 
003d8e ddfa              rcall   RQ_EMIT
003d8f d023              rcall   VER
                 ; Turnkey ?
003d90 d182              rcall   TURNKEY
003d91 940e 33e1         call    ZEROSENSE
003d93 f0d1              breq    STARTQ2
003d94 940e 3278         call    XSQUOTE
003d96 4503
003d97 4353              .db     3,"ESC"
003d98 940e 326b         call    TYPE
003d9a da10              rcall   DOLIT
003d9b 07d0              .dw     TURNKEY_DELAY
003d9c db5b              rcall   MS
003d9d 940e 30ae         call    KEYQ
003d9f 940e 33e1         call    ZEROSENSE
003da1 f049              breq    STARTQ1
003da2 940e 30a7         call    KEY
003da4 da06              rcall   DOLIT
003da5 001b              .dw     0x1b
003da6 940e 3372         call    EQUAL
003da8 940e 33e1         call    ZEROSENSE
003daa f419              brne    STARTQ2
                 STARTQ1:
003dab d167              rcall   TURNKEY
003dac 940e 30b6         call    EXECUTE
                 STARTQ2:
003dae 940c 3785         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
003db0 fa82              fdw     WARM_L
                 VER_L:
003db1 7683
003db2 7265              .db     NFA|3,"ver"
                 VER:
003db3 940e 3278         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
003db5 4624
003db6 616c
003db7 6873
003db8 6f46
003db9 7472
003dba 2068
003dbb 2035
003dbc 5441
003dbd 656d
003dbe 6167
003dbf 3233
003dc0 5038
003dc1 3120
003dc2 2e31
003dc3 3131
003dc4 322e
003dc5 3130
003dc6 0d36
avr/src/ff-atmega.asm(5423): warning: .cseg .db misalignment - padding zero byte
003dc7 000a              .db     partlen+datelen+16,"FlashForth 5 ",partstring," ", DATE,0xd,0xa
003dc8 940c 326b         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003dca fb62              fdw     VER_L
                 EI_L:
003dcb 65a2
003dcc 0069              .db     NFA|INLINE|2,"ei",0
003dcd 9478              sei
003dce 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003dcf fb96              fdw     EI_L
                 DI_L:
003dd0 64a2
003dd1 0069              .db     NFA|INLINE|2,"di",0
003dd2 94f8              cli
003dd3 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003dd4 fba0              fdw     DI_L
                 IRQ_SEMI_L:
003dd5 3bc2
003dd6 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003dd7 d9d3              rcall   DOLIT
                 .ifdef EIND
                 .else
003dd8 940c              .dw     0x940C     ; jmp
                 .endif
003dd9 d160              rcall   ICOMMA
003dda d9d0              rcall   DOLIT
003ddb 3c33              .dw     FF_ISR_EXIT
003ddc d15d              rcall   ICOMMA
003ddd 940c 3868         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003ddf fbaa              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003de0 6984
003de1 746e
003de2 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003de3 01fc              movw    zl, tosl
003de4 9731              sbiw    zl, 1
003de5 0fee              lsl     zl
                 .if low(ivec) == 0x80
003de6 e8f0              ldi     zh, low(ivec)
003de7 0fef              add     zl,  zh
                 .endif
003de8 e0f1              ldi     zh, high(ivec)
003de9 9189
003dea 9199              poptos
003deb dbc4              rcall   TO_XA
003dec 940c 3e26         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003dee fbc0              fdw     IRQ_V_L
                 LITERAL_L:
003def 6cc7
003df0 7469
003df1 7265
003df2 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003df3 d9b7              rcall   DOLIT
003df4 ef68              fdw     DUP
003df5 dc4f              rcall   INLINE0
003df6 940e 37b4         call    DUP
003df8 2f98              mov     tosh, tosl
003df9 9592              swap    tosh
003dfa 709f              andi    tosh, 0xf
003dfb 708f              andi    tosl, 0xf
003dfc 6e90              ori     tosh, 0xe0
003dfd 6880              ori     tosl, 0x80
003dfe d13b              rcall   ICOMMA
003dff 2f89              mov     tosl, tosh
003e00 9592              swap    tosh
003e01 709f              andi    tosh, 0xf
003e02 708f              andi    tosl, 0xf
003e03 6e90              ori     tosh, 0xe0
003e04 6980              ori     tosl, 0x90
003e05 940c 3f3a         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e07 d03b              rcall   LOCKEDQ
003e08 dec6              rcall   IUPDATEBUF
                 ISTORE1:
003e09 9189
003e0a 9199              poptos
003e0b e0a0              ldi     xl, low(ibuf)
003e0c e0b1              ldi     xh, high(ibuf)
003e0d 9100 01e1         lds     t0, iaddrl
003e0f 770f              andi    t0, (PAGESIZEB-1)
003e10 0fa0              add     xl, t0
003e11 938d              st      x+, tosl
003e12 939d              st      x+, tosh
003e13 9189
003e14 9199              poptos
003e15 6061              sbr     FLAGS1, (1<<idirty)
003e16 9508              ret
                 
003e17 fbde              fdw     LITERAL_L
                 TO_A_L:
003e18 3e82
003e19 0061              .db     NFA|2, ">a",0
                 TO_A:
003e1a 2f28              mov     al, tosl
003e1b 2f39              mov     ah, tosh
003e1c 9189
003e1d 9199              poptos
003e1e 9508              ret
                 
003e1f fc30              fdw     TO_A_L
                 STORE_L:
003e20 2181              .db     NFA|1, "!"
                 STORE:
003e21 3099              cpi     tosh, high(PEEPROM)
003e22 f440              brcc    STORE1
                 STORE_RAM:
003e23 01fc              movw    zl, tosl
003e24 9189
003e25 9199              poptos
                 STORE_RAM_2:
003e26 8391              std     Z+1, tosh
003e27 8380              std     Z+0, tosl
003e28 9189
003e29 9199              poptos
003e2a 9508              ret
                 STORE1:
003e2b 3890              cpi     tosh, high(OFLASH)
003e2c f6d0              brcc    ISTORE
                 ESTORE:
003e2d d015              rcall   LOCKEDQ
003e2e 99f9              sbic    eecr, eewe
003e2f cffd              rjmp    ESTORE
003e30 5099              subi    tosh, high(PEEPROM)
003e31 bd81              out     eearl, tosl
003e32 bd92              out     eearh, tosh
003e33 9189
003e34 9199              poptos
003e35 bd80              out     eedr, tosl
003e36 9afa              sbi     eecr, eemwe
003e37 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
003e38 99f9              sbic    eecr, eewe
003e39 cffe              rjmp    ESTORE1
                 
003e3a b581              in      tosl, eearl
003e3b 9583              inc     tosl
003e3c bd81              out     eearl, tosl
                 
003e3d bd90              out     eedr, tosh
003e3e 9afa              sbi     eecr, eemwe
003e3f 9af9              sbi     eecr, eewe
                 
003e40 9189
003e41 9199              poptos
003e42 9508              ret
                 LOCKEDQ:
003e43 ff62              sbrs    FLAGS1, fLOCK
003e44 9508              ret
003e45 db16              rcall   DOTS
003e46 940e 3278         call    XSQUOTE
003e48 4103
003e49 3f44              .db     3,"AD?"
003e4a 940e 326b         call    TYPE
003e4c cf61              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e4d 01fc              movw    z, tosl
003e4e 58f0              sub_pflash_z
                 .ifdef RAMPZ
                 .endif
003e4f 11fb              cpse    zh, ibaseh
003e50 c00b              rjmp    IIFETCH
003e51 2f0e              mov     t0, zl
003e52 7800              andi    t0, ~(PAGESIZEB-1)
003e53 150a              cp      t0, ibasel
003e54 f439              brne    IIFETCH
003e55 e0a0              ldi     xl, low(ibuf)
003e56 e0b1              ldi     xh, high(ibuf)
003e57 77ef              andi    zl, (PAGESIZEB-1)
003e58 0fae              add     xl, zl
003e59 918d              ld      tosl, x+
003e5a 919d              ld      tosh, x+
003e5b 9508              ret
                 IIFETCH:
003e5c 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e5d 9195              lpm_    tosh, z+
003e5e 9508              ret
                                 
003e5f fc40              fdw     STORE_L
                 A_FROM_L:
003e60 6182
003e61 003e              .db     NFA|2, "a>",0
003e62 939a
003e63 938a              pushtos
003e64 2f82              mov     tosl, al
003e65 2f93              mov     tosh, ah
003e66 9508              ret
                 
                 .if FLASHEND > 0x3fff
                 .else
003e67 fcc0              fdw     A_FROM_L
                 .endif
                 FETCH_L:
003e68 4081              .db     NFA|1, "@"
                 FETCH:
003e69 3099              cpi     tosh, high(PEEPROM)
003e6a f420              brcc    FETCH1
                 FETCH_RAM:
003e6b 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e6c 9181              ld      tosl, z+
003e6d 9191              ld      tosh, z+
003e6e 9508              ret
                 FETCH1:
003e6f 3890              cpi     tosh, high(OFLASH)
003e70 f6e0              brcc    IFETCH
                 EFETCH:
003e71 99f9              sbic    eecr, eewe
003e72 cffe              rjmp    EFETCH
003e73 5099              subi    tosh, high(PEEPROM)
003e74 bd81              out     eearl, tosl
003e75 bd92              out     eearh, tosh
003e76 9af8              sbi     eecr, eere
003e77 b580              in      tosl, eedr
003e78 b591              in      tosh, eearl
003e79 9593              inc     tosh
003e7a bd91              out     eearl, tosh
003e7b 9af8              sbi     eecr, eere
003e7c b590              in      tosh, eedr
003e7d 9508              ret
                 
                 ICFETCH:
003e7e 01fc              movw    z, tosl
003e7f 58f0              sub_pflash_z
                 .ifdef RAMPZ
                 .endif
003e80 11fb              cpse    zh, ibaseh
003e81 c00b              rjmp    IICFETCH
003e82 2f0e              mov     t0, zl
003e83 7800              andi    t0, ~(PAGESIZEB-1)
003e84 150a              cp      t0, ibasel
003e85 f439              brne    IICFETCH
003e86 e0a0              ldi     xl, low(ibuf)
003e87 e0b1              ldi     xh, high(ibuf)
003e88 77ef              andi    zl, (PAGESIZEB-1)
003e89 0fae              add     xl, zl
003e8a 918d              ld      tosl, x+
003e8b 2799              clr     tosh
003e8c 9508              ret
                 IICFETCH:
003e8d 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e8e 2799              clr     tosh
003e8f 9508              ret
                 
003e90 fcd0              fdw     FETCH_L
                 CFETCH_L:
003e91 6382
003e92 0040              .db     NFA|2, "c@",0
                 CFETCH:
003e93 3099              cpi     tosh, high(PEEPROM)
003e94 f420              brcc    CFETCH1
                 CFETCH_RAM:
003e95 01fc              movw    zl, tosl
003e96 9181              ld      tosl, z+
003e97 2799              clr     tosh
003e98 9508              ret
                 CFETCH1:
003e99 3890              cpi     tosh, high(OFLASH)
003e9a f718              brcc    ICFETCH
                 ECFETCH:
003e9b 99f9              sbic    eecr, eewe
003e9c cffe              rjmp    ECFETCH
003e9d 5099              subi    tosh, high(PEEPROM)
003e9e bd81              out     eearl, tosl
003e9f bd92              out     eearh, tosh
003ea0 9af8              sbi     eecr, eere
003ea1 b580              in      tosl, eedr
003ea2 2799              clr     tosh
003ea3 9508              ret
                 
                 ICSTORE:
003ea4 df9e              rcall   LOCKEDQ
003ea5 de29              rcall   IUPDATEBUF
003ea6 9189
003ea7 9199              poptos
003ea8 e0a0              ldi     xl, low(ibuf)
003ea9 e0b1              ldi     xh, high(ibuf)
003eaa 9100 01e1         lds     t0, iaddrl
003eac 770f              andi    t0, (PAGESIZEB-1)
003ead 0fa0              add     xl, t0
003eae 938d              st      x+, tosl
003eaf 9189
003eb0 9199              poptos
003eb1 6061              sbr     FLAGS1, (1<<idirty)
003eb2 9508              ret
                 
003eb3 fd22              fdw     CFETCH_L
                 CSTORE_L:
003eb4 6382
003eb5 0021              .db     NFA|2, "c!",0
                 CSTORE:
003eb6 3099              cpi     tosh, high(PEEPROM)
003eb7 f438              brcc    CSTORE1
                 CSTORE_RAM:
003eb8 01fc              movw zl, tosl
003eb9 9189
003eba 9199              poptos
003ebb 8380              std Z+0, tosl
003ebc 9189
003ebd 9199              poptos
003ebe 9508              ret
                 CSTORE1:
003ebf 3890              cpi     tosh, high(OFLASH)
003ec0 f718              brcc    ICSTORE
                 ECSTORE:
003ec1 df81              rcall   LOCKEDQ
003ec2 99f9              sbic    eecr, eewe
003ec3 cffd              rjmp    ECSTORE
003ec4 5099              subi    tosh, high(PEEPROM)
003ec5 bd81              out     eearl, tosl
003ec6 bd92              out     eearh, tosh
003ec7 9189
003ec8 9199              poptos
003ec9 bd80              out     eedr, tosl
003eca 9afa              sbi     eecr, eemwe
003ecb 9af9              sbi     eecr, eewe
003ecc 9189
003ecd 9199              poptos
003ece 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
003ecf fd68              fdw     CSTORE_L
                 
                 FLOCK_L:
003ed0 6683
003ed1 2d6c              .db     NFA|3,"fl-"
003ed2 6064              sbr     FLAGS1, (1<<fLOCK)
003ed3 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003ed4 fda0              fdw     FLOCK_L
                 FUNLOCK_L:
003ed5 6683
003ed6 2b6c              .db     NFA|3,"fl+"
003ed7 7f6b              cbr     FLAGS1, (1<<fLOCK)
003ed8 9508              ret
                 
                 
                 
003ed9 fdaa              fdw     FUNLOCK_L
                 VALUE_L:
003eda 7685
003edb 6c61
003edc 6575              .db     NFA|5,"value"
                 VALUE:
003edd d91f              rcall   CREATE
003ede 940e 316b         call    COMMA
003ee0 d96c              rcall   XDOES
                 VALUE_DOES:
003ee1 940e 30fe         call    DODOES
003ee3 940c 3e69         jmp     FETCH
                 
003ee5 fdb4              fdw     VALUE_L
                 DEFER_L:
003ee6 6485
003ee7 6665
003ee8 7265              .db     NFA|5,"defer"
                 DEFER:
003ee9 d913              rcall   CREATE
003eea 940e 37ab         call    DOLIT
003eec ef0a              fdw     ABORT
003eed 940e 316b         call    COMMA
003eef d95d              rcall   XDOES
                 DEFER_DOES:
003ef0 940e 30fe         call    DODOES
003ef2 940c 30c1         jmp     FEXECUTE
                 
003ef4 fdcc              fdw     DEFER_L
                 IS_L:
003ef5 69c2
003ef6 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003ef7 940e 37c7         call    TICK
003ef9 940e 333d         call    TWOPLUS
003efb 940e 333d         call    TWOPLUS
003efd df6b              rcall   FETCH
003efe d9cc              rcall   STATE_
003eff 940e 33e1         call    ZEROSENSE
003f01 f029              breq    IS1
003f02 def0              rcall   LITERAL
003f03 940e 310e         call    DOCOMMAXT
003f05 fc42              fdw     STORE
003f06 c001              rjmp    IS2
                 IS1:
003f07 df19              rcall   STORE
                 IS2:
003f08 9508              ret
                 
003f09 fdea              fdw     IS_L
                 TO_L:
003f0a 74c2
003f0b 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003f0c 940c 3ef7         jmp     IS
                 
003f0e fe14              fdw     TO_L
                 TURNKEY_L:
003f0f 7487
003f10 7275
003f11 6b6e
003f12 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003f13 940e 3ee1         call    VALUE_DOES      ; Must be call for IS to work.
003f15 01d7              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003f16 fe1e              fdw     TURNKEY_L
                 PAUSE_L:
003f17 7085
003f18 7561
003f19 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003f1a dc89              rcall   IDLE_LOAD
                 .endif
003f1b b71f              in_     t1, SREG
003f1c 94f8              cli
003f1d 93df              push    yh        ; SP
003f1e 93cf              push    yl
003f1f 939f              push    tosh      ; TOS
003f20 938f              push    tosl
003f21 935f              push    ph        ; P
003f22 934f              push    pl
003f23 01f1              movw    zl, upl
003f24 b70e              in      t0, sph
003f25 9302              st      -z, t0
003f26 b70d              in      t0, spl
003f27 9302              st      -z, t0
003f28 91b2              ld      xh, -z     ; UP
003f29 91a2              ld      xl, -z
003f2a 011d              movw    upl, xl
003f2b 910e              ld      t0, -x
003f2c bf0e              out     sph, t0
003f2d 910e              ld      t0, -x
003f2e bf0d              out     spl, t0
003f2f 914f              pop     pl
003f30 915f              pop     ph
003f31 918f              pop     tosl
003f32 919f              pop     tosh
003f33 91cf              pop     yl
003f34 91df              pop     yh
003f35 bf1f              out_    SREG, t1
003f36 9508              ret
                 
                 
003f37 df9c              fdw     OPERATOR_L
                 ICOMMA_L:
003f38 6982
003f39 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f3a 940e 37e0         call    IHERE
003f3c dee4              rcall   STORE
003f3d 940e 317c         call    CELL
003f3f 940c 399d         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f41 fe70              fdw     ICOMMA_L
                 ICCOMMA_L:
003f42 6983
003f43 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f44 940e 37e0         call    IHERE
003f46 df6f              rcall   CSTORE
003f47 940e 3224         call    ONE
003f49 940c 399d         jmp     IALLOT
                 
                 L_DOTBASE:
003f4b 2081              .db      NFA|1," "
                 DOTBASE:
003f4c 940e 34f4         call    BASE
003f4e df1a              rcall   FETCH
003f4f 3180              cpi     tosl, 0x10
003f50 f411              brne    DOTBASE1
003f51 e284              ldi     tosl,'$'
003f52 c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f53 308a              cpi     tosl, 0xa
003f54 f411              brne    DOTBASE2
003f55 e283              ldi     tosl, '#'
003f56 c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f57 3082              cpi     tosl, 0x2
003f58 f411              brne    DOTBASE3
003f59 e285              ldi     tosl, '%'
003f5a c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f5b e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f5c 9508              ret
                 
                 MEMQADDR_N:
003f5d e27c              fdw     ROM_N
003f5e e28a              fdw     EROM_N
003f5f e29a              fdw     FRAM_N
                 ;*******************************************************
                 umstar0:
003f60 920f              push t2
003f61 921f              push t3
003f62 9109              ld  t0, Y+
003f63 9119              ld  t1, Y+
003f64 9f80              mul tosl,t0
003f65 01d0              movw t4, r0 ; r0=t2, r1=t3
003f66 27ee              clr t6
003f67 27ff              clr t7
003f68 9f90              mul tosh, t0
003f69 0db0              add t5, r0
003f6a 1de1              adc t6, r1
003f6b 1df5              adc t7, zero
003f6c 9f81              mul tosl, t1
003f6d 0db0              add t5, r0
003f6e 1de1              adc t6, r1
003f6f 1df5              adc t7, zero
003f70 9f91              mul tosh, t1
003f71 0de0              add t6, r0
003f72 1df1              adc t7, r1
003f73 93ba              st -Y, t5
003f74 93aa              st -Y, t4
003f75 01cf              movw tosl, t6
003f76 901f              pop t3
003f77 900f              pop t2
003f78 9508              ret
                 
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
003f79 0000      STARTV: .dw      0
003f7a 8000      DPC:    .dw      OFLASH
003f7b 090c      DPE:    .dw      ehere
003f7c 02dd      DPD:    .dw      dpdata
003f7d f6a8      LW:     fdw      lastword
003f7e ee24      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  16 r1 :  17 r2 :   5 r3 :   1 r4 :   0 r5 :  16 r6 :   4 r7 :   6 
r8 :   4 r9 :   4 r10:   6 r11:   6 r12:   0 r13:   0 r14:   2 r15:   2 
r16: 128 r17:  55 r18:   3 r19:   2 r20:  14 r21:   7 r22:  34 r23:  12 
r24: 228 r25: 180 r26:  57 r27:  41 r28:   9 r29:   5 r30:  71 r31:  47 
x  :  17 y  : 171 z  :  32 
Registers used: 32 out of 35 (91.4%)

ATmega328P instruction use summary:
.lds  :   0 .sts  :   0 adc   :  16 add   :  18 adiw  :  12 and   :   4 
andi  :  22 asr   :   2 bclr  :   4 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  21 brcs  :   1 break :   0 breq  :  43 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   2 brmi  :   5 
brne  :  36 brpl  :   2 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  97 cbi   :   3 cbr   :  19 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :  17 cls   :   0 
clt   :   1 clv   :   0 clz   :   1 com   :   7 cp    :   4 cpc   :   2 
cpi   :  27 cpse  :   6 dec   :   4 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  14 in    :  18 inc   :   6 jmp   : 162 
ld    : 128 ldd   :   2 ldi   :  62 lds   :  17 lpm   :   7 lsl   :  11 
lsr   :   2 mov   :  19 movw  :  39 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   6 ori   :   7 out   :  31 pop   :  84 
push  :  28 rcall : 964 ret   : 131 reti  :   1 rjmp  :  92 rol   :  14 
ror   :  18 sbc   :   8 sbci  :   3 sbi   :  11 sbic  :   5 sbis  :   0 
sbiw  :  13 sbr   :  16 sbrc  :  12 sbrs  :  17 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   7 ses   :   0 set   :   1 sev   :   0 
sez   :   1 sleep :   1 spm   :   2 st    :  72 std   :   3 sts   :  18 
sub   :   2 subi  :  20 swap  :   2 tst   :   2 wdr   :   0 
Instructions used: 75 out of 113 (66.4%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007efe   5528   2462   7990   32768  24.4%
[.dseg] 0x000100 0x0002df      0    479    479    2048  23.4%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 8 warnings
