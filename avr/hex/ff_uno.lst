
AVRASM ver. 2.1.30  F:\avr\src\ff-atmega.asm Sat Jan 10 13:45:54 2015

F:\avr\src\ff-atmega.asm(34): Including file 'F:\avr\src\config.inc'
F:\avr\src\config.inc(8): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m328pdef.inc'
F:\avr\src\ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
F:\avr\src\ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
F:\avr\src\ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
F:\avr\src\ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          10.01.2015                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2014  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 ;.include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 .include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega328P.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328Pdef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328P
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328P
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328PDEF_INC_
                 #define _M328PDEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328P
                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x0f
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 .equ	BODSE	= 5	; BOD Sleep Enable
                 .equ	BODS	= 6	; BOD Sleep
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328PDEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturbs the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program.
                 .equ BAUDRATE0 = 9600               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 1
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 96          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 96                   ; 86 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #define partstring "ATmega328P"
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "10.01.2015"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def il = r18         ; FOR..LOOP INDEX variable
                   .def ih = r19
                   .def pl = r20         ; P Register
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*256/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fBUSY=     7   ; 1 = busy
                 .equ fIDLE=     6   ; 1 = busy
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)              ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 ;.equ uaddsize=     0          ; No additional user variables 
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001d7           dpSTART:    .byte 2
0001d9           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001db           dpEEPROM:   .byte 2
0001dd           dpRAM:      .byte 2
0001df           dpLATEST:   .byte 2
                 
0001e1           areg:       .byte 2 ; A register data
0001e3           iaddrl:     .byte 1
0001e4           iaddrh:     .byte 1
0001e5           load_acc:   .byte 3 ; Load measurement accumulator
0001e8           load_res:   .byte 3 ; Load result
                 ; load:       .byte 1 ; Cpu load in percent
0001eb           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0001ec           state:      .byte 1 ; Compilation state
0001ed           uvars:      .byte   (-us0)
000209           up0:        .byte   2
00020b           urbuf:      .byte   ursize
00026b           usbuf:      .byte   ussize
0002ab           utibbuf:    .byte   utibsize
00030b           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
002f80 94e8              clt
002f81 2388              tst  tosl
002f82 f429              brne umslashmodstart
002f83 2399              tst  tosh
002f84 f419              brne umslashmodstart
002f85 9468              set  ; Set T flag
002f86 940c 3d58         jmp  WARM_
                 umslashmodstart:
002f88 920f              push t2
002f89 921f              push t3
002f8a 01dc              movw t4, tosl
                 
002f8b 9019              ld t3, Y+
002f8c 91e9              ld t6, Y+
                   
002f8d 9189              ld tosl, Y+
002f8e 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
002f8f e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
002f90 27ff              clr t7
002f91 0f88              lsl tosl
002f92 1f99              rol tosh
002f93 1c11              rol t3
002f94 1fee              rol t6
002f95 1fff              rol t7
                 
                         ; try subtracting divisor
002f96 161a              cp  t3, t4
002f97 07eb              cpc t6, t5
002f98 05f5              cpc t7,zero
                 
002f99 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
002f9a 9583              inc tosl
002f9b 1a1a              sub t3, t4
002f9c 0beb              sbc t6, t5
                 
                 umslashmod2:
002f9d 950a              dec  t0
002f9e f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
002f9f 93ea              st -Y,t6
002fa0 921a              st -Y,t3
002fa1 901f              pop t3
002fa2 900f              pop t2
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
002fa3 9508              ret
                 ; *******************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fa4 0000              .dw     0
                 EXIT_L:
002fa5 6584
002fa6 6978
002fa7 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fa8 910f              pop     t0
002fa9 910f              pop     t0
002faa 9508              ret
                 
                 ; idle
002fab df4a              fdw(EXIT_L)
                 IDLE_L:
002fac 6984
002fad 6c64
002fae 0065              .db     NFA|4,"idle",0
                 IDLE:
002faf 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fb0 9508              ret
                         
                 ; busy
002fb1 df58              fdw(IDLE_L)
                 BUSY_L:
002fb2 6284
002fb3 7375
002fb4 0079              .db     NFA|4,"busy",0
                 BUSY:
002fb5 6470              sbr     FLAGS2, (1<<fIDLE)
002fb6 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fb7 febc              fdw     ICCOMMA_L
                 MSET_L:
002fb8 6d84
002fb9 6573
002fba 0074              .db     NFA|4,"mset",0
                 MSET:
002fbb 01fc              movw    zl, tosl
002fbc 9189
002fbd 9199              poptos
002fbe 8100              ld      t0, z
002fbf 2b08              or      t0, tosl
002fc0 8300              st      z, t0
002fc1 9189
002fc2 9199              poptos
002fc3 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002fc4 df70              fdw     MSET_L
                 MCLR_L:
002fc5 6d84
002fc6 6c63
002fc7 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002fc8 01fc              movw    zl, tosl
002fc9 9189
002fca 9199              poptos
002fcb 8100              ld      t0, z
002fcc 9580              com     tosl
002fcd 2308              and     t0, tosl
002fce 8300              st      z, t0
002fcf 9189
002fd0 9199              poptos
002fd1 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
002fd2 df8a              fdw     MCLR_L
                 LSHIFT_L:
002fd3 6c86
002fd4 6873
002fd5 6669
002fd6 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
002fd7 01fc              movw    zl, tosl
002fd8 9189
002fd9 9199              poptos
                 LSHIFT1:
002fda 9731              sbiw    zl, 1
002fdb f01a              brmi    LSHIFT2
002fdc 0f88              lsl     tosl
002fdd 1f99              rol     tosh
002fde cffb              rjmp    LSHIFT1
                 LSHIFT2:
002fdf 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
002fe0 dfa6              fdw     LSHIFT_L
                 RSHIFT_L:
002fe1 7286
002fe2 6873
002fe3 6669
002fe4 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
002fe5 01fc              movw    zl, tosl
002fe6 9189
002fe7 9199              poptos
                 RSHIFT1:
002fe8 9731              sbiw    zl, 1
002fe9 f01a              brmi    RSHIFT2
002fea 9596              lsr     tosh
002feb 9587              ror     tosl
002fec cffb              rjmp    RSHIFT1
                 RSHIFT2:
002fed 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
002fee d555              rcall   CFETCHPP
002fef d2a7              rcall   ROT
002ff0 d553              rcall   CFETCHPP
002ff1 940c 3297         jmp     ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
002ff3 dfc2              fdw     RSHIFT_L
                 NEQUAL_L:
002ff4 6e82
002ff5 003d              .db     NFA|2,"n=",0
                 NEQUAL:
002ff6 dff7              rcall   NEQUALSFETCH
002ff7 708f              andi    tosl, 0xf
002ff8 d346              rcall   EQUAL
002ff9 d3b5              rcall   ZEROSENSE
002ffa f0b1              breq    NEQUAL5
002ffb d30a              rcall   ONEMINUS
002ffc d547              rcall   CFETCHPP
002ffd d2a0              rcall   TOR
002ffe c00c              rjmp    NEQUAL4
                 NEQUAL2:
002fff dfee              rcall   NEQUALSFETCH
003000 d337              rcall   NOTEQUAL
003001 d3ad              rcall   ZEROSENSE
003002 f021              breq    NEQUAL3
003003 d745              rcall   TRUE_
003004 940e 3a5c         call    LEAVE
003006 c004              rjmp    NEQUAL4
                 NEQUAL3:
003007 d2aa              rcall   RFETCH
003008 d3a6              rcall   ZEROSENSE
003009 f409              brne    NEQUAL4
00300a d735              rcall   FALSE_
                 NEQUAL4:
00300b 940e 3a4c         call    XNEXT
00300d f788              brcc    NEQUAL2
00300e 911f              pop     t1
00300f 910f              pop     t0
003010 c001              rjmp    NEQUAL6
                 NEQUAL5:
003011 d737              rcall   TRUE_
                 NEQUAL6:
003012 d3dd              rcall   NIP
003013 940c 33f0         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
003015 dfe8              fdw     NEQUAL_L
                 SKIP_L:
003016 7384
003017 696b
003018 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003019 d284              rcall   TOR
                 SKIP0:
00301a d39a              rcall   DUPZEROSENSE
00301b f089              breq    SKIP2
                 
00301c d272              rcall   OVER
00301d d3f4              rcall   CFETCH_A
                 
00301e d788              rcall   DUP
00301f d77e              rcall   DOLIT
003020 0009              .dw     TAB_
003021 d31d              rcall   EQUAL
003022 d38c              rcall   ZEROSENSE
003023 f429              brne    SKIP05    
003024 d28d              rcall   RFETCH
003025 d319              rcall   EQUAL
003026 d388              rcall   ZEROSENSE
003027 f029              breq    SKIP2
003028 c001                      rjmp    SKIP1
                 SKIP05:
003029 d254              rcall   DROP
                 SKIP1:
00302a d1c7              rcall   ONE
00302b d4c3              rcall   SLASHSTRING
00302c cfed              rjmp    SKIP0
                 SKIP2:
00302d 910f              pop     t0
00302e 910f              pop     t0
00302f 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
003030 e02c              fdw     SKIP_L
                 SCAN_L:
003031 7384
003032 6163
003033 006e              .db     NFA|4,"scan",0
                 SCAN:
003034 d330              rcall   STORE_P_TO_R
003035 d268              rcall   TOR
003036 c010              rjmp    SCAN3
                 SCAN1:
003037 d50c              rcall   CFETCHPP
003038 d76e              rcall   DUP
003039 d764              rcall   DOLIT
00303a 0009              .dw     TAB_
00303b d303              rcall   EQUAL
00303c d372              rcall   ZEROSENSE
00303d f011              breq    SCAN2
00303e d23f              rcall   DROP
00303f c005              rjmp    SCAN25
                 SCAN2:
003040 940e 3b21         call    FETCH_P
003042 d2fc              rcall   EQUAL
003043 d36b              rcall   ZEROSENSE
003044 f011              breq    SCAN3
                 SCAN25:
003045 d2c0              rcall   ONEMINUS
003046 c003              rjmp    SCAN4
                 SCAN3:
003047 940e 3a4c         call    XNEXT
003049 f768              brcc    SCAN1
                 SCAN4:
00304a d25d              rcall   RFROM
00304b d2b5              rcall   ONEPLUS
00304c d323              rcall   R_TO_P
00304d 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
00304e e062              fdw     SCAN_L
                 MTST_L:
00304f 6d84
003050 7374
003051 0074              .db     NFA|4,"mtst",0
                 MTST:
003052 940e 3ea3         call    CFETCH
003054 940c 32d9         jmp     AND_
                 
003056 e09e              fdw     MTST_L
                 FCY_L:
003057 4683
003058 7963              .db     NFA|3,"Fcy"
003059 d06a              rcall   DOCREATE
00305a 3e80              .dw     FREQ_OSC / 1000
                 
                 ;*******************************************************
                 ; Assembler
                 ;*******************************************************
                 ; FIXME
                 ;*******************************************************
                         
                 
                 ;;; Check parameter stack pointer
00305b 7383
00305c 3f70              .db     NFA|3,"sp?"
                 check_sp:
00305d d089              rcall   SPFETCH
00305e 940e 38d7         call    R0_
003060 d67d              rcall   FETCH_A
003061 940e 38d2         call    S0
003063 d67a              rcall   FETCH_A
003064 d29c              rcall   ONEPLUS
003065 d2c8              rcall   WITHIN
003066 d1df              rcall   XSQUOTE
003067 5303
003068 3f50              .db     3,"SP?"
003069 d721              rcall   QABORT
00306a 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
00306b e0ae              fdw     FCY_L
                 EMIT_L:
00306c 6584
00306d 696d
00306e 0074              .db     NFA|4,"emit",0
                 EMIT:
00306f d32f              rcall   UEMIT_
003070 940c 308f         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003072 e0d8              fdw     EMIT_L
                 KEY_L:
003073 6b83
003074 7965              .db     NFA|3,"key"
                 KEY:
003075 d32f              rcall   UKEY_
003076 940c 308f         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003078 e0e6              fdw     KEY_L
                 KEYQ_L:
003079 6b84
00307a 7965
00307b 003f              .db     NFA|4,"key?",0
                 KEYQ:
00307c d32e              rcall   UKEYQ_
00307d 940c 308f         jmp     FEXECUTE
                 
00307f e0f2              fdw     KEYQ_L
                 EXECUTE_L:
003080 6587
003081 6578
003082 7563
003083 6574              .db     NFA|7,"execute"
                 EXECUTE:
003084 01fc              movw    zl, tosl
003085 58f0              sub_pflash_z
003086 9189
003087 9199              poptos
003088 9488              rampv_to_c
003089 95f7              ror     zh
00308a 95e7              ror     zl
00308b 9409              mijmp
                 
00308c e100              fdw     EXECUTE_L
                 FEXECUTE_L:
00308d 4083
00308e 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
00308f d64e              rcall   FETCH_A
003090 940c 3084         jmp     EXECUTE
                 
003092 e11a              fdw     FEXECUTE_L
                 VARIABLE_L:
003093 7688
003094 7261
003095 6169
003096 6c62
003097 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
003098 d09b              rcall   HERE
003099 d0b0              rcall   CELL
00309a d1dc              rcall   ALLOT
00309b 940c 30af         jmp     CONSTANT_
                 
00309d e126              fdw     VARIABLE_L
                 TWOVARIABLE_L:
00309e 3289
00309f 6176
0030a0 6972
0030a1 6261
0030a2 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
0030a3 d090              rcall   HERE
0030a4 d6f9              rcall   DOLIT
0030a5 0004              .dw     0x4
0030a6 d1d0              rcall   ALLOT
0030a7 940c 30af         jmp     CONSTANT_
                 
0030a9 e13c              fdw     TWOVARIABLE_L
                 CONSTANT_L:
0030aa 6388
0030ab 6e6f
0030ac 7473
0030ad 6e61
0030ae 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
0030af d7b9              rcall   COLON
0030b0 940e 3e05         call    LITERAL
0030b2 940c 3877         jmp     SEMICOLON
                 
0030b4 e154              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030b5 3289
0030b6 6f63
0030b7 736e
0030b8 6174
0030b9 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030ba d1ca              rcall   SWOP
0030bb d7ad              rcall   COLON
0030bc 940e 3e05         call    LITERAL
0030be 940e 3e05         call    LITERAL
0030c0 940c 3877         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030c2 2883
0030c3 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030c4 91ff              pop     zh
0030c5 91ef              pop     zl
0030c6 d00c              rcall   FETCHLIT
                         m_pop_zh
0030c7 91ff              pop     zh
0030c8 91ef              pop     zl
0030c9 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030ca 2883
0030cb 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030cc 91bf              pop     xh
0030cd 91af              pop     xl
                         m_pop_zh
0030ce 91ff              pop     zh
0030cf 91ef              pop     zl
0030d0 d002              rcall   FETCHLIT
0030d1 01fd              movw    z, x
0030d2 9409              mijmp    ; (z)
                 FETCHLIT:
0030d3 939a
0030d4 938a              pushtos
0030d5 0fee              lsl     zl
0030d6 1fff              rol     zh
0030d7 9185              lpm_    tosl, z+
0030d8 9195              lpm_    tosh, z+
0030d9 9508              ret
                 
0030da 2883
0030db 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
0030dc 91ff              pop     zh
0030dd 91ef              pop     zl
0030de dff4              rcall   FETCHLIT
0030df 95f7              ror     zh
0030e0 95e7              ror     zl
0030e1 93ef              push    zl
0030e2 93ff              push    zh
                         m_push_t0
0030e3 c099              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
0030e4 e16a              fdw     TWOCONSTANT_L
                 SPFETCH_L:
0030e5 7383
0030e6 4070              .db     NFA|3,"sp@"
                 SPFETCH:
0030e7 01fe              movw    z, y
0030e8 939a
0030e9 938a              pushtos
0030ea 01cf              movw    tosl, z
0030eb 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
0030ec 7383
0030ed 2170              .db     NFA|3,"sp!"
                 SPSTORE:
0030ee 01ec              movw    y, tosl
0030ef 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
0030f0 7283
0030f1 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
0030f2 91bf              pop     xh
0030f3 91af              pop     xl
0030f4 d7e2              rcall   R0_
0030f5 d5e8              rcall   FETCH_A
0030f6 bf8d              out     spl, tosl
0030f7 bf9e              out     sph, tosh
0030f8 9189
0030f9 9199              poptos
0030fa 01fd              movw    zl, xl
0030fb 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
0030fc e1ca              fdw     SPFETCH_L
                 RPFETCH_L:
0030fd 72b3
0030fe 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
0030ff 939a
003100 938a              pushtos
003101 b78d              in      tosl, spl
003102 b79e              in      tosh, sph
003103 9508              ret
                 
                 ;   ><  Swap bytes        
003104 e1fa              fdw     RPFETCH_L
                 SWAPB_L:
003105 3ea2
003106 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
003107 2f08              mov     t0, tosl
003108 2f89              mov     tosl, tosh
003109 2f90              mov     tosh, t0
00310a 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
00310b e20a              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
00310c 6685
00310d 616c
00310e 6873              .db     NFA|5,"flash"
                 ROM_:
00310f 9250 01eb         sts     cse, zero
003111 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
003112 e218              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003113 6586
003114 7065
003115 6f72
003116 006d              .db     NFA|6,"eeprom",0
                 EROM:
003117 9270 01eb         sts     cse, r_two
003119 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
00311a e226              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
00311b 7283
00311c 6d61              .db     NFA|3,"ram"
                 FRAM:
00311d e004              ldi     t0, 4
00311e 9300 01eb         sts     cse, t0
003120 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
003121 e236              fdw     RAM_L
                 DP_L:
003122 6482
003123 0070              .db     NFA|2,"dp",0
                 DP:
003124 d717              rcall   IDP
003125 d004              rcall   CSE_
003126 940c 32c3         jmp     PLUS
                 
                 
                 ;;; 
003128 6383
003129 6573              .db     NFA|3,"cse"
                 CSE_:
00312a 939a
00312b 938a              pushtos
00312c 9180 01eb         lds     tosl, cse
00312e 2799              clr     tosh
00312f 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
003130 e244              fdw     DP_L
                 HERE_L:
003131 6884
003132 7265
003133 0065              .db     NFA|4,"here",0
                 HERE:
003134 dfef              rcall   DP
003135 940c 3e79         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003137 e262              fdw     HERE_L
                 COMMA_L:
003138 2c81              .db     NFA|1,","
                 COMMA:
003139 dffa              rcall   HERE
00313a d417              rcall   STORE_A
00313b d00e              rcall   CELL
00313c 940c 3277         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
00313e e270              fdw     COMMA_L 
                 CCOMMA_L:
00313f 6382
003140 002c              .db     NFA|2,"c,",0
                 CCOMMA:
003141 dff2              rcall   HERE
003142 d2d3              rcall   CSTORE_A
003143 d0ae              rcall   ONE
003144 940c 3277         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003146 e27e              fdw     CCOMMA_L
                 CELL_L:
003147 6384
003148 6c65
003149 006c              .db     NFA|4,"cell",0
                 CELL:
00314a 939a
00314b 938a              pushtos
00314c e082              ldi     tosl, 2
00314d e090              ldi     tosh, 0
00314e 9508              ret
                 
                 ; ALIGN    --                         align DP
00314f e28e              fdw     CELL_L
                 ALIGN_L:
003150 6185
003151 696c
003152 6e67              .db     NFA|5,"align"
                 ALIGN:
003153 dfe0              rcall   HERE
003154 d008              rcall   ALIGNED
003155 dfce              rcall   DP
003156 940c 3e31         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
003158 e2a0              fdw     ALIGN_L
                 ALIGNED_L:
003159 6187
00315a 696c
00315b 6e67
00315c 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00315d 9601              adiw    tosl, 1
00315e d63f              rcall   DOLIT
00315f fffe              .dw     0xfffe
003160 940c 32d9         jmp     AND_
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
003162 e2b2              fdw     ALIGNED_L
                 CELLPLUS_L:
003163 63a5
003164 6c65
003165 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003166 9602              adiw    tosl, 2
003167 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
003168 e2c6              fdw     CELLPLUS_L
                 CELLS_L:
003169 63a5
00316a 6c65
00316b 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
00316c 0f88              lsl     tosl
00316d 1f99              rol     tosh
00316e 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
00316f e2d2              fdw     CELLS_L
                 CHARPLUS_L:
003170 63a5
003171 6168
003172 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
003173 9601              adiw    tosl, 1
003174 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
003175 e2e0              fdw     CHARPLUS_L
                 CHARS_L:
003176 63a5
003177 6168
003178 7372              .db     NFA|INLINE|5,"chars"
003179 9508      CHARS:  ret
                 
00317a e2ec              fdw     CHARS_L
                 COMMAXT_L:
00317b 6383
00317c 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
00317d d629              rcall   DUP
00317e d656              rcall   IHERE
00317f d150              rcall   MINUS
003180 d13d              rcall   ABS_ 
003181 d61c              rcall   DOLIT
003182 0ff0              .dw     0xff0
003183 d1c5              rcall   GREATER
003184 d22a              rcall   ZEROSENSE
003185 f059              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
003186 d617              rcall   DOLIT
                 .ifdef EIND
                 .else
003187 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
003188 940e 3f56         call    ICOMMA
00318a 5890              sub_pflash_tos
00318b 9488              rampv_to_c
00318c 9597              ror     tosh
00318d 9587              ror     tosl
00318e 940e 3f56         call    ICOMMA
003190 c008              rjmp    STORECF2
                 STORECF1:
003191 d643              rcall   IHERE
003192 d13d              rcall   MINUS
003193 d720              rcall   TWOMINUS
003194 d187              rcall   TWOSLASH
                         ;rcall   RCALL_
003195 709f              andi    tosh, 0x0f
003196 6d90              ori     tosh, 0xd0
003197 940e 3f56         call    ICOMMA
                 STORECF2:
003199 9508              ret
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
00319a 2186
00319b 6f63
00319c 6f6c
00319d 006e              .db     NFA|6,"!colon",0
                 STORCOLON:
00319e d5ff              rcall   DOLIT
00319f fffa              .dw     0xfffa         ;  -6
0031a0 940c 397b         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
0031a2 e2f6              fdw     COMMAXT_L
                 TWOFETCH_L:
0031a3 3282
0031a4 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
0031a5 d601              rcall   DUP
0031a6 d537              rcall   FETCH_A
0031a7 d0dd              rcall   SWOP
0031a8 dfbd              rcall   CELLPLUS
0031a9 940c 36de         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
0031ab e346              fdw     TWOFETCH_L
                 TWOSTORE_L:
0031ac 3282
0031ad 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
0031ae d0d6              rcall   SWOP
0031af d0df              rcall   OVER
0031b0 dfb5              rcall   CELLPLUS
0031b1 d3a0              rcall   STORE_A
0031b2 940c 3e31         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031b4 e358              fdw     TWOSTORE_L
                 TWODROP_L:
0031b5 3285
0031b6 7264
0031b7 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031b8 d0c5              rcall   DROP
0031b9 940c 327e         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031bb e36a              fdw     TWODROP_L
                 TWODUP_L:
0031bc 3284
0031bd 7564
0031be 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031bf d0cf              rcall   OVER
0031c0 940c 328f         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031c2 e378              fdw     TWODUP_L
                 TWOSWAP_L:
0031c3 3285
0031c4 7773
0031c5 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031c6 d0d0              rcall   ROT
0031c7 d0d6              rcall   TOR
0031c8 d0ce              rcall   ROT
0031c9 d0de              rcall   RFROM
0031ca 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031cb e386              fdw     TWOSWAP_L
                 SPACE_L:
0031cc 7385
0031cd 6170
0031ce 6563              .db     NFA|5,"space"
                 SPACE_:  
0031cf d6e9              rcall   BL
0031d0 940c 306f         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
0031d2 e398              fdw     SPACE_L
                 SPACES_L:
0031d3 7386
0031d4 6170
0031d5 6563
0031d6 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
0031d7 d1dd              rcall   DUPZEROSENSE
0031d8 f019              breq    SPCS2
0031d9 dff5              rcall   SPACE_
0031da d12b              rcall   ONEMINUS
0031db cffb              rjmp    SPCS1
0031dc 940c 327e SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
0031de e3a6              fdw     SPACES_L
                 UMIN_L:
0031df 7584
0031e0 696d
0031e1 006e              .db     NFA|4,"umin",0
                 UMIN:
0031e2 dfdc              rcall   TWODUP
0031e3 d173              rcall   UGREATER
0031e4 c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
0031e5 e3be              fdw     UMIN_L
                 UMAX_L:
0031e6 7584
0031e7 616d
0031e8 0078              .db     NFA|4,"umax",0
                 UMAX:
0031e9 dfd5              rcall   TWODUP
0031ea d164              rcall   ULESS
                 MINMAX:
0031eb d1c3              rcall   ZEROSENSE
0031ec f009              breq    UMAX1
0031ed d097              rcall   SWOP
0031ee 940c 327e UMAX1:  jmp     DROP
                 
0031f0 e3cc              fdw     UMAX_L
                 ONE_L:
0031f1 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
0031f2 939a
0031f3 938a              pushtos
0031f4 e081              ldi     tosl, 1
0031f5 e090              ldi     tosh, 0
0031f6 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
0031f7 e3e2              fdw     ONE_L
                 ACCEPT_L:
0031f8 6186
0031f9 6363
0031fa 7065
0031fb 0074              .db     NFA|6,"accept",0
                 ACCEPT:
0031fc d092              rcall   OVER
0031fd d0c5              rcall   PLUS
0031fe d090              rcall   OVER
                 ACC1:
0031ff de75              rcall   KEY
                 
003200 308d              cpi     tosl, CR_
003201 f429              brne    ACC_LF
                         
003202 d546              rcall   TRUE_
003203 d02f              rcall   FCR
003204 d211              rcall   CSTORE_A
003205 d078              rcall   DROP
003206 c026              rjmp    ACC6
                 ACC_LF:
003207 308a              cpi     tosl, LF_
003208 f449              brne    ACC2
003209 d074              rcall   DROP
                 
00320a d028              rcall   FCR
00320b d206              rcall   CFETCH_A
00320c d1a2              rcall   ZEROSENSE
00320d f0f9              breq    ACC6
00320e d531              rcall   FALSE_
00320f d023              rcall   FCR
003210 d205              rcall   CSTORE_A
003211 cfed              rjmp    ACC1
                 ACC2:
003212 d52d              rcall   FALSE_
003213 d01f              rcall   FCR
003214 d201              rcall   CSTORE_A
003215 d591              rcall   DUP
003216 de58              rcall   EMIT
003217 d58f              rcall   DUP
003218 d585              rcall   DOLIT
003219 0008              .dw     BS_
00321a d124              rcall   EQUAL
00321b d193              rcall   ZEROSENSE
00321c f039              breq    ACC3
00321d d060              rcall   DROP
00321e d0e7              rcall   ONEMINUS
00321f d07e              rcall   TOR
003220 d06e              rcall   OVER
003221 d086              rcall   RFROM
003222 dfc6              rcall   UMAX
003223 cfdb              rjmp    ACC1
                 ACC3:
003224 d06a              rcall   OVER
003225 d1f0              rcall   CSTORE_A
003226 d0da              rcall   ONEPLUS
003227 d067              rcall   OVER
003228 dfb9              rcall   UMIN
003229 df95              rcall   TWODUP
00322a d10d              rcall   NOTEQUAL
00322b d183              rcall   ZEROSENSE
00322c f691              brne     ACC1
                 ACC6:
00322d d1c2              rcall   NIP
00322e d056              rcall   SWOP
00322f 940c 32d0         jmp     MINUS
                 
003231 6683
003232 7263              .db     NFA|3,"fcr"
                 FCR:
003233 d2a3              rcall   DOUSER
003234 fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
003235 e3f0              fdw      ACCEPT_L
                 TYPE_L:
003236 7484
003237 7079
003238 0065              .db     NFA|4,"type",0
                 TYPE:
003239 d064              rcall   TOR
00323a c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
00323b d308              rcall   CFETCHPP
00323c de32              rcall   EMIT
                 TYPE2:
00323d 940e 3a4c         call    XNEXT
00323f f7d8              brcc    TYPE1
003240 911f              pop     t1
003241 910f              pop     t0
003242 940c 327e         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
003244 2883
003245 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
003246 d06b              rcall   RFETCH
003247 0f88              lsl     tosl
003248 1f99              rol     tosh
003249 5890              add_pflash_tos
00324a d2f9              rcall   CFETCHPP
00324b d55b              rcall   DUP
00324c d0b4              rcall   ONEPLUS
00324d df0f              rcall   ALIGNED
00324e 9596              lsr     tosh
00324f 9587              ror     tosl
003250 d057              rcall   RFROM
003251 d071              rcall   PLUS
003252 01fc              movw    zl, tosl
003253 9189
003254 9199              poptos
003255 9409              mijmp
                 
003256 e46c              fdw     TYPE_L
                 SQUOTE_L:
003257 73d2
003258 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
003259 de82              rcall   DOCOMMAXT
00325a e48c              fdw     XSQUOTE
00325b deb3              rcall   ROM_
00325c d005              rcall   CQUOTE
00325d 940c 311d         jmp     FRAM
                 
00325f e4ae              fdw     SQUOTE_L
                 CQUOTE_L:
003260 2c82
003261 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
003262 d53b              rcall   DOLIT
003263 0022              .dw     0x22
003264 d29d              rcall   PARSE
003265 dece              rcall   HERE
003266 d028              rcall   OVER
003267 d099              rcall   ONEPLUS
003268 def4              rcall   ALIGNED
003269 d00d              rcall   ALLOT
00326a 940c 353b         jmp     PLACE
                 
                 
00326c e4c0              fdw     CQUOTE_L
                 DOTQUOTE_L:
00326d 2ed2
00326e 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
00326f dfe9              rcall   SQUOTE
003270 de6b              rcall   DOCOMMAXT
003271 e472              fdw     TYPE
003272 9508              ret
                 
003273 e4da              fdw     DOTQUOTE_L
                 ALLOT_L:
003274 6185
003275 6c6c
003276 746f              .db     NFA|5,"allot"
                 ALLOT:
003277 deac              rcall   DP
003278 940c 3322         jmp     PLUSSTORE
                 
00327a e4e8              fdw     ALLOT_L
                 DROP_L:
00327b 64a4
00327c 6f72
00327d 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
00327e 9189
00327f 9199              poptos
003280 9508              ret
                 
003281 e4f6              fdw     DROP_L
                 SWOP_L:
003282 7384
003283 6177
003284 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
003285 9109              ld      t0, y+
003286 9119              ld      t1, y+
003287 939a
003288 938a              pushtos
003289 01c8              movw    tosl, t0
00328a 9508              ret
                 
00328b e504              fdw     SWOP_L
                 OVER_L:
00328c 6f84
00328d 6576
00328e 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
00328f 939a
003290 938a              pushtos
003291 818a              ldd     tosl, y+2
003292 819b              ldd     tosh, y+3
003293 9508              ret
                 
003294 e518              fdw     OVER_L
                 ROT_L:
003295 7283
003296 746f              .db     NFA|3, "rot"
                 ROT:
003297 d006              rcall   TOR
003298 dfec              rcall   SWOP
003299 d00e              rcall   RFROM
00329a cfea              rjmp    SWOP
                 
00329b e52a              fdw     ROT_L
                 TOR_L:
00329c 3e92
00329d 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
00329e 91ff              pop     zh
00329f 91ef              pop     zl
0032a0 938f              push    tosl
0032a1 939f              push    tosh
0032a2 9189
0032a3 9199              poptos
0032a4 9409              mijmp
                 
0032a5 e538              fdw     TOR_L
                 RFROM_L:
0032a6 7292
0032a7 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
0032a8 91ff              pop     zh
0032a9 91ef              pop     zl
0032aa 939a
0032ab 938a              pushtos
0032ac 919f              pop     tosh
0032ad 918f              pop     tosl
0032ae 9409              mijmp
                 
0032af e54c              fdw     RFROM_L
                 RFETCH_L:
0032b0 7292
0032b1 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
0032b2 91ff              pop     zh
0032b3 91ef              pop     zl
0032b4 939a
0032b5 938a              pushtos
0032b6 919f              pop     tosh
0032b7 918f              pop     tosl
0032b8 938f              push    tosl
0032b9 939f              push    tosh
0032ba 9409              mijmp
                 
                 
                 ;   ABS     n   --- n1      absolute value of n
0032bb ef4a              fdw     DUP_L
                 ABS_L:
0032bc 6183
0032bd 7362              .db     NFA|3,"abs"
                 ABS_:
0032be d4e8              rcall   DUP
0032bf 940c 33ff         jmp     QNEGATE
                 
0032c1 e578              fdw     ABS_L
                 PLUS_L:
0032c2 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032c3 9109              ld      t0, Y+        
0032c4 9119              ld      t1, Y+
0032c5 0f80              add     tosl, t0
0032c6 1f91              adc     tosh, t1
0032c7 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032c8 e584              fdw     PLUS_L
                 MPLUS_L:
0032c9 6d82
0032ca 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032cb d7a4              rcall   STOD
0032cc 940c 3a92         jmp     DPLUS
                 
0032ce e592              fdw     MPLUS_L
                 MINUS_L:
0032cf 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
0032d0 9109              ld      t0, Y+
0032d1 9119              ld      t1, Y+
0032d2 1b08              sub     t0, tosl
0032d3 0b19              sbc     t1, tosh
0032d4 01c8              movw    tosl, t0
0032d5 9508              ret
                 
0032d6 e59e              fdw     MINUS_L
                 AND_L:
0032d7 6183
0032d8 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
0032d9 9109              ld      t0, Y+
0032da 9119              ld      t1, Y+
0032db 2380              and     tosl, t0
0032dc 2391              and     tosh, t1
0032dd 9508              ret
                 
0032de e5ae              fdw     AND_L
                 OR_L:
0032df 6f82
0032e0 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
0032e1 9109              ld      t0, Y+
0032e2 9119              ld      t1, Y+
0032e3 2b80              or      tosl, t0
0032e4 2b91              or      tosh, t1
0032e5 9508              ret
                 
0032e6 e5be              fdw     OR_L
                 XOR_L:
0032e7 7883
0032e8 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
0032e9 9109              ld      t0, Y+
0032ea 9119              ld      t1, Y+
0032eb 2780              eor     tosl, t0
0032ec 2791              eor     tosh, t1
0032ed 9508              ret
                 
0032ee e5ce              fdw     XOR_L
                 INVERT_L:
0032ef 69a6
0032f0 766e
0032f1 7265
0032f2 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
0032f3 9580              com     tosl
0032f4 9590              com     tosh
0032f5 9508              ret
                 
0032f6 e5de              fdw     INVERT_L
                 NEGATE_L:
0032f7 6e86
0032f8 6765
0032f9 7461
0032fa 0065              .db     NFA|6, "negate",0
                 NEGATE:
0032fb dff7              rcall   INVERT
0032fc 940c 3301         jmp     ONEPLUS
                 
0032fe e5ee              fdw     NEGATE_L
                 ONEPLUS_L:
0032ff 31a2
003300 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
003301 9601              adiw    tosl, 1
003302 9508              ret
                 
003303 e5fe              fdw     ONEPLUS_L
                 ONEMINUS_L:
003304 31a2
003305 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
003306 9701              sbiw    tosl, 1
003307 9508              ret
                 
003308 e608              fdw     ONEMINUS_L
                 TWOPLUS_L:
003309 32a2
00330a 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
00330b 9602              adiw    tosl, 2
00330c 9508              ret
                 
00330d e612              fdw     TWOPLUS_L
                 TOBODY_L:
00330e 3ea5
00330f 6f62
003310 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
003311 9604              adiw    tosl, 4
003312 9508              ret
                 
003313 e61c              fdw     TOBODY_L
                 TWOSTAR_L:
003314 32a2
003315 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003316 0f88              lsl     tosl
003317 1f99              rol     tosh
003318 9508              ret
                 
003319 e628              fdw     TWOSTAR_L
                 TWOSLASH_L:
00331a 32a2
00331b 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
00331c 9595              asr     tosh
00331d 9587              ror     tosl
00331e 9508              ret
                 
00331f e634              fdw     TWOSLASH_L
                 PLUSSTORE_L:
003320 2b82
003321 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
003322 df62              rcall   SWOP
003323 df6b              rcall   OVER
003324 d3b9              rcall   FETCH_A
003325 df9d              rcall   PLUS
003326 df5e              rcall   SWOP
003327 940c 3e31         jmp     STORE
                 
003329 e640              fdw     PLUSSTORE_L
                 WITHIN_L:
00332a 7786
00332b 7469
00332c 6968
00332d 006e              .db     NFA|6,"within",0
                 WITHIN:
00332e df60              rcall   OVER
00332f dfa0              rcall   MINUS
003330 df6d              rcall   TOR
003331 df9e              rcall   MINUS
003332 df75              rcall   RFROM
003333 940c 334f         jmp     ULESS
                 
003335 e654              fdw     WITHIN_L
                 NOTEQUAL_L:
003336 3c82
003337 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
003338 df97              rcall   MINUS           ; MINUS leaves a valid zero flag
003339 f409              brne    NOTEQUAL1
00333a c47c              rjmp    FALSE_F
                 NOTEQUAL1:
00333b 940c 37af         jmp     TRUE_F
                 
00333d ef66              fdw     ZEROLESS_L
                 EQUAL_L:
00333e 3d81              .db     NFA|1, "="
                 EQUAL:
00333f df90              rcall   MINUS
003340 940c 37ad         jmp     ZEROEQUAL
                 
                 
003342 e67c              fdw     EQUAL_L
                 LESS_L:
003343 3c81              .db     NFA|1,"<"
                 LESS:
003344 df8b              rcall   MINUS
003345 940c 37b5         jmp     ZEROLESS
                 
003347 e686              fdw     LESS_L
                 GREATER_L:
003348 3e81              .db     NFA|1,">"
                 GREATER:
003349 df3b              rcall   SWOP
00334a 940c 3344         jmp     LESS
                 
00334c e690              fdw     GREATER_L
                 ULESS_L:
00334d 7582
00334e 003c              .db     NFA|2,"u<",0
                 ULESS:
00334f df80              rcall   MINUS
003350 f408              brcc    ULESS1        ; Carry test  
003351 c45d              rjmp    TRUE_F
                 ULESS1:
003352 940c 37b7         jmp     FALSE_F
                 
                 
003354 e69a              fdw     ULESS_L
                 UGREATER_L:
003355 7582
003356 003e              .db     NFA|2, "u>",0
                 UGREATER:
003357 df2d              rcall   SWOP
003358 940c 334f         jmp     ULESS
                 
00335a e6aa              fdw     UGREATER_L
                 STORE_P_L:
00335b 2182
00335c 0070              .db     NFA|2,"!p",0
                 STORE_P:
00335d 01ac              movw    pl, tosl
00335e 9189
00335f 9199              poptos
003360 9508              ret
                 
003361 e6b6              fdw     STORE_P_L
                 STORE_P_TO_R_L:
003362 2194
003363 3e70
003364 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
003365 91ff              pop     zh
003366 91ef              pop     zl
003367 934f              push    pl
003368 935f              push    ph
003369 01ac              movw    pl, tosl
00336a 9189
00336b 9199              poptos
00336c 9409              mijmp
                 
00336d e6c4              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
00336e 7293
00336f 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
003370 91ff              pop     zh
003371 91ef              pop     zl
003372 915f              pop     ph
003373 914f              pop     pl
003374 9409              mijmp
                 
003375 e6dc              fdw     R_TO_P_L
                 PFETCH_L:
003376 7082
003377 0040              .db     NFA|2,"p@",0
                 PFETCH:
003378 939a
003379 938a              pushtos
00337a 01ca              movw    tosl, pl
00337b 940c 3e79         jmp     FETCH
                 
00337d e6ec              fdw     PFETCH_L
                 PSTORE_L:
00337e 7082
00337f 0021              .db     NFA|2,"p!",0
                 PSTORE:
003380 939a
003381 938a              pushtos
003382 01ca              movw    tosl, pl
003383 940c 3e31         jmp     STORE
                 
003385 e6fc              fdw     PSTORE_L
                 PCSTORE_L:
003386 7083
003387 2163              .db     NFA|3,"pc!"
                 PCSTORE:
003388 939a
003389 938a              pushtos
00338a 01ca              movw    tosl, pl
00338b 940c 3ec6         jmp     CSTORE
                 
00338d e70c              fdw     PCSTORE_L
                 PPLUS_L:
00338e 70a2
00338f 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
003390 0d46              add     pl, r_one
003391 1d55              adc     ph, zero
003392 9508              ret   
                 
003393 e71c              fdw     PPLUS_L
                 PNPLUS_L:
003394 7083
003395 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
003396 0f48              add     pl, tosl
003397 1f59              adc     ph, tosh
003398 9189
003399 9199              poptos
00339a 9508              ret
                 
00339b e728              fdw     PNPLUS_L
                 UEMIT_L:
00339c 2785
00339d 6d65
00339e 7469              .db     NFA|5,"'emit"
                 UEMIT_:
00339f d137              rcall   DOUSER
0033a0 ffe8              .dw     uemit
                         
0033a1 e738              fdw     UEMIT_L
                 UKEY_L:
0033a2 2784
0033a3 656b
0033a4 0079              .db     NFA|4,"'key",0
                 UKEY_:
0033a5 d131              rcall   DOUSER
0033a6 ffea              .dw     ukey
                 
0033a7 e744              fdw     UKEY_L
                 UKEYQ_L:
0033a8 2785
0033a9 656b
0033aa 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
0033ab d12b              rcall   DOUSER
0033ac ffec              .dw     ukeyq
                 
0033ad 3f83
0033ae 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
0033af 9700              sbiw    tosl, 0
0033b0 9189
0033b1 9199              poptos
0033b2 9508              ret
                 
0033b3 6483
0033b4 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
0033b5 9700              sbiw    tosl, 0
0033b6 9508              ret
                 
0033b7 e750              fdw     UKEYQ_L
                 UMSTAR_L:
0033b8 7583
0033b9 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
0033ba 940c 3f8d         jmp     umstar0
                 
0033bc e770              fdw     UMSTAR_L
                 UMSLASHMOD_L:
0033bd 7586
0033be 2f6d
0033bf 6f6d
0033c0 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
0033c1 940c 2f80         jmp     umslashmod0
                 
                 
0033c3 e77a              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
0033c4 7585
0033c5 6d2f
0033c6 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
0033c7 d378              rcall   FALSE_
0033c8 debc              rcall   SWOP
0033c9 940c 2f80         jmp     umslashmod0
                 
0033cb e788              fdw     USLASHMOD_L
                 STAR_L:
0033cc 2a81              .db     NFA|1,"*"
                 STAR: 
0033cd dfec              rcall   UMSTAR
0033ce 940c 327e         jmp     DROP
                 
0033d0 e798              fdw     STAR_L
                 USLASH_L:
0033d1 7582
0033d2 002f              .db     NFA|2,"u/",0
                 USLASH:
0033d3 dff3              rcall   USLASHMOD
0033d4 940c 33f0         jmp     NIP
                 
0033d6 e7a2              fdw     USLASH_L
                 USSMOD_L:
0033d7 7586
0033d8 2f2a
0033d9 6f6d
0033da 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
0033db dec2              rcall   TOR
0033dc dfdd              rcall   UMSTAR
0033dd deca              rcall   RFROM
0033de 940c 33c1         jmp     UMSLASHMOD
                 
                 
0033e0 e7ae              fdw     USSMOD_L
                 SLASH_L:
0033e1 2f81              .db     NFA|1,"/"
                 SLASH: 
0033e2 dddc              rcall   TWODUP
0033e3 df05              rcall   XOR_
0033e4 deb9              rcall   TOR
0033e5 ded8              rcall   ABS_
0033e6 de9e              rcall   SWOP
0033e7 ded6              rcall   ABS_
0033e8 de9c              rcall   SWOP
0033e9 dfe9              rcall   USLASH
0033ea debd              rcall   RFROM
0033eb 940c 33ff         jmp     QNEGATE
                 
0033ed e7c2              fdw     SLASH_L
                 NIP_L:
0033ee 6ea3
0033ef 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
0033f0 9109              ld      t0, y+
0033f1 9109              ld      t0, y+
0033f2 9508              ret
                     
0033f3 e7dc              fdw     NIP_L
                 TUCK_L:
0033f4 7484
0033f5 6375
0033f6 006b              .db     NFA|4,"tuck",0
                 TUCK:
0033f7 de8d              rcall   SWOP
0033f8 940c 328f         jmp     OVER
                 
0033fa e7e8              fdw     TUCK_L
                 QNEGATE_L:
0033fb 3f87
0033fc 656e
0033fd 6167
0033fe 6574              .db     NFA|7,"?negate"
                 QNEGATE:
0033ff d3b5              rcall   ZEROLESS
003400 dfae              rcall   ZEROSENSE
003401 f009              breq    QNEGATE1
003402 def8              rcall   NEGATE
                 QNEGATE1:
003403 9508              ret
                 
003404 e7f6              fdw     QNEGATE_L
                 MAX_L:
003405 6d83
003406 7861              .db     NFA|3,"max"
003407 ddb7      MAX:    rcall   TWODUP
003408 df3b              rcall   LESS
003409 cde1              rjmp    MINMAX
                 
00340a e80a              fdw     MAX_L
                 MIN_L:
00340b 6d83
00340c 6e69              .db     NFA|3,"min"
00340d ddb1      MIN:    rcall   TWODUP
00340e df3a              rcall   GREATER
00340f cddb              rjmp    MINMAX
                 
003410 6382
003411 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
003412 940c 3ea3         jmp     CFETCH
                 
003414 6382
003415 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003416 940c 3ec6         jmp     CSTORE
                 
003418 e816              fdw     MIN_L
                 UPTR_L:
003419 7582
00341a 0070              .db     NFA|2,"up",0
00341b dca8      UPTR:   rcall   DOCREATE
00341c 0002              .dw     2 ; upl
                 
00341d e832              fdw     UPTR_L
                 HOLD_L:
00341e 6884
00341f 6c6f
003420 0064              .db     NFA|4,"hold",0
003421 d327      HOLD:   rcall   TRUE_
003422 d09a              rcall   HP
003423 defe              rcall   PLUSSTORE
003424 d098              rcall   HP
003425 d2b8              rcall   FETCH_A
003426 940c 3ec6         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
003428 e83c              fdw     HOLD_L
                 LESSNUM_L:
003429 3c82
00342a 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
00342b d096              rcall   PAD
00342c d090              rcall   HP
00342d 940c 3e31         jmp     STORE
                 
                 ; >digit   n -- c            convert to 0..9a..z
00342f e852              fdw     LESSNUM_L
                 TODIGIT_L:
003430 3e86
003431 6964
003432 6967
003433 0074              .db     NFA|6,">digit",0
                 TODIGIT: 
003434 d372              rcall   DUP
003435 d368              rcall   DOLIT
003436 0009              .dw     9
003437 df11              rcall   GREATER
003438 d365              rcall   DOLIT
003439 0027              .dw     0x27
00343a de9e              rcall   AND_
00343b de87              rcall   PLUS
00343c d361              rcall   DOLIT
00343d 0030              .dw     0x30
00343e 940c 32c3         jmp     PLUS
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
003440 e860              fdw     TODIGIT_L
                 NUM_L:
003441 2381              .db     NFA|1,"#"
                 NUM:
003442 d087              rcall   BASE
003443 d29a              rcall   FETCH_A
003444 d198              rcall   UDSLASHMOD
003445 de51              rcall   ROT
003446 dfed              rcall   TODIGIT
003447 940c 3421         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
003449 e882              fdw     NUM_L
                 NUMS_L:
00344a 2382
00344b 0073              .db     NFA|2,"#s",0
                 NUMS:
00344c dff5              rcall   NUM
00344d dd71              rcall   TWODUP
00344e de92              rcall   OR_
00344f df5f              rcall   ZEROSENSE
003450 f7d9              brne    NUMS
003451 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
003452 e894              fdw     NUMS_L
                 NUMGREATER_L:
003453 2382
003454 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
003455 dd62              rcall   TWODROP
003456 d066              rcall   HP
003457 d286              rcall   FETCH_A
003458 d069              rcall   PAD
003459 de35              rcall   OVER
00345a 940c 32d0         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
00345c e8a6              fdw     NUMGREATER_L
                 SIGN_L:
00345d 7384
00345e 6769
00345f 006e              .db     NFA|4,"sign",0
                 SIGN:   
003460 d354              rcall   ZEROLESS
003461 df4d              rcall   ZEROSENSE
003462 f019              breq    SIGN1
003463 d33a              rcall   DOLIT
003464 002d              .dw     0x2D
003465 dfbb              rcall   HOLD
                 SIGN1:
003466 9508              ret
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
003467 e8ba              fdw     SIGN_L
                 UDOT_L:
003468 7582
003469 002e              .db     NFA|2,"u.",0
                 UDOT:
00346a dfc0              rcall   LESSNUM
00346b d2d4              rcall   FALSE_
00346c dfdf              rcall   NUMS
00346d dfe7              rcall   NUMGREATER
00346e ddca              rcall   TYPE
00346f 940c 31cf         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
003471 e8d0              fdw     UDOT_L
                 UDOTR_L:
003472 7583
003473 722e              .db     NFA|3,"u.r"
                 UDOTR:
003474 dfb6              rcall   LESSNUM
003475 de90              rcall   ONEMINUS
003476 de27              rcall   TOR
003477 d2c8              rcall   FALSE_
003478 c001              rjmp    UDOTR2
                 UDOTR1:
003479 dfc8              rcall   NUM
                 UDOTR2: 
00347a d5d1              rcall   XNEXT
00347b f7e8              brcc    UDOTR1
00347c 911f              pop     t1
00347d 910f              pop     t0
00347e dfcd              rcall   NUMS
00347f dfd5              rcall   NUMGREATER
003480 ddb8              rcall   TYPE
003481 940c 31cf         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
003483 e8e4              fdw     UDOTR_L
                 DOT_L:
003484 2e81              .db     NFA|1,"."
003485 dfa5      DOT:    rcall   LESSNUM
003486 d320              rcall   DUP
003487 de36              rcall   ABS_
003488 d2b7              rcall   FALSE_
003489 dfc2              rcall   NUMS
00348a de0c              rcall   ROT
00348b dfd4              rcall   SIGN
00348c dfc8              rcall   NUMGREATER
00348d ddab              rcall   TYPE
00348e 940c 31cf         jmp     SPACE_
                 
003490 e908              FDW     DOT_L
                 DECIMAL_L:
003491 6487
003492 6365
003493 6d69
003494 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
003495 d282              rcall   TEN
003496 d033              rcall   BASE
003497 940c 3e31         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
003499 e922              Fdw     DECIMAL_l
                 HEX_L:
00349a 6883
00349b 7865              .db     NFA|3,"hex"
                 HEX:
00349c d301              rcall   DOLIT
00349d 0010              .dw     16
00349e d02b              rcall   BASE
00349f 940c 3e31         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
0034a1 e934              Fdw     HEX_L
                 BIN_L:
0034a2 6283
0034a3 6e69              .db     NFA|3,"bin"
0034a4 dca5      BIN:    rcall   CELL
0034a5 d024              rcall   BASE
0034a6 940c 3e31         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
0034a8 e944              fdw     BIN_L
                 RSAVE_L:
0034a9 7285
0034aa 6173
0034ab 6576              .db     NFA|5,"rsave"
0034ac d02a      RSAVE_: rcall   DOUSER
0034ad fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
0034ae e952              fdw     RSAVE_L
                 ULINK_L:
0034af 7585
0034b0 696c
0034b1 6b6e              .db     NFA|5,"ulink"
0034b2 d024      ULINK_: rcall   DOUSER
0034b3 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034b4 e95e              fdw     ULINK_L
                 TASK_L:
0034b5 7484
0034b6 7361
0034b7 006b              .db     NFA|4,"task",0
0034b8 d01e      TASK:   rcall   DOUSER
0034b9 fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034ba e96a              fdw     TASK_L
                 HP_L:
0034bb 6882
0034bc 0070              .db     NFA|2,"hp",0
0034bd d019      HP:     rcall   DOUSER
0034be 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
0034bf e976              fdw     HP_L
                 PAD_L:
0034c0 7083
0034c1 6461              .db     NFA|3,"pad"
                 PAD:
0034c2 d19f              rcall   TIB
0034c3 d196              rcall   TIBSIZE
0034c4 940c 32c3         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
0034c6 e980              fdw     PAD_L
                 BASE_L:
0034c7 6284
0034c8 7361
0034c9 0065              .db     NFA|4,"base",0
                 BASE:
0034ca d00c              rcall   DOUSER
0034cb ffee              .dw     ubase
                 
                 ; USER   n --
0034cc e98e              fdw     BASE_L
                 USER_L:
0034cd 7584
0034ce 6573
0034cf 0072              .db     NFA|4,"user",0
                 USER:
0034d0 d321              rcall   CREATE
0034d1 dc78              rcall   CELL
0034d2 de28              rcall   NEGATE
0034d3 d4a7              rcall   IALLOT
0034d4 940e 3f56         call    ICOMMA
0034d6 d36b              rcall   XDOES
                 DOUSER:
0034d7 939a
0034d8 938a              pushtos
                         m_pop_zh
0034d9 91ff              pop     zh
0034da 91ef              pop     zl
0034db 0fee              lsl     zl
0034dc 1fff              rol     zh
0034dd 9185              lpm_    tosl, z+
0034de 9195              lpm_    tosh, z+
0034df 0d82              add     tosl, upl
0034e0 1d93              adc     tosh, uph
0034e1 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
0034e2 e99a              fdw     USER_L
                 SOURCE_L:
0034e3 7386
0034e4 756f
0034e5 6372
0034e6 0065              .db     NFA|6,"source",0
                 SOURCE:
0034e7 d18c              rcall   TICKSOURCE
0034e8 940c 31a5         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
0034ea e9c6              fdw      SOURCE_L
                 SLASHSTRING_L:
0034eb 2f87
0034ec 7473
0034ed 6972
0034ee 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
0034ef dd95              rcall   SWOP
0034f0 dd9e              rcall   OVER
0034f1 ddde              rcall   MINUS
0034f2 ddab              rcall   TOR
0034f3 ddcf              rcall   PLUS
0034f4 ddb3              rcall   RFROM
0034f5 9508              ret
                 
                 ; \     Skip the rest of the line
0034f6 e9d6              fdw     SLASHSTRING_L
                 BSLASH_L:
0034f7 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
0034f8 dfee              rcall   SOURCE
0034f9 d173              rcall   TOIN
0034fa d057              rcall   STORE_A
0034fb 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
0034fc 940c 327e         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
0034fe e9ee              fdw     BSLASH_L
                 PARSE_L:
0034ff 7085
003500 7261
003501 6573              .db     NFA|5,"parse"
                 PARSE:
003502 d2a4              rcall   DUP             ; c c
003503 dfe3              rcall   SOURCE          ; c c a u
003504 d168              rcall   TOIN            ; c c a u a
003505 d1d8              rcall   FETCH_A         ; c c a u n
003506 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
003507 d29f              rcall   DUP             ; c c a u u
003508 dd95              rcall   TOR             ; c c a u                  R: u (new tib len
003509 dd8d              rcall   ROT             ; c a u c
00350a db0e              rcall   SKIP            ; c a u        
00350b dd83              rcall   OVER            ; c a u a
00350c dd91              rcall   TOR             ; c a u                    R: u a (start of word
00350d dd89              rcall   ROT             ; a u c
00350e db25              rcall   SCAN            ; a u      end of word, tib left       
00350f dea5              rcall   DUPZEROSENSE
003510 f009              breq    PARSE1
003511 ddf4              rcall   ONEMINUS
003512 dd95      PARSE1: rcall   RFROM           ; a u a
003513 dd94              rcall   RFROM           ; a u a u
003514 dd82              rcall   ROT             ; a a u u
003515 ddba              rcall   MINUS           ; a a n  ( addition to toin
003516 d156              rcall   TOIN
003517 de0a              rcall   PLUSSTORE       ; aend astart
003518 dede              rcall   TUCK            ; astart aend astart
003519 940c 32d0         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
00351b e9fe              fdw     PARSE_L
                 WORD_L:
00351c 7784
00351d 726f
00351e 0064              .db     NFA|4,"word",0
                 WORD:
00351f dfe2              rcall   PARSE           ; c-addr wlen
003520 dd64              rcall   SWOP
003521 dde4              rcall   ONEMINUS
003522 ded4              rcall   TUCK
003523 940c 3ec6         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
003525 ea38              fdw     WORD_L
                 CMOVE_L:
003526 6385
003527 6f6d
003528 6576              .db     NFA|5,"cmove"
                 CMOVE:
003529 dd5b              rcall   SWOP
00352a de3a              rcall   STORE_P_TO_R
00352b dd72              rcall   TOR
00352c c003              rjmp    CMOVE2
                 CMOVE1:
00352d d016              rcall   CFETCHPP
00352e de59              rcall   PCSTORE
00352f de60              rcall   PPLUS
                 CMOVE2:
003530 d51b              rcall   XNEXT
003531 f7d8              brcc    CMOVE1
003532 911f              pop     t1
003533 910f              pop     t0
003534 de3b              rcall   R_TO_P
003535 940c 327e         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
003537 ea4c              fdw     CMOVE_L
                 PLACE_L:
003538 7085
003539 616c
00353a 6563              .db     NFA|5,"place"
                 PLACE: 
00353b dc83              rcall   TWODUP
00353c ded9              rcall   CSTORE_A
00353d dc35              rcall   CHARPLUS
00353e dd46              rcall   SWOP
00353f 940c 3529         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
003541 ea70              fdw     PLACE_L
                 CFETCHPP_L:
003542 6383
003543 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
003544 d262              rcall   DUP
003545 ddbb              rcall   ONEPLUS
003546 dd3e              rcall   SWOP
003547 940c 3ea3         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
003549 ea84              fdw     CFETCHPP_L
                 FETCHPP_L:
00354a 4082
00354b 002b              .db     NFA|2,"@+",0
                 FETCHPP:
00354c d25a              rcall   DUP
00354d ddbd              rcall   TWOPLUS
00354e dd36              rcall   SWOP
00354f 940c 3e79         jmp     FETCH
                 
003551 2181              .db     NFA|1,"!"
                 STORE_A:        
003552 940c 3e31         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
003554 ea94              fdw    FETCHPP_L
                 NTOC_L:
003555 6e83
003556 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
003557 dfec              rcall   CFETCHPP
003558 d245              rcall   DOLIT
003559 000f              .dw     0x0f
00355a dd7e              rcall   AND_
00355b dd67              rcall   PLUS
00355c 940c 315d         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
00355e eaaa              fdw    NTOC_L
                 CTON_L:
00355f 6383
003560 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
003561 d352              rcall   TWOMINUS
003562 d244              rcall   DUP
003563 deae              rcall   CFETCH_A
003564 d239              rcall   DOLIT
003565 007f              .dw     0x007F
003566 dde2              rcall   GREATER
003567 de47              rcall   ZEROSENSE
003568 f3c1              breq    CFATONFA
003569 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
00356a eabe              fdw     CTON_L
                 BRACFIND_L:
00356b 2883
00356c 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
00356d dc51              rcall   TWODUP
                 ;        rcall   OVER
                 ;        rcall   CFETCH_A
00356e da87              rcall   NEQUAL
00356f de45              rcall   DUPZEROSENSE
003570 f021              breq    findi2
003571 dd0c              rcall   DROP
003572 d341              rcall   TWOMINUS ;;;      NFATOLFA
003573 d16a              rcall   FETCH_A
003574 d232              rcall   DUP
                 findi2:
003575 de39              rcall   ZEROSENSE
003576 f7b1              brne    findi1
003577 de3d              rcall   DUPZEROSENSE
003578 f041              breq    findi3
003579 de76              rcall   NIP
00357a d22c              rcall   DUP
00357b dfdb              rcall   NFATOCFA
00357c dd08              rcall   SWOP
00357d d009              rcall   IMMEDQ
00357e d22e              rcall   ZEROEQUAL
00357f dc72              rcall   ONE
003580 dd60              rcall   OR_
                 findi3: 
003581 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
003582 ead6              fdw     BRACFIND_L
                 IMMEDQ_L:
003583 6986
003584 6d6d
003585 6465
003586 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
003587 de8a              rcall   CFETCH_A
003588 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
003589 d214              rcall   DOLIT
00358a 0040              .dw     IMMED
00358b 940c 32d9         jmp     AND_
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
00358d eb06              fdw     IMMEDQ_L
                 FIND_L:
00358e 6684
00358f 6e69
003590 0064              .db     NFA|4,"find",0
                 FIND:   
003591 d20c              rcall   DOLIT
003592 f65c              fdw     kernellink
003593 dfd9              rcall   findi
003594 de20              rcall   DUPZEROSENSE
003595 f421              brne    FIND1
003596 dce7              rcall   DROP
003597 d334              rcall   LATEST_
003598 d145              rcall   FETCH_A
003599 dfd3              rcall   findi
                 FIND1:
00359a 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
00359b eb1c              fdw     FIND_L
                 DIGITQ_L:
00359c 6486
00359d 6769
00359e 7469
00359f 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
0035a0 d206              rcall   DUP             ; c c       c c
0035a1 d1fc              rcall   DOLIT
0035a2 0039              .dw     0x39            ; c c 39    c c 39
0035a3 dda5              rcall   GREATER         ; c 0       c ffff
0035a4 de0a              rcall   ZEROSENSE
0035a5 f019              breq    DIGITQ1
0035a6 d1f7              rcall   DOLIT
0035a7 0027              .dw     0x27
0035a8 dd27              rcall   MINUS
                 DIGITQ1:        
0035a9 d1f4              rcall   DOLIT
0035aa 0030              .dw     0x30            ; c 30
0035ab dd24              rcall   MINUS           ; 1
0035ac d1fa              rcall   DUP             ; 1 1
0035ad df1c              rcall   BASE            ; 1 1 base
0035ae d12f              rcall   FETCH_A         ; 1 1 10
0035af dd94              rcall   LESS            ; 1 ffff
0035b0 dcde              rcall   OVER            ; 1 ffff 1
0035b1 d203              rcall   ZEROLESS        ; 1 ffff 0
0035b2 dd40              rcall   INVERT
0035b3 940c 32d9         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035b5 eb38              fdw     DIGITQ_L
                 SIGNQ_L:
0035b6 7385
0035b7 6769
0035b8 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035b9 dcd5              rcall   OVER
0035ba de57              rcall   CFETCH_A
0035bb d1e2              rcall   DOLIT
0035bc 002c              .dw     ','
0035bd dd12              rcall   MINUS
0035be d1e8              rcall   DUP
0035bf dcfe              rcall   ABS_
0035c0 dc31              rcall   ONE
0035c1 dd7d              rcall   EQUAL
0035c2 dd16              rcall   AND_
0035c3 ddf1              rcall   DUPZEROSENSE
0035c4 f029              breq    QSIGN1
0035c5 dd3b              rcall   ONEPLUS
0035c6 dcd7              rcall   TOR
0035c7 dc2a              rcall   ONE
0035c8 df26              rcall   SLASHSTRING
0035c9 dcde              rcall   RFROM
0035ca 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
0035cb eb6c              fdw     SIGNQ_L
                 UDSTAR_L:
0035cc 7583
0035cd 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035ce d1d8              rcall   DUP
0035cf dcce              rcall   TOR
0035d0 dde9              rcall   UMSTAR
0035d1 dcac              rcall   DROP
0035d2 dcb2              rcall   SWOP
0035d3 dcd4              rcall   RFROM
0035d4 dde5              rcall   UMSTAR
0035d5 dcc1              rcall   ROT
0035d6 940c 32c3         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
0035d8 eb98              fdw     UDSTAR_L
                 UDSLASHMOD_L:
0035d9 7586
0035da 2f64
0035db 6f6d
0035dc 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
0035dd dcc0              rcall   TOR             ; ud.l ud.h 
0035de d161              rcall   FALSE_          ; ud.l ud.h 0
0035df dcd2              rcall   RFETCH          ; ud.l ud.h 0 u
0035e0 dde0              rcall   UMSLASHMOD      ; ud.l r.h q.h
0035e1 dcb5              rcall   ROT             ; r.h q.h ud.l
0035e2 dcb4              rcall   ROT             ; q.h ud.l r.h
0035e3 dcc4              rcall   RFROM           ; q.h ud.l r.h u
0035e4 dddc              rcall   UMSLASHMOD      ; q.h r.l q.l
0035e5 940c 3297         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
0035e7 ebb2              fdw     UDSLASHMOD_L
                 TONUMBER_L:
0035e8 3e87
0035e9 756e
0035ea 626d
0035eb 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
0035ec ddc8              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
0035ed f0b1              breq    TONUM3
0035ee dcaf              rcall   TOR
0035ef d1b7              rcall   DUP
0035f0 dcad              rcall   TOR             ; ud.l ud.h adr
0035f1 de20              rcall   CFETCH_A
0035f2 dfad              rcall   DIGITQ          ; ud.l ud.h digit flag
0035f3 ddbb              rcall   ZEROSENSE
0035f4 f421              brne    TONUM2
0035f5 dc88              rcall   DROP
0035f6 dcb1              rcall   RFROM
0035f7 dcb0              rcall   RFROM
0035f8 c00b              rjmp    TONUM3
                 TONUM2: 
0035f9 dca4              rcall   TOR             ; ud.l ud.h digit
0035fa decf              rcall   BASE
0035fb d0e2              rcall   FETCH_A
0035fc dfd1              rcall   UDSTAR
0035fd dcaa              rcall   RFROM
0035fe dccc              rcall   MPLUS
0035ff dca8              rcall   RFROM
003600 dca7              rcall   RFROM
                         
003601 dbf0              rcall   ONE
003602 deec              rcall   SLASHSTRING
003603 cfe8              rjmp    TONUM1
                 TONUM3: 
003604 9508              ret
                 
                 BASEQV:   
003605 e92a              fdw     DECIMAL
003606 e938              fdw     HEX
003607 e948              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
003608 ebd0              fdw     TONUMBER_L
                 NUMBERQ_L:
003609 6e87
00360a 6d75
00360b 6562
00360c 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
00360d d199              rcall   DUP             ; a a
00360e d131              rcall   FALSE_          ; a a 0 0
00360f d130              rcall   FALSE_          ; a a 0 0
003610 dc86              rcall   ROT             ; a 0 0 a
003611 df32              rcall   CFETCHPP        ; a 0 0 a' u
003612 dfa6              rcall   SIGNQ           ; a 0 0 a' u f
003613 dc8a              rcall   TOR             ; a 0 0 a' u
                 
003614 deb5              rcall   BASE
003615 d0c8              rcall   FETCH_A
003616 dc87              rcall   TOR             ; a 0 0 a' u
                         
003617 dc77              rcall   OVER
003618 ddf9              rcall   CFETCH_A
                         
003619 d184              rcall   DOLIT
00361a 0023              .dw     '#'
00361b dcb4              rcall   MINUS
00361c d18a              rcall   DUP
00361d d180              rcall   DOLIT
00361e 0003              .dw     3
00361f dd2f              rcall   ULESS
003620 dd8e              rcall   ZEROSENSE
003621 f041              breq    BASEQ1
003622 db49              rcall   CELLS
                         
003623 d17a              rcall   DOLIT
003624 ec0a              fdw     BASEQV
003625 dc9d              rcall   PLUS
003626 da68              rcall   FEXECUTE
                 
003627 dbca              rcall   ONE
003628 dec6              rcall   SLASHSTRING
003629 c001              rjmp    BASEQ2
                 BASEQ1:
00362a dc53              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
00362b dfc0              rcall   TONUMBER        ; a ud.l ud.h  a' u
00362c dc7b              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
00362d de9c              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
00362e df23              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
00362f d177              rcall   DUP
003630 d283              rcall   TWOMINUS
003631 d183              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
003632 dd7c              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
003633 f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
003634 dc73              rcall   RFROM           ; a ud.l ud.h a' u sign
003635 dc48              rcall   DROP
003636 db81              rcall   TWODROP
                 QNUM_ERR1:      
003637 db80              rcall   TWODROP
003638 d107              rcall   FALSE_          ; a 0           Not a number
003639 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
00363a db8b              rcall   TWOSWAP         ; a a' u ud.l ud.h 
00363b dc6c              rcall   RFROM           ; a a' u ud.l ud.d sign
00363c dd72              rcall   ZEROSENSE
00363d f009              breq    QNUMD1
00363e d439              rcall   DNEGATE
                 QNUMD1: 
00363f db86              rcall   TWOSWAP         ; a d.l d.h a' u
003640 dd6e              rcall   ZEROSENSE       ; a d.l d.h a'
003641 f061              breq    QNUM1
003642 940e 3ea3         call    CFETCH
003644 d159              rcall   DOLIT
003645 002e              .dw     '.'
003646 dc89              rcall   MINUS
003647 dd67              rcall   ZEROSENSE       ; a d.l d.h
003648 f771              brne    QNUM_ERR1
003649 dc4d              rcall   ROT             ; d.l d.h a
00364a dc33              rcall   DROP            ; d.l d.h
00364b d152              rcall   DOLIT         ; 
00364c 0002              .dw     2               ; d.l ud.h 2    Double number
00364d c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
00364e db69              rcall   TWODROP         ; a n
00364f dda0              rcall   NIP             ; n
003650 dba1              rcall   ONE             ; n 1           Single number
                 QNUM3:  
003651 9508              ret
                 
                 
003652 7384
003653 6177
003654 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003655 940c 3285         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003657 ec12              fdw     NUMBERQ_L
                 TIBSIZE_L:
003658 7483
003659 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
00365a de5d              rcall   TASK
00365b d082              rcall   FETCH_A
00365c 9605              adiw    tosl, 5
00365d 940c 3ea3         jmp     CFETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00365f ecb0              fdw     TIBSIZE_L
                 TIB_L:
003660 7483
003661 6269              .db     NFA|3,"tib"
                 TIB:
003662 d005              rcall   TIU
003663 940c 3e79         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003665 ecc0              fdw     TIB_L
                 TIU_L:
003666 7483
003667 7569              .db     NFA|3,"tiu"
                 TIU:
003668 de6e              rcall   DOUSER
003669 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
00366a eccc              fdw     TIU_L
                 TOIN_L:
00366b 3e83
00366c 6e69              .db     NFA|3,">in"
                 TOIN:
00366d de69              rcall   DOUSER
00366e fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00366f ecd6              fdw     TOIN_L
                 TICKSOURCE_L:
003670 2787
003671 6f73
003672 7275
003673 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
003674 de62              rcall   DOUSER
003675 fff6              .dw     usource       ; two cells !!!!!!
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
003676 ece0              fdw     TICKSOURCE_L
                 INTERPRET_L:
003677 6989
003678 746e
003679 7265
00367a 7270
00367b 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
00367c dff7              rcall   TICKSOURCE
00367d db30              rcall   TWOSTORE
00367e d0c1              rcall   FALSE_
00367f dfed              rcall   TOIN
003680 ded1              rcall   STORE_A
                 IPARSEWORD:
003681 d237              rcall   BL
003682 de9c              rcall   WORD
                 
003683 d123              rcall   DUP
003684 dd8d              rcall   CFETCH_A
003685 dd29              rcall   ZEROSENSE
003686 f409              brne    IPARSEWORD1
003687 c053              rjmp    INOWORD
                 IPARSEWORD1:
003688 df08              rcall   FIND            ; sets also wflags
003689 dd2b              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
00368a f1a1              breq    INUMBER         ; NUMBER?
00368b dc75              rcall   ONEPLUS         ; 0 = normal 2 = immediate
00368c d233              rcall   STATE_
00368d d11f              rcall   ZEROEQUAL
00368e dc52              rcall   OR_
00368f dd1f              rcall   ZEROSENSE
003690 f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
003691 fe94              sbrs    wflags, 4       ; Compile only check
003692 c00a              rjmp    IEXECUTE        ; Not a compile only word
003693 d22c              rcall   STATE_          ; Compile only word check
003694 dbb1              rcall   XSQUOTE
003695 430c
003696 4d4f
003697 4950
003698 454c
003699 4f20
00369a 4c4e
00369b 0059              .db     12,"COMPILE ONLY",0
00369c d0ee              rcall   QABORT
                 IEXECUTE:
00369d 7b6f              cbr     FLAGS1, (1<<noclear)
00369e d9e5              rcall   EXECUTE
00369f fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
0036a0 cfe0              rjmp    IPARSEWORD
0036a1 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036a2 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036a3 cfdd              rjmp    IPARSEWORD
                 ICOMPILE_1:
0036a4 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036a5 d101              rcall   DUP
0036a6 d0f7              rcall   DOLIT
0036a7 ef5a              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
0036a8 dc96              rcall   EQUAL
0036a9 dd05              rcall   ZEROSENSE
0036aa f011              breq    ICOMPILE_2
0036ab 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
0036ac c00d              rjmp    ICOMMAXT
                 ICOMPILE_2:
0036ad 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036ae d0f8              rcall   DUP
0036af d0ee              rcall   DOLIT
0036b0 ef4e              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
0036b1 dc8d              rcall   EQUAL
0036b2 dcfc              rcall   ZEROSENSE
0036b3 f009              breq    ICOMPILE
0036b4 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036b5 fe95              sbrs    wflags, 5       ; Inline check
0036b6 c003              rjmp    ICOMMAXT
0036b7 940e 3a23         call    INLINE0
0036b9 cfc7              rjmp    IPARSEWORD
                 ICOMMAXT:
0036ba d126              rcall   COMMAXT_A
0036bb 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
0036bc fc94              sbrc    wflags, 4            ; Compile only ?
0036bd 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0036be cfc2              rjmp    IPARSEWORD
                 INUMBER: 
0036bf 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036c0 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036c1 dbbc              rcall   DROP
0036c2 df4a              rcall   NUMBERQ
0036c3 dcf1              rcall   DUPZEROSENSE
0036c4 f081              breq    IUNKNOWN
0036c5 d1fa              rcall   STATE_
0036c6 dce8              rcall   ZEROSENSE
0036c7 f059              breq    INUMBER1
0036c8 2f08              mov     t0, tosl
0036c9 9189
0036ca 9199              poptos
0036cb ff01              sbrs    t0, 1
0036cc c003              rjmp    ISINGLE
                 IDOUBLE:
0036cd df87              rcall   SWOP_A
0036ce 940e 3e05         call    LITERAL
                 ISINGLE:        
0036d0 940e 3e05         call    LITERAL
0036d2 cfae              rjmp    IPARSEWORD
                 
                 INUMBER1:
0036d3 dbaa              rcall   DROP
0036d4 cfac              rjmp    IPARSEWORD
                 
                 IUNKNOWN:
0036d5 dba8              rcall   DROP 
0036d6 d045              rcall   DP_TO_RAM
0036d7 de6c              rcall   CFETCHPP
0036d8 db60              rcall   TYPE
0036d9 d066              rcall   FALSE_
0036da d0a7              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
0036db 940c 327e         jmp     DROP
                 
0036dd 4081              .db     NFA|1,"@"
                 FETCH_A:        
0036de 940c 3e79         jmp     FETCH
                 
                 ;;;    bitmask -- 
0036e0 ecee              fdw     INTERPRET_L
                 SHB_L:
0036e1 7383
0036e2 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
0036e3 d1e8              rcall   LATEST_
0036e4 dff9              rcall   FETCH_A
0036e5 d0c1              rcall   DUP
0036e6 dd2b              rcall   CFETCH_A
0036e7 dbaf              rcall   ROT
0036e8 dbf8              rcall   OR_
0036e9 df6b              rcall   SWOP_A
0036ea 940c 3ec6         jmp     CSTORE
                         
0036ec edc2              fdw     SHB_L
                 IMMEDIATE_L:
0036ed 6989
0036ee 6d6d
0036ef 6465
0036f0 6169
0036f1 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
0036f2 d0ab              rcall   DOLIT
0036f3 0040              .dw     IMMED
0036f4 940c 36e3         jmp     SHB
                 
                 ;***************************************************************
0036f6 edda              fdw     IMMEDIATE_L
                 INLINED_L:
0036f7 6987
0036f8 6c6e
0036f9 6e69
0036fa 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
0036fb d0a2              rcall   DOLIT
0036fc 0020              .dw     INLINE
0036fd 940c 36e3         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
0036ff edee              fdw     INLINED_L
                 DOTSTATUS_L:
003700 2e83
003701 7473              .db     NFA|3,".st"
                 DOTSTATUS:
003702 d09b              rcall   DOLIT
003703 003c              .dw     '<'
003704 d96a              rcall   EMIT
003705 940e 3f68         call    DOTBASE
003707 d967              rcall   EMIT
003708 d095              rcall   DOLIT
003709 002c              .dw     ','
00370a d964              rcall   EMIT
00370b 940e 3f7d         call    MEMQ
00370d db2b              rcall   TYPE
00370e d08f              rcall   DOLIT
00370f 003e              .dw     '>'
003710 d95e              rcall   EMIT
003711 940c 393a         jmp     DOTS
                 
003713 3e82
003714 0072              .db     NFA|2,">r",0
003715 940c 329e TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
003717 6181              .db     NFA|1,"a"
                 TEN:
003718 d9ab              rcall   DOCREATE
003719 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
00371a 6483
00371b 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
00371c d081              rcall   DOLIT
00371d 0900              .dw     dp_start
00371e d1bc              rcall   INI
00371f dff8              rcall   TEN
003720 940c 3529         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
003722 3e83
003723 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
003724 d079              rcall   DOLIT
003725 0900              .dw     dp_start
003726 dc3e              rcall   STORE_P_TO_R
003727 d1b3              rcall   INI
003728 d075              rcall   DOLIT
003729 0004              .dw     4
00372a db73              rcall   TOR
                 DP_TO_EEPROM_0: 
00372b de20              rcall   FETCHPP
00372c d07a              rcall   DUP
00372d dc4a              rcall   PFETCH
00372e dc09              rcall   NOTEQUAL
00372f dc7f              rcall   ZEROSENSE
003730 f011              breq    DP_TO_EEPROM_1
003731 dc4e              rcall   PSTORE
003732 c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
003733 db4a              rcall   DROP
                 DP_TO_EEPROM_2:
003734 d3fb              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
003735 d316              rcall   XNEXT
003736 f7a0              brcc    DP_TO_EEPROM_0
003737 911f              pop     t1
003738 910f              pop     t0
003739 dc36              rcall   R_TO_P
00373a 940c 327e         jmp     DROP
                 
00373c ee00              fdw     DOTSTATUS_L
                 FALSE_L:
00373d 6685
00373e 6c61
00373f 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
003740 939a
003741 938a              pushtos
003742 2788              clr     tosl
003743 2799              clr     tosh
003744 9508              ret
                 
003745 ee7a              fdw     FALSE_L
                 TRUE_L:
003746 7484
003747 7572
003748 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
003749 939a
00374a 938a              pushtos
00374b ef8f              ser     tosl
00374c ef9f              ser     tosh
00374d 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
00374e ee8c              fdw     TRUE_L
                 QUIT_L:
00374f 7184
003750 6975
003751 0074              .db     NFA|4,"quit",0
                 QUIT:
003752 d99f              rcall   RPEMPTY
003753 d109              rcall   LEFTBRACKET
003754 d9c8              rcall   FRAM
                 QUIT0:  
003755 d5ed              rcall   IFLUSH
                         ;; Copy INI and DP's from eeprom to ram
003756 dfc5              rcall   DP_TO_RAM
                 QUIT1: 
003757 d905              rcall   check_sp
003758 d08d              rcall   CR
003759 df08              rcall   TIB
00375a d04c              rcall   DUP
00375b defe              rcall   TIBSIZE
00375c dfbb              rcall   TEN                 ; Reserve 10 bytes for hold buffer
00375d db72              rcall   MINUS
00375e da9d              rcall   ACCEPT
00375f da6f              rcall   SPACE_
003760 df1b              rcall   INTERPRET
003761 d15e              rcall   STATE_
003762 dc4c              rcall   ZEROSENSE
003763 f799              brne    QUIT1
003764 dfbf              rcall   DP_TO_EEPROM
                          
003765 dae0              rcall    XSQUOTE
003766 2003
003767 6b6f              .db     3," ok"
003768 dad0              rcall    TYPE
003769 d007              rcall   PROMPT_
00376a cfea              rjmp    QUIT0
00376b 9508              ret
                 
00376c ee9e              fdw     QUIT_L
                 PROMPT_L:
00376d 7086
00376e 6f72
00376f 706d
003770 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
003771 940e 3f00         call    DEFER_DOES
003773 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
003774 eeda              fdw     PROMPT_L
                 ABORT_L:
003775 6185
003776 6f62
003777 7472              .db     NFA|5,"abort"
                 ABORT:
003778 d159              rcall   S0
003779 df64              rcall   FETCH_A
00377a d973              rcall   SPSTORE
00377b 940c 3752         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
00377d eeea              fdw     ABORT_L
                 QABORTQ_L:
00377e 3f87
00377f 6261
003780 726f
003781 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
003782 dac3              rcall   XSQUOTE
003783 3f01              .db     1,"?"
003784 940c 378b         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
003786 eefc              fdw     QABORTQ_L
                 QABORT_L:
003787 3f86
003788 6261
003789 726f
00378a 0074              .db     NFA|6,"?abort",0
                 QABORT:
00378b db0b              rcall   ROT
00378c dc22              rcall   ZEROSENSE
00378d f419              brne    QABO1
                 QABORT1:        
00378e da40              rcall   SPACE_
00378f daa9              rcall   TYPE
003790 dfe7              rcall   ABORT  ; ABORT never returns
003791 940c 31b8 QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
003793 ef0e              fdw     QABORT_L
                 ABORTQUOTE_L:
003794 61d6
003795 6f62
003796 7472
003797 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
003798 dac0              rcall   SQUOTE
003799 d942              rcall   DOCOMMAXT
00379a ef16              fdw     QABORT
00379b 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
                 
                 DOLIT_L:
00379c 6c83
00379d 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
00379e 91ff              pop     zh
00379f 91ef              pop     zl
0037a0 d932              rcall   FETCHLIT
0037a1 95f7              ror     zh
0037a2 95e7              ror     zl
0037a3 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
0037a4 e560              fdw     RFETCH_L
                 DUP_L:
0037a5 64a3
0037a6 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
0037a7 939a
0037a8 938a              pushtos
0037a9 9508              ret
                 
0037aa e66c              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
0037ab 3082
0037ac 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:      
0037ad 2b98              or      tosh, tosl
0037ae f441              brne    FALSE_F
                 TRUE_F:
0037af ef9f              ser     tosh
0037b0 ef8f              ser     tosl
                 ZEROEQUAL_1:
0037b1 9508              ret
                 
0037b2 ef56              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
0037b3 3082
0037b4 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
0037b5 2399              tst     tosh
0037b6 f3c2              brmi    TRUE_F
                 FALSE_F:
0037b7 2799              clr     tosh
0037b8 2788              clr     tosl
0037b9 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037ba ef28              fdw     ABORTQUOTE_L
                 TICK_L:
0037bb 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037bc d0fc              rcall   BL
0037bd dd61              rcall   WORD
0037be ddd2              rcall   FIND
0037bf 940c 3782         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
0037c1 ef76              fdw     TICK_L
                 CHAR_L:
0037c2 6384
0037c3 6168
0037c4 0072              .db     NFA|4,"char",0
                 CHAR:
0037c5 d0f3              rcall   BL
0037c6 dd3b              rcall   PARSE
0037c7 dab6              rcall   DROP
0037c8 940c 3ea3         jmp     CFETCH
                 
                 ; (    --                     skip input until )
0037ca ef84              fdw     CHAR_L
                 PAREN_L:
0037cb 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
0037cc dfd1              rcall   DOLIT
0037cd 0029              .dw     ')'
0037ce dd33              rcall   PARSE
0037cf 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
0037d0 940c 31b8         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
0037d2 6985
0037d3 6568
0037d4 6572              .db     NFA|5,"ihere"
                 IHERE:
0037d5 d066              rcall   IDP
0037d6 cf07              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
0037d7 ef96              fdw     PAREN_L
                 BRACCHAR_L:
0037d8 5bd6
0037d9 6863
0037da 7261
0037db 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
0037dc dfe8              rcall   CHAR
0037dd 940c 3e05         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
0037df 6383
0037e0 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
0037e1 940c 317d         jmp     COMMAXT
                 
                 ; CR      --                      output newline
0037e3 efb0              fdw     BRACCHAR_L
                 CR_L:
0037e4 6382
0037e5 0072              .db     NFA|2,"cr",0
                 CR:
0037e6 dfb7              rcall   DOLIT
0037e7 000d              .dw     0x0d       ; CR \r
0037e8 d886              rcall   EMIT
0037e9 dfb4              rcall   DOLIT
0037ea 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
0037eb 940c 306f         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
0037ed efc8              fdw     CR_L
                 CREATE_L:
0037ee 6386
0037ef 6572
0037f0 7461
0037f1 0065              .db     NFA|6,"create",0
                 CREATE:
0037f2 d0c6              rcall   BL
0037f3 dd2b              rcall   WORD            ; Parse a word
                 
0037f4 dfb2              rcall   DUP             ; Remember parsed word at rhere
0037f5 dd9b              rcall   FIND
0037f6 dbf9              rcall   NIP
0037f7 dfb5              rcall   ZEROEQUAL
0037f8 da4d              rcall   XSQUOTE
0037f9 410f
0037fa 524c
0037fb 4145
0037fc 5944
0037fd 4420
0037fe 4645
0037ff 4e49
003800 4445              .db     15,"ALREADY DEFINED"
003801 df89              rcall   QABORT         ; ABORT if word has already been defined
003802 dfa4              rcall   DUP             ; Check the word length 
003803 dc0e              rcall   CFETCH_A
003804 d9ed              rcall   ONE
003805 df98              rcall   DOLIT
003806 0010              .dw     16
003807 db26              rcall   WITHIN
003808 df79              rcall   QABORTQ          ; Abort if there is no name for create
                 
003809 d0c2              rcall   LATEST_
00380a ded3              rcall   FETCH_A
00380b 940e 3f56         call    ICOMMA          ; Link field
00380d dd36              rcall   CFETCHPP        ; str len
00380e dfc6              rcall   IHERE
00380f df97              rcall   DUP             
003810 d0bb              rcall   LATEST_         ; new 'latest' link
003811 dd40              rcall   STORE_A         ; str len ihere
003812 dd28              rcall   PLACE           ; 
003813 dfc1              rcall   IHERE           ; ihere
003814 dbfd              rcall   CFETCH_A
003815 df88              rcall   DOLIT
003816 0080              .dw     NFA
003817 decb              rcall   SHB
003818 dae8              rcall   ONEPLUS
003819 d943              rcall   ALIGNED
00381a d160              rcall   IALLOT          ; The header has now been created
00381b df82              rcall   DOLIT             
00381c e188              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
00381d d968              rcall   STORECFF1       ; Append an exeution token, CALL !
00381e d934              rcall   ALIGN
00381f d914              rcall   HERE            ; compiles the current dataspace dp into the dictionary
003820 d909              rcall   CSE_
003821 db8d              rcall   ZEROSENSE
003822 f409              brne    CREATE2
003823 dae7              rcall   TWOPLUS
                 CREATE2:
003824 940c 3f56         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
003826 efdc              fdw    CREATE_L
                 POSTPONE_L:
003827 70d8
003828 736f
003829 7074
00382a 6e6f
00382b 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
00382c d08c              rcall   BL
00382d dcf1              rcall   WORD
00382e dd62              rcall   FIND
00382f df77              rcall   DUP
003830 df51              rcall   QABORTQ
003831 df83              rcall   ZEROLESS
003832 db7c              rcall   ZEROSENSE
003833 f021              breq    POSTPONE1
003834 d8a7              rcall   DOCOMMAXT
003835 e1b8              fdw     DOCOMMAXT
003836 940c 3f56         jmp     ICOMMA
                 POSTPONE1:
003838 940c 317d         jmp     COMMAXT
                 
                 
                 IDP_L:
00383a 6983
00383b 7064              .db     NFA|3,"idp"
                 IDP:
00383c d887              rcall   DOCREATE
00383d 01d9              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
00383e 2887
00383f 6f64
003840 7365
003841 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
003842 da65              rcall   RFROM
003843 d088              rcall   LATEST_
003844 de99              rcall   FETCH_A
003845 dd11              rcall   NFATOCFA
003846 dff5              rcall   IDP
003847 de96              rcall   FETCH_A
003848 decc              rcall   TOR_A
003849 dff2              rcall   IDP
00384a dd07              rcall   STORE_A
00384b 0f88              lsl     tosl
00384c 1f99              rol     tosh
00384d d938              rcall   STORECFF1 ; Always stores a 4 byte call
00384e da59              rcall   RFROM
00384f dfec              rcall   IDP
003850 940c 3e31         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
003852 f04e              fdw     POSTPONE_L
                 DOES_L:
003853 64d5
003854 656f
003855 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
003856 d885      DOES:   rcall   DOCOMMAXT
003857 f084              fdw     XDOES
003858 d883              rcall   DOCOMMAXT
003859 e198              fdw     DODOES
00385a 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
00385b f0a6              fdw     DOES_L
                 LEFTBRACKET_L:
00385c 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
00385d 7000              cbr     t0, 0xff
00385e 9300 01ec         sts     state, t0
003860 9508              ret
                 
                 
                 ; ]        --      enter compiling state
003861 f0b8              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
003862 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
003863 6f0f              sbr     t0, 0xff
003864 9300 01ec         sts     state, t0
003866 9508              ret
                 
                 ; :        --           begin a colon definition
003867 f0c4              fdw     RIGHTBRACKET_L
                 COLON_L:
003868 3a81              .db     NFA|1,":"
                 COLON:
003869 df88              rcall   CREATE
00386a dff8              rcall   RIGHTBRACKET
00386b 940c 319e         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
00386d f0d0              fdw     COLON_L
                 NONAME_L:
00386e 3a87
00386f 6f6e
003870 616e
003871 656d              .db     NFA|7,":noname"
                 NONAME:
003872 df62              rcall   IHERE
003873 940c 3863         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
003875 f0dc              fdw     NONAME_L
                 SEMICOLON_L:
003876 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
003877 dfe5              rcall   LEFTBRACKET
003878 fd61              sbrc    FLAGS1, fTAILC
003879 c026              rjmp    ADD_RETURN_1
00387a df5a              rcall   IHERE
00387b d02b              rcall   MINUS_FETCH
00387c 018c              movw    t0, tosl
00387d 7f10              andi    t1, 0xf0
00387e 5d10              subi    t1, 0xd0
00387f f059              breq    RCALL_TO_JMP
003880 9189
003881 9199              poptos
003882 d024              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
003883 508e              subi    tosl, 0x0e
                 .endif
003884 4994              sbci    tosh, 0x94
003885 f4c9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
003886 e08c              ldi     tosl, 0x0c
                 .endif
003887 e994              ldi     tosh, 0x94
003888 d9fc              rcall   SWOP
003889 940c 3e31         jmp     STORE
                 RCALL_TO_JMP:
00388b db64              rcall   NIP
00388c 709f              andi    tosh, 0x0f
00388d fd93              sbrc    tosh, 3
00388e 6f90              ori     tosh, 0xf0
00388f da86              rcall   TWOSTAR
003890 df44              rcall   IHERE
003891 da31              rcall   PLUS
003892 df0b              rcall   DOLIT
003893 fffe              .dw     -2
003894 d0e6              rcall   IALLOT
003895 df08              rcall   DOLIT
                 .ifdef EIND
                 .else
003896 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
003897 940e 3f56         call    ICOMMA
003899 5890              sub_pflash_tos
00389a 9488              rampv_to_c
00389b 9597              ror     tosh
00389c 9587              ror     tosl
00389d 940c 3f56         jmp     ICOMMA
                 ADD_RETURN:
00389f d918              rcall   TWODROP
                 ADD_RETURN_1:
0038a0 defd              rcall   DOLIT   ; Compile a ret
0038a1 9508              .dw     0x9508
0038a2 940c 3f56         jmp    ICOMMA
                 
                 
                 
0038a4 f0ec              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
0038a5 2d82
0038a6 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
0038a7 d00c              rcall   TWOMINUS
0038a8 defe              rcall   DUP
0038a9 940c 3e79         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
0038ab f14a              fdw     MINUS_FETCH_L
                 BRACTICK_L:
0038ac 5bd3
0038ad 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
0038ae df0d              rcall   TICK       ; get xt of 'xxx'
0038af 940c 3e05         jmp     LITERAL
                 
                 ; 2-    n -- n-2
0038b1 f158              fdw     BRACTICK_L
                 TWOMINUS_L:
0038b2 32a2
0038b3 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
0038b4 9702              sbiw    tosl, 2
0038b5 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038b6 f164              fdw     TWOMINUS_L
                 BL_l:
0038b7 6282
0038b8 006c              .db     NFA|2,"bl",0
                 BL:
0038b9 940e 30c4         call    DOCREATE
0038bb 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038bc f16e              fdw     BL_L
                 STATE_L:
0038bd 7385
0038be 6174
0038bf 6574              .db     NFA|5,"state"
                 STATE_:
0038c0 939a
0038c1 938a              pushtos
0038c2 9180 01ec         lds     tosl, state
0038c4 9190 01ec         lds     tosh, state
0038c6 9508              ret
                 
                 ; LATEST    -- a-addr           
0038c7 f17a              fdw     STATE_L
                 LATEST_L:
0038c8 6c86
0038c9 7461
0038ca 7365
0038cb 0074              .db     NFA|6,"latest",0
                 LATEST_:
0038cc 940e 30c4         call    DOCREATE
0038ce 01df              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
0038cf f190              fdw     LATEST_L
                 S0_L:
0038d0 7382
0038d1 0030              .db     NFA|2,"s0",0
                 S0:
0038d2 dc04              rcall   DOUSER
0038d3 ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
0038d4 f1a0              fdw     S0_L
                 R0_L:
0038d5 7282
0038d6 0030              .db     NFA|2,"r0",0
                 R0_:
0038d7 dbff              rcall   DOUSER
0038d8 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
0038d9 6983
0038da 696e              .db     NFA|3,"ini"
                 INI:
0038db 940e 30c4          call   DOCREATE
0038dd 01d7              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
0038de f1aa              fdw     R0_L
                 TICKS_L:
0038df 7485
0038e0 6369
0038e1 736b              .db     NFA|5,"ticks"
                 TICKS:
0038e2 939a
0038e3 938a              pushtos
0038e4 b70f              in_     t0, SREG
0038e5 94f8              cli
0038e6 2d8e              mov     tosl, ms_count
0038e7 2d9f              mov     tosh, ms_count1
0038e8 bf0f              out_    SREG, t0
0038e9 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
0038ea f1be              fdw     TICKS_L
                 MS_L:
0038eb 6d82
0038ec 0073              .db     NFA|2,"ms",0
                 MS:
0038ed dff4              rcall   TICKS
0038ee d9d4              rcall   PLUS
                 MS1:    
0038ef d63a              rcall   PAUSE
0038f0 deb6              rcall   DUP
0038f1 dff0              rcall   TICKS
0038f2 d9dd              rcall   MINUS
0038f3 dec1              rcall   ZEROLESS
0038f4 daba              rcall   ZEROSENSE
0038f5 f3c9              breq    MS1
0038f6 940c 327e         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
0038f8 f1d6              fdw     MS_L
                 DOTID_L:
0038f9 2e83
0038fa 6469              .db     NFA|3,".id"
                 DOTID:
0038fb dc48              rcall   CFETCHPP
0038fc dea1              rcall   DOLIT
0038fd 000f              .dw     0x0f
0038fe d9da              rcall   AND_
0038ff d99e              rcall   TOR
003900 c003              rjmp    DOTID3
                 DOTID1:
003901 dc42              rcall   CFETCHPP
003902 d00a              rcall   TO_PRINTABLE
003903 dee7              rcall   EMIT_A
                 DOTID3:
003904 d147              rcall   XNEXT
003905 f7d8              brcc    DOTID1  
003906 911f              pop     t1
003907 910f              pop     t0
003908 940c 327e         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
00390a f1f2              fdw     DOTID_L
                 TO_PRINTABLE_L:
00390b 3e83
00390c 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:   
00390d 3080              cpi     tosl, 0
00390e f012              brmi    TO_PRINTABLE1
00390f 3280              cpi     tosl, 0x20
003910 f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
003911 e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
003912 9508              ret
                 
                  ; WORDS    --          list all words in dict.
003913 f216              fdw     TO_PRINTABLE_L
                 WORDS_L:
003914 7785
003915 726f
003916 7364              .db     NFA|5,"words"
003917 de28              rcall   FALSE_
003918 decd              rcall   CR
003919 de84              rcall   DOLIT
00391a f65c              fdw     kernellink
00391b d005              rcall   WDS1
00391c de23              rcall   FALSE_
00391d dec8              rcall   CR
00391e dec7                      rcall   CR
00391f dfac              rcall   LATEST_
003920 ddbd              rcall   FETCH_A
003921 de85      WDS1:   rcall   DUP
003922 dfd8              rcall   DOTID
003923 dd31              rcall   SWOP_A
003924 d9dc              rcall   ONEPLUS
003925 de81              rcall   DUP
003926 de77              rcall   DOLIT
003927 0007              .dw     7
003928 d9b0              rcall   AND_
003929 da85              rcall   ZEROSENSE
00392a f021              breq    WDS2
00392b de72              rcall   DOLIT
00392c 0009              .dw     9
00392d debd              rcall   EMIT_A
00392e c001              rjmp    WDS3
                 WDS2:   
00392f deb6              rcall   CR
                 WDS3:
003930 dd24              rcall   SWOP_A
                 
003931 df82              rcall   TWOMINUS
003932 ddab              rcall   FETCH_A
003933 da81              rcall   DUPZEROSENSE
003934 f761              brne    WDS1
003935 940c 31b8         jmp     TWODROP
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
003937 f228              fdw     WORDS_L
                 DOTS_L:
003938 2e82
003939 0073              .db     NFA|2,".s",0
                 DOTS:
00393a d894              rcall   SPACE_
00393b de6b              rcall   DUP          ; push tosl:tosh to memory
00393c 940e 30e7         call    SPFETCH
00393e df93              rcall   S0
00393f dd9e              rcall   FETCH_A
003940 df73              rcall   TWOMINUS
                 DOTS1:
003941 d87d              rcall   TWODUP
003942 da01              rcall   LESS
003943 da6b              rcall   ZEROSENSE
003944 f019              breq    DOTS2
003945 df61              rcall   MINUS_FETCH
003946 db23              rcall   UDOT
003947 cff9              rjmp    DOTS1
                 DOTS2:  
003948 d935              rcall   DROP
003949 940c 31b8         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
00394b f270              fdw     DOTS_L
                 DUMP_L:
00394c 6484
00394d 6d75
00394e 0070              .db     NFA|4,"dump",0
                 DUMP:
00394f de4e              rcall   DOLIT
003950 0010              .dw     16
003951 da81              rcall   USLASH
003952 d94b              rcall   TOR
003953 c020              rjmp    DUMP7
                 DUMP1:  
003954 de91              rcall   CR
003955 de51              rcall   DUP
003956 de47              rcall   DOLIT
003957 0004              .dw     4
003958 db1b              rcall   UDOTR
003959 de44              rcall   DOLIT
00395a 003a              .dw     ':'
00395b de8f              rcall   EMIT_A
00395c de41              rcall   DOLIT
00395d 000f              .dw     15
00395e d93f              rcall   TOR
                 DUMP2:
00395f dbe4              rcall   CFETCHPP
003960 de3d              rcall   DOLIT
003961 0002              .dw     2
003962 db11              rcall   UDOTR
003963 d0e8              rcall   XNEXT
003964 f7d0              brcc    DUMP2
003965 911f              pop     t1
003966 910f              pop     t0
                 
003967 de36              rcall   DOLIT
003968 0010              .dw     16
003969 d966              rcall   MINUS
00396a de33              rcall   DOLIT
00396b 000f              .dw     15
00396c d931              rcall   TOR
                 DUMP4:  
00396d dbd6              rcall   CFETCHPP
00396e df9e              rcall   TO_PRINTABLE
00396f de7b              rcall   EMIT_A
003970 d0db              rcall   XNEXT
003971 f7d8              brcc    DUMP4
003972 911f              pop     t1
003973 910f              pop     t0
                 DUMP7:
003974 d0d7              rcall   XNEXT
003975 f6f0              brcc    DUMP1
003976 911f              pop     t1
003977 910f              pop     t0
003978 940c 327e         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
00397a 2081              .db     NFA|1," "
                 IALLOT:
00397b dec0              rcall   IDP
00397c 940c 3322         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
00397e f298              fdw     DUMP_L
                 X_TO_R_L:
00397f 7883
003980 723e              .db     NFA|3,"x>r"
                 X_TO_R:
003981 01fc              movw    zl, tosl
003982 9189
003983 9199              poptos
003984 d009              rcall   TO_XA
003985 9631              adiw    zl, 1
003986 9382              st      -z, tosl
003987 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
003988 9252              st      -z, zero
003989 01cf              movw    tosl, zl
00398a 9508              ret
                 ;***************************************************************
00398b f2fe              fdw     X_TO_R_L
                 TO_XA_L:
00398c 3e83
00398d 6178              .db NFA|3,">xa"
                 TO_XA:
00398e 5890               sub_pflash_tos
00398f 9488               rampv_to_c
003990 9597               ror tosh
003991 9587               ror tosl
003992 9508               ret
                 
003993 f318               fdw     TO_XA_L
                 XA_FROM_L:
003994 7883
003995 3e61              .db NFA|3,"xa>"
                 XA_FROM:
003996 0f88               lsl     tosl
003997 1f99               rol     tosh
003998 5890               add_pflash_tos
003999 9508               ret
                 ;***************************************************************
00399a f328               fdw    XA_FROM_L
                 PFL_L:
00399b 7083
00399c 6c66              .db     NFA|3,"pfl"
                 PFL:
00399d 940e 30c4          call   DOCREATE
00399f 8000              .dw     PFLASH
                 ;***************************************************************
0039a0 f336              fdw    PFL_L
                 ZFL_L:
0039a1 7a83
0039a2 6c66              .db     NFA|3, "zfl"
                 ZFL:
0039a3 940e 30c4          call   DOCREATE
0039a5 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
0039a6 2c84
0039a7 303f
0039a8 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
0039a9 fd65              sbrc    FLAGS1, idup
0039aa c003              rjmp    COMMAZEROSENSE1
0039ab ddf2              rcall   DOLIT
0039ac e75e              fdw     ZEROSENSE
0039ad c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
0039ae d004              rcall   IDPMINUS
0039af ddee              rcall   DOLIT
0039b0 e76a              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
0039b1 7d6f              cbr     FLAGS1, (1<<idup)
0039b2 c070              rjmp    INLINE0
                 
                 IDPMINUS:
0039b3 ddea              rcall   DOLIT
0039b4 fffc              .dw     -4
0039b5 cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
0039b6 d965              rcall   TWOSLASH
0039b7 709f              andi    tosh, 0x0f
0039b8 6c90              ori     tosh, 0xc0
0039b9 940c 3f56         jmp     ICOMMA
                 
                 
                 BRCCC:
0039bb dde2              rcall   DOLIT
0039bc f008              .dw     0xf008      ; brcc pc+2
0039bd 940c 3f56         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
0039bf ddde              rcall   DOLIT
0039c0 f409              .dw     0xf409      ; brne pc+2
0039c1 fd64              sbrc    FLAGS1, izeroeq
0039c2 7f9b              andi    tosh, ~4
0039c3 940c 3f56         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
0039c5 f342              fdw     ZFL_L
                 IF_L:
0039c6 69d2
0039c7 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
0039c8 fd64              sbrc    FLAGS1, izeroeq
0039c9 dfe9              rcall   IDPMINUS
0039ca dfde              rcall   COMMAZEROSENSE
0039cb dff3              rcall   BRNEC
0039cc 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039cd de07              rcall   IHERE
0039ce dd71              rcall   FALSE_
0039cf 940c 39b6         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
0039d1 f38c              fdw     IF_L
                 ELSE_L:
0039d2 65d4
0039d3 736c
0039d4 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
0039d5 ddff              rcall   IHERE
0039d6 dd69              rcall   FALSE_
0039d7 dfde              rcall   RJMPC
0039d8 dc7c              rcall   SWOP_A      ; else-addr  if-addr 
0039d9 940c 39df         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
0039db f3a4              fdw     ELSE_L
                 THEN_L:
0039dc 74d4
0039dd 6568
0039de 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
0039df 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039e0 ddf4              rcall   IHERE
0039e1 d8ad              rcall   OVER
0039e2 d8ed              rcall   MINUS
0039e3 ded0              rcall   TWOMINUS
0039e4 d937              rcall   TWOSLASH
0039e5 ddb8              rcall   DOLIT
0039e6 c000              .dw     0xc000      ;  back-addr mask 
0039e7 d8f9              rcall   OR_
0039e8 dc6c              rcall   SWOP_A
0039e9 940c 3e31         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
0039eb f3b8              fdw     THEN_L
                 BEGIN_L:
0039ec 62d5
0039ed 6765
0039ee 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
0039ef 940c 37d5         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
0039f1 f3d8              fdw     BEGIN_L
                 UNTIL_L:
0039f2 75d5
0039f3 746e
0039f4 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
0039f5 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
0039f6 fd64              sbrc    FLAGS1, izeroeq
0039f7 dfbb              rcall   IDPMINUS
0039f8 dfb0              rcall   COMMAZEROSENSE
0039f9 dfc5              rcall   BRNEC
0039fa 7e6f              cbr     FLAGS1, (1<<izeroeq)
0039fb 940c 3a01         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
0039fd f3e4              fdw     UNTIL_L
                 AGAIN_L:
0039fe 61d5
0039ff 6167
003a00 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
003a01 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a02 ddd2              rcall   IHERE
003a03 d8cc              rcall   MINUS
003a04 deaf              rcall   TWOMINUS
003a05 940c 39b6         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
003a07 f3fc              fdw     AGAIN_L
                 WHILE_L:
003a08 77d5
003a09 6968
003a0a 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
003a0b dfbc              rcall   IF_
003a0c 940c 3285         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
003a0e f410              fdw     WHILE_L
                 REPEAT_L:
003a0f 72d6
003a10 7065
003a11 6165
003a12 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
003a13 dfed              rcall   AGAIN_
003a14 940c 39df         jmp     THEN_
                 
003a16 f41e              fdw     REPEAT_L
                 INLINE_L:
003a17 69d6
003a18 6c6e
003a19 6e69
003a1a 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a1b 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a1c 7d6f              cbr      FLAGS1, (1<<idup)
003a1d dd9e              rcall    TICK
003a1e 940c 3a23         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a20 f42e              fdw      INLINE_L
                 INLINEC_L:
003a21 6983
003a22 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a23 db28              rcall   FETCHPP
003a24 dd82              rcall   DUP
003a25 dd78              rcall   DOLIT
003a26 9508              .dw     0x9508
003a27 d910              rcall   NOTEQUAL
003a28 d986              rcall   ZEROSENSE
003a29 f011              breq    INLINE1
003a2a d52b              rcall   ICOMMA
003a2b cff7              rjmp    INLINE0
                 INLINE1:
003a2c 940c 31b8         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a2e f442              fdw     INLINEC_L
                 FOR_L:
003a2f 66d3
003a30 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a31 940e 30dc         call    DOCOMMAXT
003a33 e53c              fdw     TOR
003a34 dda0              rcall   IHERE
003a35 dd0a              rcall   FALSE_
003a36 df7f              rcall   RJMPC
003a37 dd9d              rcall   IHERE
003a38 940c 3285         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a3a f45e              fdw     FOR_L
                 NEXT_L:
003a3b 6ed4
003a3c 7865
003a3d 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a3e dfa0              rcall   THEN_
003a3f 940e 30dc         call    DOCOMMAXT
003a41 f498              fdw     XNEXT
003a42 df78              rcall   BRCCC
                 
003a43 dfbd              rcall   AGAIN_
                 
003a44 dd59              rcall   DOLIT
003a45 f4aa              fdw     XNEXT1
003a46 940c 3a23         jmp     INLINE0
                 ; (next) decrement top of return stack
003a48 2887
003a49 656e
003a4a 7478
003a4b 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003a4c 91ff              pop     zh
003a4d 91ef              pop     zl
003a4e 91bf              pop     xh
003a4f 91af              pop     xl
003a50 9711              sbiw    xl, 1
003a51 93af              push    xl
003a52 93bf              push    xh
003a53 9409              mijmp
003a54 9508              ret
                 XNEXT1:
003a55 911f              pop     t1
003a56 910f              pop     t0
003a57 9508              ret
                 
                 ; leave clear top of return stack
003a58 f476              fdw     NEXT_L
                 LEAVE_L:
003a59 6595
003a5a 646e
003a5b 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003a5c 91ff              pop     zh
003a5d 91ef              pop     zl
003a5e 911f              pop     t1
003a5f 910f              pop     t0
003a60 2700              clr     t0
003a61 2711              clr     t1
003a62 930f              push    t0
003a63 931f              push    t1
003a64 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003a65 f4b2              fdw      LEAVE_L
                 RDROP_L:
003a66 72d5
003a67 7264
003a68 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003a69 dd34              rcall   DOLIT
003a6a f4aa              fdw     XNEXT1
003a6b 940c 3a23         jmp     INLINE0
                 ;***************************************************
003a6d f4cc              fdw     RDROP_L
                 STOD_L:
003a6e 7383
003a6f 643e              .db     NFA|3,"s>d"
                 STOD:
003a70 ff97              sbrs    tosh, 7
003a71 ccce              rjmp    FALSE_
003a72 ccd6              rjmp    TRUE_
                 ;***************************************************
003a73 f4dc              fdw     STOD_L
                 DNEGATE_L:
003a74 6487
003a75 656e
003a76 6167
003a77 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003a78 d049              rcall   DINVERT
003a79 940e 31f2         call    ONE
003a7b 940c 32cb         jmp     MPLUS
                 ;***************************************************
003a7d f4e8              fdw     DNEGATE_L
                 QDNEGATE_L:
003a7e 3f88
003a7f 6e64
003a80 6765
003a81 7461
003a82 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003a83 dd31              rcall   ZEROLESS
003a84 d92a              rcall   ZEROSENSE
003a85 f009              breq    QDNEGATE1
003a86 dff1              rcall   DNEGATE
                 QDNEGATE1:
003a87 9508              ret
                 
                 ;***************************************************
003a88 f4fc              fdw     QDNEGATE_L
                 DABS_L:
003a89 6484
003a8a 6261
003a8b 0073              .db     NFA|4,"dabs",0
                 DABS:
003a8c dd1a              rcall   DUP
003a8d 940c 3a83         jmp     QDNEGATE
                 ;***************************************************
003a8f f512              fdw     DABS_L
                 DPLUS_L:
003a90 6482
003a91 002b              .db     NFA|2,"d+",0
                 DPLUS:
003a92 91a9              ld      xl, Y+
003a93 91b9              ld      xh, Y+
003a94 91e9              ld      t6, Y+
003a95 91f9              ld      t7, Y+
003a96 9109              ld      t0, Y+
003a97 9119              ld      t1, Y+
003a98 0fa0              add     xl, t0
003a99 1fb1              adc     xh, t1
003a9a 1f8e              adc     tosl, t6
003a9b 1f9f              adc     tosh, t7
003a9c 93ba              st      -Y, xh
003a9d 93aa              st      -Y, xl
003a9e 9508              ret
                 
                 ;***************************************************
003a9f f520              fdw     DPLUS_L
                 DMINUS_L:
003aa0 6482
003aa1 002d              .db     NFA|2,"d-",0
                 DMINUS:
003aa2 dfd5              rcall   DNEGATE
003aa3 940c 3a92         jmp     DPLUS
                 ;***************************************************
003aa5 f540              fdw     DMINUS_L
                 DTWOSLASH_L:
003aa6 6483
003aa7 2f32              .db     NFA|3,"d2/"
003aa8 9109              ld      t0, y+
003aa9 9119              ld      t1, y+
003aaa 9595              asr     tosh
003aab 9587              ror     tosl
003aac 9517              ror     t1
003aad 9507              ror     t0
003aae 931a              st      -y, t1
003aaf 930a              st      -y, t0
003ab0 9508              ret
                 ;***************************************************
003ab1 f54c              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003ab2 6483
003ab3 2a32              .db     NFA|3,"d2*"
003ab4 9109              ld      t0, y+
003ab5 9119              ld      t1, y+
003ab6 0f00              lsl     t0
003ab7 1f11              rol     t1
003ab8 1f88              rol     tosl
003ab9 1f99              rol     tosh
003aba 931a              st      -y, t1
003abb 930a              st      -y, t0
003abc 9508              ret
                 ;***************************************************
003abd f564              fdw     DTWOSTAR_L
                 DINVERT_L:
003abe 6487
003abf 6e69
003ac0 6576
003ac1 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003ac2 91a9              ld      xl, y+
003ac3 91b9              ld      xh, y+
003ac4 95a0              com     xl
003ac5 95b0              com     xh
003ac6 9580              com     tosl
003ac7 9590              com     tosh
003ac8 93ba              st      -y, xh
003ac9 93aa              st      -y, xl
003aca 9508              ret
                 ;***************************************************
003acb f57c              fdw     DINVERT_L
                 DZEROEQUAL_L:
003acc 6483
003acd 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003ace 91a9              ld      xl, y+
003acf 91b9              ld      xh, y+
003ad0 2b89              or      tosl, tosh
003ad1 2b8a              or      tosl, xl
003ad2 2b8b              or      tosl, xh
003ad3 f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003ad4 ef8f              ser     tosl
003ad5 ef9f              ser     tosh
003ad6 9508              ret
                 
                 ;***************************************************
003ad7 f598              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003ad8 6483
003ad9 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003ada 91a9              ld      xl, y+
003adb 91b9              ld      xh, y+
003adc 3090              cpi     tosh, 0
003add f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003ade 2788              clr     tosl
003adf 2799              clr     tosh
003ae0 9508              ret
                 ;***************************************************
003ae1 f5b0              fdw     DZEROLESS_L
                 DEQUAL_L:
003ae2 6482
003ae3 003d              .db     NFA|2,"d=",0
003ae4 dfbd              rcall   DMINUS
003ae5 940c 3ace         jmp     DZEROEQUAL
                 ;***************************************************
003ae7 f5c4              fdw     DEQUAL_L
                 DLESS_L:
003ae8 6482
003ae9 003c              .db     NFA|2,"d<",0
                 DLESS:
003aea dfb7              rcall   DMINUS
003aeb 940c 3ada         jmp     DZEROLESS
                 ;***************************************************
003aed f5d0              fdw     DLESS_L
                 DGREATER_L:
003aee 6482
003aef 003e              .db     NFA|2,"d>",0
                 DGREATER:
003af0 940e 31c6         call    TWOSWAP
003af2 940c 3aea         jmp     DLESS
                 ;***************************************************
003af4 f5dc              fdw     DGREATER_L
                 UDDOT_L:
003af5 7583
003af6 2e64              .db     NFA|3,"ud."
003af7 d933              rcall   LESSNUM
003af8 d953              rcall   NUMS
003af9 d95b              rcall   NUMGREATER
003afa 940e 3239         call    TYPE
003afc 940c 31cf         jmp     SPACE_
                 ;***************************************************
003afe f5ea              fdw     UDDOT_L
                 DDOT_L:
003aff 6482
003b00 002e              .db     NFA|2,"d.",0
003b01 d929              rcall   LESSNUM
003b02 940e 37a7         call    DUP
003b04 940e 329e         call    TOR
003b06 df85              rcall   DABS
003b07 d944              rcall   NUMS
003b08 940e 32a8         call    RFROM
003b0a d955              rcall   SIGN
003b0b d949              rcall   NUMGREATER
003b0c 940e 3239         call    TYPE
003b0e 940c 31cf         jmp     SPACE_
                 ;****************************************************
003b10 f5fe              fdw      DDOT_L
                 MEMHI_L:
003b11 6882
003b12 0069              .db     NFA|2,"hi",0
                 MEMHI:
003b13 dc8a              rcall   DOLIT
003b14 f636              fdw     FLASHHI
003b15 940e 312a         call    CSE_
003b17 940e 32c3         call    PLUS
003b19 940c 3e79         jmp     FETCH
                 FLASHHI:
003b1b deff              .dw      FLASH_HI
003b1c 0cff              .dw      EEPROM_HI
003b1d 08ff              .dw      RAM_HI
                 ;***************************************************
                 
003b1e f622              fdw      MEMHI_L
                 L_FETCH_P:
003b1f 40a2
003b20 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b21 939a
003b22 938a              pushtos
003b23 01ca              movw    tosl, pl
003b24 9508              ret
                 ;***************************************************
003b25 f63e              fdw     L_FETCH_P
                 L_PCFETCH:
003b26 7083
003b27 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b28 939a
003b29 938a              pushtos
003b2a 01ca              movw    tosl, pl
003b2b 940c 3ea3         jmp     CFETCH
                 ;***************************************************
003b2d f64c              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b2e 70a3
003b2f 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b30 0d47              add     pl, r_two
003b31 1d55              adc     ph, zero
003b32 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b33 0000              .dw     0
                 L_MARKER:
                 lastword:
003b34 6d86
003b35 7261
003b36 656b
003b37 0072              .db     NFA|6,"marker",0
                 MARKER:
003b38 940e 310f         call    ROM_
003b3a dcb7              rcall   CREATE
003b3b dc62              rcall   DOLIT
003b3c 0900              .dw     dp_start
003b3d 940e 3134         call    HERE
003b3f dbd8              rcall   TEN
003b40 d9e8              rcall   CMOVE
003b41 dbd6              rcall   TEN
003b42 940e 3277         call    ALLOT
003b44 940e 311d         call    FRAM
003b46 dcfb              rcall   XDOES
003b47 940e 30cc         call    DODOES
003b49 dd91              rcall   INI
003b4a dbcd              rcall   TEN
003b4b 940c 3529         jmp     CMOVE
                 
                 
                 ;;; Enable load led
003b4d df64              fdw     BUSY_L
                 LOADON_L:
003b4e 6c85
003b4f 616f
003b50 2b64              .db     NFA|5,"load+"
003b51 6170              sbr     FLAGS2, (1<<fLOADled)
003b52 9508              ret
                 
                 ;;; Disable load led
003b53 f69c              fdw     LOADON_L
                 LOADOFF_L:
003b54 6c85
003b55 616f
003b56 2d64              .db     NFA|5,"load-"
003b57 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
003b58 9825              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003b59 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003b5a 9508              ret
                 ;;; Enable load led
003b5b f6a8              fdw     LOADOFF_L
                 LOAD_L:
003b5c 6c84
003b5d 616f
003b5e 0064              .db     NFA|4,"load",0
003b5f 939a
003b60 938a              pushtos
003b61 9180 01e8         lds     tosl, load_res
003b63 9190 01e9         lds     tosh, load_res+1
003b65 939a
003b66 938a              pushtos
003b67 9180 01ea         lds     tosl, load_res+2
003b69 2799              clr     tosh
003b6a 939a
003b6b 938a              pushtos
003b6c e080              ldi     tosl, low(CPU_LOAD_VAL)
003b6d ea90              ldi     tosh, high(CPU_LOAD_VAL)
003b6e 940e 33c1         call    UMSLASHMOD
003b70 940c 33f0         jmp     NIP 
                 
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
003b72 0200              .dw      0x0200                ; cse, state
003b73 02a7              .dw      utibbuf-4             ; S0
003b74 026a              .dw      usbuf-1               ; R0
003b75 f914              fdw      OP_TX_
003b76 f966              fdw      OP_RX_
003b77 f9a6              fdw      OP_RXQ
003b78 000a              .dw      BASE_DEFAULT          ; BASE
003b79 02ab              .dw      utibbuf               ; TIB
003b7a fea0              fdw      OPERATOR_AREA         ; TASK
003b7b 0000              .dw      0                     ; ustatus & uflg
003b7c 0000              .dw      0                     ; source
003b7d 0000              .dw      0                     ; source
003b7e 0000              .dw      0                     ; TOIN
003b7f 0209              .dw      up0                   ; Task link
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003b80 fe00              sbrs    t2, PORF
003b81 c003              rjmp    RQ_EXTR
003b82 dc1b              rcall   DOLIT
003b83 0050              .dw     'P'
003b84 dc66              rcall   EMIT_A
                 RQ_EXTR:
003b85 fe01              sbrs    t2, EXTRF
003b86 c003              rjmp    RQ_BORF
003b87 dc16              rcall   DOLIT
003b88 0045              .dw     'E'
003b89 dc61              rcall   EMIT_A
                 RQ_BORF:
003b8a fe02              sbrs    t2, BORF
003b8b c003              rjmp    RQ_WDRF
003b8c dc11              rcall   DOLIT
003b8d 0042              .dw     'B'
003b8e dc5c              rcall   EMIT_A
                 RQ_WDRF:
003b8f fe03              sbrs    t2, WDRF
003b90 c003              rjmp    RQ_DIVZERO
003b91 dc0c              rcall   DOLIT
003b92 0057              .dw     'W'
003b93 dc57              rcall   EMIT_A
                 RQ_DIVZERO:
003b94 fe16              sbrs    t3, 6 ; T bit MATH error
003b95 c003              rjmp    RQ_END
003b96 dc07              rcall   DOLIT
003b97 004d              .dw     'M'
003b98 dc52              rcall   EMIT_A
                 RQ_END: 
003b99 940c 31cf         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
003b9b ff75              sbrs    FLAGS2, fLOAD
003b9c c00d              rjmp    CPU_LOAD_END
003b9d b70f              in_     t0, SREG
003b9e 94f8              cli
003b9f 7d7f              cbr     FLAGS2, (1<<fLOAD)
003ba0 9240 01e8         sts     load_res, loadreg0
003ba2 92c0 01e9         sts     load_res+1,loadreg1
003ba4 92d0 01ea         sts     load_res+2, loadreg2
003ba6 2444              clr     loadreg0
003ba7 24cc              clr     loadreg1
003ba8 24dd              clr     loadreg2
003ba9 bf0f              out_    SREG, t0
                 CPU_LOAD_END:
                 .endif
                 .if CPU_LOAD_LED == 1
003baa ff74              sbrs    FLAGS2, fLOADled
003bab c002              rjmp    LOAD_LED_END
003bac 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003bad 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003bae fd76              sbrc    FLAGS2, fIDLE
003baf c00b              rjmp    IDLE_LOAD1
003bb0 fd77              sbrc    FLAGS2, fBUSY
003bb1 c009              rjmp    IDLE_LOAD1
003bb2 e009              ldi     t0, low(up0)
003bb3 1620              cp      upl, t0
003bb4 f431              brne    IDLE_LOAD1
                 .ifdef SMCR
003bb5 e001              ldi     t0, (1<<SE)
003bb6 bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
003bb7 9250 0081         out_    TCCR1B, zero    ; Stop load counter
                 .endif
003bb9 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003bba be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003bbb fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003bbc 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003bbd 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d58 RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d03b                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d039                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d037                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
003c08 d035                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
003c0a d033                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d031                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
003c0e d02f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
003c10 d02d                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
003c12 d02b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
003c14 d029                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
003c16 d027                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
003c18 d025                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
003c1a d023                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
003c1c c035                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
003c1e d01f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
003c20 d01d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
003c22 d01b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
003c24 d019                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d017                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d015                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
                 .else
003c2a d013                  rcall FF_ISR
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d011                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d00f                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d00d                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d00b                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
003c33 919f              pop     tosh
003c34 918f              pop     tosl
003c35 911f              pop     t1
003c36 910f              pop     t0
003c37 91ff              pop     zh
003c38 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
003c39 91a9              ld      xl, y+
003c3a 91b9              ld      xh, y+
003c3b bfbf              out_    SREG, xh
003c3c 91b9              ld      xh, y+
003c3d 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
003c3e 9260 0081         out_    TCCR1B, r_one   ; Start load counter
                 .endif
                 .endif
003c40 93ba              st      -y, xh
003c41 b7bf              in_     xh, SREG
003c42 93ba              st      -y, xh
003c43 93aa              st      -y, xl
                         m_pop_xh
003c44 91bf              pop     xh
003c45 91af              pop     xl
003c46 93ef              push    zl
003c47 93ff              push    zh
003c48 930f              push    t0
003c49 931f              push    t1
003c4a 938f              push    tosl
003c4b 939f              push    tosh
                 .if low(ivec) == 0x80
003c4c e7bf              ldi     xh, low(ivec-1)
003c4d 0fab              add     xl, xh
                 .else
                 .endif
003c4e e0b1              ldi     xh, high(ivec)
003c4f 91ed              ld      zl, x+
003c50 91fd              ld      zh, x+
003c51 9409              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
003c52 9260 0081         out_    TCCR1B, r_one   ; Start load counter
                 .endif
                 .endif
003c54 93ba              st      -y, xh
003c55 b7bf              in_     xh, SREG
003c56 93ba              st      -y, xh
003c57 93aa              st      -y, xl
003c58 0ce6              add     ms_count,  r_one
003c59 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
                 LOAD_ADD:
003c5a 91a0 0084         in_     xl, TCNT1L
003c5c 91b0 0085         in_     xh, TCNT1H
003c5e 9250 0085         out_    TCNT1H, zero
003c60 9270 0084         out_    TCNT1L, r_two
                 
003c62 0e4a              add     loadreg0, xl
003c63 1ecb              adc     loadreg1, xh
003c64 1cd5              adc     loadreg2, zero
                 
003c65 20ee              tst     ms_count
003c66 f409              brne    LOAD_ADD_END
003c67 6270              sbr     FLAGS2, (1<<fLOAD)
                 LOAD_ADD_END:
                 .endif
003c68 cfd0              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
003c69 ebe7              ldi     zl, low(rbuf0)
003c6a e0f1              ldi     zh, high(rbuf0)
003c6b 91a0 01b4         lds     xl, rbuf0_wr
003c6d 0fea              add     zl, xl
003c6e 1df5              adc     zh, zero
003c6f 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
003c71 30bf              cpi     xh, 0xf
003c72 f409              brne    pc+2
003c73 cf8c              rjmp    RESET_
                 .endif
                 .endif
003c74 83b0              st      z, xh
003c75 95a3              inc     xl
003c76 71af              andi    xl, (RX0_BUF_SIZE-1)
003c77 93a0 01b4         sts     rbuf0_wr, xl
003c79 91a0 01b6         lds     xl, rbuf0_lv
003c7b 95a3              inc     xl
003c7c 93a0 01b6         sts     rbuf0_lv, xl
003c7e 31ae              cpi     xl, RX0_BUF_SIZE-2
003c7f f409              brne    PC+2
003c80 d004              rcall   RX0_OVF
003c81 30a4              cpi     xl, RX0_OFF_FILL
003c82 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c83 d023              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
003c84 cfae              rjmp    FF_ISR_EXIT
                 RX0_OVF:
003c85 e7fc              ldi     zh, '|'
003c86 c022              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
003c87 f6b8              fdw(LOAD_L)
                 TX0_L:
003c88 7483
003c89 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c8a 3181              cpi     tosl, XON
003c8b f071              breq    XXON_TX0_TOS
003c8c 3183              cpi     tosl, XOFF
003c8d f0a1              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c8e 6870              sbr     FLAGS2, (1<<fBUSY)
003c8f d29a              rcall   PAUSE
003c90 9100 00c0         in_     t0, UCSR0A
003c92 ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003c93 cffa              rjmp    TX0_LOOP
003c94 9380 00c6         out_    UDR0_, tosl
003c96 9189
003c97 9199              poptos
003c98 777f              cbr     FLAGS2, (1<<fBUSY)
003c99 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003c9a 9189
003c9b 9199              poptos
003c9c c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003c9d ff70              sbrs    FLAGS2, ixoff_tx0
003c9e 9508              ret
                 XXON_TX0_1:
003c9f 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003ca0 e1f1              ldi     zh, XON
003ca1 c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003ca2 9189
003ca3 9199              poptos
003ca4 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003ca5 fd70              sbrc    FLAGS2, ixoff_tx0
003ca6 9508              ret     
                 XXOFF_TX0_1:
003ca7 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003ca8 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003ca9 91e0 00c0         in_     zl, UCSR0A
003cab ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003cac cffc              rjmp    TX0_SEND
003cad 93f0 00c6         out_    UDR0_, zh
003caf 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003cb0 f910              fdw(TX0_L)
                 RX0_L:
003cb1 7283
003cb2 3078              .db     NFA|3,"rx0"
                 RX0_:
003cb3 d276              rcall   PAUSE
003cb4 d01e              rcall   RX0Q
003cb5 940e 33af         call    ZEROSENSE
003cb7 f3d9              breq    RX0_
003cb8 939a
003cb9 938a              pushtos
003cba ebe7              ldi     zl, low(rbuf0)
003cbb e0f1              ldi     zh, high(rbuf0)
003cbc 91a0 01b5         lds     xl, rbuf0_rd
003cbe 0fea              add     zl, xl
003cbf 1df5              adc     zh, zero
003cc0 8180              ld      tosl, z
003cc1 2799              clr     tosh
003cc2 b70f              in_     t0, SREG
003cc3 94f8              cli
003cc4 95a3              inc     xl
003cc5 71af              andi    xl, (RX0_BUF_SIZE-1)
003cc6 93a0 01b5         sts     rbuf0_rd, xl
003cc8 91a0 01b6         lds     xl, rbuf0_lv
003cca 95aa              dec     xl
003ccb 93a0 01b6         sts     rbuf0_lv, xl
003ccd bf0f              out_    SREG, t0
003cce 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003ccf f962              fdw     RX0_L
                 RX0Q_L:
003cd0 7284
003cd1 3078
003cd2 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003cd3 91a0 01b6         lds     xl, rbuf0_lv
003cd5 11a5              cpse    xl, zero
003cd6 940c 3749         jmp     TRUE_
                 .if U0FC_TYPE == 1
003cd8 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003cd9 940c 3740         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003cdb dc5e              rcall   DOTS
003cdc 940e 3246         call    XSQUOTE
003cde 4103
003cdf 3f44              .db     3,"AD?"
003ce0 940e 3239         call    TYPE
003ce2 ca95              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibasehi != iaddrhi)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003ce3 9380 01e3         sts     iaddrl, tosl
003ce5 9390 01e4         sts     iaddrh, tosh
003ce7 3d9f              cpi     tosh, high(FLASH_HI+1)       ; Dont allow kernel writes
003ce8 f790              brcc    ISTORERR
003ce9 9100 01e3         lds     t0, iaddrl
003ceb 7800              andi    t0, ~(PAGESIZEB-1)
003cec 110a              cpse    t0, ibasel
003ced c005              rjmp    IFILL_BUFFER
003cee 9100 01e4                 lds     t0, iaddrh
003cf0 110b              cpse    t0, ibaseh
003cf1 c001              rjmp    IFILL_BUFFER
003cf2 9508              ret
                 
                 IFILL_BUFFER:
003cf3 d04f              rcall   IFLUSH
003cf4 9100 01e3         lds     t0, iaddrl
003cf6 7800              andi    t0, ~(PAGESIZEB-1)
003cf7 2ea0              mov     ibasel, t0
003cf8 90b0 01e4         lds     ibaseh, iaddrh
                 IFILL_BUFFER_1:
003cfa e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003cfb 01f5              movw    zl, ibasel
003cfc 58f0              sub_pflash_z
003cfd e0a0              ldi     xl, low(ibuf)
003cfe e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003cff 9115              lpm_    t1, z+
003d00 931d              st      x+, t1
003d01 950a              dec     t0
003d02 f7e1              brne    IFILL_BUFFER_2
003d03 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d04 da99              rcall   DOLIT
003d05 0013              .dw     XOFF
003d06 940e 306f         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d08 da95              rcall   DOLIT
003d09 000a              .dw     10
003d0a dbe2              rcall   MS
                         ; Disable interrupts
003d0b 94f8              cli
003d0c 01f5              movw    zl, ibasel
003d0d 58f0              sub_pflash_z
003d0e e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003d0f d028              rcall   DO_SPM
003d10 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003d11 d026              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003d12 e800              ldi     t0, low(PAGESIZEB);init loop variable
003d13 e0a0              ldi     xl, low(ibuf)
003d14 e0b1              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
003d15 900d              ld      r0, x+
003d16 901d              ld      r1, x+
003d17 e011              ldi     t1, (1<<SPMEN)
003d18 d01f              rcall   DO_SPM
003d19 9632              adiw    zl, 2
003d1a 5002              subi    t0, 2
003d1b f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d1c 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d1d 40f0              sbci    zh, high(PAGESIZEB)
003d1e e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d1f d018              rcall   DO_SPM
                         ; re-enable the RWW section
003d20 d011              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d21 e800              ldi     t0, low(PAGESIZEB);init loop variable
003d22 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d23 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d24 9005              lpm_    r0, z+
003d25 901d              ld      r1, x+
003d26 1001              cpse    r0, r1
003d27 c030              rjmp    WARM_     ; reset
003d28 5001              subi    t0, 1
003d29 f7d1              brne    IWRITE_BUFFER2
                 
003d2a 24bb              clr     ibaseh
003d2b 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d2c 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d2d da70              rcall   DOLIT
003d2e 0011              .dw     XON
003d2f 940e 306f         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d31 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d32 b687              in_     t8, SPMCSR
003d33 fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d34 9508              ret
                         ; re-enable the RWW section
003d35 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d36 d001              rcall   DO_SPM
003d37 cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d38 b687              in_     t8, SPMCSR
003d39 fc80              sbrc    t8, SPMEN
003d3a cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d3b bf17              out_    SPMCSR, t1
003d3c 95e8              spm
003d3d 9508              ret
                 
                                 
003d3e fe4e              fdw     PAUSE_L
                 IFLUSH_L:
003d3f 6986
003d40 6c66
003d41 7375
003d42 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d43 fd60              sbrc    FLAGS1, idirty
003d44 cfbf              rjmp    IWRITE_BUFFER
003d45 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d46 f9a0              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d47 6585
003d48 706d
003d49 7974              .db     NFA|5,"empty"
                 EMPTY:
003d4a da53              rcall   DOLIT
003d4b ff4c              fdw     COLDLIT
003d4c da51              rcall   DOLIT
003d4d 0900              .dw     dp_start
003d4e da4f              rcall   DOLIT
003d4f 000c              .dw     coldlitsize
003d50 940e 3529         call    CMOVE
003d52 940c 371c         jmp     DP_TO_RAM
                         
                 ;*******************************************************
003d54 fa8e              fdw     EMPTY_L
                 WARM_L:
003d55 7784
003d56 7261
003d57 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d58 94f8              cli           ; Disable interrupts
003d59 27aa              clr     xl
003d5a 27bb              clr     xh
003d5b e1c9              ldi     yl, 25
003d5c e0d0              ldi     yh, 0
                 WARM_1:
003d5d 93dd              st      x+, yh
003d5e 50c1              subi    yl, 1
003d5f f7e9              brne    WARM_1
                 
003d60 b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d61 b604              in_     t2, MCUSR
003d62 9250 0034         sts     MCUSR, zero
                 .endif
003d64 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d65 925d              st      x+, zero
003d66 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d67 f7e9              brne    WARM_2
003d68 e0c1              ldi     yl, 1
003d69 2e6c              mov     r_one, yl
003d6a e0c2              ldi     yl, 2
003d6b 2e7c              mov     r_two, yl
                 ; Init Stack pointer
003d6c eac7              ldi     yl, low(utibbuf-4)
003d6d e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d6e e60a              ldi     t0, low(usbuf-1)
003d6f e012              ldi     t1, high(usbuf-1)
003d70 bf0d              out     spl, t0
003d71 bf1e              out     sph, t1
                 ; Init user pointer
003d72 e009              ldi     t0, low(up0)
003d73 e012              ldi     t1, high(up0)
003d74 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d75 da28              rcall   DOLIT
003d76 f6e4              fdw     WARMLIT
003d77 da26              rcall   DOLIT
003d78 01eb              .dw     cse
003d79 da24              rcall   DOLIT
003d7a 001c              .dw     warmlitsize
003d7b 940e 3529         call    CMOVE
                 ; init cold data to eeprom
003d7d da20              rcall   DOLIT
003d7e 0900              .dw     dp_start
003d7f d0f9              rcall   FETCH
003d80 d9c8              rcall   TRUE_
003d81 940e 333f         call    EQUAL
003d83 940e 33af         call    ZEROSENSE
003d85 f009              breq    WARM_3  
003d86 dfc3              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d87 be65              out_    MCUCR, r_one   ; (1<<IVCE)
003d88 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
003d89 bc74              out_    TCCR0A, r_two  ; CTC
003d8a e003              ldi     t0, ms_pre_tmr0
003d8b bd05              out_    TCCR0B, t0
003d8c ef09              ldi     t0, ms_value_tmr0
003d8d bd07              out_    OCR0A, t0
003d8e 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
003d90 da0d              rcall   DOLIT
003d91 3c69              .dw     RX0_ISR
003d92 da0b              rcall   DOLIT
                 .ifdef URXC0addr
                 .else
003d93 01a4              .dw     URXCaddr+ivec
                 .endif
003d94 d09c              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, zero
003d95 e607              ldi     t0, ubrr0val
003d96 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003d98 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003d99 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003d9b e006              ldi     t0, (3<<UCSZ00)|URSEL_
003d9c 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003d9e 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d9f d97c              rcall   DP_TO_RAM
003da0 9478              sei
                 
003da1 ddde              rcall   RQ_EMIT
003da2 d023              rcall   VER
                 ; Turnkey ?
003da3 d17f              rcall   TURNKEY
003da4 940e 33af         call    ZEROSENSE
003da6 f0d1              breq    STARTQ2
003da7 940e 3246         call    XSQUOTE
003da9 4503
003daa 4353              .db     3,"ESC"
003dab 940e 3239         call    TYPE
003dad d9f0              rcall   DOLIT
003dae 07d0              .dw     TURNKEY_DELAY
003daf db3d              rcall   MS
003db0 940e 307c         call    KEYQ
003db2 940e 33af         call    ZEROSENSE
003db4 f049              breq    STARTQ1
003db5 940e 3075         call    KEY
003db7 d9e6              rcall   DOLIT
003db8 001b              .dw     0x1b
003db9 940e 333f         call    EQUAL
003dbb 940e 33af         call    ZEROSENSE
003dbd f419              brne    STARTQ2
                 STARTQ1:
003dbe d164              rcall   TURNKEY
003dbf 940e 3084         call    EXECUTE
                 STARTQ2:
003dc1 940c 3778         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
003dc3 faaa              fdw     WARM_L
                 VER_L:
003dc4 7683
003dc5 7265              .db     NFA|3,"ver"
                 VER:
003dc6 940e 3246         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
003dc8 4622
003dc9 616c
003dca 6873
003dcb 6f46
003dcc 7472
003dcd 2068
003dce 5441
003dcf 656d
003dd0 6167
003dd1 3233
003dd2 5038
003dd3 3120
003dd4 2e30
003dd5 3130
003dd6 322e
003dd7 3130
003dd8 0d35
F:\avr\src\ff-atmega.asm(5288): warning: .cseg .db misalignment - padding zero byte
003dd9 000a                      .db     partlen+datelen+14,"FlashForth ",partstring," ", DATE,0xd,0xa
003dda 940c 3239         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003ddc fb88              fdw     VER_L
                 EI_L:
003ddd 65a2
003dde 0069              .db     NFA|INLINE|2,"ei",0
003ddf 9478              sei
003de0 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003de1 fbba              fdw     EI_L
                 DI_L:
003de2 64a2
003de3 0069              .db     NFA|INLINE|2,"di",0
003de4 94f8              cli
003de5 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003de6 fbc4              fdw     DI_L
                 IRQ_SEMI_L:
003de7 3bc2
003de8 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003de9 d9b4              rcall   DOLIT
                 .ifdef EIND
                 .else
003dea 940c              .dw     0x940C     ; jmp
                 .endif
003deb d16a              rcall   ICOMMA
003dec d9b1              rcall   DOLIT
003ded 3c33              .dw     FF_ISR_EXIT
003dee d167              rcall   ICOMMA
003def 940c 385d         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003df1 fbce              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003df2 6984
003df3 746e
003df4 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003df5 01fc              movw    zl, tosl
003df6 9731              sbiw    zl, 1
003df7 0fee              lsl     zl
                 .if low(ivec) == 0x80
003df8 e8f0                      ldi     zh, low(ivec)
003df9 0fef                      add     zl,  zh
                 .endif
003dfa e0f1              ldi     zh, high(ivec)
003dfb 9189
003dfc 9199              poptos
003dfd db90              rcall   TO_XA
003dfe 940c 3e36         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003e00 fbe4              fdw     IRQ_V_L
                 LITERAL_L:
003e01 6cc7
003e02 7469
003e03 7265
003e04 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003e05 d998              rcall   DOLIT
003e06 ef4e              fdw     DUP
003e07 dc1b              rcall   INLINE0
003e08 940e 37a7         call    DUP
003e0a 2f98              mov     tosh, tosl
003e0b 9592              swap    tosh
003e0c 709f              andi    tosh, 0xf
003e0d 708f              andi    tosl, 0xf
003e0e 6e90              ori     tosh, 0xe0
003e0f 6880              ori     tosl, 0x80
003e10 d145              rcall   ICOMMA
003e11 2f89              mov     tosl, tosh
003e12 9592              swap    tosh
003e13 709f              andi    tosh, 0xf
003e14 708f              andi    tosl, 0xf
003e15 6e90              ori     tosh, 0xe0
003e16 6980              ori     tosl, 0x90
003e17 940c 3f56         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e19 d039              rcall   LOCKEDQ
003e1a dec8              rcall   IUPDATEBUF
003e1b 9189
003e1c 9199              poptos
003e1d e0a0              ldi     xl, low(ibuf)
003e1e e0b1              ldi     xh, high(ibuf)
003e1f 9100 01e3         lds     t0, iaddrl
003e21 770f              andi    t0, (PAGESIZEB-1)
003e22 0fa0              add     xl, t0
003e23 938d              st      x+, tosl
003e24 939d              st      x+, tosh
003e25 9189
003e26 9199              poptos
003e27 6061              sbr     FLAGS1, (1<<idirty)
003e28 9508              ret
                 
003e29 fc02              fdw     LITERAL_L
                 TO_A_L:
003e2a 3e82
003e2b 0061              .db     NFA|2, ">a",0
003e2c eee1              ldi     zl, low(areg)
003e2d e0f1              ldi     zh, high(areg)
003e2e c007              rjmp    STORE_RAM_2
                 
003e2f fc54              fdw     TO_A_L
                 STORE_L:
003e30 2181              .db     NFA|1, "!"
                 STORE:
003e31 3099              cpi     tosh, high(PEEPROM)
003e32 f440              brcc    STORE1
                 STORE_RAM:
003e33 01fc              movw    zl, tosl
003e34 9189
003e35 9199              poptos
                 STORE_RAM_2:
003e36 8391              std     Z+1, tosh
003e37 8380              std     Z+0, tosl
003e38 9189
003e39 9199              poptos
003e3a 9508              ret
                 STORE1:
003e3b 3890              cpi     tosh, high(OFLASH)
003e3c f6e0              brcc    ISTORE
                 ESTORE:
003e3d d015              rcall   LOCKEDQ
003e3e 99f9              sbic    eecr, eewe
003e3f cffd              rjmp    ESTORE
003e40 5099              subi    tosh, high(PEEPROM)
003e41 bd81              out     eearl, tosl
003e42 bd92              out     eearh, tosh
003e43 9189
003e44 9199              poptos
003e45 bd80              out     eedr, tosl
003e46 9afa              sbi     eecr, eemwe
003e47 9af9              sbi     eecr, eewe
                 
                 ESTORE1:
003e48 99f9              sbic    eecr, eewe
003e49 cffe              rjmp    ESTORE1
                 
003e4a b581              in      tosl, eearl
003e4b 9583              inc     tosl
003e4c bd81              out     eearl, tosl
                 
003e4d bd90              out     eedr, tosh
003e4e 9afa              sbi     eecr, eemwe
003e4f 9af9              sbi     eecr, eewe
                 
003e50 9189
003e51 9199              poptos
003e52 9508              ret
                 LOCKEDQ:
003e53 ff62              sbrs    FLAGS1, fLOCK
003e54 9508              ret
003e55 dae4              rcall   DOTS
003e56 940e 3246         call    XSQUOTE
003e58 4103
003e59 3f44              .db     3,"AD?"
003e5a 940e 3239         call    TYPE
003e5c cf64              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e5d 01fc              movw    z, tosl
003e5e 11fb              cpse    zh, ibaseh
003e5f c00b              rjmp    IIFETCH
003e60 2f0e              mov     t0, zl
003e61 7800              andi    t0, ~(PAGESIZEB-1)
003e62 150a              cp      t0, ibasel
003e63 f439              brne    IIFETCH
003e64 e0a0              ldi     xl, low(ibuf)
003e65 e0b1              ldi     xh, high(ibuf)
003e66 77ef              andi    zl, (PAGESIZEB-1)
003e67 0fae              add     xl, zl
003e68 918d              ld      tosl, x+
003e69 919d              ld      tosh, x+
003e6a 9508              ret
                 IIFETCH:
003e6b 58f0              sub_pflash_z
003e6c 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e6d 9195              lpm_    tosh, z+
                 .ifdef RAMPZ
                 .endif
003e6e 9508              ret
                                 
003e6f fc60              fdw     STORE_L
                 A_FROM_L:
003e70 6182
003e71 003e              .db     NFA|2, "a>",0
003e72 939a
003e73 938a              pushtos
003e74 eee1              ldi     zl, low(areg)
003e75 e0f1              ldi     zh, high(areg)
003e76 c005              rjmp    FETCH_RAM_2
                 
003e77 fce0              fdw     A_FROM_L
                 FETCH_L:
003e78 4081              .db     NFA|1, "@"
                 FETCH:
003e79 3099              cpi     tosh, high(PEEPROM)
003e7a f420              brcc    FETCH1
                 FETCH_RAM:
003e7b 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e7c 9181              ld      tosl, z+
003e7d 9191              ld      tosh, z+
003e7e 9508              ret
                 FETCH1:
003e7f 3890              cpi     tosh, high(OFLASH)
003e80 f6e0              brcc    IFETCH
                 EFETCH:
003e81 99f9              sbic    eecr, eewe
003e82 cffe              rjmp    EFETCH
003e83 5099              subi    tosh, high(PEEPROM)
003e84 bd81              out     eearl, tosl
003e85 bd92              out     eearh, tosh
003e86 9af8              sbi     eecr, eere
003e87 b580              in      tosl, eedr
003e88 b591              in      tosh, eearl
003e89 9593              inc     tosh
003e8a bd91              out     eearl, tosh
003e8b 9af8              sbi     eecr, eere
003e8c b590              in      tosh, eedr
003e8d 9508              ret
                 
                 ICFETCH:
003e8e 01fc              movw    z, tosl
003e8f 11fb              cpse    zh, ibaseh
003e90 c00b              rjmp    IICFETCH
003e91 2f0e              mov     t0, zl
003e92 7800              andi    t0, ~(PAGESIZEB-1)
003e93 150a              cp      t0, ibasel
003e94 f439              brne    IICFETCH
003e95 e0a0              ldi     xl, low(ibuf)
003e96 e0b1              ldi     xh, high(ibuf)
003e97 77ef              andi    zl, (PAGESIZEB-1)
003e98 0fae              add     xl, zl
003e99 918d              ld      tosl, x+
003e9a 2799              clr     tosh
003e9b 9508              ret
                 IICFETCH:
003e9c 58f0              sub_pflash_z
003e9d 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e9e 2799              clr     tosh
                 .ifdef RAMPZ
                 .endif
003e9f 9508              ret
                 
003ea0 fcf0              fdw     FETCH_L
                 CFETCH_L:
003ea1 6382
003ea2 0040              .db     NFA|2, "c@",0
                 CFETCH:
003ea3 3099              cpi     tosh, high(PEEPROM)
003ea4 f420              brcc    CFETCH1
                 CFETCH_RAM:
003ea5 01fc              movw    zl, tosl
003ea6 9181              ld      tosl, z+
003ea7 2799              clr     tosh
003ea8 9508              ret
                 CFETCH1:
003ea9 3890              cpi     tosh, high(OFLASH)
003eaa f718              brcc    ICFETCH
                 ECFETCH:
003eab 99f9              sbic    eecr, eewe
003eac cffe              rjmp    ECFETCH
003ead 5099              subi    tosh, high(PEEPROM)
003eae bd81              out     eearl, tosl
003eaf bd92              out     eearh, tosh
003eb0 9af8              sbi     eecr, eere
003eb1 b580              in      tosl, eedr
003eb2 2799              clr     tosh
003eb3 9508              ret
                 
                 ICSTORE:
003eb4 df9e              rcall   LOCKEDQ
003eb5 de2d              rcall   IUPDATEBUF
003eb6 9189
003eb7 9199              poptos
003eb8 e0a0              ldi     xl, low(ibuf)
003eb9 e0b1              ldi     xh, high(ibuf)
003eba 9100 01e3         lds     t0, iaddrl
003ebc 770f              andi    t0, (PAGESIZEB-1)
003ebd 0fa0              add     xl, t0
003ebe 938d              st      x+, tosl
003ebf 9189
003ec0 9199              poptos
003ec1 6061              sbr     FLAGS1, (1<<idirty)
003ec2 9508              ret
                 
003ec3 fd42              fdw     CFETCH_L
                 CSTORE_L:
003ec4 6382
003ec5 0021              .db     NFA|2, "c!",0
                 CSTORE:
003ec6 3099              cpi     tosh, high(PEEPROM)
003ec7 f438              brcc    CSTORE1
                 CSTORE_RAM:
003ec8 01fc              movw zl, tosl
003ec9 9189
003eca 9199              poptos
003ecb 8380              std Z+0, tosl
003ecc 9189
003ecd 9199              poptos
003ece 9508              ret
                 CSTORE1:
003ecf 3890              cpi     tosh, high(OFLASH)
003ed0 f718              brcc    ICSTORE
                 ECSTORE:
003ed1 df81              rcall   LOCKEDQ
003ed2 99f9              sbic    eecr, eewe
003ed3 cffd              rjmp    ECSTORE
003ed4 5099              subi    tosh, high(PEEPROM)
003ed5 bd81              out     eearl, tosl
003ed6 bd92              out     eearh, tosh
003ed7 9189
003ed8 9199              poptos
003ed9 bd80              out     eedr, tosl
003eda 9afa              sbi     eecr, eemwe
003edb 9af9              sbi     eecr, eewe
003edc 9189
003edd 9199              poptos
003ede 9508              ret
                 
                 ;;; Disable writes to flash and eeprom
003edf fd88              fdw     CSTORE_L
                 
                 FLOCK_L:
003ee0 6683
003ee1 2d6c              .db     NFA|3,"fl-"
003ee2 6064              sbr     FLAGS1, (1<<fLOCK)
003ee3 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003ee4 fdc0              fdw     FLOCK_L
                 FUNLOCK_L:
003ee5 6683
003ee6 2b6c              .db     NFA|3,"fl+"
003ee7 7f6b              cbr     FLAGS1, (1<<fLOCK)
003ee8 9508              ret
                 
                 
                 
003ee9 fdca              fdw     FUNLOCK_L
                 VALUE_L:
003eea 7685
003eeb 6c61
003eec 6575              .db     NFA|5,"value"
                 VALUE:
003eed d904              rcall   CREATE
003eee 940e 3139         call    COMMA
003ef0 d951              rcall   XDOES
                 VALUE_DOES:
003ef1 940e 30cc         call    DODOES
003ef3 940c 3e79         jmp     FETCH
                 
003ef5 fdd4              fdw     VALUE_L
                 DEFER_L:
003ef6 6485
003ef7 6665
003ef8 7265              .db     NFA|5,"defer"
                 DEFER:
003ef9 d8f8              rcall   CREATE
003efa 940e 379e         call    DOLIT
003efc eef0              fdw     ABORT
003efd 940e 3139         call    COMMA
003eff d942              rcall   XDOES
                 DEFER_DOES:
003f00 940e 30cc         call    DODOES
003f02 940c 308f         jmp     FEXECUTE
                 
003f04 fdec              fdw     DEFER_L
                 IS_L:
003f05 69c2
003f06 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003f07 940e 37bc         call    TICK
003f09 940e 330b         call    TWOPLUS
003f0b 940e 330b         call    TWOPLUS
003f0d df6b              rcall   FETCH
003f0e d9b1              rcall   STATE_
003f0f 940e 33af         call    ZEROSENSE
003f11 f029              breq    IS1
003f12 def2              rcall   LITERAL
003f13 940e 30dc         call    DOCOMMAXT
003f15 fc62              fdw     STORE
003f16 c001              rjmp    IS2
                 IS1:
003f17 df19              rcall   STORE
                 IS2:
003f18 9508              ret
                 
003f19 fe0a              fdw     IS_L
                 TO_L:
003f1a 74c2
003f1b 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003f1c 940c 3f07         jmp     IS
                 
003f1e fe34              fdw     TO_L
                 TURNKEY_L:
003f1f 7487
003f20 7275
003f21 6b6e
003f22 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003f23 940e 3ef1         call    VALUE_DOES      ; Must be call for IS to work.
003f25 01d7              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003f26 fe3e              fdw     TURNKEY_L
                 PAUSE_L:
003f27 7085
003f28 7561
003f29 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003f2a dc70              rcall   IDLE_LOAD
                 .endif
003f2b b71f              in_     t1, SREG
003f2c 94f8              cli
003f2d 93df              push    yh        ; SP
003f2e 93cf              push    yl
003f2f 939f              push    tosh      ; TOS
003f30 938f              push    tosl
003f31 935f              push    ph        ; P
003f32 934f              push    pl
003f33 01f1              movw    zl, upl
003f34 b70e              in      t0, sph
003f35 9302              st      -z, t0
003f36 b70d              in      t0, spl
003f37 9302              st      -z, t0
003f38 91b2              ld      xh, -z     ; UP
003f39 91a2              ld      xl, -z
003f3a 011d              movw    upl, xl
003f3b 910e              ld      t0, -x
003f3c bf0e              out     sph, t0
003f3d 910e              ld      t0, -x
003f3e bf0d              out     spl, t0
003f3f 914f              pop     pl
003f40 915f              pop     ph
003f41 918f              pop     tosl
003f42 919f              pop     tosh
003f43 91cf              pop     yl
003f44 91df              pop     yh
003f45 bf1f              out_    SREG, t1
003f46 9508              ret
                 
                 
003f47 fa7e              fdw     IFLUSH_L
                 OPERATOR_L:
003f48 6f88
003f49 6570
003f4a 6172
003f4b 6f74
003f4c 0072              .db     NFA|8,"operator",0
                 OPERATOR:
003f4d 940e 30c4         call    DOCREATE
003f4f fea0              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
003f50 0209              .dw     up0
003f51 6000              .db     0, ursize
003f52 6040              .db     ussize, utibsize
                 
003f53 fe90              fdw     OPERATOR_L
                 ICOMMA_L:
003f54 6982
003f55 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f56 940e 37d5         call    IHERE
003f58 ded8              rcall   STORE
003f59 940e 314a         call    CELL
003f5b 940c 397b         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f5d fea8              fdw     ICOMMA_L
                 ICCOMMA_L:
003f5e 6983
003f5f 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f60 940e 37d5         call    IHERE
003f62 df63              rcall   CSTORE
003f63 940e 31f2         call    ONE
003f65 940c 397b         jmp     IALLOT
                 
                 L_DOTBASE:
003f67 2081              .db      NFA|1," "
                 DOTBASE:
003f68 940e 34ca         call    BASE
003f6a df0e              rcall   FETCH
003f6b 3180              cpi     tosl, 0x10
003f6c f411              brne    DOTBASE1
003f6d e284              ldi     tosl,'$'
003f6e c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f6f 308a              cpi     tosl, 0xa
003f70 f411              brne    DOTBASE2
003f71 e283              ldi     tosl, '#'
003f72 c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f73 3082              cpi     tosl, 0x2
003f74 f411              brne    DOTBASE3
003f75 e285              ldi     tosl, '%'
003f76 c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f77 e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f78 9508              ret
                 
                 MEMQADDR_N:
003f79 e218              fdw     ROM_N
003f7a e226              fdw     EROM_N
003f7b e236              fdw     FRAM_N
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
003f7c 2081              .db     NFA|1," "
                 MEMQ:
003f7d 940e 312a         call    CSE_
003f7f 940e 379e         call    DOLIT
003f81 fef2              fdw     MEMQADDR_N
003f82 940e 32c3         call    PLUS
003f84 940e 36de         call    FETCH_A
003f86 940e 3544         call    CFETCHPP
003f88 940e 379e         call    DOLIT
003f8a 000f              .dw     NFAmask
003f8b 940c 32d9         jmp     AND_
                 
                 ;*******************************************************
                 umstar0:
003f8d 920f              push t2
003f8e 921f              push t3
003f8f 9109              ld  t0, Y+
003f90 9119              ld  t1, Y+
003f91 9f80              mul tosl,t0
003f92 01d0              movw t4, r0 ; r0=t2, r1=t3
003f93 27ee              clr t6
003f94 27ff              clr t7
003f95 9f90              mul tosh, t0
003f96 0db0              add t5, r0
003f97 1de1              adc t6, r1
003f98 1df5              adc t7, zero
003f99 9f81              mul tosl, t1
003f9a 0db0              add t5, r0
003f9b 1de1              adc t6, r1
003f9c 1df5              adc t7, zero
003f9d 9f91              mul tosh, t1
003f9e 0de0              add t6, r0
003f9f 1df1              adc t7, r1
003fa0 93ba              st -Y, t5
003fa1 93aa              st -Y, t4
003fa2 01cf              movw tosl, t6
003fa3 901f              pop t3
003fa4 900f              pop t2
003fa5 9508              ret
                 
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 .equ coldlitsize=12
                 ;.section user_eedata
                 COLDLIT:
003fa6 0000      STARTV: .dw      0
003fa7 8000      DPC:    .dw      OFLASH
003fa8 090c      DPE:    .dw      ehere
003fa9 030b      DPD:    .dw      dpdata
003faa f668      LW:     fdw      lastword
003fab ee04      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  16 r1 :  17 r2 :   5 r3 :   1 r4 :   3 r5 :  17 r6 :   6 r7 :   7 
r8 :   4 r9 :   4 r10:   6 r11:   5 r12:   3 r13:   3 r14:   3 r15:   2 
r16: 124 r17:  52 r18:   0 r19:   0 r20:  14 r21:   7 r22:  34 r23:  18 
r24: 216 r25: 180 r26:  62 r27:  46 r28:   9 r29:   5 r30:  73 r31:  52 
x  :  17 y  : 181 z  :  33 
Registers used: 33 out of 35 (94.3%)

ATmega328P instruction use summary:
.lds  :   0 .sts  :   0 adc   :  18 add   :  19 adiw  :   9 and   :   3 
andi  :  20 asr   :   2 bclr  :   4 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  20 brcs  :   1 break :   0 breq  :  44 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   6 
brne  :  38 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  92 cbi   :   3 cbr   :  21 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :  24 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   7 cp    :   4 cpc   :   2 
cpi   :  23 cpse  :   6 dec   :   3 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  14 in    :  19 inc   :   6 jmp   : 163 
ld    : 125 ldd   :   2 ldi   :  68 lds   :  22 lpm   :   9 lsl   :  11 
lsr   :   2 mov   :  14 movw  :  38 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   7 ori   :   7 out   :  32 pop   :  82 
push  :  28 rcall : 980 ret   : 126 reti  :   1 rjmp  :  96 rol   :  15 
ror   :  18 sbc   :   2 sbci  :   3 sbi   :  11 sbic  :   5 sbis  :   0 
sbiw  :   8 sbr   :  18 sbrc  :  14 sbrs  :  16 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   6 ses   :   0 set   :   1 sev   :   0 
sez   :   0 sleep :   1 spm   :   2 st    :  84 std   :   3 sts   :  26 
sub   :   2 subi  :  21 swap  :   2 tst   :   4 wdr   :   0 
Instructions used: 71 out of 113 (62.8%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007f58   5606   2494   8100   32768  24.7%
[.dseg] 0x000100 0x00030d      0    525    525    2048  25.6%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 8 warnings
