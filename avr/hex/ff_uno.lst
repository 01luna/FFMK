
AVRASM ver. 2.1.30  avr/src/ff-atmega.asm Sun Jan 08 13:02:32 2017

avr/src/ff-atmega.asm(34): Including file 'avr/src/config.inc'
avr/src/config.inc(8): Including file 'avrasm2/inc\m328pdef.inc'
avr/src/ff-atmega.asm(78): warning: Register r26 already defined by the .DEF directive
avr/src/ff-atmega.asm(79): warning: Register r27 already defined by the .DEF directive
avr/src/ff-atmega.asm(80): warning: Register r30 already defined by the .DEF directive
avr/src/ff-atmega.asm(81): warning: Register r31 already defined by the .DEF directive
avr/src/ff-atmega.asm(244): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
avr/src/ff-atmega.asm(245): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
avr/src/ff-atmega.asm(246): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
                 
                 
                 ;                                                                     *
                 ;    Filename:      FlashForth.asm                                    *
                 ;    Date:          07.01.2017                                        *
                 ;    File Version:  5.0                                               *
                 ;    MCU:           Atmega                                            *
                 ;    Copyright:     Mikael Nordman                                    *
                 ;    Author:        Mikael Nordman                                    *
                 ;                                                                     * 
                 ;**********************************************************************
                 ; FlashForth is a standalone Forth system for microcontrollers that
                 ; can flash their own flash memory.
                 ;
                 ; Copyright (C) 2016  Mikael Nordman
                 
                 ; This program is free software: you can redistribute it and/or modify
                 ; it under the terms of the GNU General Public License version 3 as 
                 ; published by the Free Software Foundation.
                 ;
                 ; This program is distributed in the hope that it will be useful,
                 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                 ; GNU General Public License for more details.
                 ;
                 ; You should have received a copy of the GNU General Public License
                 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                 ;
                 ; Modified versions of FlashForth must be clearly marked as such, 
                 ; in the name of this file, and in the identification
                 ; displayed when FlashForth starts.
                 ;**********************************************************************
                 
                 ; Include the FlashForth configuration file
                 .include "config.inc"
                 
                 
                 ; Select the include file for your micro controller
                 ;.include "m2561def.inc"  ; 
                 ;.include "m2560def.inc"  ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m128def.inc"   ; Tested     Fuses: E:0xff H:0xdc L:0xff
                 ;.include "m168pdef.inc"
                 .include "m328pdef.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega328P.xml **********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m328Pdef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega328P
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega328P
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M328PDEF_INC_
                 #define _M328PDEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega328P
                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x0f
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                 .equ	PRR	= 0x64	; MEMORY MAPPED
                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	SMCR	= 0x33
                 .equ	ACSR	= 0x30
                 .equ	SPDR	= 0x2e
                 .equ	SPSR	= 0x2d
                 .equ	SPCR	= 0x2c
                 .equ	GPIOR2	= 0x2b
                 .equ	GPIOR1	= 0x2a
                 .equ	OCR0B	= 0x28
                 .equ	OCR0A	= 0x27
                 .equ	TCNT0	= 0x26
                 .equ	TCCR0B	= 0x25
                 .equ	TCCR0A	= 0x24
                 .equ	GTCCR	= 0x23
                 .equ	EEARH	= 0x22
                 .equ	EEARL	= 0x21
                 .equ	EEDR	= 0x20
                 .equ	EECR	= 0x1f
                 .equ	GPIOR0	= 0x1e
                 .equ	EIMSK	= 0x1d
                 .equ	EIFR	= 0x1c
                 .equ	PCIFR	= 0x1b
                 .equ	TIFR2	= 0x17
                 .equ	TIFR1	= 0x16
                 .equ	TIFR0	= 0x15
                 .equ	PORTD	= 0x0b
                 .equ	DDRD	= 0x0a
                 .equ	PIND	= 0x09
                 .equ	PORTC	= 0x08
                 .equ	DDRC	= 0x07
                 .equ	PINC	= 0x06
                 .equ	PORTB	= 0x05
                 .equ	DDRB	= 0x04
                 .equ	PINB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                 .equ	U2X0	= 1	; Double the USART transmission speed
                 .equ	UPE0	= 2	; Parity Error
                 .equ	DOR0	= 3	; Data overRun
                 .equ	FE0	= 4	; Framing Error
                 .equ	UDRE0	= 5	; USART Data Register Empty
                 .equ	TXC0	= 6	; USART Transmitt Complete
                 .equ	RXC0	= 7	; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ	TXB80	= 0	; Transmit Data Bit 8
                 .equ	RXB80	= 1	; Receive Data Bit 8
                 .equ	UCSZ02	= 2	; Character Size
                 .equ	TXEN0	= 3	; Transmitter Enable
                 .equ	RXEN0	= 4	; Receiver Enable
                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ	UCPOL0	= 0	; Clock Polarity
                 .equ	UCSZ00	= 1	; Character Size
                 .equ	UCPHA0	= UCSZ00	; For compatibility
                 .equ	UCSZ01	= 2	; Character Size
                 .equ	UDORD0	= UCSZ01	; For compatibility
                 .equ	USBS0	= 3	; Stop Bit Select
                 .equ	UPM00	= 4	; Parity Mode Bit 0
                 .equ	UPM01	= 5	; Parity Mode Bit 1
                 .equ	UMSEL00	= 6	; USART Mode Select
                 .equ	UMSEL0	= UMSEL00	; For compatibility
                 .equ	UMSEL01	= 7	; USART Mode Select
                 .equ	UMSEL1	= UMSEL01	; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ	TWAM0	= 1	; 
                 .equ	TWAMR0	= TWAM0	; For compatibility
                 .equ	TWAM1	= 2	; 
                 .equ	TWAMR1	= TWAM1	; For compatibility
                 .equ	TWAM2	= 3	; 
                 .equ	TWAMR2	= TWAM2	; For compatibility
                 .equ	TWAM3	= 4	; 
                 .equ	TWAMR3	= TWAM3	; For compatibility
                 .equ	TWAM4	= 5	; 
                 .equ	TWAMR4	= TWAM4	; For compatibility
                 .equ	TWAM5	= 6	; 
                 .equ	TWAMR5	= TWAM5	; For compatibility
                 .equ	TWAM6	= 7	; 
                 .equ	TWAMR6	= TWAM6	; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ	FOC1B	= 6	; 
                 .equ	FOC1A	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	TOIE2A	= TOIE2	; For compatibility
                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ	WGM20	= 0	; Waveform Genration Mode
                 .equ	WGM21	= 1	; Waveform Genration Mode
                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM22	= 3	; Waveform Generation Mode
                 .equ	FOC2B	= 6	; Force Output Compare B
                 .equ	FOC2A	= 7	; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                 .equ	EXCLK	= 6	; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PSR2	= PSRASY	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                 .equ	ACME	= 6	; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ	ADC0D	= 0	; 
                 .equ	ADC1D	= 1	; 
                 .equ	ADC2D	= 2	; 
                 .equ	ADC3D	= 3	; 
                 .equ	ADC4D	= 4	; 
                 .equ	ADC5D	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCROA_0	= 0	; 
                 .equ	OCROA_1	= 1	; 
                 .equ	OCROA_2	= 2	; 
                 .equ	OCROA_3	= 3	; 
                 .equ	OCROA_4	= 4	; 
                 .equ	OCROA_5	= 5	; 
                 .equ	OCROA_6	= 6	; 
                 .equ	OCROA_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PSR10	= PSRSYNC	; For compatibility
                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ	INTF0	= 0	; External Interrupt Flag 0
                 .equ	INTF1	= 1	; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SELFPRGEN	= 0	; Self Programming Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	IVCE	= 0	; 
                 .equ	IVSEL	= 1	; 
                 .equ	PUD	= 4	; 
                 .equ	BODSE	= 5	; BOD Sleep Enable
                 .equ	BODS	= 6	; BOD Sleep
                 
                 ; MCUSR - MCU Status Register
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	EXTREF	= EXTRF	; For compatibility
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; SMCR - Sleep Mode Control Register
                 .equ	SE	= 0	; Sleep Enable
                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSART0	= 1	; Power Reduction USART
                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                 .equ	PRTWI	= 7	; Power Reduction TWI
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock output
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select reset vector
                 .equ	BOOTSZ0	= 1	; Select boot size
                 .equ	BOOTSZ1	= 2	; Select boot size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	WDTON	= 4	; Watchdog Timer Always On
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	DWEN	= 6	; debugWIRE Enable
                 .equ	RSTDISBL	= 7	; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x00ff
                 .equ	SRAM_START	= 0x0100
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x08ff
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                 
                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                 
                 #endif  /* _M328PDEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;.include "m328def.inc"   ; Tested    Fuses: E:0xff H:0xda L:0xff
                 ;.include "m32adef.inc"
                 ;.include "m644pdef.inc"
                 
                 ; Oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ; Define the UART used for the operator
                 .equ OPERATOR_UART = 0              ; 0 or 1
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is to use XON/XOFF flow control and 1 ms intercharacter delay in the terminal program. Or use the ff-shell.py which adds CR LF flow control.
                 .equ BAUDRATE0 = 9600               ; Serial baudrate UART0
                 .equ U0FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U0RTS_PORT = portd
                 .equ U0RTS_DDR = ddrd
                 .equ U0RTS_BIT = 3
                 
                 ;;; UART1 configuration
                 .equ BAUDRATE1= 38400               ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT = portd
                 .equ U1RTS_DDR = ddrd
                 .equ U1RTS_BIT = 4
                 
                 ; Default number base
                 .equ BASE_DEFAULT = 10      ; 16 = hexadecimal, 10 = decimal
                 
                 ; Set to 1 for power save when CPU is idle
                 .equ IDLE_MODE = 1
                 
                 ; Enable the cpu load measurement. Uses Timer 1. Needs IDLE_MODE = 1
                 .equ CPU_LOAD = 0
                 
                 ; CPU load indicator led definitions. Needs IDLE_MODE = 1
                 .equ CPU_LOAD_LED = 1            ; set to 1 to enable
                 .equ CPU_LOAD_DDR = ddrb
                 .equ CPU_LOAD_PORT = portb       ; avr-p28:portc arduinomega:portb arduinouno:portb
                 .equ CPU_LOAD_BIT = 5            ; avr-p28:pin5  arduinomega:pin7  ardinouno:pin5
                 .equ CPU_LOAD_LED_POLARITY = 1   ; avr-p28:  0 = low on port turns on led, 
                                                  ; arduino : 1 = high on port turns on led 
                 
                 ; Define the startup delay for the turnkey words. Milliseconds
                 .equ TURNKEY_DELAY = 2000  ; milliseconds
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX0_OFF_FILL = 4   ; Fill level for XOFF
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE = 64          ; 48 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 90                   ; 80 chars tib size +  10 chars hold area
                 
                 ; Set to 1 to allow control-o to reset FlashForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; Select which timer to use for the system millisecond ticks 0, 1, 2
                 .equ MS_TIMER = 0
                 
                 ; Debug flash and eeprom writes
                 ; Prints F=Write to FLASH E=Write to EEPROM
                 .equ DEBUG_FLASH = 0
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #define partstring "ATmega328P"
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                 .ifdef OC0Aaddr
                 .equ MS_TIMER_ADDR = OC0Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 1
                 .ifdef OC1Aaddr
                 .else
                 .endif
                 .endif
                 
                 .if MS_TIMER == 2
                 .ifdef OC2Aaddr
                 .else
                 .endif
                 .endif
                 
                 
                 ; Define the FF version date string
                 #define DATE "07.01.2017"
                 
                 
                 ; Register definitions
                   .def upl = r2         ; not in interrupt 
                   .def uph = r3         ; not in interrupt
                   .def zero = r5        ; read only zero
                   .def r_one = r6       ; read only one
                   .def r_two = r7       ; read only two
                   .def t8 = r8          ; Not in interrupt
                   .def wflags  = r9     ; not in interrupt
                 
                   .def loadreg0 = r4    ;
                   .def loadreg1 = r12
                   .def loadreg2 = r13
                 
                 
                   .def ibasel=r10       ; Not in interrupt
                   .def ibaseh=r11       ; Not in interrupt
                   .def ms_count  = r14  ; Not in interrupt
                   .def ms_count1 = r15  ; Not in interrupt
                   .def t0 = r16
                   .def t1 = r17
                   .def t2 = r0          ; Not in interrupt
                   .def t3 = r1          ; Not in interrupt
                 
                   .def al = r18
                   .def ah = r19
                   .def pl = r20         ; P Register and FOR..LOOP INDEX variable
                   .def ph = r21
                 
                   .def FLAGS1 = r22     ; Not in interrupt
                   .def FLAGS2 = r23     ; Not in interrupt
                   .def tosl = r24
                   .def tosh = r25
                 ;  xl = r26
                 ;  xh = r27
                 ;  yl = r28  ; StackPointer Ylo
                 ;  yh = r29  ; StackPointer Yhi
                 ;  zl = r30
                 ;  zh = r31
                   .def t4 = r26
                   .def t5 = r27
                   .def t6 = r30
                   .def t7 = r31
                 
                 ; Macros
                 .macro poptos 
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro pushtos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro lpm_
                 .if (FLASHEND < 0x8000) ; Word address
                         lpm @0,@1
                 .else
                         elpm @0,@1
                 .endif
                 .endmacro
                 
                 .macro sub_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_z
                 .if (PFLASH > 0)
                         subi    zh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro sub_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(PFLASH)
                 .endif
                 .endmacro
                 
                 .macro add_pflash_tos
                 .if (PFLASH > 0)
                         subi    tosh, high(0x10000-PFLASH)
                 .endif        
                 .endmacro
                 
                 .macro rampv_to_c
                 .if (FLASHEND >= 0x8000)
                         bset    0
                 .else
                         bclr    0
                 .endif
                 .endmacro
                 
                 .macro fdw
                   .dw ((@0<<1)+PFLASH)
                 .endmacro
                 
                 .macro m_pop_zh
                 .ifdef EIND
                         pop     zh
                 .endif
                 .endmacro
                 .macro m_pop_xh
                 .ifdef EIND
                         pop     xh
                  .endif
                 .endmacro
                 .macro m_pop_t0
                 .ifdef EIND
                         pop     t0
                  .endif
                 .endmacro
                 .macro m_push_t0
                 .ifdef EIND
                         push    t0
                  .endif
                 .endmacro
                 .macro mijmp
                 .ifdef EIND
                         eijmp
                 .else
                         ijmp
                 .endif
                 .endmacro
                 
                 ; Symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 .equ UDR0_=UDR0
                 .equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 .equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 .equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 .equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .else
                 .if OPERATOR_UART == 0
                 .equ OP_TX_=TX0_
                 .equ OP_RX_=RX0_
                 .equ OP_RXQ=RX0Q
                 .endif
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/16/BAUDRATE0) - 1
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ;Hz
                 .equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 .equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 .equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                 .ifdef TCCR0B
                 .equ ms_pre_tmr0   = 3
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .equ ms_pre_tmr2   = 4
                 .endif
                 .ifdef TCCR2
                 .endif
                 
                 .else ; FREQ_OSC >= 16384000 Hz
                 .ifdef TCCR0B
                 .endif
                 .ifdef TCCR0
                 .endif
                 .ifdef TCCR2B
                 .endif
                 .ifdef TCCR2
                 .endif
                 .endif
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*255/100000)
                 ;..............................................................................
                 ;Program Specific Constants (literals used in code)
                 ;..............................................................................
                 ; Flash page size
                 .equ PAGESIZEB=PAGESIZE*2    ; Page size in bytes 
                 
                 ; Forth word header flags
                 .equ NFA= 0x80      ; Name field mask
                 .equ IMMED= 0x40    ; Immediate mask
                 .equ INLINE= 0x20   ; Inline mask for 1 and 2 cell code
                 .equ INLINE4= 0x00   ; Inline mask for 4 cell code
                 .equ INLINE5= 0x00   ; Inline mask for 5 cell code
                 .equ COMPILE= 0x10  ; Compile only mask
                 .equ NFAmask= 0xf   ; Name field length mask
                 
                 ; FLAGS2
                 .equ fIDLE=     6   ; 0 = busy, 1 = idle
                 .equ fLOAD=     5   ; Load measurement ready
                 .equ fLOADled=  4   ; 0 = no load led, 1 = load led on
                 .equ fFC_tx1=   3   ; 0=Flow Control, 1 = no Flow Control   
                 .equ fFC_tx0=   2   ; 0=Flow Control, 1 = no Flow Control   
                 .equ ixoff_tx1= 1                    
                 .equ ixoff_tx0= 0
                 
                 ; FLAGS1
                 .equ fLIT=    7     ; Literal compiled
                 .equ noclear= 6     ; dont clear optimisation flags 
                 .equ idup=    5     ; Use dupzeroequal instead of zeroequal
                 .equ izeroeq= 4     ; Use brne instead of breq if zeroequal
                 .equ istream= 3
                 .equ fLOCK=   2
                 .equ fTAILC=  1
                 .equ idirty=  0
                 
                 ;;; For Flow Control
                 .equ XON=   0x11
                 .equ XOFF=  0x13
                 
                 .equ CR_=0x0d
                 .equ LF_=0x0a
                 .equ BS_=0x08
                 .equ TAB_=0x09
                 
                 ;;; Memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 8 Kbytes of ram (atm2560)
                 .equ PEEPROM = RAMEND+1               ; 4 Kbytes of eeprom (atm2560)
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords flash
                 .else
                 .if (FLASHEND == 0xffff)              ; 64 Kwords flash
                 .else
                 .if (FLASHEND == 0x7fff)              ; 32 Kwords flash
                 .else
                 .if (FLASHEND == 0x3fff)              ; 16 Kwords flash
                 .equ OFLASH = 0x8000                  ; 32 Kbytes available for FlashForth
                 .equ PFLASH = OFLASH
                 .equ RAMPZV  = 0
                 .equ KERNEL_SIZE=0x0c80
                 .else
                 .if (FLASHEND == 0x1fff)              ; 8  Kwords flash
                 .endif
                 .endif
                 .endif
                 .endif
                 .endif
                 .equ BOOT_SIZE=0x400
                 .equ BOOT_START=FLASHEND - BOOT_SIZE + 1  ; atm128: 0xfc00, atm328: 0x3c00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  High values for memory areas
                 .equ FLASH_HI = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI =PEEPROM + EEPROMEND
                 .equ RAM_HI = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; User variables and area
                 .equ us0=          -28         ; Start of parameter stack
                 .equ ur0=          -26         ; Start of ret stack
                 .equ uemit=        -24         ; User EMIT vector
                 .equ ukey=         -22         ; User KEY vector
                 .equ ukeyq=        -20         ; User KEY? vector
                 .equ ubase=        -18         ; Number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; Task area pointer
                 .equ ustatus=      -12
                 .equ uflg=         -11
                 .equ usource=      -10         ; Two cells
                 .equ utoin=        -6          ; Input stream
                 .equ ulink=        -4          ; Task link
                 .equ ursave=       -2          ; Saved ret stack pointer
                 .equ uhp=           0          ; Hold pointer
                 
                 
                 ;;; Variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; Pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; Deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
000100           ibuf:         .byte PAGESIZEB
000180           ivec:         .byte INT_VECTORS_SIZE
                 
                 rxqueue0:
0001b4           rbuf0_wr:    .byte 1
0001b5           rbuf0_rd:    .byte 1
0001b6           rbuf0_lv:    .byte 1
0001b7           rbuf0:       .byte RX0_BUF_SIZE
                 
                 .ifdef UCSR1A
                 .endif
                 
0001d7           litbuf0:    .byte 1
0001d8           litbuf1:    .byte 1
0001d9           dpSTART:    .byte 2
0001db           dpFLASH:    .byte 2 ; DP's and LATEST in RAM
0001dd           dpEEPROM:   .byte 2
0001df           dpRAM:      .byte 2
0001e1           dpLATEST:   .byte 2
                 
0001e3           iaddrl:     .byte 1
0001e4           iaddrh:     .byte 1
                 .ifdef RAMPZ
                 .endif
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1       
                 .endif
                 .endif
                 
0001e5           cse:        .byte 1 ; Current data section 0=flash, 1=eeprom, 2=ram
0001e6           state:      .byte 1 ; Compilation state
0001e7           uvars:      .byte   (-us0)
000203           up0:        .byte   2
000205           urbuf:      .byte   ursize
000245           usbuf:      .byte   ussize
000285           utibbuf:    .byte   utibsize
0002df           dpdata:     .byte   2
                 
                 .eseg
                 .org 0
000000 ff ff             .dw 0xffff  ; Force first cell of eeprom to 0xffff
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .if (FLASHEND == 0x1ffff)
                 .else
                 .org KERNEL_START
                 .endif
                 ;***********************************************************
                 CMP:
002f80 940e 32b9         call    TOR
002f82 c009              rjmp    CMP2
                 CMP1:
002f83 940e 3008         call    NEQUALSFETCH
002f85 940e 32eb         call    MINUS
002f87 940e 33fc         call    ZEROSENSE
002f89 f011              breq    CMP2
002f8a 940c 396d         jmp     TWODROPZ
                 CMP2:
002f8c 940e 3aa1         call    XNEXT
002f8e f7a0              brcc    CMP1
002f8f 940c 3969         jmp     TWODROPNZ
                 .if (FLASHEND == 0x1ffff)
                 .endif
                 ;;; *************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 28
                 WARMLIT:
002f91 0200              .dw      0x0200                ; cse, state
002f92 0281              .dw      utibbuf-4             ; S0
002f93 0244              .dw      usbuf-1               ; R0
002f94 f8f0              fdw      OP_TX_
002f95 f93e              fdw      OP_RX_
002f96 f97e              fdw      OP_RXQ
002f97 000a              .dw      BASE_DEFAULT          ; BASE
002f98 0285              .dw      utibbuf               ; TIB
002f99 df80              fdw      OPERATOR_AREA         ; TASK
002f9a 0000              .dw      0                     ; ustatus & uflg
002f9b 0000              .dw      0                     ; source
002f9c 0000              .dw      0                     ; source
002f9d 0000              .dw      0                     ; TOIN
002f9e 0203              .dw      up0                   ; Task link
                 ; M? -- caddr count    current data space string
                 ;        dw      L_DOTBASE
                 L_MEMQ:
002f9f 2081              .db     NFA|1," "
                 MEMQ:
002fa0 940e 3147         call    CSE_
002fa2 940e 37e2         call    DOLIT
002fa4 fe6c              fdw     MEMQADDR_N
002fa5 940e 32de         call    PLUS
002fa7 940e 3723         call    FETCH_A
002fa9 940e 3584         call    CFETCHPP
002fab 940e 37e2         call    DOLIT
002fad 000f              .dw     NFAmask
002fae 940c 3328         jmp     AND_
                 
                 ;*********************************************************************
                 ; EXIT --   Compile a return
                 ;        variable link
002fb0 0000              .dw     0
                 EXIT_L:
002fb1 6584
002fb2 6978
002fb3 0074              .db     NFA|4,"exit",0
                 EXIT:
                         m_pop_t0
002fb4 910f              pop     t0
002fb5 910f              pop     t0
002fb6 9508              ret
                 
002fb7 fa56              fdw     IFLUSH_L
                 OPERATOR_L:
002fb8 6f88
002fb9 6570
002fba 6172
002fbb 6f74
002fbc 0072              .db     NFA|8,"operator",0
                 OPERATOR:
002fbd 940e 30e0         call    DOCREATE
002fbf df80              fdw     OPERATOR_AREA
                 OPERATOR_AREA:
002fc0 0203              .dw     up0
002fc1 0000
002fc2 0040              .dw     0, ursize
002fc3 0040
002fc4 005a              .dw     ussize, utibsize
                 
                 ; idle
002fc5 df62              fdw(EXIT_L)
                 IDLE_L:
002fc6 6984
002fc7 6c64
002fc8 0065              .db     NFA|4,"idle",0
                 IDLE:
002fc9 6470              sbr     FLAGS2, (1<<fIDLE)
002fca 9508              ret
                         
                 ; busy
002fcb df8c              fdw(IDLE_L)
                 BUSY_L:
002fcc 6284
002fcd 7375
002fce 0079              .db     NFA|4,"busy",0
                 BUSY:
002fcf 7b7f              cbr     FLAGS2, (1<<fIDLE)
002fd0 9508              ret        
                 ; *********************************************
                 ; Bit masking 8 bits, only for ram addresses !
                 ; : mset ( mask addr -- )
                 ;   dup >r c@ swap or r> c!
                 ; ;
002fd1 fe36              fdw     ICCOMMA_L
                 MSET_L:
002fd2 6d84
002fd3 6573
002fd4 0074              .db     NFA|4,"mset",0
                 MSET:
002fd5 01fc              movw    zl, tosl
002fd6 9189
002fd7 9199              poptos
002fd8 8100              ld      t0, z
002fd9 2b08              or      t0, tosl
002fda 8300              st      z, t0
002fdb 9189
002fdc 9199              poptos
002fdd 9508              ret
                         
                 ; : mclr  ( mask addr -- )
                 ;  dup >r c@ swap invert and r> c!
                 ; ;
002fde dfa4              fdw     MSET_L
                 MCLR_L:
002fdf 6d84
002fe0 6c63
002fe1 0072              .db     NFA|4,"mclr",0
                 MCLR_:
002fe2 01fc              movw    zl, tosl
002fe3 9189
002fe4 9199              poptos
002fe5 8100              ld      t0, z
002fe6 9580              com     tosl
002fe7 2308              and     t0, tosl
002fe8 8300              st      z, t0
002fe9 9189
002fea 9199              poptos
002feb 9508              ret
                 
                 ;   LSHIFT      x1 u -- x2
002fec dfbe              fdw     MCLR_L
                 LSHIFT_L:
002fed 6c86
002fee 6873
002fef 6669
002ff0 0074              .db     NFA|6,"lshift",0
                 LSHIFT:
002ff1 01fc              movw    zl, tosl
002ff2 9189
002ff3 9199              poptos
                 LSHIFT1:
002ff4 9731              sbiw    zl, 1
002ff5 f01a              brmi    LSHIFT2
002ff6 0f88              lsl     tosl
002ff7 1f99              rol     tosh
002ff8 cffb              rjmp    LSHIFT1
                 LSHIFT2:
002ff9 9508              ret
                 
                 ;   RSHIFT      x1 u -- x2
002ffa dfda              fdw     LSHIFT_L
                 RSHIFT_L:
002ffb 7286
002ffc 6873
002ffd 6669
002ffe 0074              .db     NFA|6,"rshift",0
                 RSHIFT:
002fff 01fc              movw    zl, tosl
003000 9189
003001 9199              poptos
                 RSHIFT1:
003002 9731              sbiw    zl, 1
003003 f01a              brmi    RSHIFT2
003004 9596              lsr     tosh
003005 9587              ror     tosl
003006 cffb              rjmp    RSHIFT1
                 RSHIFT2:
003007 9508              ret
                 
                 ;**********************************************
                 NEQUALSFETCH:
003008 d57b              rcall   CFETCHPP
003009 d2a7              rcall   ROT
00300a d579              rcall   CFETCHPP
00300b c2a5              rjmp    ROT
                 ;***************************************************
                 ; N=    c-addr nfa -- n   string:name cmp
                 ;             n=0: s1==s2, n=ffff: s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; It can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in ram and the second in program memory.
00300c dff6              fdw     RSHIFT_L
                 NEQUAL_L:
00300d 6e82
00300e 003d              .db     NFA|2,"n=",0
                 NEQUAL:
00300f dff8              rcall   NEQUALSFETCH
003010 708f              andi    tosl, 0xf
003011 d37b              rcall   EQUAL
003012 d3e9              rcall   ZEROSENSE
003013 f0b1              breq    NEQUAL5
003014 d341              rcall   ONEMINUS
003015 d56e              rcall   CFETCHPP
003016 d2a2              rcall   TOR
003017 c00c              rjmp    NEQUAL4
                 NEQUAL2:
003018 dfef              rcall   NEQUALSFETCH
003019 d36e              rcall   NOTEQUAL
00301a d3e1              rcall   ZEROSENSE
00301b f021              breq    NEQUAL3
00301c d770              rcall   TRUE_
00301d 940e 3ab1         call    LEAVE
00301f c004              rjmp    NEQUAL4
                 NEQUAL3:
003020 d2ac              rcall   RFETCH
003021 d3da              rcall   ZEROSENSE
003022 f409              brne    NEQUAL4
003023 d760              rcall   FALSE_
                 NEQUAL4:
003024 940e 3aa1         call    XNEXT
003026 f788              brcc    NEQUAL2
003027 911f              pop     t1
003028 910f              pop     t0
003029 c001              rjmp    NEQUAL6
                 NEQUAL5:
00302a d762              rcall   TRUE_
                 NEQUAL6:
00302b d411              rcall   NIP
00302c 940c 343d         jmp     NIP
                 
                 ; SKIP   c-addr u c -- c-addr' u'
                 ;                          skip matching chars
                 ; u (count) must be smaller than 256
00302e e01a              fdw     NEQUAL_L
                 SKIP_L:
00302f 7384
003030 696b
003031 0070              .db     NFA|4,"skip",0
                 SKIP:
                 
003032 d286              rcall   TOR
                 SKIP0:
003033 d3ce              rcall   DUPZEROSENSE
003034 f089              breq    SKIP2
                 
003035 d273              rcall   OVER
003036 d428              rcall   CFETCH_A
                 
003037 d7b3              rcall   DUP
003038 d7a9              rcall   DOLIT
003039 0009              .dw     TAB_
00303a d352              rcall   EQUAL
00303b d3c0              rcall   ZEROSENSE
00303c f429              brne    SKIP05    
00303d d28f              rcall   RFETCH
00303e d34e              rcall   EQUAL
00303f d3bc              rcall   ZEROSENSE
003040 f029              breq    SKIP2
003041 c001                      rjmp    SKIP1
                 SKIP05:
003042 d255              rcall   DROP
                 SKIP1:
003043 d1c4              rcall   ONE
003044 d4ea              rcall   SLASHSTRING
003045 cfed              rjmp    SKIP0
                 SKIP2:
003046 910f              pop     t0
003047 910f              pop     t0
003048 9508              ret
                 
                 
                 ; SCAN   c-addr u c -- c-addr' u'
                 ;                          find matching chars
                 
                 
003049 e05e              fdw     SKIP_L
                 SCAN_L:
00304a 7384
00304b 6163
00304c 006e              .db     NFA|4,"scan",0
                 SCAN:
00304d d364              rcall   STORE_P_TO_R
00304e d26a              rcall   TOR
00304f c010              rjmp    SCAN3
                 SCAN1:
003050 d533              rcall   CFETCHPP
003051 d799              rcall   DUP
003052 d78f              rcall   DOLIT
003053 0009              .dw     TAB_
003054 d338              rcall   EQUAL
003055 d3a6              rcall   ZEROSENSE
003056 f011              breq    SCAN2
003057 d240              rcall   DROP
003058 c005              rjmp    SCAN25
                 SCAN2:
003059 940e 3b74         call    FETCH_P
00305b d331              rcall   EQUAL
00305c d39f              rcall   ZEROSENSE
00305d f011              breq    SCAN3
                 SCAN25:
00305e d2f7              rcall   ONEMINUS
00305f c003              rjmp    SCAN4
                 SCAN3:
003060 940e 3aa1         call    XNEXT
003062 f768              brcc    SCAN1
                 SCAN4:
003063 d25f              rcall   RFROM
003064 d2ec              rcall   ONEPLUS
003065 d357              rcall   R_TO_P
003066 9508              ret
                 
                 ; : mtst ( mask addr -- flag )
                 ;   c@ and 
                 ; ;
003067 e094              fdw     SCAN_L
                 MTST_L:
003068 6d84
003069 7374
00306a 0074              .db     NFA|4,"mtst",0
                 MTST:
00306b 01fc              movw    zl, tosl
00306c 9181              ld      tosl, z+
00306d 9109              ld      t0, Y+
00306e 9119              ld      t1, Y+
00306f 2380              and     tosl, t0
003070 2799              clr     tosh
003071 9508              ret
                 
                 
003072 e0d0              fdw     MTST_L
                 FCY_L:
003073 4683
003074 7963              .db     NFA|3,"Fcy"
003075 d06a              rcall   DOCREATE
003076 3e80              .dw     FREQ_OSC / 1000
                 
                 ;;; Check parameter stack pointer
003077 7383
003078 3f70              .db     NFA|3,"sp?"
                 check_sp:
003079 d089              rcall   SPFETCH
00307a 940e 3917         call    R0_
00307c d6a6              rcall   FETCH_A
00307d 940e 3912         call    S0
00307f d6a3              rcall   FETCH_A
003080 d2d0              rcall   ONEPLUS
003081 d2fc              rcall   WITHIN
003082 d1d9              rcall   XSQUOTE
003083 5303
003084 3f50              .db     3,"SP?"
003085 d748              rcall   QABORT
003086 9508              ret
                 ;***************************************************
                 ; EMIT  c --    output character to the emit vector
003087 e0e6              fdw     FCY_L
                 EMIT_L:
003088 6584
003089 696d
00308a 0074              .db     NFA|4,"emit",0
                 EMIT:
00308b d360              rcall   UEMIT_
00308c 940c 30ab         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
00308e e110              fdw     EMIT_L
                 KEY_L:
00308f 6b83
003090 7965              .db     NFA|3,"key"
                 KEY:
003091 d360              rcall   UKEY_
003092 940c 30ab         jmp     FEXECUTE
                 
                 ;***************************************************
                 ; KEY   -- c    get char from UKEY vector
003094 e11e              fdw     KEY_L
                 KEYQ_L:
003095 6b84
003096 7965
003097 003f              .db     NFA|4,"key?",0
                 KEYQ:
003098 d35f              rcall   UKEYQ_
003099 940c 30ab         jmp     FEXECUTE
                 
00309b e12a              fdw     KEYQ_L
                 EXECUTE_L:
00309c 6587
00309d 6578
00309e 7563
00309f 6574              .db     NFA|7,"execute"
                 EXECUTE:
0030a0 01fc              movw    zl, tosl
0030a1 58f0              sub_pflash_z
0030a2 9189
0030a3 9199              poptos
0030a4 9488              rampv_to_c
0030a5 95f7              ror     zh
0030a6 95e7              ror     zl
0030a7 9409              mijmp
                 
0030a8 e138              fdw     EXECUTE_L
                 FEXECUTE_L:
0030a9 4083
0030aa 7865              .db     NFA|3,"@ex"
                 FEXECUTE:
0030ab d677              rcall   FETCH_A
0030ac 940c 30a0         jmp     EXECUTE
                 
0030ae e152              fdw     FEXECUTE_L
                 VARIABLE_L:
0030af 7688
0030b0 7261
0030b1 6169
0030b2 6c62
0030b3 0065              .db     NFA|8,"variable",0
                 VARIABLE_:
0030b4 d09c              rcall   HERE
0030b5 d0b1              rcall   CELL
0030b6 d1da              rcall   ALLOT
0030b7 940c 30cb         jmp     CONSTANT_
                 
0030b9 e15e              fdw     VARIABLE_L
                 TWOVARIABLE_L:
0030ba 3289
0030bb 6176
0030bc 6972
0030bd 6261
0030be 656c              .db     NFA|9,"2variable"
                 TWOVARIABLE_:
0030bf d091              rcall   HERE
0030c0 d721              rcall   DOLIT
0030c1 0004              .dw     0x4
0030c2 d1ce              rcall   ALLOT
0030c3 940c 30cb         jmp     CONSTANT_
                 
0030c5 e174              fdw     TWOVARIABLE_L
                 CONSTANT_L:
0030c6 6388
0030c7 6e6f
0030c8 7473
0030c9 6e61
0030ca 0074              .db     NFA|8,"constant",0
                 CONSTANT_:
0030cb d7dd              rcall   COLON
0030cc 940e 3df3         call    LITERAL
0030ce 940c 38b7         jmp     SEMICOLON
                 
0030d0 e18c              fdw     CONSTANT_L
                 TWOCONSTANT_L:
0030d1 3289
0030d2 6f63
0030d3 736e
0030d4 6174
0030d5 746e              .db     NFA|9,"2constant"
                 TWOCONSTANT_:
0030d6 d1c8              rcall   SWOP
0030d7 d7d1              rcall   COLON
0030d8 940e 3df3         call    LITERAL
0030da 940e 3df3         call    LITERAL
0030dc 940c 38b7         jmp     SEMICOLON
                 
                 ; DOCREATE, code action of CREATE
                 ; Fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0030de 2883
0030df 2963              .db     NFA|3, "(c)"
                 DOCREATE:
                         m_pop_zh
0030e0 91ff              pop     zh
0030e1 91ef              pop     zl
0030e2 d00c              rcall   FETCHLIT
                         m_pop_zh
0030e3 91ff              pop     zh
0030e4 91ef              pop     zl
0030e5 9409              mijmp
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
0030e6 2883
0030e7 2964              .db     NFA|3, "(d)"
                 DODOES:
                         m_pop_xh
0030e8 91bf              pop     xh
0030e9 91af              pop     xl
                         m_pop_zh
0030ea 91ff              pop     zh
0030eb 91ef              pop     zl
0030ec d002              rcall   FETCHLIT
0030ed 01fd              movw    z, x
0030ee 9409              mijmp    ; (z)
                 
                 FETCHLIT:
0030ef 939a
0030f0 938a              pushtos
0030f1 0fee              lsl     zl
0030f2 1fff              rol     zh
0030f3 9185              lpm_    tosl, z+
0030f4 9195              lpm_    tosh, z+
0030f5 9508              ret
                 
0030f6 2883
0030f7 292c              .db     NFA|3, "(,)"
                 DOCOMMAXT:
                         m_pop_t0
0030f8 91ff              pop     zh
0030f9 91ef              pop     zl
0030fa dff4              rcall   FETCHLIT
0030fb 95f7              ror     zh
0030fc 95e7              ror     zl
0030fd 93ef              push    zl
0030fe 93ff              push    zh
                         m_push_t0
0030ff c098              rjmp     COMMAXT
                 
                 ;   SP@     -- addr         get parameter stack pointer
003100 e1a2              fdw     TWOCONSTANT_L
                 SPFETCH_L:
003101 7383
003102 4070              .db     NFA|3,"sp@"
                 SPFETCH:
003103 01fe              movw    z, y
003104 939a
003105 938a              pushtos
003106 01cf              movw    tosl, z
003107 9508              ret
                 
                 ;   SP!     addr --         store stack pointer
003108 7383
003109 2170              .db     NFA|3,"sp!"
                 SPSTORE:
00310a 01ec              movw    y, tosl
00310b 9508              ret
                 
                 ;   RPEMPTY     -- EMPTY THE RETURN STACK       
00310c 7283
00310d 3070              .db     NFA|3,"rp0"
                 RPEMPTY:
                         m_pop_xh
00310e 91bf              pop     xh
00310f 91af              pop     xl
003110 940e 3917         call    R0_
003112 d610              rcall   FETCH_A
003113 bf8d              out     spl, tosl
003114 bf9e              out     sph, tosh
003115 9189
003116 9199              poptos
003117 01fd              movw    zl, xl
003118 9409              mijmp
                 
                 ;   RP@ Fetch the return stack pointer        
003119 e202              fdw     SPFETCH_L
                 RPFETCH_L:
00311a 72b3
00311b 4070              .db     NFA|INLINE|COMPILE|3,"rp@"
                 RPFETCH:
00311c 939a
00311d 938a              pushtos
00311e b78d              in      tosl, spl
00311f b79e              in      tosh, sph
003120 9508              ret
                 
                 ;   ><  Swap bytes        
003121 e234              fdw     RPFETCH_L
                 SWAPB_L:
003122 3ea2
003123 003c              .db     NFA|INLINE|2,"><",0
                 SWAPB:
003124 2f08              mov     t0, tosl
003125 2f89              mov     tosl, tosh
003126 2f90              mov     tosh, t0
003127 9508              ret
                 
                 ; DICTIONARY POINTER FOR the current section
                 ; Flash -- sets the data section to flash
003128 e244              fdw     SWAPB_L
                 FLASH_L:
                 ROM_N:  
003129 6685
00312a 616c
00312b 6873              .db     NFA|5,"flash"
                 ROM_:
00312c 9250 01e5         sts     cse, zero
00312e 9508              ret
                 
                 ; EEPROM -- sets the data section to EEPROM data memory
00312f e252              fdw     FLASH_L
                 EEPROM_L:
                 EROM_N: 
003130 6586
003131 7065
003132 6f72
003133 006d              .db     NFA|6,"eeprom",0
                 EROM:
003134 9270 01e5         sts     cse, r_two
003136 9508              ret
                         
                 ; RAM -- sets the data section to RAM memory
003137 e260              fdw     EEPROM_L
                 RAM_L:
                 FRAM_N: 
003138 7283
003139 6d61              .db     NFA|3,"ram"
                 FRAM:
00313a e004              ldi     t0, 4
00313b 9300 01e5         sts     cse, t0
00313d 9508              ret
                 
                 ; DP    -- a-addr          
                 ; Fetched from EEPROM
00313e e270              fdw     RAM_L
                 DP_L:
00313f 6482
003140 0070              .db     NFA|2,"dp",0
                 DP:
003141 d73c              rcall   IDP
003142 d004              rcall   CSE_
003143 940c 32de         jmp     PLUS
                 
                 
                 ;;; 
003145 6383
003146 6573              .db     NFA|3,"cse"
                 CSE_:
003147 939a
003148 938a              pushtos
003149 9180 01e5         lds     tosl, cse
00314b 2799              clr     tosh
00314c 9508              ret
                 
                 ; HERE    -- addr    get current data space ptr
                 ;   DP @ ;
00314d e27e              fdw     DP_L
                 HERE_L:
00314e 6884
00314f 7265
003150 0065              .db     NFA|4,"here",0
                 HERE:
003151 dfef              rcall   DP
003152 940c 3e5c         jmp     FETCH
                 
                 ; ,   x --             append cell to current data space
                 ;   HERE ! CELL ALLOT ;
003154 e29c              fdw     HERE_L
                 COMMA_L:
003155 2c81              .db     NFA|1,","
                 COMMA:
003156 dffa              rcall   HERE
003157 d43a              rcall   STORE_A
003158 d00e              rcall   CELL
003159 940c 3291         jmp     ALLOT
                 
                 ; C,  c --             append char to current data space
                 ;   HERE C! 1 ALLOT ;
00315b e2aa              fdw     COMMA_L 
                 CCOMMA_L:
00315c 6382
00315d 002c              .db     NFA|2,"c,",0
                 CCOMMA:
00315e dff2              rcall   HERE
00315f d303              rcall   CSTORE_A
003160 d0a7              rcall   ONE
003161 940c 3291         jmp     ALLOT
                 
                 
                 ; CELL     -- n                 size of one cell
003163 e2b8              fdw     CCOMMA_L
                 CELL_L:
003164 6384
003165 6c65
003166 006c              .db     NFA|4,"cell",0
                 CELL:
003167 939a
003168 938a              pushtos
003169 e082              ldi     tosl, 2
00316a e090              ldi     tosh, 0
00316b 9508              ret
                 
                 ; ALIGN    --                         align DP
00316c e2c8              fdw     CELL_L
                 ALIGN_L:
00316d 6185
00316e 696c
00316f 6e67              .db     NFA|5,"align"
                 ALIGN:
003170 dfe0              rcall   HERE
003171 d008              rcall   ALIGNED
003172 dfce              rcall   DP
003173 940c 3e22         jmp     STORE
                 
                 ; ALIGNED  addr -- a-addr       align given addr
003175 e2da              fdw     ALIGN_L
                 ALIGNED_L:
003176 6187
003177 696c
003178 6e67
003179 6465              .db     NFA|7,"aligned"
                 ALIGNED:
00317a 9601              adiw    tosl, 1
00317b 7f8e              cbr     tosl, 1
00317c 9508              ret
                 
                 ; CELL+    a-addr1 -- a-addr2      add cell size
                 ;   2 + ;
00317d e2ec              fdw     ALIGNED_L
                 CELLPLUS_L:
00317e 63a5
00317f 6c65
003180 2b6c              .db     NFA|INLINE|5,"cell+"
                 CELLPLUS:
003181 9602              adiw    tosl, 2
003182 9508              ret
                 
                 ; CELLS    n1 -- n2            cells->adrs units
003183 e2fc              fdw     CELLPLUS_L
                 CELLS_L:
003184 63a5
003185 6c65
003186 736c              .db     NFA|INLINE|5,"cells"
                 CELLS:
003187 0f88              lsl     tosl
003188 1f99              rol     tosh
003189 9508              ret
                 
                 ; CHAR+    c-addr1 -- c-addr2   add char size
00318a e308              fdw     CELLS_L
                 CHARPLUS_L:
00318b 63a5
00318c 6168
00318d 2b72              .db     NFA|INLINE|5,"char+"
                 CHARPLUS:
00318e 9601              adiw    tosl, 1
00318f 9508              ret
                 
                 ; CHARS    n1 -- n2            chars->adrs units
003190 e316              fdw     CHARPLUS_L
                 CHARS_L:
003191 63a5
003192 6168
003193 7372              .db     NFA|INLINE|5,"chars"
003194 9508      CHARS:  ret
                 
003195 e322              fdw     CHARS_L
                 COMMAXT_L:
003196 6383
003197 2c66              .db     NFA|3, "cf,"
                 COMMAXT:
003198 d652              rcall   DUP
003199 d67d              rcall   IHERE
00319a d150              rcall   MINUS
00319b d13d              rcall   ABS_ 
00319c d645              rcall   DOLIT
00319d 0ff0              .dw     0xff0
00319e d1f8              rcall   GREATER
00319f d25c              rcall   ZEROSENSE
0031a0 f049              breq    STORECF1
                 STORECFF1: 
                 ;        rcall   CALL_
0031a1 d640              rcall   DOLIT
                 .ifdef EIND
                 .else
0031a2 940e              .dw     0x940E  ; call jmp:0x940d
                 .endif
0031a3 940e 3f13         call    ICOMMA
0031a5 5890              sub_pflash_tos
0031a6 9488              rampv_to_c
0031a7 9597              ror     tosh
0031a8 9587              ror     tosl
0031a9 c006              rjmp    STORECF2
                 STORECF1:
0031aa d66c              rcall   IHERE
0031ab d13f              rcall   MINUS
0031ac d747              rcall   TWOMINUS
0031ad d1be              rcall   TWOSLASH
                         ;rcall   RCALL_
0031ae 709f              andi    tosh, 0x0f
0031af 6d90              ori     tosh, 0xd0
                 STORECF2:
0031b0 940c 3f13         jmp    ICOMMA
                 
                 
                 ; !COLON   --       change code field to docolon
                 ;   -6 IALLOT ; 
                 ;       .dw    link
                 ;link   set     $
0031b2 2182
0031b3 003a              .db     NFA|2,"!:",0
                 STORCOLON:
0031b4 d62d              rcall   DOLIT
0031b5 fffa              .dw     0xfffa         ;  -6
0031b6 940c 39d0         jmp     IALLOT
                 
                 
                 ; 2@    a-addr -- x1 x2            fetch 2 cells
                 ;   DUP @ SWAP CELL+ @ ;
                 ;   the lower address will appear on top of stack
0031b8 e32c              fdw     COMMAXT_L
                 TWOFETCH_L:
0031b9 3282
0031ba 0040              .db     NFA|2,"2@",0
                 TWOFETCH:
0031bb d62f              rcall   DUP
0031bc d566              rcall   FETCH_A
0031bd d0e1              rcall   SWOP
0031be dfc2              rcall   CELLPLUS
0031bf 940c 3723         jmp     FETCH_A
                 
                 ; 2!    x1 x2 a-addr --            store 2 cells
                 ;   SWAP OVER ! CELL+ ! ;
                 ;   the top of stack is stored at the lower adrs
0031c1 e372              fdw     TWOFETCH_L
                 TWOSTORE_L:
0031c2 3282
0031c3 0021              .db     NFA|2,"2!",0
                 TWOSTORE:
0031c4 d0da              rcall   SWOP
0031c5 d0e3              rcall   OVER
0031c6 dfba              rcall   CELLPLUS
0031c7 d3ca              rcall   STORE_A
0031c8 940c 3e22         jmp     STORE
                 
                 ; 2DROP  x1 x2 --                   drop 2 cells
                 ;   DROP DROP ;
0031ca e384              fdw     TWOSTORE_L
                 TWODROP_L:
0031cb 3285
0031cc 7264
0031cd 706f              .db     NFA|5,"2drop"
                 TWODROP:
0031ce d0c9              rcall   DROP
0031cf 940c 3298         jmp     DROP
                 
                 ; 2DUP   x1 x2 -- x1 x2 x1 x2    dup top 2 cells
                 ;   OVER OVER ;
0031d1 e396              fdw     TWODROP_L
                 TWODUP_L:
0031d2 3284
0031d3 7564
0031d4 0070              .db     NFA|4,"2dup",0
                 TWODUP:
0031d5 d0d3              rcall   OVER
0031d6 940c 32a9         jmp     OVER
                 
                 ; 2SWAP   x1 x2 x3 x4 -- x3 x4 x1 x2    dup top 2 cells
0031d8 e3a4              fdw     TWODUP_L
                 TWOSWAP_L:
0031d9 3285
0031da 7773
0031db 7061              .db     NFA|5,"2swap"
                 TWOSWAP:
0031dc d0d4              rcall   ROT
0031dd d0db              rcall   TOR
0031de d0d2              rcall   ROT
0031df d0e3              rcall   RFROM
0031e0 9508              ret
                 
                 ; INPUT/OUTPUT ==================================
                 
                 ; SPACE   --                      output a space
                 ;   BL EMIT ;
0031e1 e3b2              fdw     TWOSWAP_L
                 SPACE_L:
0031e2 7385
0031e3 6170
0031e4 6563              .db     NFA|5,"space"
                 SPACE_:  
0031e5 d713              rcall   BL
0031e6 940c 308b         jmp     EMIT
                 
                 ; SPACES   n --                  output n spaces
                 ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
0031e8 e3c4              fdw     SPACE_L
                 SPACES_L:
0031e9 7386
0031ea 6170
0031eb 6563
0031ec 0073              .db     NFA|6,"spaces",0
                 SPACES:
                 SPCS1:
0031ed d214              rcall   DUPZEROSENSE
0031ee f019              breq    SPCS2
0031ef dff5              rcall   SPACE_
0031f0 d165              rcall   ONEMINUS
0031f1 cffb              rjmp    SPCS1
0031f2 940c 3298 SPCS2:  jmp     DROP
                 
                 
                 ; umin     u1 u2 -- u           unsigned minimum
                 ;   2DUP U> IF SWAP THEN DROP ;
0031f4 e3d2              fdw     SPACES_L
                 UMIN_L:
0031f5 7584
0031f6 696d
0031f7 006e              .db     NFA|4,"umin",0
                 UMIN:
0031f8 dfdc              rcall   TWODUP
0031f9 d1aa              rcall   UGREATER
0031fa c006              rjmp    MINMAX
                 
                 ; umax    u1 u2 -- u            unsigned maximum
                 ;   2DUP U< IF SWAP THEN DROP ;
0031fb e3ea              fdw     UMIN_L
                 UMAX_L:
0031fc 7584
0031fd 616d
0031fe 0078              .db     NFA|4,"umax",0
                 UMAX:
0031ff dfd5              rcall   TWODUP
003200 d19c              rcall   ULESS
                 MINMAX:
003201 d1fa              rcall   ZEROSENSE
003202 f009              breq    UMAX1
003203 d09b              rcall   SWOP
003204 940c 3298 UMAX1:  jmp     DROP
                 
003206 e3f8              fdw     UMAX_L
                 ONE_L:
003207 3181              .db     NFA|INLINE4|1,"1"
                 ONE:
003208 939a
003209 938a              pushtos
00320a e081              ldi     tosl, 1
00320b e090              ldi     tosh, 0
00320c 9508              ret
                 
                 ; ACCEPT  c-addr +n -- +n'  get line from terminal
00320d e40e              fdw     ONE_L
                 ACCEPT_L:
00320e 6186
00320f 6363
003210 7065
003211 0074              .db     NFA|6,"accept",0
                 ACCEPT:
003212 d096              rcall   OVER
003213 d0ca              rcall   PLUS
003214 d094              rcall   OVER
                 ACC1:
003215 de7b              rcall   KEY
                 
003216 308d              cpi     tosl, CR_
003217 f429              brne    ACC_LF
                         
003218 d574              rcall   TRUE_
003219 d02f              rcall   FCR
00321a d248              rcall   CSTORE_A
00321b d07c              rcall   DROP
00321c c026              rjmp    ACC6
                 ACC_LF:
00321d 308a              cpi     tosl, LF_
00321e f449              brne    ACC2
00321f d078              rcall   DROP
                 
003220 d028              rcall   FCR
003221 d23d              rcall   CFETCH_A
003222 d1d9              rcall   ZEROSENSE
003223 f0f9              breq    ACC6
003224 d55f              rcall   FALSE_
003225 d023              rcall   FCR
003226 d23c              rcall   CSTORE_A
003227 cfed              rjmp    ACC1
                 ACC2:
003228 d55b              rcall   FALSE_
003229 d01f              rcall   FCR
00322a d238              rcall   CSTORE_A
00322b d5bf              rcall   DUP
00322c de5e              rcall   EMIT
00322d d5bd              rcall   DUP
00322e d5b3              rcall   DOLIT
00322f 0008              .dw     BS_
003230 d15c              rcall   EQUAL
003231 d1ca              rcall   ZEROSENSE
003232 f039              breq    ACC3
003233 d064              rcall   DROP
003234 d121              rcall   ONEMINUS
003235 d083              rcall   TOR
003236 d072              rcall   OVER
003237 d08b              rcall   RFROM
003238 dfc6              rcall   UMAX
003239 cfdb              rjmp    ACC1
                 ACC3:
00323a d06e              rcall   OVER
00323b d227              rcall   CSTORE_A
00323c d114              rcall   ONEPLUS
00323d d06b              rcall   OVER
00323e dfb9              rcall   UMIN
00323f df95              rcall   TWODUP
003240 d147              rcall   NOTEQUAL
003241 d1ba              rcall   ZEROSENSE
003242 f691              brne     ACC1
                 ACC6:
003243 d1f9              rcall   NIP
003244 d05a              rcall   SWOP
003245 940c 32eb         jmp     MINUS
                 
003247 6683
003248 7263              .db     NFA|3,"fcr"
                 FCR:
003249 d2d2              rcall   DOUSER
00324a fff5              .dw     uflg
                 
                 
                 ; TYPE    c-addr u --   type line to terminal u < $100
                 ; : type for c@+ emit next drop ;
                 
00324b e41c              fdw      ACCEPT_L
                 TYPE_L:
00324c 7484
00324d 7079
00324e 0065              .db     NFA|4,"type",0
                 TYPE:
00324f d069              rcall   TOR
003250 c002              rjmp    TYPE2       ; XFOR
                 TYPE1:  
003251 d332              rcall   CFETCHPP
003252 de38              rcall   EMIT
                 TYPE2:
003253 940e 3aa1         call    XNEXT
003255 f7d8              brcc    TYPE1
003256 911f              pop     t1
003257 910f              pop     t0
003258 940c 3298         jmp     DROP
                 
                 
                 ; (S"    -- c-addr u      run-time code for S"
00325a 2883
00325b 2273              .db      NFA|3,"(s",0x22
                 XSQUOTE:
                         m_pop_zh
00325c 91ff              pop     zh
00325d 91ef              pop     zl
00325e 0fee              lsl     zl
00325f 1fff              rol     zh
003260 9105              lpm_    t0, z+
003261 939a
003262 938a              pushtos
003263 01cf              movw    tosl, zl
003264 5890              add_pflash_tos
003265 939a
003266 938a              pushtos
003267 2f80              mov     tosl, t0
003268 2799              clr     tosh
003269 0fe0              add     zl, t0
00326a 1ff9              adc     zh, tosh
00326b 9631              adiw    zl, 1
00326c 9488              rampv_to_c
00326d 95f7              ror     zh
00326e 95e7              ror     zl
00326f 9409              mijmp
                 
003270 e498              fdw     TYPE_L
                 SQUOTE_L:
003271 73d2
003272 0022              .db      NFA|IMMED|COMPILE|2,"s",0x22,0
                 SQUOTE:
003273 de84              rcall   DOCOMMAXT
003274 e4b8              fdw     XSQUOTE
003275 deb6              rcall   ROM_
003276 d005              rcall   CQUOTE
003277 940c 313a         jmp     FRAM
                 
003279 e4e2              fdw     SQUOTE_L
                 CQUOTE_L:
00327a 2c82
00327b 0022              .db     NFA|2,",",0x22,0
                 CQUOTE: 
00327c d565              rcall   DOLIT
00327d 0022              .dw     0x22
00327e d2c3              rcall   PARSE
00327f ded1              rcall   HERE
003280 d028              rcall   OVER
003281 d0cf              rcall   ONEPLUS
003282 def7              rcall   ALIGNED
003283 d00d              rcall   ALLOT
003284 940c 357b         jmp     PLACE
                 
                 
003286 e4f4              fdw     CQUOTE_L
                 DOTQUOTE_L:
003287 2ed2
003288 0022              .db      NFA|IMMED|COMPILE|2,".",0x22,0
                 DOTQUOTE:
003289 dfe9              rcall   SQUOTE
00328a de6d              rcall   DOCOMMAXT
00328b e49e              fdw     TYPE
00328c 9508              ret
                 
00328d e50e              fdw     DOTQUOTE_L
                 ALLOT_L:
00328e 6185
00328f 6c6c
003290 746f              .db     NFA|5,"allot"
                 ALLOT:
003291 deaf              rcall   DP
003292 940c 3372         jmp     PLUSSTORE
                 
003294 e51c              fdw     ALLOT_L
                 DROP_L:
003295 64a4
003296 6f72
003297 0070              .db     NFA|INLINE|4,"drop",0
                 DROP:
003298 9189
003299 9199              poptos
00329a 9508              ret
                 
00329b e52a              fdw     DROP_L
                 SWOP_L:
00329c 7384
00329d 6177
00329e 0070              .db     NFA|INLINE5|4,"swap",0
                 SWOP:
00329f 9109              ld      t0, y+
0032a0 9119              ld      t1, y+
0032a1 939a
0032a2 938a              pushtos
0032a3 01c8              movw    tosl, t0
0032a4 9508              ret
                 
0032a5 e538              fdw     SWOP_L
                 OVER_L:
0032a6 6f84
0032a7 6576
0032a8 0072              .db     NFA|INLINE4|4,"over",0
                 OVER:
0032a9 939a
0032aa 938a              pushtos
0032ab 818a              ldd     tosl, y+2
0032ac 819b              ldd     tosh, y+3
0032ad 9508              ret
                 
0032ae e54c              fdw     OVER_L
                 ROT_L:
0032af 7283
0032b0 746f              .db     NFA|3, "rot"
                 ROT:
0032b1 d007              rcall   TOR
0032b2 dfec              rcall   SWOP
0032b3 d00f              rcall   RFROM
0032b4 940c 329f         jmp     SWOP
                 
0032b6 e55e              fdw     ROT_L
                 TOR_L:
0032b7 3e92
0032b8 0072              .db     NFA|COMPILE|2,">r",0
                 TOR:
                         m_pop_zh
0032b9 91ff              pop     zh
0032ba 91ef              pop     zl
0032bb 938f              push    tosl
0032bc 939f              push    tosh
0032bd 9189
0032be 9199              poptos
0032bf 9409              mijmp
                 
0032c0 e56e              fdw     TOR_L
                 RFROM_L:
0032c1 7292
0032c2 003e              .db     NFA|COMPILE|2,"r>",0
                 RFROM:
                         m_pop_zh
0032c3 91ff              pop     zh
0032c4 91ef              pop     zl
0032c5 939a
0032c6 938a              pushtos
0032c7 919f              pop     tosh
0032c8 918f              pop     tosl
0032c9 9409              mijmp
                 
0032ca e582              fdw     RFROM_L
                 RFETCH_L:
0032cb 7292
0032cc 0040              .db     NFA|COMPILE|2,"r@",0
                 RFETCH:
                         m_pop_zh
0032cd 91ff              pop     zh
0032ce 91ef              pop     zl
0032cf 939a
0032d0 938a              pushtos
0032d1 919f              pop     tosh
0032d2 918f              pop     tosl
0032d3 938f              push    tosl
0032d4 939f              push    tosh
0032d5 9409              mijmp
                 
                 ;   ABS     n   --- n1      absolute value of n
0032d6 efd2              fdw     DUP_L
                 ABS_L:
0032d7 6183
0032d8 7362              .db     NFA|3,"abs"
                 ABS_:
0032d9 d511              rcall   DUP
0032da 940c 344c         jmp     QNEGATE
                 
0032dc e5ae              fdw     ABS_L
                 PLUS_L:
0032dd 2b81              .db     NFA|INLINE4|1, "+"
                 
                 PLUS:
0032de 9109              ld      t0, Y+        
0032df 9119              ld      t1, Y+
0032e0 0f80              add     tosl, t0
0032e1 1f91              adc     tosh, t1
0032e2 9508              ret
                 
                 ; m+  ( d n -- d1 )
0032e3 e5ba              fdw     PLUS_L
                 MPLUS_L:
0032e4 6d82
0032e5 002b              .db     NFA|2, "m+",0
                 MPLUS:
0032e6 d7dc              rcall   STOD
0032e7 940c 3ae5         jmp     DPLUS
                 
0032e9 e5c8              fdw     MPLUS_L
                 MINUS_L:
0032ea 2d81              .db     NFA|INLINE5|1, "-"
                 MINUS:
0032eb 9109              ld      t0, Y+
0032ec 9119              ld      t1, Y+
0032ed 1b08              sub     t0, tosl
0032ee 0b19              sbc     t1, tosh
0032ef 01c8              movw    tosl, t0
0032f0 9508              ret
                 PLUSC_:
0032f1 91e0 01d7         lds     zl, litbuf0
0032f3 91f0 01d8         lds     zh, litbuf1
0032f5 95e0              com     zl
0032f6 95f0              com     zh
0032f7 9631              adiw    zl, 1
0032f8 93e0 01d7         sts     litbuf0, zl
0032fa 93f0 01d8         sts     litbuf1, zh
                 MINUSC_:
0032fc d009              rcall   ANDIC1
0032fd 6590              ori     tosh, 0x50
0032fe d024              rcall   ICOMMA_
0032ff d4eb              rcall   DUP
003300 9180 01d8         lds     tosl, litbuf1
003302 d007              rcall   ANDIC2
003303 6980              ori     tosl, 0x90
003304 6490              ori     tosh, 0x40
003305 c01d              rjmp    ICOMMA_
                 
                 ANDIC1:
003306 d701              rcall   IDPMINUS
003307 d700              rcall   IDPMINUS
003308 9180 01d7         lds     tosl, litbuf0
                 ANDIC2:
00330a 2f98              mov     tosh, tosl
00330b 9592              swap    tosh
00330c 708f              andi    tosl, 0x0f
00330d 709f              andi    tosh, 0x0f
00330e 6880              ori     tosl, 0x80
00330f 9508              ret
                 ANDIC_:
003310 dff5              rcall   ANDIC1
003311 6790              ori     tosh, 0x70
003312 d010              rcall   ICOMMA_
003313 d4d7              rcall   DUP
003314 9180 01d8         lds     tosl, litbuf1
003316 dff3              rcall   ANDIC2
003317 6980              ori     tosl, 0x90
003318 6790              ori     tosh, 0x70
003319 c009              rjmp    ICOMMA_
                 ORIC_:
00331a dfeb              rcall   ANDIC1
00331b 6690              ori     tosh, 0x60
00331c d006              rcall   ICOMMA_
00331d d4cd              rcall   DUP
00331e 9180 01d8         lds     tosl, litbuf1
003320 dfe9              rcall   ANDIC2
003321 6980              ori     tosl, 0x90
003322 6690              ori     tosh, 0x60
                 ICOMMA_:
003323 940c 3f13         jmp     ICOMMA
                 
003325 e5d4              fdw     MINUS_L
                 AND_L:
003326 6183
003327 646e              .db     NFA|INLINE4|3, "and"
                 AND_:
003328 9109              ld      t0, Y+
003329 9119              ld      t1, Y+
00332a 2380              and     tosl, t0
00332b 2391              and     tosh, t1
00332c 9508              ret
                 
00332d e64c              fdw     AND_L
                 OR_L:
00332e 6f82
00332f 0072              .db     NFA|INLINE4|2, "or",0
                 OR_:
003330 9109              ld      t0, Y+
003331 9119              ld      t1, Y+
003332 2b80              or      tosl, t0
003333 2b91              or      tosh, t1
003334 9508              ret
                 
003335 e65c              fdw     OR_L
                 XOR_L:
003336 7883
003337 726f              .db     NFA|INLINE4|3, "xor"
                 XOR_:
003338 9109              ld      t0, Y+
003339 9119              ld      t1, Y+
00333a 2780              eor     tosl, t0
00333b 2791              eor     tosh, t1
00333c 9508              ret
                 
00333d e66c              fdw     XOR_L
                 INVERT_L:
00333e 69a6
00333f 766e
003340 7265
003341 0074              .db     NFA|INLINE|6, "invert",0
                 INVERT:
003342 9580              com     tosl
003343 9590              com     tosh
003344 9508              ret
                 
003345 e67c              fdw     INVERT_L
                 NEGATE_L:
003346 6e86
003347 6765
003348 7461
003349 0065              .db     NFA|6, "negate",0
                 NEGATE:
00334a 9580              com     tosl
00334b 9590              com     tosh
00334c 9601              adiw    tosl, 1
00334d 9508              ret
                 
00334e e68c              fdw     NEGATE_L
                 ONEPLUS_L:
00334f 31a2
003350 002b              .db     NFA|INLINE|2, "1+",0
                 ONEPLUS:
003351 9601              adiw    tosl, 1
003352 9508              ret
                 
003353 e69e              fdw     ONEPLUS_L
                 ONEMINUS_L:
003354 31a2
003355 002d              .db     NFA|INLINE|2, "1-",0
                 ONEMINUS:
003356 9701              sbiw    tosl, 1
003357 9508              ret
                 
003358 e6a8              fdw     ONEMINUS_L
                 TWOPLUS_L:
003359 32a2
00335a 002b              .db     NFA|INLINE|2, "2+",0
                 TWOPLUS:
00335b 9602              adiw    tosl, 2
00335c 9508              ret
                 
00335d e6b2              fdw     TWOPLUS_L
                 TOBODY_L:
00335e 3ea5
00335f 6f62
003360 7964              .db     NFA|INLINE|5, ">body"
                 TOBODY:
003361 9604              adiw    tosl, 4
003362 9508              ret
                 
003363 e6bc              fdw     TOBODY_L
                 TWOSTAR_L:
003364 32a2
003365 002a              .db     NFA|INLINE|2, "2*",0
                 TWOSTAR:
003366 0f88              lsl     tosl
003367 1f99              rol     tosh
003368 9508              ret
                 
003369 e6c8              fdw     TWOSTAR_L
                 TWOSLASH_L:
00336a 32a2
00336b 002f              .db     NFA|INLINE|2, "2/",0
                 TWOSLASH:
00336c 9595              asr     tosh
00336d 9587              ror     tosl
00336e 9508              ret
                 
00336f e6d4              fdw     TWOSLASH_L
                 PLUSSTORE_L:
003370 2b82
003371 0021              .db     NFA|2,"+!",0
                 PLUSSTORE:
003372 df2c              rcall   SWOP
003373 df35              rcall   OVER
003374 d3ae              rcall   FETCH_A
003375 df68              rcall   PLUS
003376 df28              rcall   SWOP
003377 940c 3e22         jmp     STORE
                 
003379 e6e0              fdw     PLUSSTORE_L
                 WITHIN_L:
00337a 7786
00337b 7469
00337c 6968
00337d 006e              .db     NFA|6,"within",0
                 WITHIN:
00337e df2a              rcall   OVER
00337f df6b              rcall   MINUS
003380 df38              rcall   TOR
003381 df69              rcall   MINUS
003382 df40              rcall   RFROM
003383 940c 339d         jmp     ULESS
                 
003385 e6f4              fdw     WITHIN_L
                 NOTEQUAL_L:
003386 3c82
003387 003e              .db     NFA|2,"<>",0
                 NOTEQUAL:
003388 d004              rcall   EQUAL
003389 940c 37f1         jmp     ZEROEQUAL
                 
00338b efec              fdw     ZEROLESS_L
                 EQUAL_L:
00338c 3d81              .db     NFA|1, "="
                 EQUAL:
00338d df5d              rcall   MINUS
00338e 940c 37f1         jmp     ZEROEQUAL
                 
                 
003390 e718              fdw     EQUAL_L
                 LESS_L:
003391 3c81              .db     NFA|1,"<"
                 LESS:
003392 df58              rcall   MINUS
003393 940c 37f8         jmp     ZEROLESS
                 
003395 e722              fdw     LESS_L
                 GREATER_L:
003396 3e81              .db     NFA|1,">"
                 GREATER:
003397 df07              rcall   SWOP
003398 940c 3392         jmp     LESS
                 
00339a e72c              fdw     GREATER_L
                 ULESS_L:
00339b 7582
00339c 003c              .db     NFA|2,"u<",0
                 ULESS:
00339d df4d              rcall   MINUS       ; Carry is valid after MINUS
00339e 0b88              sbc     tosl, tosl
00339f 0b99              sbc     tosh, tosh
0033a0 9508              ret
                 
0033a1 e736              fdw     ULESS_L
                 UGREATER_L:
0033a2 7582
0033a3 003e              .db     NFA|2, "u>",0
                 UGREATER:
0033a4 defa              rcall   SWOP
0033a5 940c 339d         jmp     ULESS
                 
0033a7 e744              fdw     UGREATER_L
                 STORE_P_L:
0033a8 2182
0033a9 0070              .db     NFA|2,"!p",0
                 STORE_P:
0033aa 01ac              movw    pl, tosl
0033ab 9189
0033ac 9199              poptos
0033ad 9508              ret
                 
0033ae e750              fdw     STORE_P_L
                 STORE_P_TO_R_L:
0033af 2194
0033b0 3e70
0033b1 0072              .db     NFA|COMPILE|4,"!p>r",0
                 STORE_P_TO_R:
                         m_pop_zh
0033b2 91ff              pop     zh
0033b3 91ef              pop     zl
0033b4 934f              push    pl
0033b5 935f              push    ph
0033b6 01ac              movw    pl, tosl
0033b7 9189
0033b8 9199              poptos
0033b9 9409              mijmp
                 
0033ba e75e              fdw     STORE_P_TO_R_L
                 R_TO_P_L:
0033bb 7293
0033bc 703e              .db     NFA|COMPILE|3,"r>p"
                 R_TO_P:
                         m_pop_zh
0033bd 91ff              pop     zh
0033be 91ef              pop     zl
0033bf 915f              pop     ph
0033c0 914f              pop     pl
0033c1 9409              mijmp
                 
0033c2 e776              fdw     R_TO_P_L
                 PFETCH_L:
0033c3 7082
0033c4 0040              .db     NFA|2,"p@",0
                 PFETCH:
0033c5 939a
0033c6 938a              pushtos
0033c7 01ca              movw    tosl, pl
0033c8 940c 3e5c         jmp     FETCH
                 
0033ca e786              fdw     PFETCH_L
                 PSTORE_L:
0033cb 7082
0033cc 0021              .db     NFA|2,"p!",0
                 PSTORE:
0033cd 939a
0033ce 938a              pushtos
0033cf 01ca              movw    tosl, pl
0033d0 940c 3e22         jmp     STORE
                 
0033d2 e796              fdw     PSTORE_L
                 PCSTORE_L:
0033d3 7083
0033d4 2163              .db     NFA|3,"pc!"
                 PCSTORE:
0033d5 939a
0033d6 938a              pushtos
0033d7 01ca              movw    tosl, pl
0033d8 940c 3e91         jmp     CSTORE
                 
0033da e7a6              fdw     PCSTORE_L
                 PPLUS_L:
0033db 70a2
0033dc 002b              .db     NFA|INLINE|2,"p+",0
                 PPLUS:
0033dd 0d46              add     pl, r_one
0033de 1d55              adc     ph, zero
0033df 9508              ret   
                 
0033e0 e7b6              fdw     PPLUS_L
                 PNPLUS_L:
0033e1 7083
0033e2 2b2b              .db     NFA|3,"p++"
                 PNPLUS:
0033e3 0f48              add     pl, tosl
0033e4 1f59              adc     ph, tosh
0033e5 9189
0033e6 9199              poptos
0033e7 9508              ret
                 
0033e8 e7c2              fdw     PNPLUS_L
                 UEMIT_L:
0033e9 2785
0033ea 6d65
0033eb 7469              .db     NFA|5,"'emit"
                 UEMIT_:
0033ec d12f              rcall   DOUSER
0033ed ffe8              .dw     uemit
                         
0033ee e7d2              fdw     UEMIT_L
                 UKEY_L:
0033ef 2784
0033f0 656b
0033f1 0079              .db     NFA|4,"'key",0
                 UKEY_:
0033f2 d129              rcall   DOUSER
0033f3 ffea              .dw     ukey
                 
0033f4 e7de              fdw     UKEY_L
                 UKEYQ_L:
0033f5 2785
0033f6 656b
0033f7 3f79              .db     NFA|5,"'key?"
                 UKEYQ_:
0033f8 d123              rcall   DOUSER
0033f9 ffec              .dw     ukeyq
                 
0033fa 3f83
0033fb 3d30              .db     NFA|3,"?0="
                 ZEROSENSE:
0033fc 9700              sbiw    tosl, 0
0033fd 9189
0033fe 9199              poptos
0033ff 9508              ret
                 
003400 6483
003401 3d30              .db     NFA|3,"d0="
                 DUPZEROSENSE:
003402 9700              sbiw    tosl, 0
003403 9508              ret
                 
003404 e7ea              fdw     UKEYQ_L
                 UMSTAR_L:
003405 7583
003406 2a6d              .db     NFA|3,"um*"
                 UMSTAR:
003407 940c 3f39         jmp     umstar0
                 
003409 e80a              fdw     UMSTAR_L
                 UMSLASHMOD_L:
00340a 7586
00340b 2f6d
00340c 6f6d
00340d 0064              .db     NFA|6,"um/mod",0
                 UMSLASHMOD:
00340e 940c 3f52         jmp     umslashmod0
                 
                 
003410 e814              fdw     UMSLASHMOD_L
                 USLASHMOD_L:
003411 7585
003412 6d2f
003413 646f              .db     NFA|5,"u/mod"
                 USLASHMOD:
003414 d36f              rcall   FALSE_
003415 de89              rcall   SWOP
003416 940c 3f52         jmp     umslashmod0
                 
003418 e822              fdw     USLASHMOD_L
                 STAR_L:
003419 2a81              .db     NFA|1,"*"
                 STAR: 
00341a dfec              rcall   UMSTAR
00341b 940c 3298         jmp     DROP
                 
00341d e832              fdw     STAR_L
                 USLASH_L:
00341e 7582
00341f 002f              .db     NFA|2,"u/",0
                 USLASH:
003420 dff3              rcall   USLASHMOD
003421 940c 343d         jmp     NIP
                 
003423 e83c              fdw     USLASH_L
                 USSMOD_L:
003424 7586
003425 2f2a
003426 6f6d
003427 0064              .db     NFA|6,"u*/mod",0
                 USSMOD:
003428 de90              rcall   TOR
003429 dfdd              rcall   UMSTAR
00342a de98              rcall   RFROM
00342b 940c 340e         jmp     UMSLASHMOD
                 
                 
00342d e848              fdw     USSMOD_L
                 SLASH_L:
00342e 2f81              .db     NFA|1,"/"
                 SLASH: 
00342f dda5              rcall   TWODUP
003430 df07              rcall   XOR_
003431 de87              rcall   TOR
003432 dea6              rcall   ABS_
003433 de6b              rcall   SWOP
003434 dea4              rcall   ABS_
003435 de69              rcall   SWOP
003436 dfe9              rcall   USLASH
003437 de8b              rcall   RFROM
003438 940c 344c         jmp     QNEGATE
                 
00343a e85c              fdw     SLASH_L
                 NIP_L:
00343b 6ea3
00343c 7069              .db     NFA|INLINE|3,"nip"
                 NIP:
00343d 9109              ld      t0, y+
00343e 9109              ld      t0, y+
00343f 9508              ret
                     
003440 e876              fdw     NIP_L
                 TUCK_L:
003441 7484
003442 6375
003443 006b              .db     NFA|4,"tuck",0
                 TUCK:
003444 de5a              rcall   SWOP
003445 940c 32a9         jmp     OVER
                 
003447 e882              fdw     TUCK_L
                 QNEGATE_L:
003448 3f87
003449 656e
00344a 6167
00344b 6574              .db     NFA|7,"?negate"
                 QNEGATE:
00344c d3ab              rcall   ZEROLESS
00344d dfae              rcall   ZEROSENSE
00344e f009              breq    QNEGATE1
00344f defa              rcall   NEGATE
                 QNEGATE1:
003450 9508              ret
                 
003451 e890              fdw     QNEGATE_L
                 MAX_L:
003452 6d83
003453 7861              .db     NFA|3,"max"
003454 dd80      MAX:    rcall   TWODUP
003455 df3c              rcall   LESS
003456 cdaa              rjmp    MINMAX
                 
003457 e8a4              fdw     MAX_L
                 MIN_L:
003458 6d83
003459 6e69              .db     NFA|3,"min"
00345a dd7a      MIN:    rcall   TWODUP
00345b df3b              rcall   GREATER
00345c cda4              rjmp    MINMAX
                 
00345d 6382
00345e 0040              .db     NFA|2,"c@",0
                 CFETCH_A:       
00345f 940c 3e77         jmp     CFETCH
                 
003461 6382
003462 0021              .db     NFA|2,"c!",0
                 CSTORE_A:       
003463 940c 3e91         jmp     CSTORE
                 
003465 e8b0              fdw     MIN_L
                 UPTR_L:
003466 7582
003467 0070              .db     NFA|2,"up",0
003468 dc77      UPTR:   rcall   DOCREATE
003469 0002              .dw     2 ; upl
                 
00346a e8cc              fdw     UPTR_L
                 HOLD_L:
00346b 6884
00346c 6c6f
00346d 0064              .db     NFA|4,"hold",0
00346e d31e      HOLD:   rcall   TRUE_
00346f d092              rcall   HP
003470 df01              rcall   PLUSSTORE
003471 d090              rcall   HP
003472 d2b0              rcall   FETCH_A
003473 940c 3e91         jmp     CSTORE
                 
                 ; <#    --              begin numeric conversion
                 ;   PAD HP ! ;          (initialize Hold Pointer)
003475 e8d6              fdw     HOLD_L
                 LESSNUM_L:
003476 3c82
003477 0023              .db     NFA|2,"<#",0
                 LESSNUM: 
003478 d08e              rcall   PAD
003479 d088              rcall   HP
00347a 940c 3e22         jmp     STORE
                 
                 ; digit   n -- c            convert to 0..9a..z
00347c e8ec              fdw     LESSNUM_L
                 TODIGIT_L:
00347d 6485
00347e 6769
00347f 7469              .db     NFA|5,"digit"
                 TODIGIT:
003480 308a              cpi     tosl, 0xa
003481 f00c              brlt    TODIGIT1
003482 9687              adiw    tosl, 0x27
                 TODIGIT1:
003483 96c0              adiw    tosl, 0x30
003484 9508              ret
                 
                 ; #     ud1 -- ud2     convert 1 digit of output
                 ;   base @ ud/mod rot >digit hold ;
003485 e8fa              fdw     TODIGIT_L
                 NUM_L:
003486 2381              .db     NFA|1,"#"
                 NUM:
003487 d087              rcall   BASE
003488 d29a              rcall   FETCH_A
003489 d184              rcall   UDSLASHMOD
00348a de26              rcall   ROT
00348b dff4              rcall   TODIGIT
00348c 940c 346e         jmp     HOLD
                 
                 ; #S    ud1 -- ud2      convert remaining digits
                 ;   begin # 2dup or 0= until ;
00348e e90c              fdw     NUM_L
                 NUMS_L:
00348f 2382
003490 0073              .db     NFA|2,"#s",0
                 NUMS:
003491 dff5              rcall   NUM
003492 dd42              rcall   TWODUP
003493 de9c              rcall   OR_
003494 df67              rcall   ZEROSENSE
003495 f7d9              brne    NUMS
003496 9508              ret
                 
                 ; #>    ud1 -- c-addr u    end conv., get string
                 ;   2drop hp @ pad over - ;
003497 e91e              fdw     NUMS_L
                 NUMGREATER_L:
003498 2382
003499 003e              .db     NFA|2,"#>", 0
                 NUMGREATER:
00349a dd33              rcall   TWODROP
00349b d066              rcall   HP
00349c d286              rcall   FETCH_A
00349d d069              rcall   PAD
00349e de0a              rcall   OVER
00349f 940c 32eb         jmp     MINUS
                 
                 ; SIGN  n --               add minus sign if n<0
                 ;   0< IF 2D HOLD THEN ; 
0034a1 e930              fdw     NUMGREATER_L
                 SIGN_L:
0034a2 7384
0034a3 6769
0034a4 006e              .db     NFA|4,"sign",0
                 SIGN:
0034a5 3090              cpi     tosh, 0
0034a6 f41a              brpl    SIGN1
0034a7 d33a              rcall   DOLIT
0034a8 002d              .dw     0x2D
0034a9 dfc4              rcall   HOLD
                 SIGN1:
0034aa 940c 3298         jmp     DROP
                 
                 ; U.    u --                  display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
0034ac e944              fdw     SIGN_L
                 UDOT_L:
0034ad 7582
0034ae 002e              .db     NFA|2,"u.",0
                 UDOT:
0034af dfc8              rcall   LESSNUM
0034b0 d2d3              rcall   FALSE_
0034b1 dfdf              rcall   NUMS
0034b2 dfe7              rcall   NUMGREATER
0034b3 dd9b              rcall   TYPE
0034b4 940c 31e5         jmp     SPACE_
                 
                 
                 ; U.R    u +n --      display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
0034b6 e95a              fdw     UDOT_L
                 UDOTR_L:
0034b7 7583
0034b8 722e              .db     NFA|3,"u.r"
                 UDOTR:
0034b9 dfbe              rcall   LESSNUM
0034ba de9b              rcall   ONEMINUS
0034bb ddfd              rcall   TOR
0034bc d2c7              rcall   FALSE_
0034bd c001              rjmp    UDOTR2
                 UDOTR1:
0034be dfc8              rcall   NUM
                 UDOTR2: 
0034bf d5e1              rcall   XNEXT
0034c0 f7e8              brcc    UDOTR1
0034c1 911f              pop     t1
0034c2 910f              pop     t0
0034c3 dfcd              rcall   NUMS
0034c4 dfd5              rcall   NUMGREATER
0034c5 dd89              rcall   TYPE
0034c6 940c 31e5         jmp     SPACE_
                 
                 ; .     n --                    display n signed
                 ;   <# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
0034c8 e96e              fdw     UDOTR_L
                 DOT_L:
0034c9 2e81              .db     NFA|1,"."
0034ca dfad      DOT:    rcall   LESSNUM
0034cb d31f              rcall   DUP
0034cc de0c              rcall   ABS_
0034cd d2b6              rcall   FALSE_
0034ce dfc2              rcall   NUMS
0034cf dde1              rcall   ROT
0034d0 dfd4              rcall   SIGN
0034d1 dfc8              rcall   NUMGREATER
0034d2 dd7c              rcall   TYPE
0034d3 940c 31e5         jmp     SPACE_
                 
0034d5 e992              FDW     DOT_L
                 DECIMAL_L:
0034d6 6487
0034d7 6365
0034d8 6d69
0034d9 6c61              .db     NFA|7,"decimal"
                 DECIMAL: 
0034da d281              rcall   TEN
0034db d033              rcall   BASE
0034dc 940c 3e22         jmp     STORE
                 
                 ; HEX     --              set number base to hex
                 ;   #16 BASE ! ;
0034de e9ac              Fdw     DECIMAL_l
                 HEX_L:
0034df 6883
0034e0 7865              .db     NFA|3,"hex"
                 HEX:
0034e1 d300              rcall   DOLIT
0034e2 0010              .dw     16
0034e3 d02b              rcall   BASE
0034e4 940c 3e22         jmp     STORE
                 
                 ; BIN     --              set number base to binary
                 ;   #2 BASE ! ;
0034e6 e9be              Fdw     HEX_L
                 BIN_L:
0034e7 6283
0034e8 6e69              .db     NFA|3,"bin"
0034e9 dc7d      BIN:    rcall   CELL
0034ea d024              rcall   BASE
0034eb 940c 3e22         jmp     STORE
                 
                 ; RSAVE   -- a-addr     Saved return stack pointer
0034ed e9ce              fdw     BIN_L
                 RSAVE_L:
0034ee 7285
0034ef 6173
0034f0 6576              .db     NFA|5,"rsave"
0034f1 d02a      RSAVE_: rcall   DOUSER
0034f2 fffe              .dw     ursave
                 
                 
                 ; ULINK   -- a-addr     link to next task
0034f3 e9dc              fdw     RSAVE_L
                 ULINK_L:
0034f4 7585
0034f5 696c
0034f6 6b6e              .db     NFA|5,"ulink"
0034f7 d024      ULINK_: rcall   DOUSER
0034f8 fffc              .dw     ulink
                 
                 
                 ; TASK       -- a-addr              TASK pointer
0034f9 e9e8              fdw     ULINK_L
                 TASK_L:
0034fa 7484
0034fb 7361
0034fc 006b              .db     NFA|4,"task",0
0034fd d01e      TASK:   rcall   DOUSER
0034fe fff2              .dw     utask
                 
                 
                 ; HP       -- a-addr                HOLD pointer
0034ff e9f4              fdw     TASK_L
                 HP_L:
003500 6882
003501 0070              .db     NFA|2,"hp",0
003502 d019      HP:     rcall   DOUSER
003503 0000              .dw     uhp
                 
                 ; PAD     -- a-addr        User Pad buffer
003504 ea00              fdw     HP_L
                 PAD_L:
003505 7083
003506 6461              .db     NFA|3,"pad"
                 PAD:
003507 d185              rcall   TIB
003508 d17c              rcall   TIBSIZE
003509 940c 32de         jmp     PLUS
                 
                 ; BASE    -- a-addr       holds conversion radix
00350b ea0a              fdw     PAD_L
                 BASE_L:
00350c 6284
00350d 7361
00350e 0065              .db     NFA|4,"base",0
                 BASE:
00350f d00c              rcall   DOUSER
003510 ffee              .dw     ubase
                 
                 ; USER   n --
003511 ea18              fdw     BASE_L
                 USER_L:
003512 7584
003513 6573
003514 0072              .db     NFA|4,"user",0
                 USER:
003515 d31e              rcall   CREATE
003516 dc50              rcall   CELL
003517 de32              rcall   NEGATE
003518 d4b7              rcall   IALLOT
003519 940e 3f13         call    ICOMMA
00351b d368              rcall   XDOES
                 DOUSER:
                         m_pop_zh
00351c 91ff              pop     zh
00351d 91ef              pop     zl
00351e dbd0              rcall   FETCHLIT
00351f 0d82              add     tosl, upl
003520 1d93              adc     tosh, uph
003521 9508              ret
                 
                 ; SOURCE   -- adr n         current input buffer
                 ;   'SOURCE 2@ ;        length is at higher adrs
003522 ea24              fdw     USER_L
                 SOURCE_L:
003523 7386
003524 756f
003525 6372
003526 0065              .db     NFA|6,"source",0
                 SOURCE:
003527 d177              rcall   TICKSOURCE
003528 940c 31bb         jmp     TWOFETCH
                 
                 
                 ; /STRING  a u n -- a+n u-n          trim string
                 ;   swap over - >r + r>
00352a ea46              fdw      SOURCE_L
                 SLASHSTRING_L:
00352b 2f87
00352c 7473
00352d 6972
00352e 676e              .db     NFA|7,"/string"
                 SLASHSTRING:
00352f dd6f              rcall   SWOP
003530 dd78              rcall   OVER
003531 ddb9              rcall   MINUS
003532 dd86              rcall   TOR
003533 ddaa              rcall   PLUS
003534 dd8e              rcall   RFROM
003535 9508              ret
                 
                 ; \     Skip the rest of the line
003536 ea56              fdw     SLASHSTRING_L
                 BSLASH_L:
003537 5cc1              .db     NFA|IMMED|1,0x5c
                 BSLASH:
003538 dfee              rcall   SOURCE
003539 d15e              rcall   TOIN
00353a d057              rcall   STORE_A
00353b 6460              sbr     FLAGS1, (1<<noclear)  ; dont clear flags in case of \
00353c 940c 3298         jmp     DROP
                 
                 ; PARSE  char -- c-addr u
00353e ea6e              fdw     BSLASH_L
                 PARSE_L:
00353f 7085
003540 7261
003541 6573              .db     NFA|5,"parse"
                 PARSE:
003542 d2a8              rcall   DUP             ; c c
003543 dfe3              rcall   SOURCE          ; c c a u
003544 d153              rcall   TOIN            ; c c a u a
003545 d1dd              rcall   FETCH_A         ; c c a u n
003546 dfe8              rcall   SLASHSTRING     ; c c a u   new tib addr/len
003547 d2a3              rcall   DUP             ; c c a u u
003548 dd70              rcall   TOR             ; c c a u                  R: u (new tib len
003549 dd67              rcall   ROT             ; c a u c
00354a dae7              rcall   SKIP            ; c a u        
00354b dd5d              rcall   OVER            ; c a u a
00354c dd6c              rcall   TOR             ; c a u                    R: u a (start of word
00354d dd63              rcall   ROT             ; a u c
00354e dafe              rcall   SCAN            ; a u      end of word, tib left       
00354f deb2              rcall   DUPZEROSENSE
003550 f009              breq    PARSE1
003551 de04              rcall   ONEMINUS
003552 dd70      PARSE1: rcall   RFROM           ; a u a
003553 dd6f              rcall   RFROM           ; a u a u
003554 dd5c              rcall   ROT             ; a a u u
003555 dd95              rcall   MINUS           ; a a n  ( addition to toin
003556 d141              rcall   TOIN
003557 de1a              rcall   PLUSSTORE       ; aend astart
003558 deeb              rcall   TUCK            ; astart aend astart
003559 940c 32eb         jmp     MINUS           ; astart wlen
                      
                 
                 ; WORD   char -- c-addr        word delimited by char and/or TAB
00355b ea7e              fdw     PARSE_L
                 WORD_L:
00355c 7784
00355d 726f
00355e 0064              .db     NFA|4,"word",0
                 WORD:
00355f dfe2              rcall   PARSE           ; c-addr wlen
003560 dd3e              rcall   SWOP
003561 ddf4              rcall   ONEMINUS
003562 dee1              rcall   TUCK
003563 940c 3e91         jmp     CSTORE          ; Write the length into the TIB ! 
                 
                 ; CMOVE  src dst u --  copy u bytes from src to dst
                 ; cmove swap !p for c@+ pc! p+ next drop ;
003565 eab8              fdw     WORD_L
                 CMOVE_L:
003566 6385
003567 6f6d
003568 6576              .db     NFA|5,"cmove"
                 CMOVE:
003569 dd35              rcall   SWOP
00356a de47              rcall   STORE_P_TO_R
00356b dd4d              rcall   TOR
00356c c003              rjmp    CMOVE2
                 CMOVE1:
00356d d016              rcall   CFETCHPP
00356e de66              rcall   PCSTORE
00356f de6d              rcall   PPLUS
                 CMOVE2:
003570 d530              rcall   XNEXT
003571 f7d8              brcc    CMOVE1
003572 911f              pop     t1
003573 910f              pop     t0
003574 de48              rcall   R_TO_P
003575 940c 3298         jmp     DROP
                 
                 
                 ; place  src n dst --     place as counted str
003577 eacc              fdw     CMOVE_L
                 PLACE_L:
003578 7085
003579 616c
00357a 6563              .db     NFA|5,"place"
                 PLACE: 
00357b dc59              rcall   TWODUP
00357c dee6              rcall   CSTORE_A
00357d dc10              rcall   CHARPLUS
00357e dd20              rcall   SWOP
00357f 940c 3569         jmp     CMOVE
                 
                 ; :     c@+ ( addr -- addr+1 n ) dup 1+ swap c@ ;
003581 eaf0              fdw     PLACE_L
                 CFETCHPP_L:
003582 6383
003583 2b40              .db     NFA|3,"c@+"
                 CFETCHPP:
003584 d266              rcall   DUP
003585 ddcb              rcall   ONEPLUS
003586 dd18              rcall   SWOP
003587 940c 3e77         jmp     CFETCH
                 
                 ; :     @+ ( addr -- addr+2 n ) dup 2+ swap @ ;
003589 eb04              fdw     CFETCHPP_L
                 FETCHPP_L:
00358a 4082
00358b 002b              .db     NFA|2,"@+",0
                 FETCHPP:
00358c d25e              rcall   DUP
00358d ddcd              rcall   TWOPLUS
00358e dd10              rcall   SWOP
00358f 940c 3e5c         jmp     FETCH
                 
003591 2181              .db     NFA|1,"!"
                 STORE_A:        
003592 940c 3e22         jmp     STORE
                 
                 ; N>C   nfa -- cfa    name adr -> code field
003594 eb14              fdw    FETCHPP_L
                 NTOC_L:
003595 6e83
003596 633e              .db     NFA|3,"n>c"
                 NFATOCFA:
003597 dfec              rcall   CFETCHPP
003598 708f              andi    tosl, 0x0f
003599 dd44              rcall   PLUS
00359a 940c 317a         jmp     ALIGNED
                 
                 ; C>N   cfa -- nfa    code field addr -> name field addr
00359c eb2a              fdw    NTOC_L
                 CTON_L:
00359d 6383
00359e 6e3e              .db     NFA|3,"c>n"
                 CFATONFA:
00359f d354              rcall   TWOMINUS
0035a0 d24a              rcall   DUP
0035a1 debd              rcall   CFETCH_A
0035a2 940e 3e1b         call    TO_A
0035a4 ff27              sbrs    al, 7
0035a5 f3c9              breq    CFATONFA
0035a6 9508              ret
                 
                 ; findi   c-addr nfa -- c-addr 0   if not found
                 ;                          xt  1      if immediate
                 ;                          xt -1      if "normal"
0035a7 eb3a              fdw     CTON_L
                 BRACFIND_L:
0035a8 2883
0035a9 2966              .db     NFA|3,"(f)"
                 findi:
                 findi1:
                 FIND_1: 
0035aa dc2a              rcall   TWODUP
0035ab da63              rcall   NEQUAL
0035ac de55              rcall   DUPZEROSENSE
0035ad f021              breq    findi2
0035ae dce9              rcall   DROP
0035af d344              rcall   TWOMINUS ;;;      NFATOLFA
0035b0 d172              rcall   FETCH_A
0035b1 d239              rcall   DUP
                 findi2:
0035b2 de49              rcall   ZEROSENSE
0035b3 f7b1              brne    findi1
0035b4 de4d              rcall   DUPZEROSENSE
0035b5 f041              breq    findi3
0035b6 de86              rcall   NIP
0035b7 d233              rcall   DUP
0035b8 dfde              rcall   NFATOCFA
0035b9 dce5              rcall   SWOP
0035ba d009              rcall   IMMEDQ
0035bb d235              rcall   ZEROEQUAL
0035bc dc4b              rcall   ONE
0035bd dd72              rcall   OR_
                 findi3: 
0035be 9508              ret
                 ;        jmp     PAUSE
                 
                 ; IMMED?    nfa -- f        fetch immediate flag
0035bf eb50              fdw     BRACFIND_L
                 IMMEDQ_L:
0035c0 6986
0035c1 6d6d
0035c2 6465
0035c3 003f              .db     NFA|6,"immed?",0
                 IMMEDQ: 
0035c4 de9a              rcall   CFETCH_A
0035c5 2e98              mov     wflags, tosl  ; COMPILE and INLINE flags for the compiler
0035c6 7480              andi    tosl, IMMED
0035c7 9508              ret
                 
                 ; FIND   c-addr -- c-addr 0   if not found
                 ;                  xt  1      if immediate
                 ;                  xt -1      if "normal"
0035c8 eb80              fdw     IMMEDQ_L
                 FIND_L:
0035c9 6684
0035ca 6e69
0035cb 0064              .db     NFA|4,"find",0
                 FIND:   
0035cc d215              rcall   DOLIT
0035cd f702              fdw     kernellink
0035ce dfdb              rcall   findi
0035cf de32              rcall   DUPZEROSENSE
0035d0 f421              brne    FIND1
0035d1 dcc6              rcall   DROP
0035d2 d339              rcall   LATEST_
0035d3 d14f              rcall   FETCH_A
0035d4 dfd5              rcall   findi
                 FIND1:
0035d5 9508              ret
                 
                 ; DIGIT?   c -- n -1   if c is a valid digit
0035d6 eb92              fdw     FIND_L
                 DIGITQ_L:
0035d7 6486
0035d8 6769
0035d9 7469
0035da 003f              .db     NFA|6,"digit?",0
                 DIGITQ:
                                                 ; 1 = 31    A = 41
0035db 3480              cpi     tosl, 0x40
0035dc f00c              brlt    DIGITQ1
0035dd 9787              sbiw    tosl, 0x27
                 DIGITQ1:        
0035de 97c0              sbiw    tosl, 0x30      ; 1
0035df d20b              rcall   DUP             ; 1 1
0035e0 df2e              rcall   BASE            ; 1 1 base
0035e1 d141              rcall   FETCH_A         ; 1 1 10
0035e2 ddaf              rcall   LESS            ; 1 ffff
0035e3 dcc5              rcall   OVER            ; 1 ffff 1
0035e4 d213              rcall   ZEROLESS        ; 1 ffff 0
0035e5 dd5c              rcall   INVERT
0035e6 940c 3328         jmp     AND_
                 
                 ; SIGN?   adr n -- adr' n' f   get optional sign
                 ; + leaves $0000 flag
                 ; - leaves $0002 flag
0035e8 ebae              fdw     DIGITQ_L
                 SIGNQ_L:
0035e9 7385
0035ea 6769
0035eb 3f6e              .db     NFA|5,"sign?"
                 SIGNQ:
0035ec dcbc              rcall   OVER
0035ed de71              rcall   CFETCH_A
0035ee 978c              sbiw    tosl, ','
0035ef d1fb              rcall   DUP
0035f0 dce8              rcall   ABS_
0035f1 dc16              rcall   ONE
0035f2 dd9a              rcall   EQUAL
0035f3 dd34              rcall   AND_
0035f4 de0d              rcall   DUPZEROSENSE
0035f5 f029              breq    QSIGN1
0035f6 dd5a              rcall   ONEPLUS
0035f7 dcc1              rcall   TOR
0035f8 dc0f              rcall   ONE
0035f9 df35              rcall   SLASHSTRING
0035fa dcc8              rcall   RFROM
0035fb 9508      QSIGN1: ret
                 
                 ; UD*  ud u -- ud
0035fc ebd2              fdw     SIGNQ_L
                 UDSTAR_L:
0035fd 7583
0035fe 2a64              .db     NFA|3,"ud*"
                 UDSTAR:
0035ff d1eb              rcall   DUP
003600 dcb8              rcall   TOR
003601 de05              rcall   UMSTAR
003602 dc95              rcall   DROP
003603 dc9b              rcall   SWOP
003604 dcbe              rcall   RFROM
003605 de01              rcall   UMSTAR
003606 dcaa              rcall   ROT
003607 940c 32de         jmp     PLUS
                         
                 ; UD/MOD  ud u --u(rem) ud(quot)
003609 ebfa              fdw     UDSTAR_L
                 UDSLASHMOD_L:
00360a 7586
00360b 2f64
00360c 6f6d
00360d 0064              .db     NFA|6,"ud/mod",0
                 UDSLASHMOD:
00360e dcaa              rcall   TOR             ; ud.l ud.h 
00360f d174              rcall   FALSE_          ; ud.l ud.h 0
003610 dcbc              rcall   RFETCH          ; ud.l ud.h 0 u
003611 ddfc              rcall   UMSLASHMOD      ; ud.l r.h q.h
003612 dc9e              rcall   ROT             ; r.h q.h ud.l
003613 dc9d              rcall   ROT             ; q.h ud.l r.h
003614 dcae              rcall   RFROM           ; q.h ud.l r.h u
003615 ddf8              rcall   UMSLASHMOD      ; q.h r.l q.l
003616 940c 32b1         jmp     ROT             ; r.l q.l q.h
                         
                 ; >NUMBER  0 0 adr u -- ud.l ud.h adr' u'
                 ;                       convert string to number
003618 ec14              fdw     UDSLASHMOD_L
                 TONUMBER_L:
003619 3e87
00361a 756e
00361b 626d
00361c 7265              .db     NFA|7,">number"
                 TONUMBER:
                 TONUM1:
00361d dde4              rcall   DUPZEROSENSE      ; ud.l ud.h adr u
00361e f0b1              breq    TONUM3
00361f dc99              rcall   TOR
003620 d1ca              rcall   DUP
003621 dc97              rcall   TOR             ; ud.l ud.h adr
003622 de3c              rcall   CFETCH_A
003623 dfb7              rcall   DIGITQ          ; ud.l ud.h digit flag
003624 ddd7              rcall   ZEROSENSE
003625 f421              brne    TONUM2
003626 dc71              rcall   DROP
003627 dc9b              rcall   RFROM
003628 dc9a              rcall   RFROM
003629 c00b              rjmp    TONUM3
                 TONUM2: 
00362a dc8e              rcall   TOR             ; ud.l ud.h digit
00362b dee3              rcall   BASE
00362c d0f6              rcall   FETCH_A
00362d dfd1              rcall   UDSTAR
00362e dc94              rcall   RFROM
00362f dcb6              rcall   MPLUS
003630 dc92              rcall   RFROM
003631 dc91              rcall   RFROM
                         
003632 dbd5              rcall   ONE
003633 defb              rcall   SLASHSTRING
003634 cfe8              rjmp    TONUM1
                 TONUM3: 
003635 9508              ret
                 
                 BASEQV:   
003636 e9b4              fdw     DECIMAL
003637 e9c2              fdw     HEX
003638 e9d2              fdw     BIN
                 
                 
                 ; NUMBER?  c-addr -- n 1
                 ;                 -- dl dh 2
                 ;                 -- c-addr 0  if convert error
003639 ec32              fdw     TONUMBER_L
                 NUMBERQ_L:
00363a 6e87
00363b 6d75
00363c 6562
00363d 3f72              .db     NFA|7,"number?"
                 NUMBERQ:
00363e d1ac              rcall   DUP             ; a a
00363f d144              rcall   FALSE_          ; a a 0 0
003640 d143              rcall   FALSE_          ; a a 0 0
003641 dc6f              rcall   ROT             ; a 0 0 a
003642 df41              rcall   CFETCHPP        ; a 0 0 a' u
003643 dfa8              rcall   SIGNQ           ; a 0 0 a' u f
003644 dc74              rcall   TOR             ; a 0 0 a' u
                 
003645 dec9              rcall   BASE
003646 d0dc              rcall   FETCH_A
003647 dc71              rcall   TOR             ; a 0 0 a' u
                         
003648 dc60              rcall   OVER
003649 de15              rcall   CFETCH_A
                         
00364a 9783              sbiw    tosl, '#'
00364b 3083              cpi     tosl, 3
00364c f440              brsh    BASEQ1
                 
00364d db39              rcall   CELLS
00364e d193              rcall   DOLIT
00364f ec6c              fdw     BASEQV
003650 dc8d              rcall   PLUS
003651 da59              rcall   FEXECUTE
                 
003652 dbb5              rcall   ONE
003653 dedb              rcall   SLASHSTRING
003654 c001              rjmp    BASEQ2
                 BASEQ1:
003655 dc42              rcall   DROP
                 BASEQ2:                         ; a 0 0 a' u
003656 dfc6              rcall   TONUMBER        ; a ud.l ud.h  a' u
003657 dc6b              rcall   RFROM           ; a ud.l ud.h  a' u oldbase
003658 deb6              rcall   BASE            ; a ud.l ud.h  a' u oldbase addr
003659 df38              rcall   STORE_A         ; a ud.l ud.h  a' u
                 
00365a d190              rcall   DUP
00365b d298              rcall   TWOMINUS
00365c d19b              rcall   ZEROLESS        ; a ud.l ud.h  a' u f
00365d dd9e              rcall   ZEROSENSE       ; a ud.l ud.h  a' u
00365e f431              brne    QNUMD
                 QNUM_ERR:                       ; Not a number
00365f dc63              rcall   RFROM           ; a ud.l ud.h a' u sign
003660 dc37              rcall   DROP
003661 db6c              rcall   TWODROP
                 QNUM_ERR1:      
003662 db6b              rcall   TWODROP
003663 d120              rcall   FALSE_          ; a 0           Not a number
003664 c017              rjmp    QNUM3
                 QNUMD:                          ; Double number
                                                 ; a ud.l ud.h a' u
003665 db76              rcall   TWOSWAP         ; a a' u ud.l ud.h 
003666 dc5c              rcall   RFROM           ; a a' u ud.l ud.d sign
003667 dd94              rcall   ZEROSENSE
003668 f009              breq    QNUMD1
003669 d461              rcall   DNEGATE
                 QNUMD1: 
00366a db71              rcall   TWOSWAP         ; a d.l d.h a' u
00366b dd90              rcall   ZEROSENSE       ; a d.l d.h a'
00366c f061              breq    QNUM1
00366d 940e 3e77         call    CFETCH
00366f d172              rcall   DOLIT
003670 002e              .dw     '.'
003671 dc79              rcall   MINUS
003672 dd89              rcall   ZEROSENSE       ; a d.l d.h
003673 f771              brne    QNUM_ERR1
003674 dc3c              rcall   ROT             ; d.l d.h a
003675 dc22              rcall   DROP            ; d.l d.h
003676 d16b              rcall   DOLIT         ; 
003677 0002              .dw     2               ; d.l ud.h 2    Double number
003678 c003              rjmp    QNUM3
                 QNUM1:                          ; single precision dumber
                                                 ; a ud.l ud.h  a'
003679 db54              rcall   TWODROP         ; a n
00367a ddc2              rcall   NIP             ; n
00367b db8c              rcall   ONE             ; n 1           Single number
                 QNUM3:  
00367c 9508              ret
                 
                 
00367d 7384
00367e 6177
00367f 0070              .db     NFA|4,"swap",0
                 SWOP_A:
003680 940c 329f         jmp     SWOP
                 
                 ; TI#  -- n                      size of TIB
                 ; : ti# task @ 8 + @ ;
003682 ec74              fdw     NUMBERQ_L
                 TIBSIZE_L:
003683 7483
003684 2369              .db     NFA|3,"ti#"
                 TIBSIZE:
003685 de77              rcall   TASK
003686 d09c              rcall   FETCH_A
003687 9608              adiw    tosl, 8
003688 940c 3e5c         jmp     FETCH
                 
                 ; TIB     -- a-addr        Terminal Input Buffer
00368a ed06              fdw     TIBSIZE_L
                 TIB_L:
00368b 7483
00368c 6269              .db     NFA|3,"tib"
                 TIB:
00368d d005              rcall   TIU
00368e 940c 3e5c         jmp     FETCH
                         
                 ; TIU     -- a-addr        Terminal Input Buffer user variable 
003690 ed16              fdw     TIB_L
                 TIU_L:
003691 7483
003692 7569              .db     NFA|3,"tiu"
                 TIU:
003693 de88              rcall   DOUSER
003694 fff0              .dw     utib       ; pointer to Terminal input buffer
                 
                 ; >IN     -- a-addr        holds offset into TIB
                 ; In RAM
003695 ed22              fdw     TIU_L
                 TOIN_L:
003696 3e83
003697 6e69              .db     NFA|3,">in"
                 TOIN:
003698 de83              rcall   DOUSER
003699 fffa              .dw     utoin
                 
                 ; 'SOURCE  -- a-addr        two cells: len, adrs
                 ; In RAM ?
00369a ed2c              fdw     TOIN_L
                 TICKSOURCE_L:
00369b 2787
00369c 6f73
00369d 7275
00369e 6563              .db     NFA|7,"'source"
                 TICKSOURCE:
00369f de7c              rcall   DOUSER
0036a0 fff6              .dw     usource       ; two cells !!!!!!
                 
                 WORDQ:
0036a1 d149              rcall   DUP
                         m_pop_t0
0036a2 91ff              pop     zh
0036a3 91ef              pop     zl
0036a4 da4a              rcall   FETCHLIT
0036a5 95f7              ror     zh
0036a6 95e7              ror     zl
0036a7 dce5              rcall   EQUAL
0036a8 dd53              rcall   ZEROSENSE
0036a9 9409              mijmp
                 
                 ;  INTERPRET  c-addr u --    interpret given buffer
0036aa ed36              fdw     TICKSOURCE_L
                 INTERPRET_L:
0036ab 6989
0036ac 746e
0036ad 7265
0036ae 7270
0036af 7465              .db     NFA|9,"interpret"
                 INTERPRET: 
0036b0 dfee              rcall   TICKSOURCE
0036b1 db12              rcall   TWOSTORE
0036b2 d0d1              rcall   FALSE_
0036b3 dfe4              rcall   TOIN
0036b4 dedd              rcall   STORE_A
                 IPARSEWORD:
0036b5 d243              rcall   BL
0036b6 dea8              rcall   WORD
                 
0036b7 d133              rcall   DUP
0036b8 dda6              rcall   CFETCH_A
0036b9 dd42              rcall   ZEROSENSE
0036ba f409              brne    IPARSEWORD1
0036bb c064              rjmp    INOWORD
                 IPARSEWORD1:
0036bc df0f              rcall   FIND            ; sets also wflags
0036bd dd44              rcall   DUPZEROSENSE    ; 0 = not found, -1 = normal, 1 = immediate
0036be f409              brne    IPARSEWORD2     ; NUMBER?
0036bf c045              rjmp    INUMBER
                 IPARSEWORD2:
0036c0 dc90              rcall   ONEPLUS         ; 0 = normal 2 = immediate
0036c1 d23e              rcall   STATE_
0036c2 d12e              rcall   ZEROEQUAL
0036c3 dc6c              rcall   OR_
0036c4 dd37              rcall   ZEROSENSE
0036c5 f099              breq    ICOMPILE_1      ; Compile a word
                         
                                                 ; Execute a word
                                                 ; immediate&compiling or interpreting
0036c6 fe94              sbrs    wflags, 4       ; Compile only check
0036c7 c00a              rjmp    IEXECUTE        ; Not a compile only word
0036c8 d237              rcall   STATE_          ; Compile only word check
0036c9 db92              rcall   XSQUOTE
0036ca 430c
0036cb 4d4f
0036cc 4950
0036cd 454c
0036ce 4f20
0036cf 4c4e
0036d0 0059              .db     12,"COMPILE ONLY",0
0036d1 d0fc              rcall   QABORT
                 IEXECUTE:
0036d2 7b6f              cbr     FLAGS1, (1<<noclear)
0036d3 d9cc              rcall   EXECUTE
0036d4 fd66              sbrc    FLAGS1, noclear ;  set by \ and by (
0036d5 cfdf              rjmp    IPARSEWORD
0036d6 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036d7 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036d8 c02a              rjmp    ICLRFLIT
                 ICOMPILE_1:
0036d9 7e6f              cbr     FLAGS1, (1<<izeroeq) ; Clear 0= encountered in compilation
0036da dfc6              rcall   WORDQ
0036db efe2              fdw     ZEROEQUAL       ; Check for 0=, modifies IF and UNTIL to use bnz
0036dc f011              breq    ICOMPILE_2
0036dd 6160              sbr     FLAGS1, (1<<izeroeq) ; Mark 0= encountered in compilation
0036de c020              rjmp    ICOMMAXT
                 ICOMPILE_2:
0036df ff67              sbrs    FLAGS1, fLIT
0036e0 c014              rjmp    ICOMPILE_6
0036e1 dfbf              rcall   WORDQ
0036e2 e650              fdw     AND_    
0036e3 f011              breq    ICOMPILE_3
0036e4 dc2b              rcall   ANDIC_
0036e5 c01d              rjmp    ICLRFLIT
                 ICOMPILE_3:
0036e6 dfba              rcall   WORDQ
0036e7 e660              fdw     OR_
0036e8 f011              breq    ICOMPILE_4
0036e9 dc30              rcall   ORIC_
0036ea c018              rjmp    ICLRFLIT
                 ICOMPILE_4:
0036eb dfb5              rcall   WORDQ
0036ec e5bc              fdw     PLUS
0036ed f011              breq    ICOMPILE_5
0036ee dc02              rcall   PLUSC_
0036ef c013              rjmp    ICLRFLIT
                 ICOMPILE_5:
0036f0 dfb0              rcall   WORDQ
0036f1 e5d6              fdw     MINUS
0036f2 f011              breq    ICOMPILE_6
0036f3 dc08              rcall   MINUSC_
0036f4 c00e              rjmp    ICLRFLIT
                 ICOMPILE_6:
0036f5 7d6f              cbr     FLAGS1, (1<<idup)    ; Clear DUP encountered in compilation
0036f6 dfaa              rcall   WORDQ
0036f7 efd6              fdw     DUP             ; Check for DUP, modies IF and UNTIl to use DUPZEROSENSE
0036f8 f009              breq    ICOMPILE
0036f9 6260              sbr     FLAGS1, (1<<idup)    ; Mark DUP encountered during compilation
                 ICOMPILE:
0036fa fe95              sbrs    wflags, 5       ; Inline check
0036fb c003              rjmp    ICOMMAXT
0036fc 940e 3a78         call    INLINE0
0036fe c004              rjmp    ICLRFLIT
                 ICOMMAXT:
0036ff d123              rcall   COMMAXT_A
003700 7f6d              cbr     FLAGS1, (1<<fTAILC)  ; Allow tailjmp  optimisation
003701 fc94              sbrc    wflags, 4            ; Compile only ?
003702 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
                 ICLRFLIT:
003703 776f              cbr     FLAGS1, (1<<fLIT)
003704 cfb0              rjmp    IPARSEWORD
                 INUMBER: 
003705 746f              cbr     FLAGS1, (1<<izeroeq) | (1<<idup) | (1<<fLIT)
003706 db91              rcall   DROP
003707 df36              rcall   NUMBERQ
003708 dcf9              rcall   DUPZEROSENSE
003709 f081              breq    IUNKNOWN
00370a d1f5              rcall   STATE_
00370b dcf0              rcall   ZEROSENSE
00370c f059              breq    INUMBER1
00370d 2f08              mov     t0, tosl
00370e 9189
00370f 9199              poptos
003710 ff01              sbrs    t0, 1
003711 c003              rjmp    ISINGLE
                 IDOUBLE:
003712 df6d              rcall   SWOP_A
003713 940e 3df3         call    LITERAL
                 ISINGLE:        
003715 940e 3df3         call    LITERAL
003717 cf9d              rjmp    IPARSEWORD
                 
                 INUMBER1:
003718 db7f              rcall   DROP
003719 cfe9              rjmp    ICLRFLIT
                 
                 IUNKNOWN:
00371a db7d              rcall   DROP 
00371b d044              rcall   DP_TO_RAM
00371c de67              rcall   CFETCHPP
00371d db31              rcall   TYPE
00371e d065              rcall   FALSE_
00371f d0a5              rcall   QABORTQ         ; Never returns & resets the stacks
                 INOWORD: 
003720 940c 3298         jmp     DROP
                 
003722 4081              .db     NFA|1,"@"
                 FETCH_A:        
003723 940c 3e5c         jmp     FETCH
                 
                 ;;;    bitmask -- 
003725 ed56              fdw     INTERPRET_L
                 SHB_L:
003726 7383
003727 6268              .db     NFA|3,"shb"     ; Set header bit
                 SHB:
003728 d1e3              rcall   LATEST_
003729 dff9              rcall   FETCH_A
00372a d0c0              rcall   DUP
00372b dd33              rcall   CFETCH_A
00372c db84              rcall   ROT
00372d dc02              rcall   OR_
00372e df51              rcall   SWOP_A
00372f 940c 3e91         jmp     CSTORE
                         
003731 ee4c              fdw     SHB_L
                 IMMEDIATE_L:
003732 6989
003733 6d6d
003734 6465
003735 6169
003736 6574              .db     NFA|9,"immediate" ; 
                 IMMEDIATE:
003737 d0aa              rcall   DOLIT
003738 0040              .dw     IMMED
003739 940c 3728         jmp     SHB
                 
                 ;***************************************************************
00373b ee64              fdw     IMMEDIATE_L
                 INLINED_L:
00373c 6987
00373d 6c6e
00373e 6e69
00373f 6465              .db     NFA|7,"inlined" ; 
                 INLINED:
003740 d0a1              rcall   DOLIT
003741 0020              .dw     INLINE
003742 940c 3728         jmp     SHB
                 
                 ;; .st ( -- ) output a string with current data section and current base info
                 ;;; : .st base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;;;     <# [char] > hold cse @ #s #> type base ! ;
003744 ee78              fdw     INLINED_L
                 DOTSTATUS_L:
003745 2e83
003746 7473              .db     NFA|3,".st"
                 DOTSTATUS:
003747 d09a              rcall   DOLIT
003748 003c              .dw     '<'
003749 d941              rcall   EMIT
00374a 940e 3f25         call    DOTBASE
00374c d93e              rcall   EMIT
00374d d094              rcall   DOLIT
00374e 002c              .dw     ','
00374f d93b              rcall   EMIT
003750 940e 2fa0         call    MEMQ
003752 dafc              rcall   TYPE
003753 d08e              rcall   DOLIT
003754 003e              .dw     '>'
003755 d935              rcall   EMIT
003756 940c 398f         jmp     DOTS
                 
003758 3e82
003759 0072              .db     NFA|2,">r",0
00375a 940c 32b9 TOR_A:  jmp     TOR
                 
                 
                 ;;; TEN ( -- n ) Leave decimal 10 on the stack
                 ;        .db     NFA|1,"a"
                 TEN:
00375c d983              rcall   DOCREATE
00375d 000a              .dw     10
                 
                 ; dp> ( -- ) Copy ini, dps and latest from eeprom to ram
                 ;        .dw     link
                 ; link    set     $
00375e 6483
00375f 3e70              .db     NFA|3,"dp>"
                 DP_TO_RAM:
003760 d081              rcall   DOLIT
003761 0900              .dw     dp_start
003762 d1b8              rcall   INI
003763 dff8              rcall   TEN
003764 940c 3569         jmp     CMOVE
                 
                 ; >dp ( -- ) Copy only changed turnkey, dp's and latest from ram to eeprom
                 ;        .dw     link
                 ; link    set     $
003766 3e83
003767 7064              .db     NFA|3,">dp"
                 DP_TO_EEPROM:
003768 d079              rcall   DOLIT
003769 0900              .dw     dp_start
00376a dc47              rcall   STORE_P_TO_R
00376b d1af              rcall   INI
00376c d075              rcall   DOLIT
00376d 0004              .dw     4
00376e db4a              rcall   TOR
                 DP_TO_EEPROM_0: 
00376f de1c              rcall   FETCHPP
003770 d07a              rcall   DUP
003771 dc53              rcall   PFETCH
003772 dc15              rcall   NOTEQUAL
003773 dc88              rcall   ZEROSENSE
003774 f011              breq    DP_TO_EEPROM_1
                 .if DEBUG_FLASH == 1
                 .endif
003775 dc57              rcall   PSTORE
003776 c001              rjmp    DP_TO_EEPROM_2
                 DP_TO_EEPROM_1:
003777 db20              rcall   DROP
                 DP_TO_EEPROM_2:
003778 d40a              rcall   PTWOPLUS
                 DP_TO_EEPROM_3:
003779 d327              rcall   XNEXT
00377a f7a0              brcc    DP_TO_EEPROM_0
00377b 911f              pop     t1
00377c 910f              pop     t0
00377d dc3f              rcall   R_TO_P
00377e 940c 3298         jmp     DROP
                 
003780 ee8a              fdw     DOTSTATUS_L
                 FALSE_L:
003781 6685
003782 6c61
003783 6573              .db     NFA|5,"false"
                 FALSE_:                     ; TOS is 0000 (FALSE)
003784 939a
003785 938a              pushtos
003786 2788              clr     tosl
003787 2799              clr     tosh
003788 9508              ret
                 
003789 ef02              fdw     FALSE_L
                 TRUE_L:
00378a 7484
00378b 7572
00378c 0065              .db     NFA|4,"true",0
                 TRUE_:                      ; TOS is ffff (TRUE)
00378d 939a
00378e 938a              pushtos
00378f ef8f              ser     tosl
003790 ef9f              ser     tosh
003791 9508              ret
                 
                 ; QUIT     --    R: i*x --    interpret from kbd
003792 ef14              fdw     TRUE_L
                 QUIT_L:
003793 7184
003794 6975
003795 0074              .db     NFA|4,"quit",0
                 QUIT:
003796 d977              rcall   RPEMPTY
003797 d107              rcall   LEFTBRACKET
003798 d9a1              rcall   FRAM
                 QUIT0:  
                         ;; Copy INI and DP's from eeprom to ram
003799 dfc6              rcall   DP_TO_RAM
                 QUIT1: 
00379a d8de              rcall   check_sp
00379b d08c              rcall   CR
00379c def0              rcall   TIB
00379d d04d              rcall   DUP
00379e dee6              rcall   TIBSIZE
00379f 970a              sbiw    tosl, 10     ; Reserve 10 bytes for hold buffer
0037a0 da71              rcall   ACCEPT
0037a1 da43              rcall   SPACE_
0037a2 df0d              rcall   INTERPRET
0037a3 d15c              rcall   STATE_
0037a4 dc57              rcall   ZEROSENSE
0037a5 f7a1              brne    QUIT1
0037a6 d588              rcall   IFLUSH
0037a7 dfc0              rcall   DP_TO_EEPROM
                          
0037a8 dab3              rcall    XSQUOTE
0037a9 2003
0037aa 6b6f              .db     3," ok"
0037ab daa3              rcall    TYPE
0037ac d007              rcall   PROMPT_
0037ad 940c 3799         jmp     QUIT0
                 
                 
0037af ef26              fdw     QUIT_L
                 PROMPT_L:
0037b0 7086
0037b1 6f72
0037b2 706d
0037b3 0074              .db     NFA|6,"prompt",0
                 PROMPT_:
0037b4 940e 3ec9         call    DEFER_DOES
0037b6 090a              .dw     prompt
                 
                 ; ABORT    i*x --   R: j*x --   clear stk & QUIT
0037b7 ef60              fdw     PROMPT_L
                 ABORT_L:
0037b8 6185
0037b9 6f62
0037ba 7472              .db     NFA|5,"abort"
                 ABORT:
0037bb d156              rcall   S0
0037bc df66              rcall   FETCH_A
0037bd d94c              rcall   SPSTORE
0037be 940c 3796         jmp     QUIT            ; QUIT never rets
                 
                 ; ?ABORT   f --       abort & print ?
0037c0 ef70              fdw     ABORT_L
                 QABORTQ_L:
0037c1 3f87
0037c2 6261
0037c3 726f
0037c4 3f74              .db     NFA|7,"?abort?"
                 QABORTQ:
0037c5 da96              rcall   XSQUOTE
0037c6 3f01              .db     1,"?"
0037c7 940c 37ce         jmp     QABORT
                 
                 
                 ; ?ABORT   f c-addr u --       abort & print msg if flag is false
0037c9 ef82              fdw     QABORTQ_L
                 QABORT_L:
0037ca 3f86
0037cb 6261
0037cc 726f
0037cd 0074              .db     NFA|6,"?abort",0
                 QABORT:
0037ce dae2              rcall   ROT
0037cf dc2c              rcall   ZEROSENSE
0037d0 f419              brne    QABO1
                 QABORT1:        
0037d1 da13              rcall   SPACE_
0037d2 da7c              rcall   TYPE
0037d3 dfe7              rcall   ABORT  ; ABORT never returns
0037d4 940c 31ce QABO1:  jmp     TWODROP
                 
                 ; ABORT"  i*x 0  -- i*x   R: j*x -- j*x  x1=0
                 ;         i*x x1 --       R: j*x --      x1<>0
0037d6 ef94              fdw     QABORT_L
                 ABORTQUOTE_L:
0037d7 61d6
0037d8 6f62
0037d9 7472
0037da 0022              .db     NFA|IMMED|COMPILE|6,"abort",0x22,0
                 ABORTQUOTE:
0037db da97              rcall   SQUOTE
0037dc d91b              rcall   DOCOMMAXT
0037dd ef9c              fdw     QABORT
0037de 9508              ret
                 
                 ;***************************************************
                 ; LIT   -- x    fetch inline 16 bit literal to the stack
0037df efae              fdw     ABORTQUOTE_L
                 DOLIT_L:
0037e0 6c83
0037e1 7469              .db     NFA|3, "lit"
                 DOLIT:
                         m_pop_zh
0037e2 91ff              pop     zh
0037e3 91ef              pop     zl
0037e4 d90a              rcall   FETCHLIT
0037e5 95f7              ror     zh
0037e6 95e7              ror     zl
0037e7 9409              mijmp    ; (z)
                 
                 ; DUP must not be reachable from user code with rcall
0037e8 e596              fdw     RFETCH_L
                 DUP_L:
0037e9 64a3
0037ea 7075              .db     NFA|INLINE|3, "dup"
                 DUP:
0037eb 939a
0037ec 938a              pushtos
0037ed 9508              ret
                 
0037ee e70c              fdw     NOTEQUAL_L
                 ZEROEQUAL_L:
0037ef 3082
0037f0 003d              .db     NFA|2, "0=",0
                 ZEROEQUAL:
0037f1 9701              sbiw    tosl, 1
0037f2 0b88              sbc     tosl, tosl
0037f3 0b99              sbc     tosh, tosh
0037f4 9508              ret
                 
0037f5 efde              fdw     ZEROEQUAL_L
                 ZEROLESS_L:
0037f6 3082
0037f7 003c              .db     NFA|2, "0<",0
                 ZEROLESS:
0037f8 0f99              lsl     tosh
0037f9 0b88              sbc     tosl, tosl
0037fa 0b99              sbc     tosh, tosh
0037fb 9508              ret
                 
                 
                 ; '    -- xt             find word in dictionary
0037fc efc0              fdw     DOLIT_L
                 TICK_L:
0037fd 2781              .db     NFA|1,0x27    ; 27h = '
                 TICK:
0037fe d0fa              rcall   BL
0037ff dd5f              rcall   WORD
003800 ddcb              rcall   FIND
003801 940c 37c5         jmp     QABORTQ
                 
                 ; CHAR   -- char           parse ASCII character
003803 effa              fdw     TICK_L
                 CHAR_L:
003804 6384
003805 6168
003806 0072              .db     NFA|4,"char",0
                 CHAR:
003807 d0f1              rcall   BL
003808 dd39              rcall   PARSE
003809 da8e              rcall   DROP
00380a 940c 3e77         jmp     CFETCH
                 
                 ; (    --                     skip input until )
00380c f008              fdw     CHAR_L
                 PAREN_L:
00380d 28c1              .db     NFA|IMMED|1,"("
                 PAREN:
00380e dfd3              rcall   DOLIT
00380f 0029              .dw     ')'
003810 dd31              rcall   PARSE
003811 6460              sbr     FLAGS1, (1<<noclear) ; dont clear flags in case of (
003812 940c 31ce         jmp     TWODROP
                 
                 ; IHERE    -- a-addr    ret Code dictionary ptr
                 ;   IDP @ ;
                 ;;;         .dw     link
                 ;;; link    set     $
003814 6985
003815 6568
003816 6572              .db     NFA|5,"ihere"
                 IHERE:
003817 d066              rcall   IDP
003818 cf0a              rjmp    FETCH_A
                 
                 ; [CHAR]   --          compile character DOLITeral
003819 f01a              fdw     PAREN_L
                 BRACCHAR_L:
00381a 5bd6
00381b 6863
00381c 7261
00381d 005d              .db     NFA|IMMED|COMPILE|6,"[char]",0
                 BRACCHAR:
00381e dfe8              rcall   CHAR
00381f 940c 3df3         jmp     LITERAL
                 
                 ; COMPILE,  xt --         append codefield
003821 6383
003822 2c66              .db     NFA|3,"cf,"
                 COMMAXT_A:
003823 940c 3198         jmp     COMMAXT
                 
                 ; CR      --                      output newline
003825 f034              fdw     BRACCHAR_L
                 CR_L:
003826 6382
003827 0072              .db     NFA|2,"cr",0
                 CR:
003828 dfb9              rcall   DOLIT
003829 000d              .dw     0x0d       ; CR \r
00382a d860              rcall   EMIT
00382b dfb6              rcall   DOLIT
00382c 000a              .dw     0x0a       ; LF \n
                 EMIT_A:
00382d 940c 308b         jmp     EMIT
                 
                 ; CREATE   --         create an empty definition
                 ; Create a definition header and append 
                 ; doCREATE and the current data space dictionary pointer
                 ; in FLASH.
                 ;  Examples :   
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
00382f f04c              fdw     CR_L
                 CREATE_L:
003830 6386
003831 6572
003832 7461
003833 0065              .db     NFA|6,"create",0
                 CREATE:
003834 d0c4              rcall   BL
003835 dd29              rcall   WORD            ; Parse a word
                 
003836 dfb4              rcall   DUP             ; Remember parsed word at rhere
003837 dd94              rcall   FIND
003838 dc04              rcall   NIP
003839 dfb7              rcall   ZEROEQUAL
00383a da21              rcall   XSQUOTE
00383b 410f
00383c 524c
00383d 4145
00383e 5944
00383f 4420
003840 4645
003841 4e49
003842 4445              .db     15,"ALREADY DEFINED"
003843 df8a              rcall   QABORT         ; ABORT if word has already been defined
003844 dfa6              rcall   DUP             ; Check the word length 
003845 dc19              rcall   CFETCH_A
003846 d9c1              rcall   ONE
003847 df9a              rcall   DOLIT
003848 0010              .dw     16
003849 db34              rcall   WITHIN
00384a df7a              rcall   QABORTQ          ; Abort if there is no name for create
                 
00384b d0c0              rcall   LATEST_
00384c ded6              rcall   FETCH_A
00384d 940e 3f13         call    ICOMMA          ; Link field
00384f dd34              rcall   CFETCHPP        ; str len
003850 dfc6              rcall   IHERE
003851 df99              rcall   DUP             
003852 d0b9              rcall   LATEST_         ; new 'latest' link
003853 dd3e              rcall   STORE_A         ; str len ihere
003854 dd26              rcall   PLACE           ; 
003855 dfc1              rcall   IHERE           ; ihere
003856 dc08              rcall   CFETCH_A
003857 df8a              rcall   DOLIT
003858 0080              .dw     NFA
003859 dece              rcall   SHB
00385a daf6              rcall   ONEPLUS
00385b d91e              rcall   ALIGNED
00385c d173              rcall   IALLOT          ; The header has now been created
00385d df84              rcall   DOLIT             
00385e e1c0              fdw     DOCREATE        ; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
00385f d941              rcall   STORECFF1       ; Append an exeution token, CALL !
003860 d90f              rcall   ALIGN
003861 d8ef              rcall   HERE            ; compiles the current dataspace dp into the dictionary
003862 d8e4              rcall   CSE_
003863 db98              rcall   ZEROSENSE
003864 f409              brne    CREATE2
003865 daf5              rcall   TWOPLUS
                 CREATE2:
003866 940c 3f13         jmp     ICOMMA          ; dp now points to a free cell
                 
                 ;***************************************************************
                 ; POSTPONE
003868 f060              fdw    CREATE_L
                 POSTPONE_L:
003869 70d8
00386a 736f
00386b 7074
00386c 6e6f
00386d 0065              .db     NFA|IMMED|COMPILE|8,"postpone",0
                 POSTPONE:
00386e d08a              rcall   BL
00386f dcef              rcall   WORD
003870 dd5b              rcall   FIND
003871 df79              rcall   DUP
003872 df52              rcall   QABORTQ
003873 df84              rcall   ZEROLESS
003874 db87              rcall   ZEROSENSE
003875 f021              breq    POSTPONE1
003876 d881              rcall   DOCOMMAXT
003877 e1f0              fdw     DOCOMMAXT
003878 940c 3f13         jmp     ICOMMA
                 POSTPONE1:
00387a 940c 3198         jmp     COMMAXT
                 
                 
                 IDP_L:
00387c 6983
00387d 7064              .db     NFA|3,"idp"
                 IDP:
00387e d861              rcall   DOCREATE
00387f 01db              .dw     dpFLASH
                 
                 ;***************************************************************
                 ; (DOES>)  --      run-time action of DOES>
                 ;        .dw    link
                 ;link   set     $
003880 2887
003881 6f64
003882 7365
003883 293e              .db     NFA|7,"(does>)"
                 XDOES:
                         m_pop_zh
003884 da3e              rcall   RFROM
003885 d086              rcall   LATEST_
003886 de9c              rcall   FETCH_A
003887 dd0f              rcall   NFATOCFA
003888 dff5              rcall   IDP
003889 de99              rcall   FETCH_A
00388a decf              rcall   TOR_A
00388b dff2              rcall   IDP
00388c dd05              rcall   STORE_A
00388d 0f88              lsl     tosl
00388e 1f99              rol     tosh
00388f d911              rcall   STORECFF1 ; Always stores a 4 byte call
003890 da32              rcall   RFROM
003891 dfec              rcall   IDP
003892 940c 3e22         jmp     STORE
                 
                 
                 ; DOES>    --      change action of latest def'n
003894 f0d2              fdw     POSTPONE_L
                 DOES_L:
003895 64d5
003896 656f
003897 3e73              .db     NFA|IMMED|COMPILE|5,"does>"
003898 d85f      DOES:   rcall   DOCOMMAXT
003899 f108              fdw     XDOES
00389a d85d              rcall   DOCOMMAXT
00389b e1d0              fdw     DODOES
00389c 9508              ret
                 
                 
                 ;*****************************************************************
                 ; [        --      enter interpretive state
00389d f12a              fdw     DOES_L
                 LEFTBRACKET_L:
00389e 5bc1              .db     NFA|IMMED|1,"["
                 LEFTBRACKET:
00389f 9250 01e6         sts     state, zero
0038a1 9508              ret
                 
                 
                 ; ]        --      enter compiling state
0038a2 f13c              fdw     LEFTBRACKET_L
                 RIGHTBRACKET_L:
0038a3 5d81              .db     NFA|1,"]"
                 RIGHTBRACKET:
0038a4 9260 01e6         sts     state, r_one
0038a6 9508              ret
                 
                 ; :        --           begin a colon definition
0038a7 f146              fdw     RIGHTBRACKET_L
                 COLON_L:
0038a8 3a81              .db     NFA|1,":"
                 COLON:
0038a9 df8a              rcall   CREATE
0038aa dff9              rcall   RIGHTBRACKET
0038ab 940c 31b4         jmp     STORCOLON
                 
                 ; :noname        -- a          define headerless forth code
0038ad f150              fdw     COLON_L
                 NONAME_L:
0038ae 3a87
0038af 6f6e
0038b0 616e
0038b1 656d              .db     NFA|7,":noname"
                 NONAME:
0038b2 df64              rcall   IHERE
0038b3 940c 38a4         jmp     RIGHTBRACKET
                 
                 ; ;        --             end a colon definition
0038b5 f15c              fdw     NONAME_L
                 SEMICOLON_L:
0038b6 3bd1              .db     NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
0038b7 dfe7              rcall   LEFTBRACKET
0038b8 fd61              sbrc    FLAGS1, fTAILC
0038b9 c026              rjmp    ADD_RETURN_1
0038ba df5c              rcall   IHERE
0038bb d02b              rcall   MINUS_FETCH
0038bc 018c              movw    t0, tosl
0038bd 7f10              andi    t1, 0xf0
0038be 5d10              subi    t1, 0xd0
0038bf f059              breq    RCALL_TO_JMP
0038c0 9189
0038c1 9199              poptos
0038c2 d024              rcall   MINUS_FETCH
                 .ifdef EIND
                 .else
0038c3 508e              subi    tosl, 0x0e
                 .endif
0038c4 4994              sbci    tosh, 0x94
0038c5 f4c9              brne    ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
0038c6 e08c              ldi     tosl, 0x0c
                 .endif
0038c7 e994              ldi     tosh, 0x94
0038c8 d9d6              rcall   SWOP
0038c9 940c 3e22         jmp     STORE
                 RCALL_TO_JMP:
0038cb db71              rcall   NIP
0038cc 709f              andi    tosh, 0x0f
0038cd fd93              sbrc    tosh, 3
0038ce 6f90              ori     tosh, 0xf0
0038cf da96              rcall   TWOSTAR
0038d0 df46              rcall   IHERE
0038d1 da0c              rcall   PLUS
0038d2 df0f              rcall   DOLIT
0038d3 fffe              .dw     -2
0038d4 d0fb              rcall   IALLOT
0038d5 df0c              rcall   DOLIT
                 .ifdef EIND
                 .else
0038d6 940c              .dw     0x940c      ; jmp:0x940c
                 .endif
0038d7 940e 3f13         call    ICOMMA
0038d9 5890              sub_pflash_tos
0038da 9488              rampv_to_c
0038db 9597              ror     tosh
0038dc 9587              ror     tosl
0038dd 940c 3f13         jmp     ICOMMA
                 ADD_RETURN:
0038df d8ee              rcall   TWODROP
                 ADD_RETURN_1:
0038e0 df01              rcall   DOLIT   ; Compile a ret
0038e1 9508              .dw     0x9508
0038e2 940c 3f13         jmp    ICOMMA
                 
                 
                 
0038e4 f16c              fdw     SEMICOLON_L
                 MINUS_FETCH_L:
0038e5 2d82
0038e6 0040              .db     NFA|2,"-@",0
                 MINUS_FETCH:
0038e7 d00c              rcall   TWOMINUS
0038e8 df02              rcall   DUP
0038e9 940c 3e5c         jmp     FETCH
                 
                 ; [']  --         find word & compile as DOLITeral
0038eb f1ca              fdw     MINUS_FETCH_L
                 BRACTICK_L:
0038ec 5bd3
0038ed 5d27              .db     NFA|IMMED|COMPILE|3,"[']"
                 BRACTICK:
0038ee df0f              rcall   TICK       ; get xt of 'xxx'
0038ef 940c 3df3         jmp     LITERAL
                 
                 ; 2-    n -- n-2
0038f1 f1d8              fdw     BRACTICK_L
                 TWOMINUS_L:
0038f2 32a2
0038f3 002d              .db     NFA|INLINE|2,"2-",0
                 TWOMINUS:
0038f4 9702              sbiw    tosl, 2
0038f5 9508              ret
                 
                         
                 ; BL      -- char                 an ASCII space
0038f6 f1e4              fdw     TWOMINUS_L
                 BL_l:
0038f7 6282
0038f8 006c              .db     NFA|2,"bl",0
                 BL:
0038f9 940e 30e0         call    DOCREATE
0038fb 0020              .dw     ' '
                 
                 ; STATE   -- flag                 holds compiler state
0038fc f1ee              fdw     BL_L
                 STATE_L:
0038fd 7385
0038fe 6174
0038ff 6574              .db     NFA|5,"state"
                 STATE_:
003900 939a
003901 938a              pushtos
003902 9180 01e6         lds     tosl, state
003904 9190 01e6         lds     tosh, state
003906 9508              ret
                 
                 ; LATEST    -- a-addr           
003907 f1fa              fdw     STATE_L
                 LATEST_L:
003908 6c86
003909 7461
00390a 7365
00390b 0074              .db     NFA|6,"latest",0
                 LATEST_:
00390c 940e 30e0         call    DOCREATE
00390e 01e1              .dw     dpLATEST
                 
                 ; S0       -- a-addr      start of parameter stack
00390f f210              fdw     LATEST_L
                 S0_L:
003910 7382
003911 0030              .db     NFA|2,"s0",0
                 S0:
003912 dc09              rcall   DOUSER
003913 ffe4              .dw     us0
                         
                 ; R0       -- a-addr      start of parameter stack
003914 f220              fdw     S0_L
                 R0_L:
003915 7282
003916 0030              .db     NFA|2,"r0",0
                 R0_:
003917 dc04              rcall   DOUSER
003918 ffe6              .dw     ur0
                         
                 ; ini -- a-addr       ini variable contains the user-start xt
                 ; In RAM
                 ;        .dw     link
                 ;link    set     $
003919 6983
00391a 696e              .db     NFA|3,"ini"
                 INI:
00391b 940e 30e0          call   DOCREATE
00391d 01d9              .dw     dpSTART
                 
                 ; ticks  -- u      system ticks (0-ffff) in milliseconds
00391e f22a              fdw     R0_L
                 TICKS_L:
00391f 7485
003920 6369
003921 736b              .db     NFA|5,"ticks"
                 TICKS:  
003922 939a
003923 938a              pushtos
003924 b70f              in_     t0, SREG
003925 94f8              cli
003926 2d8e              mov     tosl, ms_count
003927 2d9f              mov     tosh, ms_count1
003928 bf0f              out_    SREG, t0
003929 9508              ret
                 
                         
                 ; ms  +n --      Pause for n millisconds
                 ; : ms ( +n -- )     
                 ;   ticks -
                 ;   begin
                 ;     pause dup ticks - 0<
                 ;   until drop ;
                 ;
00392a f23e              fdw     TICKS_L
                 MS_L:
00392b 6d82
00392c 0073              .db     NFA|2,"ms",0
                 MS:
00392d dff4              rcall   TICKS
00392e d9af              rcall   PLUS
                 MS1:    
00392f d5c3              rcall   PAUSE
003930 deba              rcall   DUP
003931 dff0              rcall   TICKS
003932 d9b8              rcall   MINUS
003933 dec4              rcall   ZEROLESS
003934 dac7              rcall   ZEROSENSE
003935 f3c9              breq    MS1
003936 940c 3298         jmp     DROP
                 
                 ;  .id ( nfa -- ) 
003938 f256              fdw     MS_L
                 DOTID_L:
003939 2e83
00393a 6469              .db     NFA|3,".id"
                 DOTID:
00393b dc48              rcall   CFETCHPP
00393c 708f              andi    tosl, 0x0f
00393d d97b              rcall   TOR
00393e c003              rjmp    DOTID3
                 DOTID1:
00393f dc44              rcall   CFETCHPP
003940 d00a              rcall   TO_PRINTABLE
003941 deeb              rcall   EMIT_A
                 DOTID3:
003942 d15e              rcall   XNEXT
003943 f7d8              brcc    DOTID1  
003944 911f              pop     t1
003945 910f              pop     t0
003946 940c 3298         jmp     DROP
                 
                  ; >pr   c -- c      Filter a character to printable 7-bit ASCII
003948 f272              fdw     DOTID_L
                 TO_PRINTABLE_L:
003949 3e83
00394a 7270              .db     NFA|3,">pr"
                 TO_PRINTABLE:
00394b 2799              clr     tosh   
00394c 3080              cpi     tosl, 0
00394d f012              brmi    TO_PRINTABLE1
00394e 3280              cpi     tosl, 0x20
00394f f40a              brpl    TO_PRINTABLE2
                 TO_PRINTABLE1:
003950 e28e              ldi     tosl, '.'
                 TO_PRINTABLE2:
003951 9508              ret
                 
                 ;;;;;;;;;;;;;;
                 LIKEQ:
003952 dc31              rcall   CFETCHPP
003953 de8e              rcall   DOLIT
003954 000f              .dw     0x0f
003955 d9d2              rcall   AND_
003956 d948              rcall   SWOP
003957 da52              rcall   STORE_P
003958 d946              rcall   SWOP
003959 dc2a              rcall   CFETCHPP
00395a d956              rcall   ROT
00395b d94d              rcall   OVER
00395c d98e              rcall   MINUS
00395d d9f3              rcall   ONEPLUS
00395e de25              rcall   FALSE_
00395f daf4              rcall   MAX
003960 d958              rcall   TOR
003961 c009              rjmp    LIKEQ3
                 LIKEQ1:
003962 d872              rcall   TWODUP
003963 d210              rcall   FETCH_P
003964 da78              rcall   PPLUS
003965 d939              rcall   SWOP
003966 940e 2f80         call    CMP
003968 f011              breq    LIKEQ3
                 TWODROPNZ:
003969 9498              clz
00396a c003              rjmp    LIKEQ4
                 LIKEQ3:
00396b d135              rcall   XNEXT
00396c f7a8              brcc    LIKEQ1
                 TWODROPZ:
00396d 9418              sez
                 LIKEQ4:
00396e 911f              pop     t1
00396f 910f              pop     t0
003970 c00a              rjmp    TWODROP__
                 
                 ;;;;;;;;;;;;;;;;;;;;
                 LIKES:
003971 d863              rcall   TWODUP
003972 dfdf              rcall   LIKEQ
003973 f019              breq    LIKES1
003974 de76              rcall   DUP
003975 dfc5              rcall   DOTID
003976 d86e              rcall   SPACE_
                 LIKES1:
003977 df7c              rcall   TWOMINUS
003978 ddaa              rcall   FETCH_A
003979 da88              rcall   DUPZEROSENSE
00397a f7b1              brne    LIKES
                 TWODROP__:
00397b 940c 31ce         jmp     TWODROP
                 
                  ; WORDS    -- filter
00397d f292              fdw     TO_PRINTABLE_L
                 WORDS_L:
00397e 7785
00397f 726f
003980 7364              .db     NFA|5,"words"
003981 df77              rcall   BL
003982 dbdc              rcall   WORD
003983 de67              rcall   DUP
003984 de5d              rcall   DOLIT
003985 f702              fdw     kernellink
003986 d002              rcall   WDS1
003987 df84              rcall   LATEST_
003988 dd9a              rcall   FETCH_A
003989 de9e      WDS1:   rcall   CR
00398a 940c 3971         jmp     LIKES
                 
                 ; .S      --           print stack contents
                 ; : .s space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
00398c f2fc              fdw     WORDS_L
                 DOTS_L:
00398d 2e82
00398e 0073              .db     NFA|2,".s",0
                 DOTS:
00398f d855              rcall   SPACE_
003990 de5a              rcall   DUP          ; push tosl:tosh to memory
003991 940e 3103         call    SPFETCH
003993 df7e              rcall   S0
003994 dd8e              rcall   FETCH_A
003995 df5e              rcall   TWOMINUS
                 DOTS1:
003996 d83e              rcall   TWODUP
003997 d9fa              rcall   LESS
003998 da63              rcall   ZEROSENSE
003999 f019              breq    DOTS2
00399a df4c              rcall   MINUS_FETCH
00399b db13              rcall   UDOT
00399c cff9              rjmp    DOTS1
                 DOTS2:  
00399d d8fa              rcall   DROP
00399e 940c 31ce         jmp     TWODROP
                 
                 ;   DUMP  ADDR U --       DISPLAY MEMORY
0039a0 f31a              fdw     DOTS_L
                 DUMP_L:
0039a1 6484
0039a2 6d75
0039a3 0070              .db     NFA|4,"dump",0
                 DUMP:
0039a4 de3d              rcall   DOLIT
0039a5 0010              .dw     16
0039a6 da79              rcall   USLASH
0039a7 d911              rcall   TOR
0039a8 c020              rjmp    DUMP7
                 DUMP1:  
0039a9 de7e              rcall   CR
0039aa de40              rcall   DUP
0039ab de36              rcall   DOLIT
0039ac 0004              .dw     4
0039ad db0b              rcall   UDOTR
0039ae de33              rcall   DOLIT
0039af 003a              .dw     ':'
0039b0 de7c              rcall   EMIT_A
0039b1 de30              rcall   DOLIT
0039b2 000f              .dw     15
0039b3 d905              rcall   TOR
                 DUMP2:
0039b4 dbcf              rcall   CFETCHPP
0039b5 de2c              rcall   DOLIT
0039b6 0002              .dw     2
0039b7 db01              rcall   UDOTR
0039b8 d0e8              rcall   XNEXT
0039b9 f7d0              brcc    DUMP2
0039ba 911f              pop     t1
0039bb 910f              pop     t0
                 
0039bc de25              rcall   DOLIT
0039bd 0010              .dw     16
0039be d92c              rcall   MINUS
0039bf de22              rcall   DOLIT
0039c0 000f              .dw     15
0039c1 d8f7              rcall   TOR
                 DUMP4:  
0039c2 dbc1              rcall   CFETCHPP
0039c3 df87              rcall   TO_PRINTABLE
0039c4 de68              rcall   EMIT_A
0039c5 d0db              rcall   XNEXT
0039c6 f7d8              brcc    DUMP4
0039c7 911f              pop     t1
0039c8 910f              pop     t0
                 DUMP7:
0039c9 d0d7              rcall   XNEXT
0039ca f6f0              brcc    DUMP1
0039cb 911f              pop     t1
0039cc 910f              pop     t0
0039cd 940c 3298         jmp     DROP
                 
                 ; IALLOT   n --    allocate n bytes in ROM
                 ;       .dw     link
                 ;link   set     $
0039cf 2081              .db     NFA|1," "
                 IALLOT:
0039d0 dead              rcall   IDP
0039d1 940c 3372         jmp     PLUSSTORE
                     
                 
                 ;***************************************************************
                 ;  Store the execcution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
0039d3 f342              fdw     DUMP_L
                 X_TO_R_L:
0039d4 7883
0039d5 723e              .db     NFA|3,"x>r"
                 X_TO_R:
0039d6 01fc              movw    zl, tosl
0039d7 9189
0039d8 9199              poptos
0039d9 d009              rcall   TO_XA
0039da 9631              adiw    zl, 1
0039db 9382              st      -z, tosl
0039dc 9392              st      -z, tosh
                 .ifdef EIND
                 .endif
0039dd 9252              st      -z, zero
0039de 01cf              movw    tosl, zl
0039df 9508              ret
                 ;***************************************************************
0039e0 f3a8              fdw     X_TO_R_L
                 TO_XA_L:
0039e1 3e83
0039e2 6178              .db NFA|3,">xa"
                 TO_XA:
0039e3 5890               sub_pflash_tos
0039e4 9488               rampv_to_c
0039e5 9597               ror tosh
0039e6 9587               ror tosl
0039e7 9508               ret
                 
0039e8 f3c2               fdw     TO_XA_L
                 XA_FROM_L:
0039e9 7883
0039ea 3e61              .db NFA|3,"xa>"
                 XA_FROM:
0039eb 0f88               lsl     tosl
0039ec 1f99               rol     tosh
0039ed 5890               add_pflash_tos
0039ee 9508               ret
                 ;***************************************************************
0039ef f3d2               fdw    XA_FROM_L
                 PFL_L:
0039f0 7083
0039f1 6c66              .db     NFA|3,"pfl"
                 PFL:
0039f2 940e 30e0          call   DOCREATE
0039f4 8000              .dw     OFLASH
                 ;***************************************************************
0039f5 f3e0              fdw    PFL_L
                 ZFL_L:
0039f6 7a83
0039f7 6c66              .db     NFA|3, "zfl"
                 ZFL:
0039f8 940e 30e0          call   DOCREATE
0039fa 0000              .dw     RAMPZV
                 ;***************************************************************
                 ; ,?0=    -- addr  Compile ?0= and make make place for a branch instruction
0039fb 2c84
0039fc 303f
0039fd 003d              .db     NFA|4, ",?0=",0    ; Just for see to work !
                 COMMAZEROSENSE:
0039fe fd65              sbrc    FLAGS1, idup
0039ff c003              rjmp    COMMAZEROSENSE1
003a00 dde1              rcall   DOLIT
003a01 e7f8              fdw     ZEROSENSE
003a02 c003              rjmp    COMMAZEROSENSE2
                 COMMAZEROSENSE1:
003a03 d004              rcall   IDPMINUS
003a04 dddd              rcall   DOLIT
003a05 e804              fdw     DUPZEROSENSE
                 COMMAZEROSENSE2:
003a06 7d6f              cbr     FLAGS1, (1<<idup)
003a07 c070              rjmp    INLINE0
                 
                 IDPMINUS:
003a08 ddd9              rcall   DOLIT
003a09 fffc              .dw     -4
003a0a cfc5              rjmp    IALLOT
                 
                 ;       rjmp, ( rel-addr -- )
                 RJMPC:
003a0b d960              rcall   TWOSLASH
003a0c 709f              andi    tosh, 0x0f
003a0d 6c90              ori     tosh, 0xc0
003a0e 940c 3f13         jmp     ICOMMA
                 
                 
                 BRCCC:
003a10 ddd1              rcall   DOLIT
003a11 f008              .dw     0xf008      ; brcc pc+2
003a12 940c 3f13         jmp     ICOMMA
                 ;BREQC:
                 ;        rcall   DOLIT
                 ;        .dw     0xf009      ; breq pc+2
                 ;        sbrc    FLAGS1, izeroeq
                 ;        ori     tosh, 4     ; brne pc+2
                 ;        jmp     ICOMMA
                 BRNEC:
003a14 ddcd              rcall   DOLIT
003a15 f409              .dw     0xf409      ; brne pc+2
003a16 fd64              sbrc    FLAGS1, izeroeq
003a17 7f9b              andi    tosh, ~4
003a18 940c 3f13         jmp     ICOMMA
                 
                 ; IF       -- adrs   conditional forward branch
                 ; Leaves address of branch instruction 
                 ; and compiles the condition byte
003a1a f3ec              fdw     ZFL_L
                 IF_L:
003a1b 69d2
003a1c 0066              .db     NFA|IMMED|COMPILE|2,"if",0
                 IF_:
003a1d fd64              sbrc    FLAGS1, izeroeq
003a1e dfe9              rcall   IDPMINUS
003a1f dfde              rcall   COMMAZEROSENSE
003a20 dff3              rcall   BRNEC
003a21 7e6f              cbr     FLAGS1, (1<<izeroeq)
003a22 ddf4              rcall   IHERE
003a23 dd60              rcall   FALSE_
003a24 940c 3a0b         jmp     RJMPC           ; Dummy, replaced by THEN with rjmp 
                 
                 ; ELSE     adrs1 -- adrs2    branch for IF..ELSE
                 ; Leave adrs2 of bra instruction and store bz in adrs1
                 ; Leave adress of branch instruction and FALSE flag on stack
003a26 f436              fdw     IF_L
                 ELSE_L:
003a27 65d4
003a28 736c
003a29 0065              .db     NFA|IMMED|COMPILE|4,"else",0
                 ELSE_:
003a2a ddec              rcall   IHERE
003a2b dd58              rcall   FALSE_
003a2c dfde              rcall   RJMPC
003a2d dc52              rcall   SWOP_A      ; else-addr  if-addr 
003a2e 940c 3a34         jmp     THEN_
                 
                 ; THEN     adrs  --        resolve forward branch
003a30 f44e              fdw     ELSE_L
                 THEN_L:
003a31 74d4
003a32 6568
003a33 006e              .db     NFA|IMMED|COMPILE|4,"then",0
                 THEN_:
003a34 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a35 dde1              rcall   IHERE
003a36 d872              rcall   OVER
003a37 d8b3              rcall   MINUS
003a38 debb              rcall   TWOMINUS
003a39 d932              rcall   TWOSLASH
003a3a dda7              rcall   DOLIT
003a3b c000              .dw     0xc000      ;  back-addr mask 
003a3c d8f3              rcall   OR_
003a3d dc42              rcall   SWOP_A
003a3e 940c 3e22         jmp     STORE
                 
                 ; BEGIN    -- adrs        target for bwd. branch
003a40 f462              fdw     THEN_L
                 BEGIN_L:
003a41 62d5
003a42 6765
003a43 6e69              .db     NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
003a44 940c 3817         jmp     IHERE
                 
                 ; UNTIL    adrs --   Branch bakwards if true
003a46 f482              fdw     BEGIN_L
                 UNTIL_L:
003a47 75d5
003a48 746e
003a49 6c69              .db     NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
003a4a 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a4b fd64              sbrc    FLAGS1, izeroeq
003a4c dfbb              rcall   IDPMINUS
003a4d dfb0              rcall   COMMAZEROSENSE
003a4e dfc5              rcall   BRNEC
003a4f 7e6f              cbr     FLAGS1, (1<<izeroeq)
003a50 940c 3a56         jmp     AGAIN_
                 
                                                 ; AGAIN    adrs --      uncond'l backward branch
                 ;   unconditional backward branch
003a52 f48e              fdw     UNTIL_L
                 AGAIN_L:
003a53 61d5
003a54 6167
003a55 6e69              .db     NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
003a56 6062              sbr     FLAGS1, (1<<fTAILC)  ; Prevent tailjmp  optimisation
003a57 ddbf              rcall   IHERE
003a58 d892              rcall   MINUS
003a59 de9a              rcall   TWOMINUS
003a5a 940c 3a0b         jmp     RJMPC
                 
                 ; WHILE    addr1 -- addr2 addr1         branch for WHILE loop
                 ; addr1 : address of BEGIN
                 ; addr2 : address where to store bz instruction
003a5c f4a6              fdw     AGAIN_L
                 WHILE_L:
003a5d 77d5
003a5e 6968
003a5f 656c              .db     NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
003a60 dfbc              rcall   IF_
003a61 940c 329f         jmp     SWOP
                 
                 ; REPEAT   addr2 addr1 --     resolve WHILE loop
003a63 f4ba              fdw     WHILE_L
                 REPEAT_L:
003a64 72d6
003a65 7065
003a66 6165
003a67 0074              .db     NFA|IMMED|COMPILE|6,"repeat",0
                 REPEAT_:
003a68 dfed              rcall   AGAIN_
003a69 940c 3a34         jmp     THEN_
                 
003a6b f4c8              fdw     REPEAT_L
                 INLINE_L:
003a6c 69d6
003a6d 6c6e
003a6e 6e69
003a6f 0065              .db      NFA|IMMED|COMPILE|6,"inline",0
003a70 7e6f              cbr      FLAGS1, (1<<izeroeq)
003a71 7d6f              cbr      FLAGS1, (1<<idup)
003a72 dd8b              rcall    TICK
003a73 940c 3a78         jmp      INLINE0
                 ; in, ( addr -- ) begin @+ dup $9508 <> while i, repeat 2drop ;
003a75 f4d8              fdw      INLINE_L
                 INLINEC_L:
003a76 6983
003a77 2c6e              .db      NFA|3,"in,"
                 INLINE0:        
003a78 db13              rcall   FETCHPP
003a79 dd71              rcall   DUP
003a7a dd67              rcall   DOLIT
003a7b 9508              .dw     0x9508
003a7c d90b              rcall   NOTEQUAL
003a7d d97e              rcall   ZEROSENSE
003a7e f011              breq    INLINE1
003a7f d493              rcall   ICOMMA
003a80 cff7              rjmp    INLINE0
                 INLINE1:
003a81 940c 31ce         jmp     TWODROP
                 
                 ; FOR   -- bc-addr bra-addr
003a83 f4ec              fdw     INLINEC_L
                 FOR_L:
003a84 66d3
003a85 726f              .db     NFA|IMMED|COMPILE|3,"for"
                 FOR:
003a86 940e 30f8         call    DOCOMMAXT
003a88 e572              fdw     TOR
003a89 dd8d              rcall   IHERE
003a8a dcf9              rcall   FALSE_
003a8b df7f              rcall   RJMPC
003a8c dd8a              rcall   IHERE
003a8d 940c 329f         jmp     SWOP
                 
                 ; NEXT bra-addr bc-addr --
003a8f f508              fdw     FOR_L
                 NEXT_L:
003a90 6ed4
003a91 7865
003a92 0074              .db     NFA|IMMED|COMPILE|4,"next", 0
                 NEXT:
003a93 dfa0              rcall   THEN_
003a94 940e 30f8         call    DOCOMMAXT
003a96 f542              fdw     XNEXT
003a97 df78              rcall   BRCCC
                 
003a98 dfbd              rcall   AGAIN_
                 
003a99 dd48              rcall   DOLIT
003a9a f554              fdw     XNEXT1
003a9b 940c 3a78         jmp     INLINE0
                 ; (next) decrement top of return stack
003a9d 2887
003a9e 656e
003a9f 7478
003aa0 2029              .db     NFA|7,"(next) "
                 XNEXT:  
                         m_pop_zh
003aa1 91ff              pop     zh
003aa2 91ef              pop     zl
003aa3 91bf              pop     xh
003aa4 91af              pop     xl
003aa5 9711              sbiw    xl, 1
003aa6 93af              push    xl
003aa7 93bf              push    xh
003aa8 9409              mijmp
003aa9 9508              ret
                 XNEXT1:
003aaa 911f              pop     t1
003aab 910f              pop     t0
003aac 9508              ret
                 
                 ; leave clear top of return stack
003aad f520              fdw     NEXT_L
                 LEAVE_L:
003aae 6595
003aaf 646e
003ab0 7469              .db     NFA|COMPILE|5,"endit"
                 LEAVE:
                         m_pop_zh
003ab1 91ff              pop     zh
003ab2 91ef              pop     zl
003ab3 911f              pop     t1
003ab4 910f              pop     t0
003ab5 925f              push    zero
003ab6 925f              push    zero
003ab7 9409              mijmp
                 ;***************************************************
                 ; RDROP compile a pop
003ab8 f55c              fdw      LEAVE_L
                 RDROP_L:
003ab9 72d5
003aba 7264
003abb 706f              .db      NFA|IMMED|COMPILE|5,"rdrop"
                 RDROP:
003abc dd25              rcall   DOLIT
003abd f554              fdw     XNEXT1
003abe 940c 3a78         jmp     INLINE0
                 ;***************************************************
003ac0 f572              fdw     RDROP_L
                 STOD_L:
003ac1 7383
003ac2 643e              .db     NFA|3,"s>d"
                 STOD:
003ac3 ff97              sbrs    tosh, 7
003ac4 ccbf              rjmp    FALSE_
003ac5 ccc7              rjmp    TRUE_
                 ;***************************************************
003ac6 f582              fdw     STOD_L
                 DNEGATE_L:
003ac7 6487
003ac8 656e
003ac9 6167
003aca 6574              .db     NFA|7,"dnegate"
                 DNEGATE:
003acb d049              rcall   DINVERT
003acc 940e 3208         call    ONE
003ace 940c 32e6         jmp     MPLUS
                 ;***************************************************
003ad0 f58e              fdw     DNEGATE_L
                 QDNEGATE_L:
003ad1 3f88
003ad2 6e64
003ad3 6765
003ad4 7461
003ad5 0065              .db     NFA|8,"?dnegate",0
                 QDNEGATE:
003ad6 dd21              rcall   ZEROLESS
003ad7 d924              rcall   ZEROSENSE
003ad8 f009              breq    QDNEGATE1
003ad9 dff1              rcall   DNEGATE
                 QDNEGATE1:
003ada 9508              ret
                 
                 ;***************************************************
003adb f5a2              fdw     QDNEGATE_L
                 DABS_L:
003adc 6484
003add 6261
003ade 0073              .db     NFA|4,"dabs",0
                 DABS:
003adf dd0b              rcall   DUP
003ae0 940c 3ad6         jmp     QDNEGATE
                 ;***************************************************
003ae2 f5b8              fdw     DABS_L
                 DPLUS_L:
003ae3 6482
003ae4 002b              .db     NFA|2,"d+",0
                 DPLUS:
003ae5 91a9              ld      xl, Y+
003ae6 91b9              ld      xh, Y+
003ae7 91e9              ld      t6, Y+
003ae8 91f9              ld      t7, Y+
003ae9 9109              ld      t0, Y+
003aea 9119              ld      t1, Y+
003aeb 0fa0              add     xl, t0
003aec 1fb1              adc     xh, t1
003aed 1f8e              adc     tosl, t6
003aee 1f9f              adc     tosh, t7
003aef 93ba              st      -Y, xh
003af0 93aa              st      -Y, xl
003af1 9508              ret
                 
                 ;***************************************************
003af2 f5c6              fdw     DPLUS_L
                 DMINUS_L:
003af3 6482
003af4 002d              .db     NFA|2,"d-",0
                 DMINUS:
003af5 dfd5              rcall   DNEGATE
003af6 940c 3ae5         jmp     DPLUS
                 ;***************************************************
003af8 f5e6              fdw     DMINUS_L
                 DTWOSLASH_L:
003af9 6483
003afa 2f32              .db     NFA|3,"d2/"
003afb 9109              ld      t0, y+
003afc 9119              ld      t1, y+
003afd 9595              asr     tosh
003afe 9587              ror     tosl
003aff 9517              ror     t1
003b00 9507              ror     t0
003b01 931a              st      -y, t1
003b02 930a              st      -y, t0
003b03 9508              ret
                 ;***************************************************
003b04 f5f2              fdw     DTWOSLASH_L
                 DTWOSTAR_L:
003b05 6483
003b06 2a32              .db     NFA|3,"d2*"
003b07 9109              ld      t0, y+
003b08 9119              ld      t1, y+
003b09 0f00              lsl     t0
003b0a 1f11              rol     t1
003b0b 1f88              rol     tosl
003b0c 1f99              rol     tosh
003b0d 931a              st      -y, t1
003b0e 930a              st      -y, t0
003b0f 9508              ret
                 ;***************************************************
003b10 f60a              fdw     DTWOSTAR_L
                 DINVERT_L:
003b11 6487
003b12 6e69
003b13 6576
003b14 7472              .db     NFA|7,"dinvert"
                 DINVERT:
003b15 9109              ld      t0, y+
003b16 9119              ld      t1, y+
003b17 9500              com     t0
003b18 9510              com     t1
003b19 9580              com     tosl
003b1a 9590              com     tosh
003b1b 931a              st      -y, t1
003b1c 930a              st      -y, t0
003b1d 9508              ret
                 ;***************************************************
003b1e f622              fdw     DINVERT_L
                 DZEROEQUAL_L:
003b1f 6483
003b20 3d30              .db     NFA|3,"d0="
                 DZEROEQUAL:
003b21 91a9              ld      xl, y+
003b22 91b9              ld      xh, y+
003b23 2b89              or      tosl, tosh
003b24 2b8a              or      tosl, xl
003b25 2b8b              or      tosl, xh
003b26 f451              brne    DZEROLESS_FALSE
                 DZEROEQUAL_TRUE:
003b27 ef8f              ser     tosl
003b28 ef9f              ser     tosh
003b29 9508              ret
                 
                 ;***************************************************
003b2a f63e              fdw     DZEROEQUAL_L
                 DZEROLESS_L:
003b2b 6483
003b2c 3c30              .db     NFA|3,"d0<"
                 DZEROLESS:
003b2d 91a9              ld      xl, y+
003b2e 91b9              ld      xh, y+
003b2f 3090              cpi     tosh, 0
003b30 f3b2              brmi    DZEROEQUAL_TRUE
                 DZEROLESS_FALSE:
003b31 2788              clr     tosl
003b32 2799              clr     tosh
003b33 9508              ret
                 ;***************************************************
003b34 f656              fdw     DZEROLESS_L
                 DEQUAL_L:
003b35 6482
003b36 003d              .db     NFA|2,"d=",0
003b37 dfbd              rcall   DMINUS
003b38 940c 3b21         jmp     DZEROEQUAL
                 ;***************************************************
003b3a f66a              fdw     DEQUAL_L
                 DLESS_L:
003b3b 6482
003b3c 003c              .db     NFA|2,"d<",0
                 DLESS:
003b3d dfb7              rcall   DMINUS
003b3e 940c 3b2d         jmp     DZEROLESS
                 ;***************************************************
003b40 f676              fdw     DLESS_L
                 DGREATER_L:
003b41 6482
003b42 003e              .db     NFA|2,"d>",0
                 DGREATER:
003b43 940e 31dc         call    TWOSWAP
003b45 940c 3b3d         jmp     DLESS
                 ;***************************************************
003b47 f682              fdw     DGREATER_L
                 UDDOT_L:
003b48 7583
003b49 2e64              .db     NFA|3,"ud."
003b4a d92d              rcall   LESSNUM
003b4b d945              rcall   NUMS
003b4c d94d              rcall   NUMGREATER
003b4d 940e 324f         call    TYPE
003b4f 940c 31e5         jmp     SPACE_
                 ;***************************************************
003b51 f690              fdw     UDDOT_L
                 DDOT_L:
003b52 6482
003b53 002e              .db     NFA|2,"d.",0
003b54 d923              rcall   LESSNUM
003b55 940e 37eb         call    DUP
003b57 940e 32b9         call    TOR
003b59 df85              rcall   DABS
003b5a d936              rcall   NUMS
003b5b 940e 32c3         call    RFROM
003b5d d947              rcall   SIGN
003b5e d93b              rcall   NUMGREATER
003b5f 940e 324f         call    TYPE
003b61 940c 31e5         jmp     SPACE_
                 ;****************************************************
003b63 f6a4              fdw      DDOT_L
                 MEMHI_L:
003b64 6882
003b65 0069              .db     NFA|2,"hi",0
                 MEMHI:
003b66 dc7b              rcall   DOLIT
003b67 f6dc              fdw     FLASHHI
003b68 940e 3147         call    CSE_
003b6a 940e 32de         call    PLUS
003b6c 940c 3e5c         jmp     FETCH
                 FLASHHI:
003b6e deff              .dw      FLASH_HI
003b6f 0cff              .dw      EEPROM_HI
003b70 08ff              .dw      RAM_HI
                 
                 .if FLASHEND > 0x3fff
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
                 .endif
                 
                 ;***************************************************
                 
003b71 f6c8              fdw      MEMHI_L
                 L_FETCH_P:
003b72 40a2
003b73 0070              .db      NFA|INLINE|2,"@p", 0
                 FETCH_P:
003b74 939a
003b75 938a              pushtos
003b76 01ca              movw    tosl, pl
003b77 9508              ret
                 ;***************************************************
003b78 f6e4              fdw     L_FETCH_P
                 L_PCFETCH:
003b79 7083
003b7a 4063              .db     NFA|3,"pc@" ; ( -- c ) Fetch char from pointer
                 PCFETCH:
003b7b 939a
003b7c 938a              pushtos
003b7d 01ca              movw    tosl, pl
003b7e 940c 3e77         jmp     CFETCH
                 ;***************************************************
003b80 f6f2              fdw      L_PCFETCH
                 L_PTWOPLUS:
                 kernellink:
003b81 70a3
003b82 2b32              .db     NFA|INLINE|3,"p2+" ; ( n -- ) Add 2 to p
                 PTWOPLUS:
003b83 0d47              add     pl, r_two
003b84 1d55              adc     ph, zero
003b85 9508              ret
                 
                 ;***************************************************
                 ; marker --- name
003b86 0000              .dw     0
                 L_MARKER:
                 lastword:
003b87 6d86
003b88 7261
003b89 656b
003b8a 0072              .db     NFA|6,"marker",0
                 MARKER:
003b8b 940e 312c         call    ROM_
003b8d dca6              rcall   CREATE
003b8e dc53              rcall   DOLIT
003b8f 0900              .dw     dp_start
003b90 940e 3151         call    HERE
003b92 dbc9              rcall   TEN
003b93 d9d5              rcall   CMOVE
003b94 dbc7              rcall   TEN
003b95 940e 3291         call    ALLOT
003b97 940e 313a         call    FRAM
003b99 dcea              rcall   XDOES
003b9a 940e 30e8         call    DODOES
003b9c dd7e              rcall   INI
003b9d dbbe              rcall   TEN
003b9e 940c 3569         jmp     CMOVE
                 
                 .if IDLE_MODE == 1
                 .if CPU_LOAD_LED == 1
                 ;;; Enable load led
003ba0 df98              fdw     BUSY_L
                 LOADON_L:
003ba1 6c85
003ba2 616f
003ba3 2b64              .db     NFA|5,"load+"
003ba4 6170              sbr     FLAGS2, (1<<fLOADled)
003ba5 9508              ret
                 
                 ;;; Disable load led
003ba6 f742              fdw     LOADON_L
                 LOADOFF_L:
003ba7 6c85
003ba8 616f
003ba9 2d64              .db     NFA|5,"load-"
003baa 7e7f              cbr     FLAGS2, (1<<fLOADled)
                 .if CPU_LOAD_LED == 1
003bab 9825              cbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003bac 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003bad 9508              ret
                 .endif
                 ;;; 
                 .if CPU_LOAD == 1
                 .if CPU_LOAD_LED == 1
                 .else
                 .endif
                 .endif
                 .endif
                 
                 .ifdef UCSR1A
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .if OPERATOR_UART == 1
                 .if CTRL_O_WARM_RESET == 1
                 .endif
                 .endif
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 ;***************************************************
                 RQ_EMIT:
003bae fe00              sbrs    t2, PORF
003baf c003              rjmp    RQ_EXTR
003bb0 dc31              rcall   DOLIT
003bb1 0050              .dw     'P'
003bb2 dc7a              rcall   EMIT_A
                 RQ_EXTR:
003bb3 fe01              sbrs    t2, EXTRF
003bb4 c003              rjmp    RQ_BORF
003bb5 dc2c              rcall   DOLIT
003bb6 0045              .dw     'E'
003bb7 dc75              rcall   EMIT_A
                 RQ_BORF:
003bb8 fe02              sbrs    t2, BORF
003bb9 c003              rjmp    RQ_WDRF
003bba dc27              rcall   DOLIT
003bbb 0042              .dw     'B'
003bbc dc70              rcall   EMIT_A
                 RQ_WDRF:
003bbd fe03              sbrs    t2, WDRF
003bbe c003              rjmp    RQ_DIVZERO
003bbf dc22              rcall   DOLIT
003bc0 0057              .dw     'W'
003bc1 dc6b              rcall   EMIT_A
                 RQ_DIVZERO:
003bc2 fe16              sbrs    t3, 6 ; T bit MATH error
003bc3 c003              rjmp    RQ_END
003bc4 dc1d              rcall   DOLIT
003bc5 004d              .dw     'M'
003bc6 dc66              rcall   EMIT_A
                 RQ_END: 
003bc7 940c 31e5         jmp    SPACE_
                 
                 ;*****************************************************
                 .if IDLE_MODE == 1
                 IDLE_LOAD:
                 .if CPU_LOAD == 1       
                 .endif
                 .if CPU_LOAD_LED == 1
003bc9 ff74              sbrs    FLAGS2, fLOADled
003bca c002              rjmp    LOAD_LED_END
003bcb 9a25              sbi_    CPU_LOAD_DDR, CPU_LOAD_BIT
                 .if CPU_LOAD_LED_POLARITY == 1
003bcc 982d              cbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 LOAD_LED_END:
                 .endif
003bcd ff76              sbrs    FLAGS2, fIDLE
003bce c007              rjmp    IDLE_LOAD1
003bcf e003              ldi     t0, low(up0)
003bd0 1620              cp      upl, t0
003bd1 f421              brne    IDLE_LOAD1
                 .ifdef SMCR
003bd2 e001              ldi     t0, (1<<SE)
003bd3 bf03              out_    SMCR, t0
                 .else
                 .endif
                 .if CPU_LOAD == 1
                 .endif
003bd4 9588              sleep               ; IDLE mode
                 .ifdef SMCR
003bd5 be53              out_    SMCR, zero
                 .else
                 .endif
                 IDLE_LOAD1:
                 .if CPU_LOAD_LED == 1
003bd6 fd74              sbrc    FLAGS2, fLOADled
                 .if CPU_LOAD_LED_POLARITY == 1
003bd7 9a2d              sbi_    CPU_LOAD_PORT, CPU_LOAD_BIT
                 .else
                 .endif
                 .endif
003bd8 9508              ret
                 .endif
                 end_of_dict:
                 
                 ;FF_DP code:
                 dpcode:
                 ;****************************************************
                 ;        org h'f00000'
                 ;        de  h'ff', h'ff'
                 ;        de  dp_user_dictionary&0xff, (dp_user_dictionary>>8)&0xff
                 ;        de  dpeeprom&0xff, (dpeeprom>>8)&0xff
                 ;        de  (dpdata)&0xff, ((dpdata)>>8)&0xff
                 ;        de  lastword_lo, lastword_hi
                 ;        de  DOTSTATUS;&0xff;, (DOTSTATUS>>8)&0xff
                 
                 ; .end
                 ;********************************************************** 
                 .cseg
                 .org BOOT_START
003c00 940c 3d44 RESET_:     jmp  WARM_
                 .org BOOT_START + 0x02
003c02 d03b                  rcall FF_ISR
                 .org BOOT_START + 0x04
003c04 d039                  rcall FF_ISR
                 .org BOOT_START + 0x06
003c06 d037                  rcall FF_ISR
                 .org BOOT_START + 0x08
                 .if MS_TIMER_ADDR == 0x08
                 .else
003c08 d035                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x0a
003c0a d033                  rcall FF_ISR
                 .org BOOT_START + 0x0c
003c0c d031                  rcall FF_ISR
                 .org BOOT_START + 0x0e
                 .if MS_TIMER_ADDR == 0x0e
                 .else
003c0e d02f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x10
003c10 d02d                  rcall FF_ISR
                 .org BOOT_START + 0x12
                 .if MS_TIMER_ADDR == 0x12
                 .else
003c12 d02b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x14
                 .if MS_TIMER_ADDR == 0x14
                 .else
003c14 d029                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x16
                 .if MS_TIMER_ADDR == 0x16
                 .else
003c16 d027                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x18
                 .if MS_TIMER_ADDR == 0x18
                 .else
003c18 d025                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1a
                 .if MS_TIMER_ADDR == 0x1a
                 .else
003c1a d023                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x1c
                 .if MS_TIMER_ADDR == 0x1c
003c1c c033                  rjmp  MS_TIMER_ISR
                 .else
                 .endif
                 .org BOOT_START + 0x1e
                 .if MS_TIMER_ADDR == 0x1e
                 .else
003c1e d01f                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x20
                 .if MS_TIMER_ADDR == 0x20
                 .else
003c20 d01d                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x22
                 .if MS_TIMER_ADDR == 0x22
                 .else
003c22 d01b                  rcall FF_ISR
                 .endif
                 .org BOOT_START + 0x24
003c24 d019                  rcall FF_ISR
                 .if 0x26 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x26
003c26 d017                  rcall FF_ISR
                 .endif
                 .if 0x28 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x28
003c28 d015                  rcall FF_ISR
                 .endif
                 .if 0x2a < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2a
                 .if MS_TIMER_ADDR == 0x2a
                 .else
003c2a d013                  rcall FF_ISR
                 .endif
                 .endif
                 .if 0x2c < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2c
003c2c d011                  rcall FF_ISR
                 .endif
                 .if 0x2e < INT_VECTORS_SIZE
                 .org BOOT_START + 0x2e
003c2e d00f                  rcall FF_ISR
                 .endif
                 .if 0x30 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x30
003c30 d00d                  rcall FF_ISR
                 .endif
                 .if 0x32 < INT_VECTORS_SIZE
                 .org BOOT_START + 0x32
003c32 d00b                  rcall FF_ISR
                 .endif
                 .if 0x34 < INT_VECTORS_SIZE
                 .endif
                 .if 0x36 < INT_VECTORS_SIZE
                 .endif
                 .if 0x38 < INT_VECTORS_SIZE
                 .endif
                 .if 0x3a < INT_VECTORS_SIZE
                 .endif
                 .if 0x3c < INT_VECTORS_SIZE
                 .endif
                 .if 0x3e < INT_VECTORS_SIZE
                 .endif
                 .if 0x40 < INT_VECTORS_SIZE
                 .endif
                 .if 0x42 < INT_VECTORS_SIZE
                 .endif
                 .if 0x44 < INT_VECTORS_SIZE
                 .endif
                 .if 0x46 < INT_VECTORS_SIZE
                 .endif
                 .if 0x48 < INT_VECTORS_SIZE
                 .endif
                 .if 0x4a < INT_VECTORS_SIZE
                 .endif
                 .if 0x4c < INT_VECTORS_SIZE
                 .endif
                 .if 0x4e < INT_VECTORS_SIZE
                 .endif
                 .if 0x50 < INT_VECTORS_SIZE
                 .endif
                 .if 0x52 < INT_VECTORS_SIZE
                 .endif
                 .if 0x54 < INT_VECTORS_SIZE
                 .endif
                 .if 0x56 < INT_VECTORS_SIZE
                 .endif
                 .if 0x58 < INT_VECTORS_SIZE
                 .endif
                 .if 0x5a < INT_VECTORS_SIZE
                 .endif
                 .if 0x5c < INT_VECTORS_SIZE
                 .endif
                 .if 0x5e < INT_VECTORS_SIZE
                 .endif
                 .if 0x60 < INT_VECTORS_SIZE
                 .endif
                 .if 0x62 < INT_VECTORS_SIZE
                 .endif
                 .if 0x64 < INT_VECTORS_SIZE
                 .endif
                 .if 0x66 < INT_VECTORS_SIZE
                 .endif
                 .if 0x68 < INT_VECTORS_SIZE
                 .endif
                 .if 0x6a < INT_VECTORS_SIZE
                 .endif
                 .if 0x6c < INT_VECTORS_SIZE
                 .endif
                 .if 0x6e < INT_VECTORS_SIZE
                 .endif
                 .if 0x70 < INT_VECTORS_SIZE
                 .endif
                 
                 .org BOOT_START + INT_VECTORS_SIZE - 1
                 FF_ISR_EXIT:
003c33 919f              pop     tosh
003c34 918f              pop     tosl
003c35 911f              pop     t1
003c36 910f              pop     t0
003c37 91ff              pop     zh
003c38 91ef              pop     zl
                 MS_TIMER_ISR_EXIT:
003c39 91a9              ld      xl, y+
003c3a 91b9              ld      xh, y+
003c3b bfbf              out_    SREG, xh
003c3c 91b9              ld      xh, y+
003c3d 9518              reti
                         
                 FF_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
003c3e 93ba              st      -y, xh
003c3f b7bf              in_     xh, SREG
003c40 93ba              st      -y, xh
003c41 93aa              st      -y, xl
                         m_pop_xh
003c42 91bf              pop     xh
003c43 91af              pop     xl
003c44 93ef              push    zl
003c45 93ff              push    zh
003c46 930f              push    t0
003c47 931f              push    t1
003c48 938f              push    tosl
003c49 939f              push    tosh
                 .if low(ivec) == 0x80
003c4a e7bf              ldi     xh, low(ivec-1)
003c4b 0fab              add     xl, xh
                 .else
                 .endif
003c4c e0b1              ldi     xh, high(ivec)
003c4d 91ed              ld      zl, x+
003c4e 91fd              ld      zh, x+
003c4f 9409              mijmp   ;(z)
                 
                 ;;; *************************************************
                 MS_TIMER_ISR:
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .endif
                 .endif
003c50 93ba              st      -y, xh
003c51 b7bf              in_     xh, SREG
003c52 93ba              st      -y, xh
003c53 93aa              st      -y, xl
003c54 0ce6              add     ms_count,  r_one
003c55 1cf5              adc     ms_count1, zero
                 .if CPU_LOAD == 1
                 .endif
003c56 cfe2              rjmp    MS_TIMER_ISR_EXIT
                 ;;; ***************************************************
                 RX0_ISR:
003c57 ebe7              ldi     zl, low(rbuf0)
003c58 e0f1              ldi     zh, high(rbuf0)
003c59 91a0 01b4         lds     xl, rbuf0_wr
003c5b 0fea              add     zl, xl
003c5c 1df5              adc     zh, zero
003c5d 91b0 00c6         in_     xh, UDR0_
                 .if OPERATOR_UART == 0
                 .if CTRL_O_WARM_RESET == 1
003c5f 30bf              cpi     xh, 0xf
003c60 f409              brne    pc+2
003c61 cf9e              rjmp    RESET_
                 .endif
                 .endif
003c62 83b0              st      z, xh
003c63 95a3              inc     xl
003c64 71af              andi    xl, (RX0_BUF_SIZE-1)
003c65 93a0 01b4         sts     rbuf0_wr, xl
003c67 91a0 01b6         lds     xl, rbuf0_lv
003c69 95a3              inc     xl
003c6a 93a0 01b6         sts     rbuf0_lv, xl
003c6c 31ae              cpi     xl, RX0_BUF_SIZE-2
003c6d f409              brne    PC+2
003c6e d004              rcall   RX0_OVF
003c6f 30a4              cpi     xl, RX0_OFF_FILL
003c70 f00a              brmi    RX0_ISR_SKIP_XOFF
                 .if U0FC_TYPE == 1
003c71 d021              rcall   XXOFF_TX0_1
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 RX0_ISR_SKIP_XOFF:
003c72 cfc0              rjmp    FF_ISR_EXIT
                 RX0_OVF:
003c73 e7fc              ldi     zh, '|'
003c74 c020              rjmp    TX0_SEND
                 TX0_ISR:
                 
                 .ifdef UCSR1A
                 .endif
                 ;***************************************************
                 ; TX0   c --    output character to UART 0
                 .if IDLE_MODE == 1
                 .if CPU_LOAD == 1
                 .else
                 .if CPU_LOAD_LED == 1
003c75 f74e              fdw(LOADOFF_L)
                 .else
                 .endif
                 .endif
                 .else
                 .endif
                 TX0_L:
003c76 7483
003c77 3078              .db     NFA|3,"tx0"
                 TX0_:
                 .if U0FC_TYPE == 1
003c78 3181              cpi     tosl, XON
003c79 f061              breq    XXON_TX0_TOS
003c7a 3183              cpi     tosl, XOFF
003c7b f091              breq    XXOFF_TX0_TOS
                 .endif
                 TX0_LOOP:
003c7c d276              rcall   PAUSE
003c7d 9100 00c0         in_     t0, UCSR0A
003c7f ff05              sbrs    t0, 5        ; UDRE0, UDRE USART Data Register Empty
003c80 cffb              rjmp    TX0_LOOP
003c81 9380 00c6         out_    UDR0_, tosl
003c83 9189
003c84 9199              poptos
003c85 9508              ret
                 
                 .if U0FC_TYPE == 1
                 XXON_TX0_TOS:
003c86 9189
003c87 9199              poptos
003c88 c002              rjmp    XXON_TX0_1
                 XXON_TX0:
003c89 ff70              sbrs    FLAGS2, ixoff_tx0
003c8a 9508              ret
                 XXON_TX0_1:
003c8b 7f7e              cbr     FLAGS2, (1<<ixoff_tx0)
003c8c e1f1              ldi     zh, XON
003c8d c007              rjmp    TX0_SEND
                 
                 XXOFF_TX0_TOS:
003c8e 9189
003c8f 9199              poptos
003c90 c002              rjmp    XXOFF_TX0_1
                 XXOFF_TX0:
003c91 fd70              sbrc    FLAGS2, ixoff_tx0
003c92 9508              ret     
                 XXOFF_TX0_1:
003c93 6071              sbr     FLAGS2, (1<<ixoff_tx0)
003c94 e1f3              ldi     zh, XOFF
                 .endif
                 TX0_SEND:
003c95 91e0 00c0         in_     zl, UCSR0A
003c97 ffe5              sbrs    zl, 5        ; UDRE0, UDRE USART Data Register Empty
003c98 cffc              rjmp    TX0_SEND
003c99 93f0 00c6         out_    UDR0_, zh
003c9b 9508              ret
                 ;***************************************************
                 ; RX0    -- c    get character from the UART 0 buffer
003c9c f8ec              fdw(TX0_L)
                 RX0_L:
003c9d 7283
003c9e 3078              .db     NFA|3,"rx0"
                 RX0_:
003c9f d253              rcall   PAUSE
003ca0 d01e              rcall   RX0Q
003ca1 940e 33fc         call    ZEROSENSE
003ca3 f3d9              breq    RX0_
003ca4 939a
003ca5 938a              pushtos
003ca6 ebe7              ldi     zl, low(rbuf0)
003ca7 e0f1              ldi     zh, high(rbuf0)
003ca8 91a0 01b5         lds     xl, rbuf0_rd
003caa 0fea              add     zl, xl
003cab 1df5              adc     zh, zero
003cac 8180              ld      tosl, z
003cad 2799              clr     tosh
003cae b70f              in_     t0, SREG
003caf 94f8              cli
003cb0 95a3              inc     xl
003cb1 71af              andi    xl, (RX0_BUF_SIZE-1)
003cb2 93a0 01b5         sts     rbuf0_rd, xl
003cb4 91a0 01b6         lds     xl, rbuf0_lv
003cb6 95aa              dec     xl
003cb7 93a0 01b6         sts     rbuf0_lv, xl
003cb9 bf0f              out_    SREG, t0
003cba 9508              ret
                 ;***************************************************
                 ; RX0?  -- n    return the number of characters in queue
003cbb f93a              fdw     RX0_L
                 RX0Q_L:
003cbc 7284
003cbd 3078
003cbe 003f              .db     NFA|4,"rx0?",0
                 RX0Q:
003cbf 91a0 01b6         lds     xl, rbuf0_lv
003cc1 11a5              cpse    xl, zero
003cc2 940c 378d         jmp     TRUE_
                 .if U0FC_TYPE == 1
003cc4 dfc4              rcall   XXON_TX0
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
003cc5 940c 3784         jmp     FALSE_
                 
                 
                 ;*************************************************************
                  ISTORERR:
003cc7 dcc7              rcall   DOTS
003cc8 940e 325c         call    XSQUOTE
003cca 4103
003ccb 3f44              .db     3,"AD?"
003ccc 940e 324f         call    TYPE
003cce caec              rjmp    ABORT
                         
                 ; Coded for max 256 byte pagesize !
                 ;if (ibaselo != (iaddrlo&(~(PAGESIZEB-1))))(ibaseh != iaddrh)(ibaseu != iaddru)
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo&(~(PAGESIZEB-1))
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003ccf 5890      	sub_pflash_tos
                 .ifdef  RAMPZ
                 .endif
                 XUPDATEBUF:
003cd0 9380 01e3         sts     iaddrl, tosl
003cd2 9390 01e4         sts     iaddrh, tosh
                 .ifdef RAMPZ
                 .endif
003cd4 359f              cpi     tosh, high(FLASH_HI-PFLASH+1) ; Dont allow kernel writes
003cd5 f788              brcc    ISTORERR
                 XUPDATEBUF2:	
003cd6 9100 01e3 	lds     t0, iaddrl
003cd8 7800              andi    t0, ~(PAGESIZEB-1)
003cd9 110a              cpse    t0, ibasel
003cda c005              rjmp    IFILL_BUFFER
003cdb 9100 01e4         lds     t0, iaddrh
003cdd 110b              cpse    t0, ibaseh
003cde c001              rjmp    IFILL_BUFFER
                 .ifdef RAMPZ
                 .endif
003cdf 9508              ret
                 
                 IFILL_BUFFER:
003ce0 d04e              rcall   IFLUSH
003ce1 9100 01e3         lds     t0, iaddrl
003ce3 7800              andi    t0, ~(PAGESIZEB-1)
003ce4 2ea0              mov     ibasel, t0
003ce5 90b0 01e4         lds     ibaseh, iaddrh
                 .ifdef RAMPZ
                 .endif
                 IFILL_BUFFER_1:
003ce7 e800              ldi     t0, PAGESIZEB&0xff ; 0x100 max PAGESIZEB
003ce8 01f5              movw    zl, ibasel
003ce9 e0a0              ldi     xl, low(ibuf)
003cea e0b1              ldi     xh, high(ibuf)
                 IFILL_BUFFER_2:
003ceb 9115              lpm_    t1, z+
003cec 931d              st      x+, t1
003ced 950a              dec     t0
003cee f7e1              brne    IFILL_BUFFER_2
                 .ifdef RAMPZ
                 .endif
003cef 9508              ret
                 
                 IWRITE_BUFFER:
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003cf0 daf1              rcall   DOLIT
003cf1 0013              .dw     XOFF
003cf2 940e 308b         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else  ;; UART1
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003cf4 daed              rcall   DOLIT
003cf5 000a              .dw     10
003cf6 dc36              rcall   MS
                         ; Disable interrupts
003cf7 94f8              cli
003cf8 01f5              movw    zl, ibasel
                 .ifdef RAMPZ
                 .endif
003cf9 e013              ldi     t1, (1<<PGERS) | (1<<SPMEN) ; Page erase
003cfa d029              rcall   DO_SPM
003cfb e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN); re-enable the RWW section
003cfc d027              rcall   DO_SPM
                 
                         ; transfer data from RAM to Flash page buffer
003cfd e800              ldi     t0, low(PAGESIZEB);init loop variable
003cfe e0a0              ldi     xl, low(ibuf)
003cff e0b1              ldi     xh, high(ibuf)
                 IWRITE_BUFFER1:
003d00 900d              ld      r0, x+
003d01 901d              ld      r1, x+
003d02 e011              ldi     t1, (1<<SPMEN)
003d03 d020              rcall   DO_SPM
003d04 9632              adiw    zl, 2
003d05 5002              subi    t0, 2
003d06 f7c9              brne    IWRITE_BUFFER1
                 
                         ; execute page write
003d07 58e0              subi    zl, low(PAGESIZEB) ;restore pointer
003d08 40f0              sbci    zh, high(PAGESIZEB)
003d09 e015              ldi     t1, (1<<PGWRT) | (1<<SPMEN)
003d0a d019              rcall   DO_SPM
                         ; re-enable the RWW section
003d0b d012              rcall   IWRITE_BUFFER3
                 
                         ; read back and check, optional
003d0c e800              ldi     t0, low(PAGESIZEB);init loop variable
003d0d 58a0              subi    xl, low(PAGESIZEB) ;restore pointer
003d0e 40b0              sbci    xh, high(PAGESIZEB)
                 IWRITE_BUFFER2:
003d0f 9005              lpm_    r0, z+
003d10 901d              ld      r1, x+
003d11 1001              cpse    r0, r1
003d12 c031              rjmp    WARM_     ; reset
003d13 5001              subi    t0, 1
003d14 f7d1              brne    IWRITE_BUFFER2
003d15 ef0f      	ser     t0
003d16 2eb0      	mov     ibaseh, t0
                 .ifdef RAMPZ
                 .endif
                 .ifdef RAMPZ
                 .endif
003d17 7f6e              cbr     FLAGS1, (1<<idirty)
                         // reenable interrupts
003d18 9478              sei
                 .if OPERATOR_UART == 0
                 .if U0FC_TYPE == 1
003d19 dac8              rcall   DOLIT
003d1a 0011              .dw     XON
003d1b 940e 308b         call    EMIT
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .else
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
                 .if DEBUG_FLASH == 1
                 .endif
003d1d 9508               ret
                         ; ret to RWW section
                         ; verify that RWW section is safe to read
                 IWRITE_BUFFER3:
003d1e b687              in_     t8, SPMCSR
003d1f fe86              sbrs    t8, RWWSB ; If RWWSB is set, the RWW section is not ready yet
003d20 9508              ret
                         ; re-enable the RWW section
003d21 e111              ldi     t1, (1<<RWWSRE) | (1<<SPMEN)
003d22 d001              rcall   DO_SPM
003d23 cffa              rjmp    IWRITE_BUFFER3
                 
                 DO_SPM:
003d24 b687              in_     t8, SPMCSR
003d25 fc80              sbrc    t8, SPMEN
003d26 cffd              rjmp    DO_SPM       ; Wait for previous write to complete
003d27 bf17              out_    SPMCSR, t1
003d28 95e8              spm
003d29 9508              ret
                 
003d2a fde0              fdw     PAUSE_L
                 IFLUSH_L:
003d2b 6986
003d2c 6c66
003d2d 7375
003d2e 0068              .db     NFA|6,"iflush",0
                 IFLUSH:
003d2f fd60              sbrc    FLAGS1, idirty
003d30 cfbf              rjmp    IWRITE_BUFFER
003d31 9508              ret
                 
                 ;***************************************************
                 .ifdef UCSR1A
                 .else
003d32 f978              fdw     RX0Q_L
                 .endif
                 EMPTY_L:
003d33 6585
003d34 706d
003d35 7974              .db     NFA|5,"empty"
                 EMPTY:
003d36 daab              rcall   DOLIT
003d37 fee4              fdw     COLDLIT
003d38 daa9              rcall   DOLIT
003d39 0900              .dw     dp_start
003d3a daa7              rcall   DOLIT
003d3b 000c              .dw     coldlitsize
003d3c 940e 3569         call    CMOVE
003d3e 940c 3760         jmp     DP_TO_RAM
                         
                 ;*******************************************************
003d40 fa66              fdw     EMPTY_L
                 WARM_L:
003d41 7784
003d42 7261
003d43 006d              .db     NFA|4,"warm",0
                 WARM_:
                 ; Zero memory
003d44 94f8              cli           ; Disable interrupts
003d45 27aa              clr     xl
003d46 27bb              clr     xh
003d47 e1c9              ldi     yl, 25
003d48 e0d0              ldi     yh, 0
                 WARM_1:
003d49 93dd              st      x+, yh
003d4a 50c1              subi    yl, 1
003d4b f7e9              brne    WARM_1
                 
003d4c b61f              in_     t3, SREG
                 .ifdef MCUCSR
                 .endif
                 .ifdef MCUSR
003d4d b604              in_     t2, MCUSR
003d4e 9250 0034         sts     MCUSR, zero
                 .endif
003d50 e1ac              ldi     xl, 0x1C  ; clear ram from y register upwards
                 WARM_2:
003d51 925d              st      x+, zero
003d52 31b0              cpi     xh, 0x10  ; up to 0xfff, 4 Kbytes 
003d53 f7e9              brne    WARM_2
                 
                 ; Init empty flash buffer
003d54 94ba      	dec     ibaseh
                 .ifdef RAMPZ
                 .endif
                 
                 ; Init constant registers
003d55 e0c1              ldi     yl, 1
003d56 2e6c              mov     r_one, yl
003d57 e0c2              ldi     yl, 2
003d58 2e7c              mov     r_two, yl
                 ; Init Stack pointer
003d59 e8c1              ldi     yl, low(utibbuf-4)
003d5a e0d2              ldi     yh, high(utibbuf-4)
                 
                 ; Init Return stack pointer
003d5b e404              ldi     t0, low(usbuf-1)
003d5c e012              ldi     t1, high(usbuf-1)
003d5d bf0d              out     spl, t0
003d5e bf1e              out     sph, t1
                 ; Init user pointer
003d5f e003              ldi     t0, low(up0)
003d60 e012              ldi     t1, high(up0)
003d61 0118              movw    upl, t0
                 ; Set RAMPZ for correct flash addressing
                 .ifdef RAMPZ
                 .endif
                 .ifdef EIND
                 .endif
                 ; init warm literals
003d62 da7f              rcall   DOLIT
003d63 df22              fdw     WARMLIT
003d64 da7d              rcall   DOLIT
003d65 01e5              .dw     cse
003d66 da7b              rcall   DOLIT
003d67 001c              .dw     warmlitsize
003d68 940e 3569         call    CMOVE
                 ; init cold data to eeprom
003d6a da77              rcall   DOLIT
003d6b 0900              .dw     dp_start
003d6c d0ef              rcall   FETCH
003d6d da1f              rcall   TRUE_
003d6e 940e 338d         call    EQUAL
003d70 940e 33fc         call    ZEROSENSE
003d72 f009              breq    WARM_3  
003d73 dfc2              rcall   EMPTY
                 WARM_3:
                 ; Move interrupts to boot flash section
003d74 be65              out_    MCUCR, r_one   ; (1<<IVCE)
003d75 be75              out_    MCUCR, r_two   ; (1<<IVSEL)
                 
                 
                 .if MS_TIMER == 0
                 .ifdef TIMSK0
003d76 bc74              out_    TCCR0A, r_two  ; CTC
003d77 e003              ldi     t0, ms_pre_tmr0
003d78 bd05              out_    TCCR0B, t0
003d79 ef09              ldi     t0, ms_value_tmr0
003d7a bd07              out_    OCR0A, t0
003d7b 9270 006e         out_    TIMSK0, r_two ; (1<<OCIE0A)
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 .if MS_TIMER == 1
                 .ifdef TIMSK
                 .endif
                 .ifdef TIMSK1
                 .endif
                 .endif
                 .if MS_TIMER == 2
                 .ifdef TIMSK2
                 .endif
                 .ifdef TIMSK
                 .endif
                 .endif
                 
                 ; Init UART 0
                 .ifdef UBRR0L
003d7d da64              rcall   DOLIT
003d7e 3c57              .dw     RX0_ISR
003d7f da62              rcall   DOLIT
                 .ifdef URXC0addr
                 .else
003d80 01a4              .dw     URXCaddr+ivec
                 .endif
003d81 d0a0              rcall   STORE
                 ;;;     Set baud rate
                 ;        out_    UBRR0H, zero
003d82 e607              ldi     t0, ubrr0val
003d83 9300 00c4         out_    UBRR0L, t0
                         ; Enable receiver and transmitter, rx1 interrupts
003d85 e908              ldi     t0, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003d86 9300 00c1         out_    UCSR0B,t0
                         ; Set frame format: 8data, 1stop bit
003d88 e006              ldi     t0, (3<<UCSZ00)|URSEL_
003d89 9300 00c2         out_    UCSR0C,t0
                 .if U0FC_TYPE == 1
003d8b 6071              sbr     FLAGS2, (1<<ixoff_tx0)
                 .endif
                 .if U0FC_TYPE == 2
                 .endif
                 .endif
                 ; Init UART 1
                 .ifdef UBRR1L
                 .if U1FC_TYPE == 1
                 .endif
                 .if U1FC_TYPE == 2
                 .endif
                 .endif
003d8c d9d3              rcall   DP_TO_RAM
003d8d 9478              sei
                 
003d8e de1f              rcall   RQ_EMIT
003d8f d023              rcall   VER
                 ; Turnkey ?
003d90 d15b              rcall   TURNKEY
003d91 940e 33fc         call    ZEROSENSE
003d93 f0d1              breq    STARTQ2
003d94 940e 325c         call    XSQUOTE
003d96 4503
003d97 4353              .db     3,"ESC"
003d98 940e 324f         call    TYPE
003d9a da47              rcall   DOLIT
003d9b 07d0              .dw     TURNKEY_DELAY
003d9c db90              rcall   MS
003d9d 940e 3098         call    KEYQ
003d9f 940e 33fc         call    ZEROSENSE
003da1 f049              breq    STARTQ1
003da2 940e 3091         call    KEY
003da4 da3d              rcall   DOLIT
003da5 001b              .dw     0x1b
003da6 940e 338d         call    EQUAL
003da8 940e 33fc         call    ZEROSENSE
003daa f419              brne    STARTQ2
                 STARTQ1:
003dab d140              rcall   TURNKEY
003dac 940e 30a0         call    EXECUTE
                 STARTQ2:
003dae 940c 37bb         jmp     ABORT
                 
                 .equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
003db0 fa82              fdw     WARM_L
                 VER_L:
003db1 7683
003db2 7265              .db     NFA|3,"ver"
                 VER:
003db3 940e 325c         call    XSQUOTE
                          ;      1234567890123456789012345678901234567890
                         ;.db 34,"FlashForth Atmega 5.0 ",DATE,0xd,0xa,0
003db5 4624
003db6 616c
003db7 6873
003db8 6f46
003db9 7472
003dba 2068
003dbb 2035
003dbc 5441
003dbd 656d
003dbe 6167
003dbf 3233
003dc0 5038
003dc1 3020
003dc2 2e37
003dc3 3130
003dc4 322e
003dc5 3130
003dc6 0d37
avr/src/ff-atmega.asm(5444): warning: .cseg .db misalignment - padding zero byte
003dc7 000a              .db     partlen+datelen+16,"FlashForth 5 ",partstring," ", DATE,0xd,0xa
003dc8 940c 324f         jmp     TYPE
                 
                 ; ei  ( -- )    Enable interrupts
003dca fb62              fdw     VER_L
                 EI_L:
003dcb 65a2
003dcc 0069              .db     NFA|INLINE|2,"ei",0
003dcd 9478              sei
003dce 9508              ret
                         
                 ; di  ( -- )    Disable interrupts
003dcf fb96              fdw     EI_L
                 DI_L:
003dd0 64a2
003dd1 0069              .db     NFA|INLINE|2,"di",0
003dd2 94f8              cli
003dd3 9508              ret
                 ;*******************************************************
                 ; ;i  ( -- )    End definition of user interrupt routine
003dd4 fba0              fdw     DI_L
                 IRQ_SEMI_L:
003dd5 3bc2
003dd6 0069              .db     NFA|IMMED|2,";i",0
                 IRQ_SEMI:
003dd7 da0a              rcall   DOLIT
                 .ifdef EIND
                 .else
003dd8 940c              .dw     0x940C     ; jmp
                 .endif
003dd9 d139              rcall   ICOMMA
003dda da07              rcall   DOLIT
003ddb 3c33              .dw     FF_ISR_EXIT
003ddc d136              rcall   ICOMMA
003ddd 940c 389f         jmp     LEFTBRACKET
                 
                 
                 ; int!  ( addr n  --  )   store to interrupt vector number
003ddf fbaa              fdw     IRQ_SEMI_L
                 IRQ_V_L:
003de0 6984
003de1 746e
003de2 0021              .db     NFA|4,"int!",0
                 IRQ_V:
003de3 01fc              movw    zl, tosl
003de4 9731              sbiw    zl, 1
003de5 0fee              lsl     zl
                 .if low(ivec) == 0x80
003de6 e8f0              ldi     zh, low(ivec)
003de7 0fef              add     zl,  zh
                 .endif
003de8 e0f1              ldi     zh, high(ivec)
003de9 9189
003dea 9199              poptos
003deb dbf7              rcall   TO_XA
003dec 940c 3e27         jmp     STORE_RAM_2
                 
                 ; DOLITERAL  x --           compile DOLITeral x as native code
003dee fbc0              fdw     IRQ_V_L
                 LITERAL_L:
003def 6cc7
003df0 7469
003df1 7265
003df2 6c61              .db     NFA|IMMED|7,"literal"
                 LITERAL:
003df3 d9ee              rcall   DOLIT
003df4 efd6              fdw     DUP
003df5 dc82              rcall   INLINE0
003df6 9380 01d7         sts     litbuf0, tosl
003df8 9390 01d8         sts     litbuf1, tosh
003dfa 6860              sbr     FLAGS1, (1<<fLIT)
003dfb 940e 37eb         call    DUP
003dfd 2f98              mov     tosh, tosl
003dfe 9592              swap    tosh
003dff 709f              andi    tosh, 0xf
003e00 708f              andi    tosl, 0xf
003e01 6e90              ori     tosh, 0xe0
003e02 6880              ori     tosl, 0x80
003e03 d10f              rcall   ICOMMA
003e04 2f89              mov     tosl, tosh
003e05 9592              swap    tosh
003e06 709f              andi    tosh, 0xf
003e07 708f              andi    tosl, 0xf
003e08 6e90              ori     tosh, 0xe0
003e09 6980              ori     tosl, 0x90
003e0a 940c 3f13         jmp     ICOMMA
                 
                 #if 0
                 #endif
                 
                 ;*****************************************************************
                 ISTORE:
003e0c dec2              rcall   IUPDATEBUF
                 ISTORE1:
003e0d 9189
003e0e 9199              poptos
003e0f e0a0              ldi     xl, low(ibuf)
003e10 e0b1              ldi     xh, high(ibuf)
003e11 9100 01e3         lds     t0, iaddrl
003e13 770f              andi    t0, (PAGESIZEB-1)
003e14 0fa0              add     xl, t0
003e15 938d              st      x+, tosl
003e16 939d              st      x+, tosh
003e17 c074              rjmp    ICSTORE_POP
                 
003e18 fbde              fdw     LITERAL_L
                 TO_A_L:
003e19 3e82
003e1a 0061              .db     NFA|2, ">a",0
                 TO_A:
003e1b 2f28              mov     al, tosl
003e1c 2f39              mov     ah, tosh
003e1d 9189
003e1e 9199              poptos
003e1f 9508              ret
                 
003e20 fc32              fdw     TO_A_L
                 STORE_L:
003e21 2181              .db     NFA|1, "!"
                 STORE:
003e22 3099              cpi     tosh, high(PEEPROM)
003e23 f440              brcc    STORE1
                 STORE_RAM:
003e24 01fc              movw    zl, tosl
003e25 9189
003e26 9199              poptos
                 STORE_RAM_2:
003e27 8391              std     Z+1, tosh
003e28 8380              std     Z+0, tosl
003e29 9189
003e2a 9199              poptos
003e2b 9508              ret
                 STORE1:
003e2c d009              rcall   LOCKEDQ
003e2d 3890              cpi     tosh, high(OFLASH)
003e2e f6e8              brcc    ISTORE
                 ESTORE:
003e2f 940e 31d5         call    TWODUP
003e31 d06b              rcall   ECSTORE
003e32 9601              adiw    tosl, 1
003e33 8109              ldd     t0, Y+1
003e34 8308              std     y+0, t0
003e35 c067              rjmp    ECSTORE
                 
                 LOCKEDQ:
003e36 ff62              sbrs    FLAGS1, fLOCK
003e37 9508              ret
003e38 db56              rcall   DOTS
003e39 940e 325c         call    XSQUOTE
003e3b 4103
003e3c 3f44              .db     3,"AD?"
003e3d 940e 324f         call    TYPE
003e3f cf6e              rjmp    STARTQ2        ; goto    ABORT
                         
                 ;***********************************************************
                 IFETCH:
003e40 01fc              movw    z, tosl
003e41 58f0              sub_pflash_z
                 .ifdef RAMPZ
                 .endif
003e42 11fb              cpse    zh, ibaseh
003e43 c00b              rjmp    IIFETCH
003e44 2f0e              mov     t0, zl
003e45 7800              andi    t0, ~(PAGESIZEB-1)
003e46 150a              cp      t0, ibasel
003e47 f439              brne    IIFETCH
003e48 e0a0              ldi     xl, low(ibuf)
003e49 e0b1              ldi     xh, high(ibuf)
003e4a 77ef              andi    zl, (PAGESIZEB-1)
003e4b 0fae              add     xl, zl
003e4c 918d              ld      tosl, x+
003e4d 919d              ld      tosh, x+
003e4e 9508              ret
                 IIFETCH:
003e4f 9185              lpm_    tosl, z+     ; Fetch from Flash directly
003e50 9195              lpm_    tosh, z+
003e51 9508              ret
                                 
003e52 fc42              fdw     STORE_L
                 A_FROM_L:
003e53 6182
003e54 003e              .db     NFA|2, "a>",0
003e55 939a
003e56 938a              pushtos
003e57 2f82              mov     tosl, al
003e58 2f93              mov     tosh, ah
003e59 9508              ret
                 
                 .if FLASHEND > 0x3fff
                 .else
003e5a fca6              fdw     A_FROM_L
                 .endif
                 FETCH_L:
003e5b 4081              .db     NFA|1, "@"
                 FETCH:
003e5c 3099              cpi     tosh, high(PEEPROM)
003e5d f420              brcc    FETCH1
                 FETCH_RAM:
003e5e 01fc              movw    zl, tosl
                 FETCH_RAM_2:
003e5f 9181              ld      tosl, z+
003e60 9191              ld      tosh, z+
003e61 9508              ret
                 FETCH1:
003e62 3890              cpi     tosh, high(OFLASH)
003e63 f6e0              brcc    IFETCH
                 EFETCH:
003e64 99f9              sbic    eecr, eewe
003e65 cffe              rjmp    EFETCH
003e66 5099              subi    tosh, high(PEEPROM)
003e67 bd81              out     eearl, tosl
003e68 bd92              out     eearh, tosh
003e69 9af8              sbi     eecr, eere
003e6a b500              in      t0, eedr
003e6b 9583              inc     tosl
003e6c bd81              out     eearl, tosl
003e6d 9af8              sbi     eecr, eere
003e6e b590              in      tosh, eedr
003e6f 2f80              mov     tosl, t0
003e70 9508              ret
                 
                 ICFETCH:
003e71 dfce              rcall   IFETCH
003e72 2799              clr     tosh
003e73 9508              ret
                 
003e74 fcb6              fdw     FETCH_L
                 CFETCH_L:
003e75 6382
003e76 0040              .db     NFA|2, "c@",0
                 CFETCH:
003e77 3099              cpi     tosh, high(PEEPROM)
003e78 f420              brcc    CFETCH1
                 CFETCH_RAM:
003e79 01fc              movw    zl, tosl
003e7a 9181              ld      tosl, z+
003e7b 2799              clr     tosh
003e7c 9508              ret
                 CFETCH1:
003e7d 3890              cpi     tosh, high(OFLASH)
003e7e f790              brcc    ICFETCH
                 ECFETCH:
003e7f dfe4              rcall   EFETCH
003e80 2799              clr     tosh
003e81 9508              ret
                 
                 ICSTORE:
003e82 de4c              rcall   IUPDATEBUF
003e83 9189
003e84 9199              poptos
003e85 e0a0              ldi     xl, low(ibuf)
003e86 e0b1              ldi     xh, high(ibuf)
003e87 9100 01e3         lds     t0, iaddrl
003e89 770f              andi    t0, (PAGESIZEB-1)
003e8a 0fa0              add     xl, t0
003e8b 938d              st      x+, tosl
                 ICSTORE_POP:
003e8c 6061              sbr     FLAGS1, (1<<idirty)
003e8d c009              rjmp    CSTORE_POP
                 
003e8e fcea              fdw     CFETCH_L
                 CSTORE_L:
003e8f 6382
003e90 0021              .db     NFA|2, "c!",0
                 CSTORE:
003e91 3099              cpi     tosh, high(PEEPROM)
003e92 f438              brcc    CSTORE1
                 CSTORE_RAM:
003e93 01fc              movw zl, tosl
003e94 9189
003e95 9199              poptos
003e96 8380              st      Z, tosl
                 CSTORE_POP:
003e97 9189
003e98 9199              poptos
003e99 9508              ret
                 CSTORE1:
003e9a df9b              rcall   LOCKEDQ
003e9b 3890              cpi     tosh, high(OFLASH)
003e9c f728              brcc    ICSTORE
                 ECSTORE:
003e9d 99f9              sbic    eecr, eewe
003e9e cffe              rjmp    ECSTORE
003e9f 5099              subi    tosh, high(PEEPROM)
003ea0 bd81              out     eearl, tosl
003ea1 bd92              out     eearh, tosh
003ea2 9189
003ea3 9199              poptos
003ea4 bd80              out     eedr, tosl
003ea5 9afa              sbi     eecr, eemwe
003ea6 9af9              sbi     eecr, eewe
003ea7 cfef              rjmp    CSTORE_POP
                 
                 ;;; Disable writes to flash and eeprom
003ea8 fd1e              fdw     CSTORE_L
                 
                 FLOCK_L:
003ea9 6683
003eaa 2d6c              .db     NFA|3,"fl-"
003eab 6064              sbr     FLAGS1, (1<<fLOCK)
003eac 9508              ret
                 
                 ;;; Enable writes to flash and eeprom
003ead fd52              fdw     FLOCK_L
                 FUNLOCK_L:
003eae 6683
003eaf 2b6c              .db     NFA|3,"fl+"
003eb0 7f6b              cbr     FLAGS1, (1<<fLOCK)
003eb1 9508              ret
                 
                 
                 
003eb2 fd5c              fdw     FUNLOCK_L
                 VALUE_L:
003eb3 7685
003eb4 6c61
003eb5 6575              .db     NFA|5,"value"
                 VALUE:
003eb6 d97d              rcall   CREATE
003eb7 940e 3156         call    COMMA
003eb9 d9ca              rcall   XDOES
                 VALUE_DOES:
003eba 940e 30e8         call    DODOES
003ebc 940c 3e5c         jmp     FETCH
                 
003ebe fd66              fdw     VALUE_L
                 DEFER_L:
003ebf 6485
003ec0 6665
003ec1 7265              .db     NFA|5,"defer"
                 DEFER:
003ec2 d971              rcall   CREATE
003ec3 940e 37e2         call    DOLIT
003ec5 ef76              fdw     ABORT
003ec6 940e 3156         call    COMMA
003ec8 d9bb              rcall   XDOES
                 DEFER_DOES:
003ec9 940e 30e8         call    DODOES
003ecb 940c 30ab         jmp     FEXECUTE
                 
003ecd fd7e              fdw     DEFER_L
                 IS_L:
003ece 69c2
003ecf 0073              .db     NFA|IMMED|2,"is",0
                 IS:
003ed0 940e 37fe         call    TICK
003ed2 940e 335b         call    TWOPLUS
003ed4 940e 335b         call    TWOPLUS
003ed6 df85              rcall   FETCH
003ed7 da28              rcall   STATE_
003ed8 940e 33fc         call    ZEROSENSE
003eda f029              breq    IS1
003edb df17              rcall   LITERAL
003edc 940e 30f8         call    DOCOMMAXT
003ede fc44              fdw     STORE
003edf c001              rjmp    IS2
                 IS1:
003ee0 df41              rcall   STORE
                 IS2:
003ee1 9508              ret
                 
003ee2 fd9c              fdw     IS_L
                 TO_L:
003ee3 74c2
003ee4 006f              .db     NFA|IMMED|2,"to",0
                 TO:
003ee5 940c 3ed0         jmp     IS
                 
003ee7 fdc6              fdw     TO_L
                 TURNKEY_L:
003ee8 7487
003ee9 7275
003eea 6b6e
003eeb 7965              .db     NFA|7,"turnkey"
                 TURNKEY:
003eec 940e 3eba         call    VALUE_DOES      ; Must be call for IS to work.
003eee 01d9              .dw     dpSTART
                 
                 
                 ;;; *******************************************************
                 ; PAUSE  --     switch task
003eef fdd0              fdw     TURNKEY_L
                 PAUSE_L:
003ef0 7085
003ef1 7561
003ef2 6573              .db     NFA|5,"pause"
                 PAUSE:
                 .if IDLE_MODE == 1
003ef3 dcd5              rcall   IDLE_LOAD
                 .endif
003ef4 b71f              in_     t1, SREG
003ef5 94f8              cli
003ef6 93df              push    yh        ; SP
003ef7 93cf              push    yl
003ef8 939f              push    tosh      ; TOS
003ef9 938f              push    tosl
003efa 935f              push    ph        ; P
003efb 934f              push    pl
003efc 01f1              movw    zl, upl
003efd b70e              in      t0, sph
003efe 9302              st      -z, t0
003eff b70d              in      t0, spl
003f00 9302              st      -z, t0
003f01 91b2              ld      xh, -z     ; UP
003f02 91a2              ld      xl, -z
003f03 011d              movw    upl, xl
003f04 910e              ld      t0, -x
003f05 bf0e              out     sph, t0
003f06 910e              ld      t0, -x
003f07 bf0d              out     spl, t0
003f08 914f              pop     pl
003f09 915f              pop     ph
003f0a 918f              pop     tosl
003f0b 919f              pop     tosh
003f0c 91cf              pop     yl
003f0d 91df              pop     yh
003f0e bf1f              out_    SREG, t1
003f0f 9508              ret
                 
                 
003f10 df70              fdw     OPERATOR_L
                 ICOMMA_L:
003f11 6982
003f12 002c              .db     NFA|2, "i,",0
                 ICOMMA:
003f13 940e 3817         call    IHERE
003f15 df0c              rcall   STORE
003f16 940e 3167         call    CELL
003f18 940c 39d0         jmp     IALLOT
                 
                 
                 ;   IHERE ! 1 CHARS IALLOT ;
003f1a fe22              fdw     ICOMMA_L
                 ICCOMMA_L:
003f1b 6983
003f1c 2c63              .db     NFA|3,"ic,"
                 ICCOMMA:
003f1d 940e 3817         call    IHERE
003f1f df71              rcall   CSTORE
003f20 940e 3208         call    ONE
003f22 940c 39d0         jmp     IALLOT
                 
                 L_DOTBASE:
003f24 2081              .db      NFA|1," "
                 DOTBASE:
003f25 940e 350f         call    BASE
003f27 df34              rcall   FETCH
003f28 3180              cpi     tosl, 0x10
003f29 f411              brne    DOTBASE1
003f2a e284              ldi     tosl,'$'
003f2b c009              rjmp    DOTBASEEND
                 DOTBASE1:
003f2c 308a              cpi     tosl, 0xa
003f2d f411              brne    DOTBASE2
003f2e e283              ldi     tosl, '#'
003f2f c005              rjmp    DOTBASEEND
                 DOTBASE2:
003f30 3082              cpi     tosl, 0x2
003f31 f411              brne    DOTBASE3
003f32 e285              ldi     tosl, '%'
003f33 c001              rjmp    DOTBASEEND
                 DOTBASE3:
003f34 e38f              ldi     tosl, '?'
                 DOTBASEEND:
003f35 9508              ret
                 
                 MEMQADDR_N:
003f36 e252              fdw     ROM_N
003f37 e260              fdw     EROM_N
003f38 e270              fdw     FRAM_N
                 ;*******************************************************
                 umstar0:
003f39 920f              push t2
003f3a 921f              push t3
003f3b 9109              ld  t0, Y+
003f3c 9119              ld  t1, Y+
003f3d 9f80              mul tosl,t0
003f3e 01d0              movw t4, r0 ; r0=t2, r1=t3
003f3f 27ee              clr t6
003f40 27ff              clr t7
003f41 9f90              mul tosh, t0
003f42 0db0              add t5, r0
003f43 1de1              adc t6, r1
003f44 1df5              adc t7, zero
003f45 9f81              mul tosl, t1
003f46 0db0              add t5, r0
003f47 1de1              adc t6, r1
003f48 1df5              adc t7, zero
003f49 9f91              mul tosh, t1
003f4a 0de0              add t6, r0
003f4b 1df1              adc t7, r1
003f4c 93ba              st -Y, t5
003f4d 93aa              st -Y, t4
003f4e 01cf              movw tosl, t6
003f4f 901f              pop t3
003f50 900f              pop t2
003f51 9508              ret
                 
                 ;***********************************************************
                 ; unsigned 32/16 -> 16/16 division
                 umslashmod0:
003f52 94e8              clt
003f53 2388              tst  tosl
003f54 f429              brne umslashmodstart
003f55 2399              tst  tosh
003f56 f419              brne umslashmodstart
003f57 9468              set  ; Set T flag
003f58 940c 3d44         jmp  WARM_
                 umslashmodstart:
003f5a 01dc              movw t4, tosl
                 
003f5b 9019              ld t3, Y+
003f5c 91e9              ld t6, Y+
                 
003f5d 9189              ld tosl, Y+
003f5e 9199              ld tosh, Y+
                 
                 ; unsigned 32/16 -> 16/16 division
                         ; set loop counter
003f5f e100              ldi t0,$10 ;6
                 
                 umslashmod1:
                         ; shift left, saving high bit
003f60 27ff              clr t7
003f61 0f88              lsl tosl
003f62 1f99              rol tosh
003f63 1c11              rol t3
003f64 1fee              rol t6
003f65 1fff              rol t7
                 
                         ; try subtracting divisor
003f66 161a              cp  t3, t4
003f67 07eb              cpc t6, t5
003f68 05f5              cpc t7,zero
                 
003f69 f018              brcs umslashmod2
                 
                         ; dividend is large enough
                         ; do the subtraction for real
                         ; and set lowest bit
003f6a 9583              inc tosl
003f6b 1a1a              sub t3, t4
003f6c 0beb              sbc t6, t5
                 
                 umslashmod2:
003f6d 950a              dec  t0
003f6e f789              brne umslashmod1 ;16=17=272
                 
                 umslashmod3:
                         ; put remainder on stack
003f6f 93ea              st -Y,t6
003f70 921a              st -Y,t3
                         ; Quotient is already in tos ; 6 + 272 + 4 =282 cycles
003f71 9508              ret
                 ;;; *************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
003f72 0000      STARTV: .dw      0
003f73 8000      DPC:    .dw      OFLASH
003f74 090c      DPE:    .dw      ehere
003f75 02df      DPD:    .dw      dpdata
003f76 f70e      LW:     fdw      lastword
003f77 ee8e      STAT:   fdw      DOTSTATUS
                 ;*******************************************************************
                 ; BOOT sector END **************************************************
                 
                 KERNEL_END:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  14 r1 :  15 r2 :   5 r3 :   1 r4 :   0 r5 :  17 r6 :   5 r7 :   6 
r8 :   4 r9 :   4 r10:   5 r11:   5 r12:   0 r13:   0 r14:   2 r15:   2 
r16: 128 r17:  55 r18:   3 r19:   2 r20:  14 r21:   7 r22:  35 r23:  12 
r24: 233 r25: 180 r26:  55 r27:  40 r28:   9 r29:   5 r30:  79 r31:  54 
x  :  16 y  : 171 z  :  31 
Registers used: 32 out of 35 (91.4%)

ATmega328P instruction use summary:
.lds  :   0 .sts  :   0 adc   :  17 add   :  18 adiw  :  15 and   :   4 
andi  :  23 asr   :   2 bclr  :   5 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  21 brcs  :   1 break :   0 breq  :  46 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   2 brmi  :   5 
brne  :  35 brpl  :   2 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  97 cbi   :   3 cbr   :  19 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :  17 cls   :   0 
clt   :   1 clv   :   0 clz   :   1 com   :  11 cp    :   3 cpc   :   2 
cpi   :  27 cpse  :   5 dec   :   4 eor   :   2 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :  15 in    :  15 inc   :   5 jmp   : 163 
ld    : 117 ldd   :   3 ldi   :  60 lds   :  23 lpm   :   7 lsl   :  11 
lsr   :   1 mov   :  21 movw  :  38 mul   :   4 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   6 ori   :  17 out   :  24 pop   :  86 
push  :  26 rcall : 968 ret   : 127 reti  :   1 rjmp  : 100 rol   :  14 
ror   :  21 sbc   :   8 sbci  :   3 sbi   :   6 sbic  :   2 sbis  :   0 
sbiw  :  14 sbr   :  15 sbrc  :  12 sbrs  :  18 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   5 ses   :   0 set   :   1 sev   :   0 
sez   :   1 sleep :   1 spm   :   2 st    :  81 std   :   3 sts   :  22 
sub   :   2 subi  :  17 swap  :   3 tst   :   2 wdr   :   0 
Instructions used: 75 out of 113 (66.4%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x005f00 0x007ef0   5586   2464   8050   32768  24.6%
[.dseg] 0x000100 0x0002e1      0    481    481    2048  23.5%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 8 warnings
